---
layout: post
title: "计算机网络笔记"
date: 2018-02-20
comments: true
tags: 
  - 学习笔记
  - network
---

### 概述（上）

计算机网络学习笔记，包括：

1. 基本概念：网络结构、体系结构
2. 网络层：web、Email、DNS、P2P、Socket
3. 传输层：TCP、UDP
4. 网络层：IP、CIDR、DHCP、NAT、ICMP、路由
5. 数据链路层：差错编码、MAC
6. 局域网：ARP、以太网

<!-- more -->

#### 基本概念

计算机网络 = 通信技术 + 计算机技术

定义： 计算机网络是互连的、自治的计算机集合

网络结构：

* 网络边缘： 主机、网络应用
  *  主机（端系统）：运行网络应用程序
  *  模型：
    * client、server 客户 服务器模型：客户发送请求，服务器响应
    * p2p模型：无专用服务器，通信在对等实体间直接进行
* 接入网络，物理介质： 有线或无线通信链路
  *  DSL 数字用户线路：用电话线连接，FDM分频
* 网络核心（核心网络）：互联的路由器、网络的网络
  * 核心功能：路由routing + 转发 forwarding
    * 路由：确定分组从源到目的传输路径
    * 转发：分组从路由器输入端口转发至正确的输出端口
  * **数据交换**

端系统通过 接入ISP 连接到Internet， 接入ISP互连

#### 网络核心

数据交换：数据通过网络核心从源主机到达目的主机的手段

数据交换分类：

1. 电路交换
2. 报文交换
3. 分组交换

##### 电路交换

最典型的电路交换网络：电话网络

三个阶段：

* 建立连接
* 通信
* 释放连接

特点：资源**独占**

如何共享中继线： 多路复用（Multiplexing）

多路复用： 链路、网络资源划分资源片，每路独占分配的资源片，资源片可能闲置

典型多路复用方法：

* 频分多路复用 FDM
  * 各用户占用不同频率带宽
  * 通信过程中始终使用一个频带
* 时分多路复用 TDM
  * 将时间划分为等长的帧，帧划分为时隙，每个用户使用固定序号的时隙
  * 每个用户的时隙周期性出现（周期为帧长度）
  * 所有用户使用所有频带宽度
* 波分多路复用 WDM
  * 光的频分复用
* 码分多路复用 CDM
  * 广泛应用于无线链路共享
  * 每个用户有唯一的码片序列，码片序列之间正交
  * 用户用码片序列编码自己的数据

##### 报文交换 message switching

一次发送信息整体

##### 分组交换 package switching

分组： 报文拆分出的一系列较小的数据包

需要报文的拆分和重组

每个分组需要额外的分组头

**统计多路复用 statistical multiplexing**： 按需共享（传输数据多的速度快，数据少的速度慢）

交换方式： **存储-转发**：

​	一次存储整个分组，而后转发

分组交换和电路交换：

分组交换适用于突发数据传输：

* 优点
    * 资源充分共享
  * 简单、无需建立呼叫电路
* 缺点：
  * 可能产生拥塞 congestion： 分组延迟和丢包
  * 需要协议处理可靠数据传输和拥塞控制

### 概述（下）

#### 计算机网络性能

速率：

* 速率、数据率、比特率： 单位时间(秒)内传输信息（比特）量， b/s ,bps, kb/s
* 速率往往指的是额定速率、标称速率（理论值）

带宽： 

* 原本：信号具有的频带宽度，最高频率和最低频率之差，单位 hz
* 网络：数字信道所能传输的最大数据率，单位 b/s

延迟delay、时延 latency：

* 原因： 分组在路由器缓存中排队
* 四种类型：
  * 处理延迟( nodal processing delay)：
    * 差错检测
    * 确定输出链路
    * 通常毫秒、微秒级 
  * 排队延迟 (queueing delay)
    * 等待输出链路可用
    * 取决于路由器拥塞程度
  * 传输延迟 (transmission delay) ：路由器到链路
    * 取决于分组长度L、链路带宽R， d trans = L/R
  * 传播延迟 (propagation delay)：链路上到下一个路由器
    * 取决于链路长度d，信号传播速度s，　d prop = d/s
* d nodal = d proc + d queue + d trans + d prop

时延带宽积＝传播时延＊带宽 = 链路上能容纳多少比特

丢包：

 * 原因：队列缓存有限
 * 分组到达已满队列将被丢弃
 * 丢弃分组可能由前序结点或源重发
 * 以丢包率衡量

吞吐量  throughput

 * 发送端与接收端之间的速率
 * 分类：
    * 即时吞吐量
    * 平均吞吐量
* 取决于端到端路径上，最小速率的链路

#### 计算机网络体系结构

用**分层结构**从**功能上**描述计算机网络体系

每层完成一个特定功能，每层依赖底层提供的服务

每层遵循某个协议完成本层功能

计算机网络体系结构是计算机网络各层及其协议的集合

分层结构的优点

* 结构清晰
* 模块化思想，易于系统更新、维护
  * 任何一层服务实现上的改变对其它层不影响​

基本概念：

* 实体 entity ： 任何可发送或接收信息的硬件或软件进程
* 协议 protocol：控制两个对等实体进行通信的规则的集合（同层的，水平的）
* 服务是垂直的，任一层实体需要使用下层服务，遵循本层协议，实现本层功能，对上层提供服务
* 下层实现对上层是不可见的
* 相邻层之间通过接口进行交互，通过服务访问点SAP

##### OSI参考模型

概念：

* 目的： 支持异构网络系统的互联互通
* 异构网络系统互连的国际标准
* 理解网络通信的最佳学习工具（理论模型，市场失败）

分层： 7层：

* 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
* 主机需要完成7层
* 路由器只需要完成3层，物理层、链路层、网络层
* 数据纵向流动，协议水平
* 端到端层 end-end： 应用层到传输层 四层

数据封装和通信过程：

1. APDU 应用层数据单元
2. PPDU 表示层
3. SPDU 会话层
4. TPDU 传输层
5. NPDU 网络层
6. DPDU 链路层加头加尾
7. 物理层对应比特，不加额外信息

* 增加控制信息： 最终构造成 PDU 构造协议数据单元
* 控制信息包括：
  * 地址： 标识发送端、接收端
  * 差错检测编码：差错检测或纠正
  * 协议控制：实现协议功能的附加信息

功能：

* 物理层功能：   总：实现比特的传输
  * 定义、规范接口特性
    * 机械特性：接口的几何形状
    * 电气特性：接口的电平、电压
    * 功能特性：多少引脚、引脚的功能
    * 规程特性：接口的使用规则，也叫过程特性
  * 比特编码
  * 数据率
  * 比特同步： 时钟同步问题
  * 传输模式
    * 单工模式 simplex ： 单向发信（如电视）
    * 半双工 half-duplex ： 可双向，但只能交替进行（如对讲机）
    * 全双工 full-duplex ： 可同时收发
* 数据链路层功能：
  * 负责结点-结点 node-to-node数据传输
  * 以帧为单位进行传输
  * 功能：
    * 组帧 framing ： 加头加尾 ： 使得接收方能够切分帧病识别控制信息
    * 物理寻址 physical addressing：包含源和目的物理地址
    * 流量控制 flow control ： 避免淹没接收端
    * 差错控制 error control ： 检测并重传损坏或丢失帧，并避免重复帧
    * 访问（接入）控制 access control：决定哪个设备拥有链路的控制使用权
* 网络层功能：负责数据分组packet的交付
  * 原因：可能穿越多个网络
  * 逻辑寻址 logical addressing： 全局唯一逻辑地址，确保数据分组被送到目的地，如IP地址
  * 路由 routing： 选择路径
  * 分组转发
* 传输层功能： 负责端-端 完整报文的传输
  * 报文的分段和重组
  * SAP寻址：确保报文提交给正确进程，如端口号
  * 连接控制：逻辑连接
  * 流量控制
  * 差错控制
* 会话层功能： 插入控制信息
  * 对话控制 dialog controlling： 对话的建立与维护
  * 对话同步 synchronization： 数据流中插入同步点
  * 最“薄”的一层
* 表示层功能： 编码、加密、压缩数据
  * 数据表示转化
    * 转换为主机独立的编码
  * 加密解密
  * 压缩解压缩
* 应用层功能：支持用户通过接口使用网络服务
  * 典型类型：
    * FTP 文件传输
    * HTTP WEB
    * SMTP 电子邮件

##### TCP / IP模型

四层： 应用层、运输层、网际层、网络接口层

##### 五层参考模型

综合OSI和TCP/IP模型的优点

应用层、传输层、网络层、数据链路层、物理层

层次：

* 主机 五层
* 路由器 三层
* 交换机 两层

#### 网络发展历史

1961-1972： 交换分组原理提出与应用

1972-1980：网络互连，大量新型、私有网络的涌现

1980-1990：新型网络协议与网络的激增

1990-2000初： 商业化，web，新应用

2005-今

### 网络应用（上）

应用层 - 传输层 - 网络层 - 链路层 - 物理层

#### 网络应用层概述

* 网络应用体系结构
* 网络应用的服务需求
* Internet传输层服务模型
* 特定网络应用与协议
* Socket编程

#### 网络应用的基本原理

##### 网络应用的体系结构

* 客户机、服务器结构  C/S  Client-Server
  * 服务器
    * 7*24小时提供服务
    * 永久性访问地址\域名
    * 利用大量服务器实现可扩展性（处理大量并发请求）
  * 客户机
    * 与服务器通信，使用服务器提供的服务
    * 间歇性接入网络
    * 可能使用动态IP
    * 不会和其他客户机直接通信
* 点对点结构 P2P Peer-to-peer
  * 没有永远在线的服务器
  * 任意端系统之间可以直接通信
  * 节点间歇性接入网络
  * 节点可能改变IP
  * 优点：高度可伸缩、可扩展
  * 缺点：难以管理
* 混合结构 hyrid

##### 网络应用进程通信

同一主机上进程通信：

* 进程间通信机制
* 由操作系统提供

不同主机进程通信：消息交换

Socket套接字：进程间利用socket发送和接受消息

传输基础设施向进程提供API：

* 传输协议的选择
* 参数的设置

进程寻址：

* 不同主机进程通信，每个进程必须有标识符
* 寻址主机：IP地址
* 端口号 port number：主机上每个需要通信的进程分配一个端口号
* 已经分配的端口： HTTP：80     mail：25
* 进程的标识符： IP+端口号

应用层协议：

* 网络应用都应该遵循应用层协议
* 公开协议： 
   * 由 RFC（request for comments）定义
   * 允许互操作
   * 例如： HTTP、SMTP
* 私有协议：
  * 多数P2P文件共享应用
* 内容：
  * 消息的类型type：
    * 请求消息
    * 响应消息
  * 消息的语法syntax 、格式
    * 消息中由哪些字段 field
    * 每个字段如何描述
  * 字段的语义 semantics ：信息的含义
  * 规则 rules： 何时、如何发送、相应消息

##### 网络应用的需求与传输层服务

需求：

* 数据丢失 data loss、 可靠性reliability
  * 某些可容忍一定的数据丢失：网络电话
  * 某些要求100%可靠的数据传输
* 时间timing 、 延迟 delay：
  * 延迟低才有效（网络电话、网络游戏）
* 带宽 bandwidth：
  * 带宽达到最低要求才有效：网路视频
  * 可适应任何带宽——弹性应用：email、文件下载

传输服务：

* TCP服务：
  * 面向连接：客户机和服务器需要建立连接
  * 可靠的传输
  * 流量控制：发送方不会发送速度过快
  * 拥塞控制：网络负载过重时能限制发送方发送速度
  * 不提供时间保障
  * 不提供最小带宽保障
* UDP服务：
  * 无连接
  * 不可靠
  * 不提供：可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障

#### Web应用

##### web与http

web：

* 网页
* 网页互相链接

网页 webpage 包含多个对象 objects：

* 对象：html文件、jpeg图片、视频、动态脚本
* 基本html文件：包含对其他对象引用的链接

对象的寻址 addressing：

* URL（uniform resource locator）：统一资源定位器
* 格式：  Scheme:// host:port/path

HTTP协议 hypertext transfer protocol 超文本传输协议：

* CS结构：
  * 客户- browser：请求、接受、展示web对象
  * 服务器-web server：相应客户请求、发送对象
* 使用TCP传输服务
* 无状态 stateless：服务器不维护任何过去发送请求的信息

##### HTTP连接

非持久性连接 nonpersistent http：

* 每个TCP连接最多允许传输一个对象
* 在HTTP 1.0版本
* 缺点：
  * 每个对象需要2个RTT
  * 操作系统要为每个TCP连接开销资源
  * 浏览器需要打开多个并行TCP连接获取对象

持久性连接：

* 每个TCP连接允许传输多个对象
* HTTP 1.1默认
* 发送响应后，服务器保持TCP连接打开以发送后续HTTP消息
* 分类：
  * 无流水pipelining的持久性连接
    * 客户端受到一个响应才发送一个新请求
    * 每个对象消耗 1RTT
  * 流水机制的持久性连接：
    * HTTP 1.1默认
    * 客户端遇到一个引用对象就尽快发送请求
    * 理想情况下收到所有引用对象只需要约 1RTT

响应时间 RTT ： round trip time：从客户端发送一个很小数据包到服务器并返回所经历的时间

##### HTTP请求消息

HTTP协议两类信息：

* 请求消息 request
  * ASCII：人直接可读
  * 上传输入的方法：
    * POST方法：在请求消息的消息体中输入
    * URL方法：GET方法：输入信息通过request行中的URL段上传
    * HEAD：请求服务器不要把所请求对象放入相应消息中（只返回头，一般用作测试）
    * PUT：（HTTP  1.1）消息体中的文件上传到URL段所指定的路径（上传文件到服务器）
    * DELETE：（HTTP1.1）删除URL字段指定文件
* 响应消息 response
  * 状态响应代码：相应消息的第一行
  * 如 200 OK， 404 Not Found

##### Cookie 方法

cookie技术：网站为辨明用户身份、通过session跟踪而存储在用户本地终端的数据

RFC 6265

Cookie组件：

* HTTP响应消息的Cookie头部行
* HTTP请求消息的Cookie头部行
* 保存在客户端主机的Cookie文件，由浏览器管理
* web服务器端的后台数据库

Cookie的作用：

* 身份认证、购物车、推荐、email

隐私问题

##### web缓存、代理服务器技术

功能：在不访问服务器的前提下满足客户端的HTTP请求

原因： 性能优化

* 缩短客户请求响应时间
* 减少机构、组织流量
* 在大范围内实现有效内容分发

步骤：

* 用户设定浏览器通过缓存进行web访问
* 浏览器向缓存、代理服务器发送所有HTTP请求
  * 若请求对象在缓存中 ，则缓存返回对象
  * 若不在缓存，则缓存服务器向原始服务器发送HTTP请求，获取对象并返回给客户端、并保存对象

解决对象更新问题： 条件性GET

* 若缓存为最新版本，则不需要发送请求对象
* 缓存服务器请求信息中声明持有版本的日期 modified 日期
* 目标服务器：
  * 若缓存版本是最新的，响应消息中不包含对象，返回 304 Not Modified
  * 若缓存版本不是最新，则返回对象

#### Email 应用

##### email应用概述

构成组件：

* 客户端
* 服务器
  * 邮箱：存储发给该用户的email
  * 消息队列 msessage queue：存储等待发送的email
* SMTP协议：email消息传输、交换协议
  * 邮件服务器之间传递消息所使用的协议
  * 客户端：发送消息的服务器
  * 服务器：接受消息的服务器
  * 端口25
  * 使用TCP 进行可靠传输、持久性连接
  * 三个阶段：
    * 握手
    * 消息传输
    * 关闭
  * 命令、相应交互模式：
    * 命令 command：ASCII文本
    * 响应 response：状态代码和语句
  * email消息只能包含7位ASCII码

##### Email消息格式与POP3协议

RFC 822：文本消息格式标准：

* 头部行 header
  * To 、 From、 Subject
* 消息体 body
  * 消息本身，只能是ASCII字符

为了支持多媒体： 使用 MIME 多媒体邮件扩展

* 在邮件头部增加额外的行声明MIME的内容类型

邮件访问协议：收件方从服务器获取邮件

* POP：post office protocol 协议：两个阶段：认证/授权和下载
  * 模式：
    * 下载并删除模式：用户换了客户端软件，则无法重读邮件
    * 下载并保持模式：不同客户端都可以保存拷贝
  * POP3是无状态协议（服务器没有记忆功能）
* IMAP: internet mail access protocol协议
  * 更多功能、更复杂，新于POP3
  * 可操纵服务器上存储的消息
  * 所有消息统一保存在服务器
  * 允许用户利用文件夹组织消息
  * 支持跨会话Session 的用户状态
  * 有状态协议
* HTTP协议： 163、 qq 、 mail

#### DNS应用

##### DNS概述

DNS：domain name system 域名系统：解决Internet上主机、路由器识别问题

DNS域名解析系统：域名和IP地址的映射

* 多层命名服务器构成的分布式数据库
* 应用层协议：完成名字的解析
  * Internet核心功能，用应用层协议实现
  * 网络边界复杂

服务：

* 域名向IP地址翻译
* 主机别名
* 邮件服务器别名
* 负载均衡：web服务器

集中式DNS的问题： 不可伸缩

* 单点失败问题：服务器坏掉
* 流量问题
* 距离问题
* 维护性问题

分布式层次式数据库：

1. 根服务器 root
2. 顶级域名服务器  com、org、edu等

根域名服务器： 本地域名解析服务器无法解析域名时，访问根域名服务器

* 不知道映射时，访问权威域名服务器

顶级域名服务器 TLD top-level domain：负责com、edu等

权威域名服务器：组织的域名解析服务器，负责解析组织内部服务器的解析服务

* 组织负责维护
* 服务提供商负责维护

本地域名解析服务器：

* 不严格属于层次体系
* 每个ISP都有一个本地域名服务器：默认的服务器
* 本地服务器作为代理，把查询转发给域名解析服务器系统
* 查询方式：
  * 迭代查询：获得下一个服务器地址，本地服务器挨个询问
  * 递归查询：本地服务器把询问任务交给根服务器

DNS记录缓存与更新：

* 本地域名服务器一般会缓存顶级域名服务器的映射
  * 因此根域名服务器不经常被访问

##### DNS记录与消息格式

资源记录 RR resource records

格式： name value type ttl

类型：

* Type = A
  * Name：主机域名
  * value：IP地址
* Type = NS
  * Name：域
  * value：该域的权威域名解析服务器的主机域名
* Type = CNAME
  * Name：某一域名的别名
  * Value：真实域名
* Type = MX
  * Value ：与name对应的邮件服务器

DNS协议：

* 查询query 和回复 reply
* 消息格式相同
  * 头部：
    * identification：16位查询编号，回复使用相同编号
    * flags

### 网络应用（下）

#### P2P应用

##### P2P应用：原理与文件分发

典型协议：BT BitTorrent：

* torrent：交换同一个文件的文件块的节点组
* tracker：跟踪参与torrent的节点

获取chunk：

* 给定任意时刻，不同节点持有文件的不同chunk集合
* 节点定期查询每个邻居持有的chunk列表
* 节点发送请求，请求获取缺失的chunk：
  * 稀缺优先原则

发送chunk： tit-for-tat：

* 向4个邻居发送chunk：正在向其发送chunk且速率最快的四个
  * 每10s重新评估top4
* 每30s随机选择一个其他节点，向其发送chunk

##### P2P应用；索引技术

索引：信息到节点位置（IP地址+端口号）的映射

文件共享：

* 利用索引动态跟踪节点所共享的文件的位置
* 节点告诉索引它拥有哪些文件
* 节点搜索索引，获知能够得知哪些文件

即时消息：

* 索引把用户名映射到位置
* 用户开启IM应用时，需要通知索引它的位置
* 节点检索索引，确定用户的IP地址

###### 集中式索引

Napster最早采用

1. 节点加入时，通知中央服务器
   * IP地址
   * 内容
2. 节点向中央服务器查找文件
3. 节点向用户请求文件

缺点： 内容定位高度集中

* 单点失效问题
* 性能瓶颈
* 版权问题

###### 洪泛式查询 query flooding

完全分布式架构

每个节点只对自己共享的文件进行索引

覆盖网络 overlay network：

* 节点之间若有TCP连接，则构成一条边
* 所有活动节点和边构成网络
* 边：虚拟链路
* 节点邻居数一般少于10

查询：

* 查询消息通过已有的TCP连接发送
* 节点转发查询消息
* 查询命中，则利用反向路径发回查询节点

缺点：消息泛滥、造成网络阻塞

###### 层次式覆盖网络

介于集中式索引和洪泛查询之间

每个节点 要么是超级节点，要么被分配一个超级节点

* 节点和超级节点之间维持TCP连接（集中式索引）
* 超级节点之间维持TCP连接（洪泛式查询）

超级节点负责跟踪子节点内容

#### Socket编程

###### 应用编程接口API

将应用进程的控制权和操作系统的控制权进行转换的系统接口

典型接口：

* 套接字 socket
* winsock：Windows Socket interface，微软的套接字接口
* TLI，transport layer interface 传输层接口

##### Socket API概述

最初面向 BSD UNIX-Berkley

Internet网络应用最典型的API接口

通信模型： 客户、服务器模型

应用进程间通信的抽象机制

标识通信端点（对外）：IP地址+端口号

对内管理套接字：套接字描述符 Socket descriptor

Socket抽象：

* 类似文件的抽象
* 应用程序创建套接字时，操作系统分配一个数据结构存储该套接字相关信息
* 返回套接字描述符

##### Socket API函数 Winsock：

WSAStartup：初始化api  ->  应用程序  -> WSACleanup

socket(protofamily , type, proto )：

 * 创建套接字，返回套接字描述符
 * protofamily 协议族  （TCP/IP = PF_INET）
 * type：套接字类型
 * proto：协议号，0为默认

面向TCP/IP 服务类型：

* SOCK_DGRAM：传输层UDP协议：不可靠、无连接、数据报传输
* SOCK_STREAM：传输层TCP协议：可靠、面向连接、字节流传输、点对点
* SOCK_RAW：网络层，IP/ICMP/IGMP

int Closesocket( SOCKET sd);

 * 关闭一个描述符为sd的套接字
 * 多个进程共享一个套接字时，调用该函数将套接字引用计数减一，减到0才关闭
 * 一个进程多线程对一个套接字使用无计数
 * 返回值：0成功

int bind(sd, localaddr, addrlen);

* 绑定套接字的本地端点地址（IP+端口号）
* 参数：
  * 套接字描述符 sd
  * 端点地址 localaddr： 结构 sockaddr_in
* 客户端程序一般不必调用bind函数
* 服务器绑定多IP地址：地址通配符：INADDR_ANY

int listen(sd, queuesize);

* 置服务器端的流套接字处于监听状态
  * 仅服务器端调用
  * 仅用于面向连接的流套接字
* 设置连接请求队列大小 queuesize
* 返回值：成功 0

connect( sd, addr , saddrlen);

* 仅用于客户端，使客户套接字与特定计算机的特定端口saddr的套接字进行连接
* 可用于TCP、 UDP
  * TCP：建立连接
  * UDP：指定服务器端点地址

newsock = accept( sd, caddr, caddrlen);

* 只用于服务器端，只用于TCP套接字
* 从客户连接请求队列中取出最前的客户请求，并创建一个新的套接字和客户套接字创建连接通道
* 利用新创建的套接字和客户通信（TCP是点对点的）

send( sd , *buf, len , flags);

sendto( sd, * buf , len, flags, destaddr, addrlen);

* send函数TCP套接字（客户端或服务器）或调用了connect函数的UDP客户端套接字
* sendto用于UDP服务器端套接字和未调用connect函数的UDP客户端套接字

recv，recvfrom 类似send，sendto

setsockopt、 getsockopt 设置或获取套接字设置

网络字节顺序 network byte order：

​	TCP/IP定义了标准的用于协议头中的二进制整数表示

​	某些socket API函数参数需要存储为网络字节顺序（如IP地址、端口号等）

##### 客户端软件设计

解析服务器IP地址： 域名或IP地址转换为32位二进制IP地址：

* inet_addr() 点分十进制IP到32位IP地址
* gethostbyname() 域名到32位IP地址： 返回指向结构hostent的指针
* 都返回网络字节顺序

解析端口号： 可能使用服务名（如HTTP）或端口号

* getservbyname() 服务名转为熟知端口号

解析协议号：可能使用协议名（如TCP）指定协议

* getprotobyname() 协议名到协议号的转换

TCP客户端软件流程：

1. 确定服务器IP地址+端口号
2. 创建客户端套接字
3. 分配本地端点地址（IP+端口号） （系统自动完成）
4. 连接服务器套接字
5. 遵循应用层协议进行通信
6. 关闭或释放连接

UDP客户端软件流程：

1. 确定服务器IP地址+端口号
2. 创建客户端套接字
3. 分配本地端点地址（IP+端口号） （系统自动完成）
4. 指定服务器端点地址，构造UDP数据报
5. 遵循应用层协议进行通信
6. 关闭或释放套接字

##### 服务器软件设计

基本服务器类型：

1. 循环无连接 IteratIve connectionless
   * 一次只接受一个客户端请求
   * 无连接：基于UDP
   * 流程：
     1. 创建套接字
     2. 绑定端点地址（INADDR_ANY+端口号）
     3. 反复接收来自客户端的请求
     4. 遵循应用层协议，构造响应报文，发送给客户
   * 服务器端不能使用connect函数
   * 无连接服务器使用 sendto发送数据报
   * 客户端端点地址在调用recvfrom接收数据时自动提取
2. 循环面向连接 Iterative connection-oriented
   * 流程：
     1. 创建主套接字，绑定熟知端口号
     2. 主套接字设置为被动监听模式
     3. 调用accept接收连接请求，创建新套接字和客户建立连接
     4. 通过新套接字接收请求、构造并发送响应
     5. 完成服务后，关闭连接，返回3
3. 并发无连接 Concurrent connectionless
   * 流程：
     1. 主线程1 创建套接字，绑定熟知端口号
     2. 主线程2 反复调用recvfrom函数，接收请求，创建新线程处理响应
     3. 子线程1 接收请求
     4. 子线程2 构造响应报文，调用sendto发送
     5. 子线程3 退出
4. 并发面向连接 Concurrent connection-oriented
   * 流程：
     1. 主线程1 创建套接字，绑定熟知端口号
     2. 主线程2 设置主套接字为被动监听模式
     3. 主线程3 反复调用accept接收连接请求，创建新的子线程处理客户响应
     4. 子线程1 接收请求（通过新套接字）
     5. 子线程2 根据协议进行交互
     6. 子线程3 关闭、释放连接并退出（线程终止）


### 传输层（上）

#### 传输层服务概述

传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制

端系统运行传输层协议：

* 发送方：把消息分成多个Segment并传给网络层
* 接收方：把segment组装成消息，交给应用层

协议类型：

* TCP、UDP

与网络层的区别：

* 网络层提供主机之间的逻辑通信机制
* 位于网络层之上、依赖网络层
* 对网络层服务进行（可能的）增强

#### 复用和分用

原因：

* 接收端（多路分用）：传输层将segment交给正确的socket 即正确的进程
* 发送端（多路复用）：从多个socket接收消息，每块数据封装头部消息，生成Segment，交给网络层

分用工作：

* 主机接收到IP数据报 datagram
* 每个数据报携带源IP、目的IP，一个传输层的段
* 每个段携带源端口号、目的端口号
* 传输层协议根据IP地址和端口号，把Segment导向Socket
  * TCP做更多处理
* 无连接分用：UDP：用二元组标识（目的IP，目的端口号）
* 面向连接的分用：TCP：用四元组（源IP，源端口号，目的IP，目的端口号）

#### UDP

UDP：user datagram protocol 【RFC 768】

特点：

* 基于 IP协议：
  * 多路复用、分用
  * 简单的错误校验：端到端原则，不能确保所有链路层协议都有错误检测，也不能确保转发时错误不发生
* Best effort（尽力而为）服务，UDP可能：
  * 丢失
  * 非按序到达
* 无连接：
  * 发送方接收方不需要握手、不需要建立连接
  * 每个UDP段处理独立

价值：

* 无需建立连接：延迟显著减少（2个RTT）（DNS用UDP）
* 实现简单，无需维护连接状态
* 头部开销少（8字节 VS  20字节）
* 没有拥塞控制，上层控制发送时间和速率

用途：

* 常用于流媒体：容忍丢失、速率敏感
* DNS、SNMP
* 在其之上实现可靠数据传输：（应用层开发）
  * 在应用层增加可靠性机制
  * 应用特定的错误恢复机制

![UDP](http://ot1c7ttzm.bkt.clouddn.com/UDP.png)

UDP校验和 checksum： 

* 目的：检测UDP段传输过程中是否发生错误
* 发送方：
  * 段内容视为16-bit证书
  * 校验和计算：求和，进位加到和后面，按位取反
  * 校验和填入校验和字段
* 发送方：
  * 计算校验和
  * 进行比对：
    * 不相等：检错
    * 相等：未检测到错误（可能有错）

#### 可靠数据传输原理

可靠的定义：不错、不丢、不乱

可靠数据传输协议：

* 对应用层、传输层、链路层都重要
* 信道的不可靠特性决定了可靠数据传输协议rdt的复杂性

Rdt 1.0：可靠信道上的可靠数据传输

* 底层信道完全可靠
* 发送方和接收方 FSM独立

Rdt 2.0： 产生位错误：

* 底层信道可能翻转分组中的位

  * 用校验和检测位错误

* 如何从错误中恢复：

  * 确认机制 ACK acknowledgements：接收方显式告知发送方分组已经正确接收
  * NAK：接收方显式告诉发送方分组有错误
  * 发送方收到NAK后，重传分组

* 基于重传机制的rdt协议成为ARQ automatic repeat request 协议

* 新机制：

  * 差错检测
  * 接收方反馈控制消息： ACK、 NAK
  * 重传

  ![rdt2.0](http://ot1c7ttzm.bkt.clouddn.com/rdt2.0.png)

* 缺陷： ACK、NAK消息发生错误或被破坏 corrupted：

* 解决方案： rdt 2.1

  1. ACK、NAK增加校验和，检错并纠错（代价高）
  2. 添加额外控制消息
  3. 发送方重传：可能产生重复分组
     * 解决重复分组： 序列号 sequence number：发送方给每个分组增加序列号
     * 接收方丢弃重复分组

* ![rdt2.1](http://ot1c7ttzm.bkt.clouddn.com/rdt2.1.png)

* ![rdt2.1rev](http://ot1c7ttzm.bkt.clouddn.com/rdt2.1rev.png)

  发送方变化：

  * 每个分组增加了序列号(0,1序号)
  * 需要校验ACK、NAK消息是否错误
  * 状态数量翻倍

  接收方变化：

  * 需要判断分组是否重复

* Rdt 2.2 ：只使用ACK：检验和+序列号+ACK+重传

  * 接收方通过ACK告知最后一个被正确接收的分组
  * ACK中显式加入被确认分组的序列号
  * 发送方收到重复ACK后，重传当前分组

Rdt 3.0：既可能错误，也可能丢失：

* 方法：发送方等待 合理 时间：
  * 没收到ACK，重传
  * 分组或ACK只是延迟而不是丢了
  * 增加定时器
* ![rdt3.0send](http://ot1c7ttzm.bkt.clouddn.com/rdt3.0send.png)
* 问题：性能很差：停等操作

#### 流水线与滑动窗口协议

流水线机制：

* 允许发送方收到ACK之前连续发送多个分组：
  * 更大的序列号范围
  * 发送方、接收方需要更大存储空间缓存分组

滑动窗口协议 sliding-window protocol：

* 窗口：
  * 允许使用的序列号范围
  * 窗口尺寸为N：最多由N个等待确认的消息
* 滑动窗口：
  * 随着协议的运行，窗口在序列号空间内向前滑动
* 滑动窗口协议：GBN，SR

GBN go-back-N 协议：

* 发送方：
  * 分组头有k-bit序列号
  * 窗口尺寸为N，最多允许N个分组未确认
  * 累计确认机制：ACK(n)：确认到序列号n（包含n）的分组都被正常接收
    * 可能收到重复ACK
  * 空中分组设置计时器 timer
  * timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组
* 接收方：
  * ACK机制：发送拥有最高序列号的，已经被正确接收的分组的ACK
    * 可能产生重复ACK
    * 只需记住唯一的expectedseqnum
  * 乱序到达的分组：
    * 直接丢弃
    * 重新确认序列号最大的、按序到达的分组
* 缺陷：
  * 重传大量不必要分组

SR selective repeat协议：

* 接收方对每个分组单独进行确认
  * 设置缓存机制，缓存乱序到达的分组
* 发送方只重发没收到ACK的分组
  * 为每个分组设置定时器
* 发送方窗口不变化
* 新增接收方窗口
* ![sr](http://ot1c7ttzm.bkt.clouddn.com/sr.png)
* SR协议问题： 困境
  * 出现原因：序列号少且窗口尺寸大
  * 解决： $N_S + N_R <= 2^k $


### 传输层（下）

#### 面向连接传输协议 TCP

概述：

* 点对点
* 可靠的、按序的字节流
* 流水线机制： TCP拥塞控制和流量控制机制动态设置窗口尺寸
* 发送方、接收方缓存
* 全双工：同一连接双向传输数据
* 面向连接：
  * 通信双方在发送数据前必须建立连接
  * 连接状态只在两端维护
  * TCP连接包括： 两台主机上的缓存、连接状态变量、Socket等
* 流量控制机制


序列号：

* 序列号指的是Segment第一个字节的编号，而不是Segment的编号
* 建立连接时，双方随机选择序列号

ACK：

* 希望接收的下一个字节的序列号
* 累计确认：该序列号之前的所有字节都已被正确接收

乱序到达的Segment：没有规定，由TCP实现者做决策

![TCP](http://ot1c7ttzm.bkt.clouddn.com/TCP.png)

##### TCP可靠数据传输

概述：

* 流水线机制
* 累计确认
* 单一重传计时器
* 触发重传事件：
  * 超时
  * 受到重复ACK

RTT与超时时间设置：

* 需要大于RTT：但RTT是变化的
* 超时时间 = 平均RTT + 4*安全时间
* 安全时间 =  0.25*|平均RTT-RTT|+0.75旧安全时间

发送方事件：

* 从应用层收到数据：
  * 创建Segment
  * 开启计时器
  * 设置超时时间
* 超时：
  * 重传超时的Segment
  * 重启计时器
* 收到ACK
  * 未确认的Segment：
    * 更新sendbase
    * 窗口若还有未确认的分组，重启计时器

快速重传机制：

* 如果超时，超时时间间隔重新设置，导致其很大
* 通过重复ACK检测分组丢失：
  * 发送方收到同一分组的3次ACK，则立刻重传

##### TCP 流量控制

原因：接收方为TCP设置了buffer，上层应用可能处理buffer的速度太慢

实现：接受者在Segment的头部信息的revwindow告诉发送方还剩余多少可用空间，发送方限制数据不超过revwindow的大小

##### TCP连接管理

* 初始化TCP变量：
  * 选择序列号
  * 设置缓存和流量控制信息
* client：连接发起者
* server：等待连接请求
* 三次握手建立连接：
  1. 客户端向server发送 SYN段
     * 不携带任何数据
     * SYN标志位为1
     * 传递初始序列号
     * SYN=1，seq=client_isn
  2. 服务器接到SYN，同意后发送 SYNACK段
     * 服务器分配缓存
     * 选择自己的初始序列号
     * SYN=1, seq=server_isn，ack=client_isn+1
  3. 客户端受到SYNACK，回复ACK报文段，SYN不再置1，可能有数据
     * SYN=0, seq=client_isn+1 , ack=server_isn+1
* 连接关闭：
  1. 客户端向服务器发送 FIN 控制段
  2. 服务器收到FIN，回复ACK，关闭连接，发送FIN
  3. 客户端收到FIN，回复ACK：进入等待状态，若收到FIN，重发ACK
  4. 服务器收到ACK，真正关闭连接

#### 拥塞控制问题

拥塞 congestion： 太多主机发送太多数据或速度太快以致网络无法处理

表现：

* 分组丢失（路由器缓存溢出）
* 分组延迟过大（在路由器缓存中排队）

拥塞控制 （网络阻塞） vs 流量控制（接收方处理不过来）

为什么拥塞控制要在传输层进行

拥塞控制方法：

* 端到端的拥塞控制：
  * 网络层不需要显式提供支持
  * 端系统通过观察loss、delay等网络行为判断是否发生拥塞
  * TCP采用这种方法
* 网络辅助的拥塞控制：
  * 路由器向发送方显式反馈网络拥塞信息
  * 简单的拥塞指示(1-bit)：SNA、DECbit，TCP/IP ECN, ATM
  * 指示发送方应该采用何种速率

ATM ABR拥塞控制  available bit rate：

* 弹性服务
* 发送方路径可用：使用可用贷款
* 发送方路径堵塞：发送速率降到最低保障速率
* RM resource management cell：
  * 发送几个数据段就发送一个RM cell
  * 发送方发送
  * 交换机设置 RM cell位（网络辅助）
    * NI bit：rate不许增长
    * CI bit：拥塞指示
  * RM cell由接收方返回给发送方
  * RM cell有显式的速率ER 字段：两个字节：
    * 拥塞的交换机可以把ER设置为更低的值
    * 发送方获知路径所能支持的最小速率
  * 数据cell的EFCI位：拥塞的交换机将其设置为1：
    * 若RM cell前data cell的EFCI位设置为1，那么发送方在返回的RM cell中置CI位

TCP拥塞控制：

* 如何控制发送速率：

  * 拥塞窗口 CongWin：
    * LastByteSent-LastByteAcked <= CongWin
    * 速率 ≈ CongWin / RTT byte/sec
    * 动态调整以改变发送速率
    * 反映所感知的网络拥塞

* 如何感知拥塞状况：

  * Loss事件 = timeout 或 3个重复ACK
  * 发生loss事件后，发送方降低速率

* 如何合理调整发送速率：

  * 加性增- 乘性减： AIMD
    * 原理：谨慎探测可用带宽，逐渐增加速率，直到loss，一旦loss，快速降低速率
    * additive increase：每个RTT将CongWin增大一个MSS（拥塞避免）
    * multiplicative decrease：发生loss后CongWin减半
  * 慢启动： SS
    * TCP建立时，CongWin=1，可用带宽可能远高于初始速率，希望快速增长
    * 原理：连接开始时，速率指数增长（收到每个ack时 CongWin+1）
  * 何时从指数增长切换到线性增长：
    * 当CongWin达到loss事件前值的一半时
    * Threshold记录loss事件前CongWin值的1/2
  * Loss事件的处理：
    * 3个重复ACK：
      * CongWin切到一半
      * 而后线性增长
      * 原因：能收到3个ACK说明网络还能传输
    * timeout：
      * CongWin直接减为1个MSS
      * 而后指数增长
      * 达到threshold后再线性增长
      * 原因：timeout说明网络拥塞更严重

TCP的公平性：

* 公平性与UDP：
  * 多媒体应用通常不适用TCP，以免被拥塞控制机制限制速率
  * 使用UDP：以恒定速率发送，能容忍丢失
  * 产生不公平
* 都使用TCP：
  * 可能打开多个并发连接
  * 如WEB浏览器
  * 产生公平性问题

### 网络层服务（上）

#### 网络层

源主机向目的主机发送数据报

每个主机和路由器都运行网络层协议

路由器检验所有穿越它的IP数据报的头部域：决策如何处理IP数据报

网络层核心功能：

* 转发 forwarding：
  * 功能：分组从路由器输入端口转移到合适的输出端口
  * 路由器维护转发表：确定在该路由器中根据地址信息转发到哪条链路
* 路由 routing：
  * 确定分组从源到目的经过的路径
  * 根据 路由算法 routing algorithms
* 连接建立：不是所有网络都需要
  * 数据分组传输之前两端主机需要首先建立虚拟连接
    * 网络设备（路由器）参与连接的建立

网络层服务模型：

* 无连接服务 connection-less service：
  * 特点：
    * 不事先为系列分组的传输确定传输路径
    * 每个分组独立确定传输路径
    * 不同分组可能路径不同
  * 典型例子：数据报网络 datagram network
* 连接服务：
  * 特点：
    * 首先为系列分组传输确定路径
    * 沿路径传输系列分组
    * 系列分组传输路径相同
    * 传输结束后拆除连接
  * 典型例子：虚电路网络 virtual-circuit network

#### 虚电路网络和数据报网络

##### 虚电路网络

提供网络层连接服务

一条从源主机到目的主机，类似电路的路径：

* 分组交换
* 每个分组的传输利用链路的全部带宽
* 源到目的主机经过网络层设备共同完成虚电路建设

通信过程： 呼叫建立 call setup -> 数据传输 -> 拆除呼叫

每个分组携带虚电路标识 VCID，而不是目标主机地址

每个网络设备都需要维护经过它的虚电路连接状态

可以面向虚电路VC 进行预分配资源：

* 如ATM的电路仿真 CBR

具体实现：

* 每条虚电路包括：
  1. 从源主机到目的主机的一条路径
  2. 虚电路号 VCID，沿路每段链路一个编号（不可能统一编号，因为每段链路负载不一样）
  3. 沿途每个网络设备，利用转发表记录经过的每条虚电路
* 路由器转发分组时根据转发表改写、替换VCID
* 转发表包括： 输入接口+输入VC+输出接口+输出VC

虚电路信令协议 signaling protocols：

* 用于虚电路的建立、维护及拆除
  * 路径选择
* 应用于虚电路网络，如ATM，帧中继 frame-relay网络等
* 目前的Internet不采用

##### 数据报网络

提供网络层无连接服务

每个分组携带目的地址

路由器根据目的地址转发分组：

* 根据路由协议、路由算法构建转发表
* 检索转发表
* 每个分组独立选路

数据报转发表：

* 转发表中目的地址针对地址范围
* 最长前缀匹配优先：优先选择匹配前缀最长的入口



数据报网络和VC网络的对比：

* 数据报网络 Internet：
  * 计算机之间数据交换：
    * 时间要求不严格
  * 链路类型众多：
    * 特点、性能各异
    * 统一服务困难
  * 智能端系统（计算机）
  * 简化网络，复杂边缘
* VC网络 ATM：
  * 电话网络演化而来
  * 核心业务是实时对话：
    * 严格时间、可靠性
  * 非智能端系统（电话机、传真机）
  * 简化边缘，复杂网络

#### IP协议

ICMP协议（IP协议的伴随协议）：

* 差错报告
* 路由器信令

IP数据报：

* 格式：
  * 头部
    * 固定部分：20字节
    * ![IP](http://ot1c7ttzm.bkt.clouddn.com/IP.png)
      * 版本号： 4-bit，IP协议的版本： 4：ipv4, 6：ipv6
      * 首部长度：4-bit：IP分组首部长度，以4字节为单位
      * 服务类型 TOS，占 8-bit：指示期望获得哪种类型的服务
        * 98年改名为区分服务，只有在网络提供区分服务diffserv时使用
        * 一般不使用，通常为00H
      * 总长度： 16-bit， IP分组的总字节数（首部+数据），最多可以放65535-20 Byte
      * 生存时间 TTL，8-bit：IP分组在网络中可以通过的路由器数，路由器转发一次分组，TTL-1，TTL==0时路由器丢弃该分组
      * 协议，8-bit：指示IP分组封装的是哪个协议的数据报，实现复用、分解， 6：TCP， 17：UDP
      * 首部校验和 16-bit：对IP首部差错检测，计算校验和时该字段置0，逐跳计算，逐跳检验
      * 源IP地址、目的IP地址，各32-bit
    * 可变部分： 0字节<=长度<=40字节，携带安全、源选路径、时间戳和路由记录等内容，实际很少被使用
    * 填充部分：长度可变， 0<=长度<=3B，目的是补齐首部符合32位对齐
  * 数据

IP分片：

* 最大传输单元 MTU：链路层 数据帧可封装数据的上限，不同链路MTU不同
* 当大IP分组向小MTU链路转发时，**可以**被分片 fragmented，若不允许分片且放不下，则将分组扔掉
* 一个大IP分组分成多个小IP分片，IP分片到达目的主机进行重装 reassembled
* IP首部的相关字段用于标识分片以及确定分片的相对顺序
* 涉及字段：
  * 总长度
  * 标识 16-bit：用于标识一个IP分组，每产生一个IP分组计时器加1，作为该IP分组的标识
  * 标志位 3-bit：保留，DF don't fragment ， MF more fragment：
    * DF=1：禁止分片   DF=0：允许分片
    * MF=1：非最后一片， MF=0：最后一片（或未分片）
  * 片偏移 13-bit：一个IP分组分片封装原数据的相对偏移量（未分片则为0），以8字节为单位

分片过程：

* 若 总长度>MTU且 DF=0，则分片
* 每个分片标识复制原IP分组的标识
* 除最后一片，其他分片均分为MUT最大允许分片
* 一个最大分片可封装的数据应该是8的倍数，可封装数据为 d = [ (M-20) / 8]*8（向下取整）（20字节头部）
* 需要总的片数  n = [(L-20)/d] (向上取整)
* 每片的片偏移字段取值为  F = d/8 * (i-1)  1<=i<=n
* 每片总字段长度   Li = d+20 （非最后一片）  Li= L-(n-1)d （最后一片）

#### IP编址 addressing

接口 interface：主机、路由器与物理链路的连接：

* 实现网络层功能
* 路由器通常有多个接口
* 主机通常只有一个或两个接口

IP地址：32-bit  IPv4：

* 编号标识主机、路由器的接口
* 32-bit =》  4个8bit的点分十进制地址
* IP地址与每个接口关联
* 如何为接口分配IP地址：
  * IP地址分为两部分：网络号netID （高位）+ 主机号hostID（低位）：
  * IP子网 subnet：
    * IP地址具有相同网络号的设备接口
    * 不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口

##### 有类IP地址

有类编址：

* A类地址 （50%） （第一位为0）  netID 8-bit，hostID 24-bit  0.0.0.0~127.255.255.255

* B类地址 （25%）（1\2位为10） netID 16-bit  hostID 16-bit   128.0.0.0~191.255.255.255

* C类地址（12.5%）（11） netID 24-bit， hostID 8-bit   192.0.0.0~223.255.255.255

* D、E不再区分netID和hostID

  * D类地址（6.25%）（1110） ：多播地址
    * 用作特殊目的：命名或标识一组主机，理论上可分布在任何地方，只能向其发送数据
  * E类地址（6.25%）（1111）：研究所用

* 特殊IP地址

  ![特殊IP](http://ot1c7ttzm.bkt.clouddn.com/specialIP.png)

* 私有地址：只用于内部网络，在公共环境无效

  * A类： netID 10 ，1个
  * B类： netID 172.16到172.31      16个
  * C类： netID 192.168.0 到 192.168.255      255个 

##### IP子网及子网掩码

子网划分：

* IP地址：
  * 网络号 netID：高位比特
  * 子网号 subid ：原网络主机号部分比特
  * 主机号 hostID：低位比特
* 子网掩码：
  * 确定是否划分了子网，利用多少位划分子网
  * 形式和IP地址相同， 32-bit，点分十进制形式
  * 取值： netID、subID全取1，hostID位全取0
  * 默认子网掩码：
    * A类默认子网掩码：255.0.0.0
    * B类默认子网掩码：255.255.0.0
    * C类默认子网掩码：255.255.255.0
    * 借用3比特划分子网的B类子网掩码 255.255.224.0
  * 子网地址 + 子网掩码 ：准确确定子网大小
  * 应用：
    * IP分组的目标IP地址与子网掩码按位与运算提取子网地址
    * 子网地址，地址范围 -> 去除不可用地址 -> 可分配地址范围


### 网络层（中）

#### CIDR与路由聚合

无类域间路由 classless interdomain routing：

* 消除ABC类地址界限
  * netID + subID -> 网络前缀 prefix  任意长度
* 融合子网地址和子网掩码，方便子网划分
  * 无类地址格式： a.b.c.d/x  x为前缀长度
* 优点：
  * 提高IPV4地址空间分配效率
  * 提高路由效率：
    * 将多个子网聚合成一个大网
    * 构造超网（supernetting）
    * 路由聚合（route aggregation）


#### DHCP协议

主机如何获得IP地址：

* 硬编码：
  * 静态配置（自行填写）
    * 默认网关：数据报转发到的路由器默认接口的IP地址
  * 动态配置协议 DHCP dynamic host configuration protocol：
    * 从服务器动态获取
      * IP地址
      * 子网掩码
      * 默认网关
      * DNS服务器名称及IP
    * 在应用层实现，封装在UDP数据报
    * 即插即用的协议
    * 允许地址重用
    * 支持在用地址续租
    * 支持移动用户加入网络
    * 与DHCP服务器交换报文：
      * 发现报文DHCP discover：客户端进行广播，确认服务器的地址
      * 提供报文DHCP offer：DHCP服务器利用提供报文进行广播响应并发送IP地址
      * 请求报文DHCP request：主机广播发送以请求IP地址，并通知其它可能的DHCP服务器回收资源
      * 确认报文DHCP ack：服务器向主机发送确认消息

#### NAT 网络地址转换

所有离开内网的源IP需要替换成相同NAT的IP地址及不同端口号

动机：

* 只需/只能从ISP申请到一个IP地址
  * IPV4耗尽
* 本地网络设备IP地址变更，无需通告外界网络
* 变更ISP时无需修改内网IP
* 内网设备对外网不可见，不能直接寻址（安全）

实现：

* 替换：（内到外）
  * 离开内网的IP数据报的源IP地址及源端口号替换NAT的IP地址及新端口号
* 记录：
  * 每对（NAT IP地址及新端口号）与（源IP地址及端口号）替换信息存储到NAT转换表
* 替换：（外到内）
  * 发回的数据报，利用NAT转换表替换IP地址和端口号

问题：

* 16-bit端口号字段（0-65535），可以同时支持6万多并行连接
* 争议：
  * 路由器应只处理第三层功能（NAT修改了第四层数据段的内容）
  * 违背了端到端通信原则
    * 应用开发者必须考虑到NAT的存在，如P2P应用
  * 地址短缺问题应该由IPv6解决

NAT穿透方案：

* 静态配置NAT：特定端口总是与特定内部IP及端口连接
* 利用UPnP universal plug and play 互联网网关设备协议IGD internet gateway device自动配置:
  * 内网主机自动学习到NAT公共IP地址
  * 在NAT转换表中，增删端口映射
* 中继 （如 Skype）：
  * NAT内部客户与中继服务器建立连接
  * 外部客户也和中继服务器建立连接
  * 中继服务器桥接两个连接的分组

#### ICMP互联网控制报文协议

internet control message protocol 互联网控制报文协议支持主机和路由器：

* 差错或异常报告（反馈）
* 网络探询（主动发送）

分类：

* 差错报告报文（5种）：
  * 目的不可达
  * 源抑制 source quench：拥塞控制，路由器向源主机发送，让其降低发送分组速度
  * 超时、超期（如TTL 可以跨越的路由器数目）
  * 参数问题：路由器认为IP数据报头部数据有问题
  * 重定向 redirect：路由器认定路径不对
* 网络探询（2组）：
  * 回声（Echo）请求与应答报文（Reply）：探测到目标主机的网络是否通达，如 ping
  * 时间戳请求与应答报文

不发送ICMP的特殊情况：

* 对ICMP差错报文不再发送ICMP
* 除对第一个分片外，后续分片都不发送ICMP
* 所有多播IP数据报都不发送
* 对特殊地址的IP数据报不发送ICMP

不再使用的ICMP报文：

* 信息请求与应答
* 子网掩码请求与应答
* 路由器询问和通告

报文格式：

* ICMP报文封装到IP数据报的数据部分传输
* ICMP头部：类型、代码、校验和

ICMP的应用：Traceroute

#### IPv6

动机：

* 32位ipv4地址空间分配殆尽
* 改进首部格式：
  * 快速处理、转发数据报
  * 支持QoS

数据报格式：

* 固定长度的40字节基本首部
* 路由器不允许分片（若要分片，源主机分）
* 基本首部+扩展首部（路由器一般不处理）+数据部分
* 扩展首部+数据 = 载荷（0至64KB）
* ![ipv6](http://ot1c7ttzm.bkt.clouddn.com/ipv6.png)
* 流标签 flow label：标识同一流中的数据报
* 下一个首部 next header：标识下一个选项首部或上层协议首部
* 跳步限制：TTL：允许经过的路由器数目

与IPV4的对比：

* 无校验和：以减少每跳处理时间
* 通过多个选项首部 支持 选项
* ICMPv6：新版ICMP：
  * 附加报文类型： packet too big
  * 多播组管理功能

地址表示：

* 一般形式：冒号分割的8组16进制数，每组4个数字
* 压缩：用两个连续冒号省略中间的0
* 兼容ipv4：前8个bit都为0:0:0:0:0：FFFF：ipv4地址 或 ::FFFF:ipv4
* 地址前缀：ipv6不再使用掩码

基本地址类型：

* 单播unicast： 一对一通信
* 多播multicast：一对多通信
* 任意播 anycast：一对一组之一（最近一个）通信

IPV4向IPV6过渡：

* 隧道 tunneling：IPV6数据报作为ipv4数据报的载荷进行封装穿越ipv4的网络


### 网络层（下）

#### 路由算法

概念：寻找最小费用路径的算法

静态路由 vs 动态路由：

* 静态路由：
  * 手工配置的路由
  * 路由更新慢
  * 优先级高
* 动态路由：
  * 计算得来的路由
  * 更新快
    * 定期更新
    * 及时响应连路费用或网络拓扑变化

全局信息 vs 分散信息：

* 全局信息：
  * 所有路由器掌握完整网络拓扑和链路费用
  * 典型算法：链路状态LS路由算法
* 分散decentralized信息：
  * 只掌握物理相连的邻居及链路费用
  * 通过邻居间信息交换及迭代运算
  * 典型算法：距离向量DV路由算法



链路状态路由算法：

* 所有路由器掌握网络拓扑和链路费用
* 通过链路状态广播
* 采用 dijkstra算法在每个路由器计算单源最短路
* 存在 震荡oscillations 可能

距离向量（Distance Vector）路由算法：

* 每个路由器只掌握物理相连的邻居及链路费用
* Bellman-Ford方程（动态规划）
* 步骤：
  * 每个结点不定时将自己的DV估计发送给邻居
  * 结点接收到邻居的新的DV估计时，依据BF更新其自身估计，若估计变化了，则传播给邻居
  * 距离最终收敛于实际的最小费用
* 特点：
  * 异步迭代
    * 引发局部迭代的因素：
      * 局部链路费用改变
      * 邻居的DV更新
  * 分布式：结点只当自己DV变化时才告诉邻居
  * 好消息（高费降低费）传播快，坏消息（低费升高费）传播慢
  * 可能有 无穷计数 count to infinite 问题，解决方案：
    * 毒性逆转技术 poisoned reverse：
      * 若Z到X的最小路径是通过Y，则y收到Z到X的费用是正无穷
    * 定义最大度量 maximum metric：
      * 定义一个最大的有效费用值，超过最大费用的记为无穷

层次路由：

* 提出原因：把网络抽象为一个图计算路由过于理想化，网络规模过大，管理自治
* 聚合路由器为一个区域：自治系统AS autonomous system
* 同一AS内路由器运行相同路由协议算法
  * 自治系统内部路由协议
  * 不同自治系统内的路由器可以运行不同的AS内部路由协议
* 网关路由器 gateway router：
  * 位于AS边缘
  * 通过链路连接其他AS的网关路由器
* 转发表由AS内部路由算法和AS间路由算法共同配置
* 热土豆路由：将分组发给最近的网关路由器

#### Internet 路由

路由协议：

* AS内部路由： 内部网关协议 IGP interior gateway protocols
  * 路由信息协议  RIP routing information protocol：
    * 距离向量路由算法
    * 距离用跳步数度量（最大有效为15跳步）
    * 通告advertisement ：每30s，邻居交换一次DV
    * 每次通告：最多25个目的子网
    * 链路失效、恢复：
      * 180s没有收到通告 -> 邻居、链路失效 -> 重新计算路由 -> 向邻居发送新的通告 -> 邻居可能向外发送通告
    * RIP路由表处理：利用一个称作route-d的应用层进程进行管理
    * 通告报文周期性通过UDP数据报发送
  * 开放最短路径优先 OSPF open shortest path first：
    * 链路状态路由算法：所有路由器对整个网络已知，dijkstra求解：
      * LS分组扩散（通告）
      * 每个路由器构造完整的网络AS拓扑图
      * 利用dijkstra计算
    * 每个入口对应一个邻居
    * 通告在整个AS中泛洪
    * 通告报文直接封装到IP数据报中
    * 优点：
      * 安全：所有OSPF报文可以被认证（预防恶意入侵）
      * 允许使用多条到同一目的的相同费用的路径（RIP只能从中选一条）
      * 对同一链路针对不同TOS设置不同费用度量
      * 集成单播与多播路由：
        * 多播OSPF协议（MOSPF）与OSPF利用相同的拓扑数据
      * 支持大规模AS分层 hierarchical：
        * 区边界路由器：同时在主干区和分支区的路由器
        * 主干路由器：只在主干区
        * AS边界路由器：连接其它AS
  * 内部网关路由协议 IGRP interior gateway routing protocol（思科的私有协议）
* AS间路由协议：BGP border gateway protocol：
  * 事实上的标准域间路由协议
  * 为每个AS提供了一种手段：
    * eBGP：从邻居AS获取子网可传达性信息（外部会话）
    * iBGP：向所有AS内部路由器传播子网可达性信息（内部会话）
  * 基础：
    * BGP会话session：两个路由器交换BGP报文
      * 通告去往不同目的前缀（子网）的路径
      * 报文交换基于半永久的TCP连接
    * BGP报文：
      * OPEN：建立TCP连接并认证发送方
      * UPDATE：通告新路径（或撤销原路径）
      * KEEPALIVE：无UPDATE时保活连接，也用于对OPEN的确认
      * NOTIFICATION：报告先前报文的差错，也用于关闭连接
    * 路径信息与BGP路由：
      * 通告的前缀信息包括BGP属性
        * 前缀+属性 = “路由”
      * 两个重要属性：
        * AS-PATH  AS路径：包含前缀通告所经过的AS路径
        * NEXT-HOP下一跳：开始一个AS-PATH的路由器的接口，指向下一跳AS
  * 路由选择：网关路由器收到路由通告后，利用输入策略import policy决策接收或拒绝路由：
  * 多条路径的挑选准则：
    1. 本地偏好preference值策略
    2. 最短AS-PATH
    3. 最近NEXT-HOP路由器：热土豆路由
    4. 附加准则
* 采用不同的AS内、AS间路由协议原因：
  * 策略：
    * AS间inter-AS：希望能够管理控制流量如何被路由，谁路由经过网络
    * intra-AS 内部：单一管理，无需策略决策
  * 规模：
    * 层次路由节省路由表大小，减少更新流量
    * 适应大规模互联网
  * 性能：
    * inter-AS间：策略主导
    * intra-AS内：侧重性能


### 数据链路层

#### 链路层服务

术语：

* 结点 nodes：主机和路由器
* 链路 links：连接相邻结点的通信信道：
  * 有线链路 wired links
  * 无线链路 wireless links
  * 局域网 LANS
* 帧 frame：链路层的数据分组，封装网络层的数据报

功能：负责通过链路在相邻结点间传输数据报

服务：

* 组帧 framing：
  * 封装数据报构成数据帧，加头加尾
  * 帧同步
* 链路接入 link access：
  * 若是共享介质时，需要解决信道接入 channel access
  * 帧首部的MAC地址 ( 物理地址 )，用于标识帧的源和目的
* 相邻结点间的可靠交付
  * 低误码率的有线链路很少采用（如光纤，某些双绞线）
  * 无线链路：误码率高，需要可靠交付
* 流量控制 flow control：
  * 协调pacing相邻发送结点与接收
* 差错检测 error detection：
  * 应对信号衰减和噪声
  * 接收端检测到差错：重传或丢弃
* 差错纠正 error correction （个别协议）：
  * 纠错编码：接收端可以直接纠正比特差错
* 全双工和半双工的通信控制

具体实现：

* 链路层在网络接口卡实现
* 由硬件、软件和固件组成
* 链接主机的系统总线

#### 差错编码

原理：

* 在数据上增加冗余信息 R 称为监督位或冗余比特

分类：

* 分组码
  * 线性码
  * 非线性码
* 卷积码

差错编码的检错能力：

* 差错编码分为 检错码 和 纠错码
* 对于检错码，若编码集的汉明距离d = r+1 ， 则该差错编码可以100%检测 r位差错
  * 汉明距离：编码集中任意两个字符编码不同比特数目的最小值
* 对于纠错码，汉明距离 d=2r+1，则该差错编码可以100%纠正r位差错（纠成与之距离最近的码字）

常见差错编码：

* 奇偶校验码：0的个数或1的个数加上冗余位为奇数或偶数
  * 1比特校验位：检测奇数位差错，冗余位少
  * 二维奇偶校验：
    * 检测所有奇数位差错、部分偶数位差错
    * 可以检测同一行或同一列差错
* Internet校验和  checksum：
  * 数据划分为16位二进制整数序列
  * 求和后取反码
* 循环冗余校验码 CRC
  * 数据 D 看成一个二进制数
  * 选择一个 r+1 位的生成比特模式 G
  * 目标：选择 r 位CRC比特 R 满足 < D,R >刚好可以被G整除
  * R计算方法： 
    * $ D*2^{r} (XOR)  R = n*G$
    * $ R =( D*2^r ) mod G $
  * 可以检测所有突发长度小于r+1位差错
  * 广泛应用于实际网络

#### 多路访问控制 MAC 协议

两类链路：

* 点对点链路：
  * 拨号接入的PPP
  * 以太网交换机和主机间的点对点链路
* 广播链路（共享介质）
  * 单一共享广播信道
  * 两个或两个以上结点同时传输：干扰 interference
    * 冲突 collision：结点同时接收多个信号
  * 多路访问控制协议 MAC multiple access control protocol：
    * 采用分布式算法决定结点如何共享信道
    * 基于信道本身进行协调
      * 无带外信道进行协调
    * 理想的MAC协议：
      * 完全分散控制：
        * 无需特定结点协调
        * 无需时钟、时隙同步
      * 需要发送数据的结点平分链路带宽
      * 简单
    * 分类：
      * 信道划分 channel partitioning MAC协议：
        * 多路复用技术 TDMA、FDMA、CDMA、WDMA等
        * 网络负载重时公平、效率高
        * 负载轻时效率低
      * 随机访问 random access MAC协议：
        * 信道不划分，允许冲突
        * 采用冲突恢复机制
        * 结点要发送数据时
          * 用信道的全部速率发送分组
          * 没有事先的节点间协调
        * 需要定义：
          * 如何检测冲突
          * 如何从冲突中恢复（通常是延迟重传）
        * 负载重时冲突大、效率低
        * 负载低时效率高
        * 典型随机访问MAC协议：
          * 时隙soted ALOHA：
            * 假定：
              * 假设所有帧大小相等
              * 时间划分成等长时隙（每个时隙可以传1个帧）
              * 结点只能在时隙开始时发送帧
              * 结点间时钟同步
            * 运行：
              * 有帧时，在下一个时隙发送：
                * 无冲突：在下一个时隙发新的帧
                * 有冲突：在下一个时隙以概率p重发，直至成功
            * 优点：
              * 单个结点活动时用整个信道速率
              * 高度分散化：只需要同步时隙
              * 简单
            * 缺点：
              * 容易冲突，浪费时隙
              * 空闲时隙
              * 时钟同步
              * 效率低，最好情况 37%
          * ALOHA：
            * 无时隙划分，纯ALOHA，更简单，无需同步
            * 有新的帧生成时：立即发送
            * 冲突可能性大
            * 比时隙ALOHA协议效率更低，18%
          * CSMA、CSMA/CD、CSMA/CA
            * CSMA 载波监听多路访问协议 carrier sense multiple access：发送帧之前监听信道：
              * 信道空闲：发送完整帧
              * 信道忙：推迟发送：
                * 1-坚持CSMA：以概率p=1监听信道
                * 非坚持CSMA：随机等待一段时间后再监听
                * P-坚持CSMA：以概率p坚持监听，1-p非坚持
              * 冲突仍然可能发送：信号传播延迟
              * 继续发送冲突帧：浪费信道资源
            * CSMA/CD CSMA with Collision Detection 带冲突检测的CSMA协议：短时间内可以检测冲突
              * 广泛用于以太网
              * 检测到冲突后，立刻停止传输
              * 冲突检测：
                * 有线局域网易实现：测量信号强度
                * 无线局域网难实现：接收信号强度淹没在本地发射信号强度下
              * 边发边听，不发不听
              * Lmin / R = RTTmax （Lmin：数据帧最小长度，R：网络带宽，RTT：消息来回的时间），发送数据时能够检测到冲突的最小长度，防止数据在冲突时已经发完，因不发不听而不知道有冲突
            * CSMA/CA 应用于802.11无线局域网
      * 轮转 taking turns MAC协议：
        * 结点轮流使用信道
        * 综合信道划分和随机访问的优点
        * 类型：
          * 轮询 polling：
            * 主结点轮流邀请从属结点发送数据
            * 典型应用： 哑dump（非智能、蓝牙）从属设备
            * 问题：
              * 轮询开销，数据占用带宽
              * 等待延迟
              * 单点故障，主结点故障问题
          * 令牌传递 token passing：
            * 控制令牌依次从一个结点传递到下一个结点
            * 令牌：特殊帧，网络中有且只有一个令牌
            * 网络可能构成环形网络
            * 问题：
              * 令牌开销，带宽开销
              * 等待延迟
              * 单点故障：令牌丢失

### 局域网

#### ARP协议

MAC地址：物理地址、LAN地址、以太网地址

* 作用：在局域网中标识一个帧从哪个接口发出，到达哪个物理相连的其它接口
* 48位（16进制6字节）MAC地址，固化在网卡的ROM中，有时可以软件设置
* 局域网中每块网卡都有唯一的MAC地址
* 由IEEE统一管理与分配
* 网卡厂商在IEEE购买前24比特MAC地址空间
* 与IP地址区别：
  * MAC地址是“平面地址”，可以从一个LAN移到另一个LAN，用于标识帧
  * IP地址是层次地址，依赖结点连接到哪个子网，用于标识数据报

ARP：地址解析协议

* 已知目的接口的IP地址下确定MAC地址
* ARP表：LAN中每个IP结点维护一个表，存储某些LAN结点IP/MAC地址映射关系：< IP; MAC ; TTL>(TTL time to live:经过这个时间后该映射关系会丢弃，一般为20min)
* ARP是“即插即用”协议：结点无需干预，自主创建ARP表
* 获取目标主机的MAC地址：
  * 同一局域网内：
    * 若A的ARP表不包含B的MAC地址，则A广播ARP查询分组，其中包含B的IP地址，只有B向A利用单播帧响应B的MAC地址，A缓存B的地址对直至超时
  * 不同局域网内：
    * A发数据帧至网关路由器（源IP为A，目标IP为B，源MAC为A，目的MAC为网关路由器的一端口），网关路由器转发数据报，更改源MAC地址为发出端口的MAC地址，若双方都在公网，则不需要更改IP地址

#### 以太网 Ethernet

有线LAN技术、应用最广泛的LAN技术

物理拓扑：

* 总线 bus：同轴电缆，上世纪90年代中期流行
  * 所有结点在同一冲突域 collision domain ，可能彼此冲突
* 星型 star：目前主流网络拓扑
  * 利用中心交换机 switch
  * 每个结点一个单独冲突域，结点间彼此不冲突

特点:

* 无连接 connectionless：发送帧的网卡和接收帧的网卡没有握手过程
* 不可靠 unreliable：接收网卡不向发送网卡进行确认
  * 出错可能性低，差错帧直接丢弃，依靠高层协议恢复数据
* 采用二进制指数退避算法CSMA/CD的 MAC协议：
  1. 网卡从网络层接收数据报，创建数据帧
  2. 监听信道：
     1. 监听到信道空闲，则发送帧
     2. 信道忙，一直等待到信道空闲，然后发送
  3. 发送完整个帧没有检测到其他结点数据发送，则确认发送成功
  4. 若检测到其他结点传输数据，终止发送并发送阻塞信号 jam signal
  5. 网卡进入二进制指数退避：
     * 第m次连续冲突后：
       * 取n=Max(m,10)
       * 网卡从 0到 $2^n-1$随机取一个数K
       * 等待 K * 512bit的传输延迟时间，再返回第2步
     * 连续16次冲突后，报告差错

帧结构：

* 把IP数据报封装到以太网帧中
* 前导码 preamble   8B：
  * 前7个字节为10101010，第八字节为10101011
  * 用于发送端和接收端的时钟一致
* 目的MAC和源MAC地址（各6B）
* 类型 Type  2B：指示帧中封装哪种高层协议的分组
* 数据 Data 46-1500B：上层协议载荷 （CSMA/CD发送数据时能够检测到冲突的最小长度）
* CRC 4B：循环冗余校验码
