---
layout: post
title: "软件开发综合实训小结：基于Qt的排序算法演示系统"
date: 2018-07-14
comments: true
tags: 
	- C++
	- 软件开发
	- Qt
---

2018年 6月4日 - 7月5日 间， 我们进行了为其一个月的软件开发综合实训。 在实训中我们以5-6人的小组为单位进行团队开发，使用c++最终完成基于Qt的排序算法演示系统。在这一个月中，我担任小组的组长，和团队成员一起学习Qt、学习团队开发、进行需求分析、功能设计、系统模块设计，并到后来的编码实现及测试。通过这次实训我收获颇多，在此将整个实训过程梳理并小结一番。

<!-- more -->

### 题目背景与需求分析

限定语言为C++，可选题目为：线性表、堆栈、队列、树、图5个基本结构（或基本排序算法-插入、冒泡、选择、快速、堆排序、归并、基数排序）的算法演示系统。

经过小组讨论，我们选择排序算法演示系统。

而后，我们查找了当前已有的排序算法演示系统，并以 [这个算法可视化网站](https://visualgo.net/zh) 作为参考。 通过实际使用已有的算法可视化系统，我们将要实现的功能分为三类：

1. 算法功能：系统所支持的排序算法，以题目给出的七种排序算法为准。
2. 演示功能：一开始的讨论中我们认为演示起码要有连续执行和单步执行，连续执行要能够在连续和暂停之间切换。而返回上一步的功能作为备选功能。
3. 数组生成功能：系统应当支持随机生成和用户自定义数组。通过对数组进行分析，我们确定了两个用户可修改的属性：数组规模和具体的数组元素。

此外，对于数据的表现形式，我们认为采用数字并不直观，以图形的形式表示更好，并且最好数字的相对大小能够反映到图形的相对大小上，由此我们直接采用了上文已有的可视化形式：用矩形+数字来表示一个数组元素，矩形的宽度固定而长度不定，根据数组内元素分布而动态变化。

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo0.png)

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo1.png)

### 模块划分与小组分工

通过对演示系统进行分析、观察已有的算法演示系统，我们根据经验以及观察的结果，首先将系统划分成各个模块：窗口模块、图形元素及按钮的静态模块、算法演示模块、辅助模块（如记录日志、数组等）以及能够在图形元素上进行的操作模块。

对于小组分工，起初我们的设想是由一个同学统一封装好图形操作并提供简单的接口，就是我们所学的 Facade 模式。但在讨论的过程中发现我们需要对很多操作进行约定，但这些约定是建立在有经验的基础上的，而对于我们这些初学者来说，开始时建立的约定很可能会不断变更，那么维护接口并根据接口调整程序就变得相当麻烦。此外，我们还需要那位封装接口的同学尽可能快地完成封装任务，才能确定其它模块实现的可行性。

后来我们想到，团队分工其实是和软件的类设计以及职责分配是一样的，虽然提倡高内聚且低耦合，但一般很难同时达到这两点。为了项目开发进度着想，并且我们对项目的可维护性要求并不高，因此我们采用每个人完成一到两个算法演示部分的方法，每个人自行完成单步演示、连续播放、暂停以及重设数组等操作，至于每个操作具体如何实现则由实现的同学自行考虑。而最后我们仅需要将算法演示和主窗口结合起来即可。

这样的分工虽然内聚性较低且重复性也比较高，但是每个人都能够参与算法完整演示的开发，每个人都能够学到东西，并且团队的耦合性也比较低，每个人能够较为独立地进行开发。这对我们目前的团队和任务来说是比较优的方法了。

而要具体划分算法模块时，我们还遇到一个问题：算法的难度不同。

对于三个基本排序（选择、插入、冒泡）以及快排，演示时涉及到的仅是块的颜色变换以及块的交换。

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo2.png)

对于归并排序，我们还需要块能够上下移动，以表明一个归并的过程：

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo3.png)

对于堆排序，我们需要矩形以二叉树的形式进行演示，在这种情况下不需要矩形的长度随着数据大小进行变化。涉及到的演示过程主要为变色与矩形块的交换。

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo4.png)

对于基数排序，我们需要有基数槽。此外，矩形的操作除了变色外并不需要交换，但它需要方便地进行移动。

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo5.png)

在将每个算法演示涉及到的操作列举出来之后，我们认为在难度方面： 三个基本排序+快排 < 归并 < 基数 ≈ 堆排，此外我们还需要绘制窗口、处理用户事件以及撰写过程文档。

最终我们的分工如下：

1. 一名同学负责窗口设计与绘制，并负责一个基本的排序算法
2. 一名同学负责用户事件处理（点击、输入数据等事件）并做最后整合，且负责一个基本排序算法
3. 一名同学作为文档负责人，并且负责一个基本排序算法
4. 一名同学完成两个排序算法：归并与快排
5. 两名同学分别完成两个较为困难的排序算法的演示：堆排序和基数排序

我负责的为第二点，用户事件处理、最终整合以及选择排序的实现。

### 选择排序演示的实现

#### 1. 类设计与功能划分

在学习Qt的基本操作以及了解了图形移动的实现方式之后，我就开始着手进行类的设计以及功能划分了。

Qt中静态的窗口及元素由QWidget完成，而涉及到矩形、圆形等的几何图形绘制及移动，就需要用到View 和 Scene了，在算法演示系统中，我们不仅需要矩形等几何图形，也同样需要QWidget的按钮等元素，由此我们利用scene的addWidget函数将Widget作为其中一个元素加入场景中。这样我们就能够专心在Widget中处理各种按钮及其它事件，在主类中生成矩形以及进行各种演示操作。

了解到矩形移动需要使用定时器来控制移动时间和频率，为了提高类的内聚性以及提高通用性，我将各种计时器统一提取出来放到一个单例模式辅助类，在之后整合的时候，这个类还可以放入其它杂属性来保存一些全局信息。

在大的框架上总共有三个类（不考虑排序算法的虚基类）：

1.  排序算法主类，进行数组生成、记录生成及演示
2.  Widget类，静态窗口类，用于放置各种静态按钮、文本输入框以及处理和它们相关的事件
3.  辅助类Event，用来保存全局信息和各种计时器。

而到了底层，我们还需要以下几个类作为框架类的属性并提供支持：

1.  矩形类，使用了Qt允许的自定义的图像元素，方便根据需要生成变长矩形
2.  图形元素类，封装了矩形类+数字文本类，并保存了这个图形元素对应的数组数字，是排序算法操作的基本单位。
3.  记录类，描述单个记录需要保存哪些信息：记录的类型（变色或移动）、模式（变什么颜色或往哪里移动）、图形元素的索引（哪个图形要发生变化）。此外还有一个前驱指针和一个后继指针。
4.  记录链表，使用双向链表保存一系列记录，包含首尾两个哨兵以及一个指向当前正在读取的记录的指针current。当中实现了些常用的双向链表的操作（清空、尾插入、判空等）。

#### 2. 数组、记录生成及演示操作

在数组的生成方面，为了方便用户使用，我们首先随机在规定范围内生成一个数组以供用户直接使用演示功能。而后，用户能够随时更改数组规模和具体的数组元素。数组生成共分为四大类情况：

1.  用户未设置数组规模及具体数组元素，则系统随机生成数组。
2.  用户设置了数组规模未设置具体元素，则系统根据规模生成随机数组。
3.  用户仅设置了具体的数组元素但未设置规模，则系统原样根据元素生成数组。
4.  用户同时设置了数组规模和元素（原则：以规模数为准）：
   1.  元素数目和规模匹配：则系统原样生成。
   2.  规模数大于元素数：系统补足剩余元素。
   3.  规模数小于元素数：系统截取规模数以内的元素。

每当数组生成之后，系统就会立刻根据排序算法生成记录列表，之后的演示就只是移动双向链表中的current指针依次读取记录并执行了。

那么记录是如何生成的呢？在生成的函数内，实际上有个临时数组复制了生成的数组，而后对临时数组执行相应的排序算法，在算法执行的过程中在关键的部分创建记录并插入链表中。

记录包含三个属性：type，attribute1，attribute2：

1. type = 0 代表变色，此时attribute1表明变色的模式，attribute2表明要变色的矩形下标：
   1. attribute1 = 0 将矩形变为正常颜色
   2. attribute1 = 1 矩形此时被选中，变为选中模式的颜色，若前一个矩形不是最小的矩形，则将上一个矩形恢复未正常颜色
   3. attribute1 = 2 矩形为当前最小，变为最小模式的颜色
   4. attribute1 = 3 若矩形不是当前最小，则恢复为正常颜色
2. type = 1 代表交换：attribute1和attribute2记录要交换位置的两个图形元素的索引。

#### 3. 演示与定时器

在演示部分，用户可以选择连续演示、暂停和单步演示。

从上一次演示到下一次演示是通过设定计时器并等待计时器触发，执行相应触发函数完成的。

演示模式分为播放和暂停，当前的演示模式通过辅助类的一个全局变量记录下来，每读取并执行完一条记录，则检查全局变量标签，若此时为播放模式，则开启下一轮计时器，当计时器达到设定值时系统开始读取并执行下一条记录，直到用户暂停或执行完最后一条记录。若此时为暂停模式，则不做任何操作，等待用户下一步操作。

用户能够单击连续演示、暂停、下一步和重新开始按钮：

1.  连续演示按钮实则将标签设置为播放，而后手动开启一次计时器
2.  暂停按钮则将当前的计时器关闭，将标签设置为暂停
3.  下一步按钮则将标签设置为暂停并手动开启一次定时器
4.  重新开始按钮则会调用算法类实现的重设功能，我们将current指针一步步向前移动并根据恢复换位操作，最终将所有的矩形块变为正常颜色。

对于动画演示至关重要的计时器在选择排序部分总共分为两个：

1. 第一个全局计时器描述执行一条记录所需要的时间，这个时间视当前执行的记录的类型而定，反映到界面上就是每个变化之间的时间间隔，变色的时间间隔要比交换的时间间隔短得多。
2. 第二个交换计时器描述交换一小步的时间，我们将一个完整的交换过程切成固定数目的段并用一个常量记录下来，而交换计时器每触发一次，就会将两个要交换位置的矩形稍微向对方位置移动一小点，同时更新一个临时计数器，一旦临时计数器达到先前提到的常量，则说明两个矩形到达目标位置了，那么就关闭交换计时器。

### 用户事件处理及整合

用户所能够进行的操作共分为三类：

1.  设定数组
2.  切换演示模式
3.  切换算法

前面介绍了前两类操作，而第三种分为两种情况：

1.  用户当前在主界面，界面列出用户可选的算法，用户通过点击选择一个算法并进入演示界面

   ![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png)

2.  用户已经进入了某个算法的演示界面，想要直接切换到另外一个算法

   ![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF11.png)

对于整合，在开发的过程中，我就根据自己实现的选择排序算法类构造了一个虚基类并规定了几个必须要实现的接口，因此拿到其他成员实现的算法类我并不需要知道它们内部是怎么实现的，只需要用虚基类的指针指向对应的实例对象然后通过多态调用相应的函数即可。

整合的方法总共尝试了三种，前两种均因不明情况而宣告失败，最后选用了最简单粗暴的方案三解决了。

1. 方案一：全局使用一个view、scene和widget，每个算法的单例对象在创建后不删除。每当用户选择其它排序算法时，将当前算法类的图形元素一个个从场景中抹去，而后将虚基类指针指向新的算法类单例对象，完成初始化并调用重设函数。
2. 方案二：全局使用一个view，算法的单例对象创建后不删除，scene和widget在每次切换都重新生成，需要调用算法的重设函数重新向scene中添加元素。
3. 方案三：全局使用一个view，算法对象、scene和widget每次切换都重新生成。

采用方案一、方案二实现的过程中，总会在切换时发生各样奇怪的bug。由此看来问题很可能出现在算法对象的重设以及和scene的交互上，进一步推测很可能出现在指针指向对象的存在性以及空间分配和回收上。鉴于项目时间紧迫，我们就没有再采用方案一或二深入纠正了。

### 成果展示

最终我们的系统成品如下，所有的交换过程均为实际动画。

起始界面:

![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png)

冒泡排序算法的演示界面:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF1.png)

块互换位置的过程:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF2.png)

块被选中及进行大小比较:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF3.png)

归并的过程:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF4.png)

归并归位的过程:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF5.png)

堆排序建堆过程:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF6.png)

堆排序构建有序数组过程(粉色代表已经有序)

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF7.png)

基数排序初始样式:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF8.png)

基数排序取个位数选槽的过程:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF9.png)

第一轮基数排序即将完成:

![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF10.png)

### 总结

本次实训我的收获很大，收获分为以下几个方面：

1. 团队合作开发软件的经历。作为组长不仅要考虑从需求转换到功能，更要根据需求的可实现性对需求进行挑选。此外还需要尽可能地合理划分模块并进行分工。在开发过程中需要时时确认开发进度，锁定开发中遇到的问题并组织讨论解决。在开始时有预想好分工，但后来想到，团队分工其实和类的设计是一样的，要尽可能提高内聚，降低耦合，尤其大家都没有开发经验，因此一开始约定的接口很可能变来变去，于是就直接划分算法让大家自行实现，最后直接整合。
2. 第二自然是对Qt开发和使用有了了解，对于C++带界面的应用程序也总算有了接触。因为Qt极其庞大，功能奇多，之前也没有C++界面应用程序的开发经验，因此一开始总有种畏惧情绪。但后来实际接触下来，发现其实和java的fx差不多，尤其creator已经集成了很多很方便的功能，如界面设计直接拖控件即可等。并且Qt虽然功能很多，但我们仅需要其中的很少一部分，只要在用的时候查对应的部分即可，以往想要全部掌握再开工的学生思维很不适合这样的开发。
3. 第三则是C++本身的使用了，大一过后除了实验课之外就很少再用C++进行开发了，java的面向对象更为直观，python方便快速易用，让我很少再使用C++。而这次综合实训让我重新把c++捡起来并且再度体会到它的博大精深，有相当多玄妙而精巧的设计，难怪其难度远远在其它语言之上，尤其在开发过程中我们大量使用指针，在debug过程中也相当艰辛。

这次实训让我收获匪浅，不仅认识到自己的不足，开拓了自己的眼界，掌握了新的知识，还实际进行了团队开发。以往自己个人开发时不需要考虑太多代码和接口的易读性，以及界面的易用性等，但团队开发时这些都非常重要。我的团队意识也有了非常大的提高。

### 源代码

整个项目的源代码可以在[我的github](https://github.com/zedom1/Class_Project/tree/master/Sorting%20Algorithm)看到。
