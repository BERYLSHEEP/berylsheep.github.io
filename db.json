{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"f32c465cddf5fbe3c1ff1506cbf438a7b3667dc7","modified":1527251731644},{"_id":"source/README.md","hash":"ddeedf15bed7fc9d74587296bd1f690cdd0aaffe","modified":1527252871653},{"_id":"source/robots.txt","hash":"79cb92b89a36c4b1384fcaa7a3648caca8afcd48","modified":1527863350573},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1527214970928},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1527214970929},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1527214970929},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1527214970929},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1527214970929},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1527214970929},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1527214970929},{"_id":"themes/yilia/_config.yml","hash":"4a772a5ec6e0e1a869b626443622d0a55c941f2e","modified":1527847152524},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1527214970945},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1527214970968},{"_id":"source/_posts/Compiler1.md","hash":"786a17a587c995a1b365c582b937557af0798c5b","modified":1527252071535},{"_id":"source/_posts/Compiler2.md","hash":"39d7eb9560d671caa76242b15b8049fdc43f54d1","modified":1527252071924},{"_id":"source/_posts/Cyclooctane 2.md","hash":"f136d34fe1e120c892e411ecfb0cd7f8189575c4","modified":1527252072071},{"_id":"source/_posts/Cyclooctane.md","hash":"bffaca5af9c8c331a8b5a99a86ffdfd09ea6f55f","modified":1527252071994},{"_id":"source/_posts/DataStructure_Graph.md","hash":"2ed40180df156d8b831976a91f077a81f73d650f","modified":1527252072161},{"_id":"source/_posts/DataStructure_List.md","hash":"349bfd9363e8723c53a1e697a796e5b98a81e33a","modified":1527252072233},{"_id":"source/_posts/DataStructure_Stack.md","hash":"d706805e9d8dba1ef32f29ab5c08f246d51a60f0","modified":1527252072313},{"_id":"source/_posts/Hello,World.md","hash":"2d10522f711fbf2e7da59da0e8bb52694f7f015a","modified":1527252072717},{"_id":"source/_posts/DataStructure_Tree.md","hash":"2b032ff066a2e6ff0a942004660ff1d294181cfa","modified":1527252072394},{"_id":"source/_posts/ProblemSet1.md","hash":"57609f1e86fb2d967edd152b7ddbad97bbb933dc","modified":1527252072572},{"_id":"source/_posts/Java_note1.md","hash":"0d684320bc1b647ccb5c0923f33160bb0eaa3fa8","modified":1527945032326},{"_id":"source/_posts/RC_DuReader.md","hash":"3204a38be2e70cb9a26a82b34ec5c55bd24438d1","modified":1527945396651},{"_id":"source/_posts/SAT.md","hash":"0603c3586399723f3a1d2ac88275a89622f414d7","modified":1527252072646},{"_id":"source/_posts/ProblemSet_Tree.md","hash":"3b92ff422b0810199cfb26306204d1ed69b54b36","modified":1527252072805},{"_id":"source/_posts/VSM.md","hash":"279e5cfec8a67b3dfa7cc9a6a70d0e468d86d0ad","modified":1527908392474},{"_id":"source/_posts/chineseErrorDectection_n_gram.md","hash":"52dcb6a744e2377f7977ccb96a4ccd4494b0cda6","modified":1532263137548},{"_id":"source/_posts/sorting algorithm.md","hash":"358635050ab1344faebcd7087af1bdcbbe7cba9d","modified":1531574488523},{"_id":"source/_posts/tf_csc_trick.md","hash":"0b53a26fc077c8406c04c7221ef96f6630988578","modified":1535526029198},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1527214970905},{"_id":"source/_posts/csc_corpus.md","hash":"7d72ee20d43fa97411d22475909789d5a15ca085","modified":1535447083251},{"_id":"themes/yilia/.git/config","hash":"032e5805693203a246253009a88385e709bbbe14","modified":1527214970909},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1527214964214},{"_id":"themes/yilia/.git/index","hash":"38023b006a359fab7d93df11f2226ea91bea6fd9","modified":1527252331266},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1527214970901},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1527214970930},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1527214970930},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1527214970930},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1527214970930},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1527214970930},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1527214970930},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1527214970930},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1527214970944},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1527214970944},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1527214970944},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1527214970944},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1527214970945},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1527214970945},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1527214970945},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1527214970963},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1527214970967},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1527214970945},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1527214970960},{"_id":"source/_posts/network_note.md","hash":"9f2c4bcca7993e347f8d91dd49fef0460bdec54b","modified":1527944365606},{"_id":"source/_posts/os_note.md","hash":"7ed652d4695b562c18411939d3fde68c9e095b81","modified":1527944542586},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527214970943},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1527214970964},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1527214970967},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1527214964215},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1527214964217},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1527214964218},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1527214964216},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1527214964216},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1527214964215},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1527214964216},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1527214964217},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1527214964217},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1527214964218},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1527214964218},{"_id":"themes/yilia/.git/logs/HEAD","hash":"8a90d444e08c047a2fd84d18a61ab893569d5f47","modified":1527214970907},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"1b14cbc4139c09ceaf86443b6a0e8922b5790e33","modified":1531471931263},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1527214970932},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1527214970932},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"2ee4e93b25bf909363e0730e5f8b4cd0c6cd9496","modified":1531472509374},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1527214970934},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"ccb143d6aaf65911225e6f40c40217a6e38f32cb","modified":1527240445520},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1527214970934},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1527214970935},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1527214970935},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1527214970935},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1527214970944},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1527214970944},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1527214970960},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527214970960},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527214970961},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527214970961},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527214970961},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527214970961},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1527214970962},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1527214970962},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527214970962},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1527214970945},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1527214970946},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1527214970947},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1527214970947},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1527214970947},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1527214970948},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1527214970952},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1527214970953},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1527214970953},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1527214970954},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1527214970954},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1527214970955},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1527214970955},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1527214970955},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1527214970955},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1527214970955},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1527214970956},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1527214970956},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1527214970957},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1527214970957},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1527214970958},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1527214970958},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1527214970958},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1527214970958},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1527214970958},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1527214970958},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1527214970959},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1527214970959},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1527214970959},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1527214970959},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1527214970959},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1527214970943},{"_id":"themes/yilia/.git/objects/pack/pack-40d65f13e401affe70836d4abdca0ee54aa7b186.idx","hash":"704c0b5040efce2c79d04ae53872445453160c49","modified":1527214970780},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1527214970907},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1527214970940},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1527214970942},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1527214970942},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1527214970942},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1527214970947},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1527214970947},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1527214970948},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1527214970948},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1527214970948},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527214970949},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527214970949},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527214970950},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527214970950},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527214970954},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527214970954},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1527214970954},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"8a90d444e08c047a2fd84d18a61ab893569d5f47","modified":1527214970908},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1527214970904},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"8a90d444e08c047a2fd84d18a61ab893569d5f47","modified":1527214970904},{"_id":"themes/yilia/.git/objects/pack/pack-40d65f13e401affe70836d4abdca0ee54aa7b186.pack","hash":"5abf4afacaf3b21748592f04b32982768856de49","modified":1527214970779},{"_id":"public/baidusitemap.xml","hash":"8730115ed07d8b720bf9e9a6e7bfcc1c31c41f12","modified":1535526038219},{"_id":"public/content.json","hash":"fd5ebd030a29eea7300857aab06dd08fe4b5255b","modified":1535526038219},{"_id":"public/sitemap.xml","hash":"000a67dcfd2822dc6e41b97f2f55d7fcc83376de","modified":1535526038220},{"_id":"public/2018/08/29/tf_csc_trick/index.html","hash":"04645a42277513367e625ad60b2b39d0a6530f22","modified":1535526039863},{"_id":"public/2018/08/28/csc_corpus/index.html","hash":"c6fd6542980d64f51167ec624692abd734f0cdf3","modified":1535526039863},{"_id":"public/2018/07/22/chineseErrorDectection_n_gram/index.html","hash":"9a1ab8c5b7be490cc10dc495e660cf2a184dd8d4","modified":1535525932426},{"_id":"public/2018/07/14/sorting algorithm/index.html","hash":"22c5fe42de614af07cd2a6af345b6c5dc1824bec","modified":1535525932426},{"_id":"public/2018/06/01/VSM/index.html","hash":"6cdcadf5fb92add1f0360a3c637ab2416e46a1b3","modified":1535525932427},{"_id":"public/2018/05/22/RC_DuReader/index.html","hash":"5908a37f8a89bc2d9d8f972dd62c6ccb31216f4a","modified":1535525932427},{"_id":"public/2018/02/20/os_note/index.html","hash":"5f4c15e0ea39229e46c6d1e5123b854de96401ce","modified":1535525932427},{"_id":"public/2018/02/20/network_note/index.html","hash":"3b2869dfbb82e68515f58652f6c5f0c8a6eda398","modified":1535525932427},{"_id":"public/2017/09/11/Java_note1/index.html","hash":"328a127ae98bc3b53c2229f37893e0d86bfcd8b2","modified":1535525932427},{"_id":"public/2017/08/28/Cyclooctane 2/index.html","hash":"595ebb9e3b82ee3ec2ad600125b42579df0cdeee","modified":1535525932427},{"_id":"public/2017/08/24/Compiler2/index.html","hash":"6e038ec421ef56304476b4fa0e67c920ed5c9825","modified":1535525932427},{"_id":"public/2017/08/23/Compiler1/index.html","hash":"42f8b097fa4c31159c38ea8e6e7814c06fb23a15","modified":1535525932427},{"_id":"public/2017/08/19/DataStructure_Graph/index.html","hash":"8a32b3205e44f341b906b0f1ddd5672ae6a44b6d","modified":1535525932427},{"_id":"public/2017/08/18/ProblemSet_Tree/index.html","hash":"f88b765abddab976f5c8809478d90469ac794272","modified":1535525932427},{"_id":"public/2017/08/18/ProblemSet1/index.html","hash":"f6c101fe04e26d7d34bda5444f51d7df506a5ae4","modified":1535525932427},{"_id":"public/2017/08/15/DataStructure_Tree/index.html","hash":"e8b9c48cb2c66b2aed98193ba998ce04bf5b0760","modified":1535525932428},{"_id":"public/2017/08/14/DataStructure_Stack/index.html","hash":"f6ea3628bc2163fec24adf98650f71e3dfe5a97d","modified":1535525932428},{"_id":"public/2017/08/12/DataStructure_List/index.html","hash":"25906be605f423037dec0a713d26c65caf95958e","modified":1535525932428},{"_id":"public/2017/07/15/SAT/index.html","hash":"a157f7c48cf2f8d39c611c9bb4ff80402e5ee114","modified":1535525932429},{"_id":"public/2017/05/11/Cyclooctane/index.html","hash":"8874c94ad9e7bc2ef7c754434e48c83f8af06974","modified":1535525932429},{"_id":"public/2017/05/10/Hello,World/index.html","hash":"c0ec082375b0e311079d5bec3b77f1c06f02e9dd","modified":1535525932429},{"_id":"public/archives/index.html","hash":"82e9a12f598a30b9e7124a4e1a6b67701688fbc6","modified":1535526039863},{"_id":"public/archives/page/2/index.html","hash":"884c24cf1f6d5513a09dbd22d31e50df97be89d3","modified":1535525932429},{"_id":"public/archives/page/3/index.html","hash":"257351a127c537fee494e57b8e02519fbd77d32c","modified":1535525932429},{"_id":"public/archives/2017/index.html","hash":"b8a38c7efffb270dedd27be439b2f257a25326ca","modified":1535525932429},{"_id":"public/archives/2017/page/2/index.html","hash":"1b1b755c52459c3ba523b71beb855f72d3e35097","modified":1535525932429},{"_id":"public/archives/2017/05/index.html","hash":"e218f6641eb4209b2f73d1beeeb615d87e8d7f36","modified":1535525932429},{"_id":"public/archives/2017/07/index.html","hash":"30bc324e2415a45a5c63f1619251239d53598e25","modified":1535525932429},{"_id":"public/archives/2017/08/index.html","hash":"468ada2e36163cccfd6cbfc333ce02ea98703711","modified":1535525932429},{"_id":"public/archives/2017/09/index.html","hash":"f5dc71a082b872c7e87553886059eebacd33c081","modified":1535525932430},{"_id":"public/archives/2018/index.html","hash":"9961827f1ab4d43f26ccd144f4c50f56157eb78d","modified":1535526039864},{"_id":"public/archives/2018/02/index.html","hash":"a46f0b41cfdd37b2be4a6aec10069a32ccd3f223","modified":1535525932430},{"_id":"public/archives/2018/05/index.html","hash":"49b07dfb7808582c46532091cf5e78ee1d3fa5c4","modified":1535525932430},{"_id":"public/archives/2018/06/index.html","hash":"a27e29629250659fc320e5f5600ba6f0d39df1a8","modified":1535525932430},{"_id":"public/archives/2018/07/index.html","hash":"42453d6fb5d596f07f298328fe161afd87d76c9e","modified":1535525932430},{"_id":"public/archives/2018/08/index.html","hash":"ef1c31c5170bdf280feaf592940c1c0f2cd2c2ba","modified":1535526039864},{"_id":"public/index.html","hash":"560fef386b4b2704ddd229cc1dad80a9410af7be","modified":1535526039864},{"_id":"public/page/2/index.html","hash":"35b479234edb452ed1e35f4e136f797b31b1a355","modified":1535525932430},{"_id":"public/page/3/index.html","hash":"fd57ebc507a2c7a03e3cc05a5f8a48d5ccaa50a2","modified":1535525932430},{"_id":"public/tags/编译原理/index.html","hash":"4f418eaa97ceea92c91ba9e9f0c179140518e9f9","modified":1535525932431},{"_id":"public/tags/学习笔记/index.html","hash":"d680fa647abba1888feb6705435d728543d23389","modified":1535525932431},{"_id":"public/tags/游戏/index.html","hash":"ac8f38cf4dacfa69c0c16a483952da2d6228bcf6","modified":1535525932431},{"_id":"public/tags/c/index.html","hash":"487e43848c5d80d50ed9350d62227961282ac60d","modified":1535525932431},{"_id":"public/tags/数据结构/index.html","hash":"39f114dfaf858dade17a3dac591a005130c26387","modified":1535525932431},{"_id":"public/tags/others/index.html","hash":"f636be3eab6c2135b775371838ccdb504a70374c","modified":1535525932431},{"_id":"public/tags/刷题/index.html","hash":"6ee1190eb1ab191008df8dbdfb20a176bf101671","modified":1535525932431},{"_id":"public/tags/JAVA/index.html","hash":"b91439184dcd7dd2da82dd1da091f9dec68bd32d","modified":1535525932431},{"_id":"public/tags/NLP/index.html","hash":"2dba1aa2209f663e707619fa0c65799cf2fd3c06","modified":1535526039864},{"_id":"public/tags/阅读理解/index.html","hash":"6e6d530f1923fb11f0cd951e06ba242446e68bad","modified":1535525932431},{"_id":"public/tags/机器学习/index.html","hash":"d4bba89d35dbf1309682ccd6b23aa52fff26bb17","modified":1535525932431},{"_id":"public/tags/算法/index.html","hash":"6e1ede00267251230515a3654386fef5446680a5","modified":1535525932432},{"_id":"public/tags/VSM/index.html","hash":"f47264e0b93d29745ed551091b86fe0c32002600","modified":1535525932432},{"_id":"public/tags/文本纠错/index.html","hash":"ace7f6247e98a2d1011f85ef26a8e13ed4d10e2e","modified":1535526039864},{"_id":"public/tags/tensorflow/index.html","hash":"d0111d55fd25c6e4c997318fd286e982efebe4f7","modified":1535526039864},{"_id":"public/tags/C/index.html","hash":"47e99f2732fc05f5bdf27704385e6e388c78c914","modified":1535525932432},{"_id":"public/tags/软件开发/index.html","hash":"4e72e633a3693bd156547f0b45745934c6caed00","modified":1535525932432},{"_id":"public/tags/Qt/index.html","hash":"4739cde2502bb5a33cef247ddc53bf062d0a45d1","modified":1535525932432},{"_id":"public/tags/network/index.html","hash":"4dd10ab30b894bfb594be84c40eadf50fc7f4f0d","modified":1535525932432},{"_id":"public/tags/OS/index.html","hash":"cdda3207af531db27a47a17460d9ad6a598d9ca4","modified":1535525932432},{"_id":"public/robots.txt","hash":"79cb92b89a36c4b1384fcaa7a3648caca8afcd48","modified":1535525932439},{"_id":"public/README.md","hash":"ddeedf15bed7fc9d74587296bd1f690cdd0aaffe","modified":1535525932439},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1535525932439},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1535525932440},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1535525932440},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1535525932440},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1535525932440},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1535525932440},{"_id":"public/CNAME","hash":"f32c465cddf5fbe3c1ff1506cbf438a7b3667dc7","modified":1535525932440},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1535525932440},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1535525932440},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1535525932440},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1535525932454},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1535525932454},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1535525932454},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1535525932454}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"编译原理笔记（一）：概述","date":"2017-08-22T16:00:00.000Z","comments":1,"_content":"\n\nStanford的CS1 Compilers 课程学习笔记\n\n学习编译知识并最终制作COOL语言的编译器\n\n<!-- more -->\n\n## 01-01. Introduction\n\nTwo major approaches to implementing programming languages:\n**Compilers(编译器)** 、 **Interpreters(解释器)**\n\n### 1. Interpreters(解释器)\n\n![Interpreters](http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG)\n\n**Online**: the work it does is all part of running your program.\n\nThe Interpreter produces the output with data and program directly\n\nIt doesn’t do any processing of the program before it executes the program on the input.\n\n### 2. Compilers(编译器)\n\n![Compilers](http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG)\n\n**Offline**: produces an executable\nThe executable is **another program**, might be another language or bytecode, it can be **run separately** on data.\n\n### 01-02. FORTRAN:\n\nFORTRAN ( Formula Translation Project )：**The first successful high level language**.\nMeanings : The formulas were translated into a form that the machine could execute directly.\n\nProgramming languages = fairly deep theory + good engineering skills\n\nThe structure of FORTRAN one:\n1.Lexical Analysis (词法分析)\n2.Parsing (语法分析)\n3.Semantic Analysis (语义分析)\n4.Optimization (优化)\n5.Code Generation (代码生成)\n\n#### 1.Lexical Analysis (词法分析)\n\nGoal : **divide** the program text into its **tokens** (words)(符号).\n\nExample of tokens :\n1.key words 关键词 ( like “if”)\n2.variable names 变量名 (“x”,”y”,”z”)\n3.constants 常量 (“1”,”2”)\n4.operators 运算符(“=”,”==”)\n5.punctuation 标点符号(“;” “,”)\n\n![tokens](http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG)\n\n#### 2.Parsing (语法分析)\n\nGoal : **diagramming sentences **(分析句子)\n\nThe first step : Identify the role of each word\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG)\n\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG)\n\n#### 3.Semantic Analysis (语义分析)\n\nThe compilers can only do very** limited** kinds of semantic analysis.\n\nIt generally try to catch inconsistencies. (捕捉异常)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG)\n\n![lexically scoped](http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG)\n\n#### 4.Optimization (优化)\n\nGoal : To modify the program so that it **uses less of some resource** ,(use less time, run faster or use less space)\n\nif(x and y are integers)\n![Optimization](http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG)\n\n#### 5.Code Generation (代码生成)\n\nThe most common goal : produce assembly code (生成汇编代码)\n\nGeneral goal : do a translation into some other languages.\n\n#### The proportions (比例)\n\n![proportions](http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG)\n\nFORTRAN I :\ncomplex lexical analysis phase and parsing phase,\nsmall semantic anaysis phase (very weak)\n\nToday:\nvery little in parsing and lexical analysis. ( we have good tools to help us )\nvery large optimization phase\na small code-generation phase ( we also have good tools )\n\n### 01-03. The Economy of Programming Languages\n\n1.Why are there so many programming languages\n2.Why are there new programming languages\n3.What is a good programming language\n\n#### 1. Why are there so many programming languages\n\n1.**application domains**(应用域) have distinctive and conflicting needs.\n\n![application domains](http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG)\n\nIt would be** difficult to integrate all of these into one system **that would do good job on all of these things.\n\n#### 2. Why are there new programming languages\n\n**Programmer training** is the dominant cost for a programming language\n\nHere are some facts:\n\n1. Widely-used languages are slow to change\n\n   > Design and build a compiler for a new language are not actually taht expensive.\n   > The real cost is in all the **users and educating them**.\n\n2. Easy to start a new language\n\n   > Zero or low training cost\n   > Adapt quickly to changing situations, not very costly to experiment.\n\n3. Languages adopted to fill a void\n\n   > Programming languages exist for **purpose**.\n   > There are **new application domains** coming along all the time.\n\n#### 3. What is a good programming language\n\nThere is **no universally accepted metric**(普遍接受的标准) for language design.\n\n### 02-(01-03). Cool Overview\n\n**COOL**: Classroom Object Oriented Language\n\nCOOL -> MIPS assembly language\n\n```\nclass Main\n{\n\tmain():Int { 1 };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():IO {  i.out_string(\"Hello World!\\n\") };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():Object {  i.out_string(\"Hello World!\\n\"); 1; };\n};\nclass Main\n{\n\tmain():IO {  (new IO).out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  self.out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  out_string(\"Hello World!\\n\") };\n};\n\n\n\nclass Main\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string( (new IO).in_string.concat(\"\\n\\\") )\n\t};\n};\n// in_string : 接受输入，返回string\n// concat :  连接字符串\nclass Main inherits A2I    // ascii to integer\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(\"\\n\\\")       )\n\t};\n};\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int { if(i=0) then 1 else i*fact(i-1) fi };\n};\n\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int \n\t{ \n\t\tlet fact: Int <- 1 in  // 声明局部变量\n\t\t{\n\t\t\twhile ( not (i=0) ) loop\n\t\t\t{\n\t\t\t\tfact <- fact*i;\n\t\t\t\ti <- i-1;\n\t\t\t}\n\t\t\tpool;\n\t\t\tfact;\n\t\t}\n\t};\n};\n\n\nclass List inherits A2I    //链表类\n{\n\titem : Object;    // 数据\n\tnext : List ;    // 指向下一个\n\tinit ( i: Object , n: List ): List\n\t{\n\t\titem <- i;\n\t\tnext <- n;\n\t\tself;    // 返回值为List \n\t}\n\tflatten (): String\n\t{\n\t\tlet string : String <-\n\t\t\tcase item of       // 相当于switch    关键词为 case .. of \n\t\t\t\ti : Int => i2a(i);     //  变量名+“:”+类型+操作\n\t\t\t\ts : String => s;\n\t\t\t\to : Object => { abort(); \"\"; };    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了\"\" 以返回String\n\t\t\tesac;    // case的结束标志\n\t\tin    // 局部变量范围\n\t\t\tif ( isvoid next ) then    // 若next为空\n\t\t\t\tstring\n\t\t\telse\n\t\t\t\tstring.concat(next.flatte())\n\t\t\tfi     // if的结束标志\n\t};\n};\n\t\nclass Main inherits IO\n{\n\tmain(): Object\n\t{\n\t\tlet \thello : String <- \"Hello \",\n\t\t\tworld : String <- \"World!\",\n\t\t\tnewline: String <- \"\\n\",\n\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记\n\t\t\tlist : List <-\n\t\t\t\t(new List).init(hello, \n\t\t\t\t\t(new List).init(world,\n\t\t\t\t\t\t(new List).init(newline, nil ) ) )\n\t\tin\n\t\t\tout_string(list.flatten())\n\t};\n};\n```\n\n语法：\nclass 是一系列method(函数)的集合，每个method以大括号+分号结尾\n必有Main class和main函数\n函数后用 “：”+”type” 声明函数的返回类型\n单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式\n所有类继承自Object, self相当于其它语言中的this\n用“=”作判断，用”<-“作赋值\nif以fi作为结尾\nloop以pool结尾\ncase..of以esac结尾，每个分支都要以分号结尾","source":"_posts/Compiler1.md","raw":"---\nlayout: post\ntitle: \"编译原理笔记（一）：概述\"\ndate: 2017-08-23\ncomments: true\ntags: \n\t- 编译原理\n\t- 学习笔记\n---\n\n\nStanford的CS1 Compilers 课程学习笔记\n\n学习编译知识并最终制作COOL语言的编译器\n\n<!-- more -->\n\n## 01-01. Introduction\n\nTwo major approaches to implementing programming languages:\n**Compilers(编译器)** 、 **Interpreters(解释器)**\n\n### 1. Interpreters(解释器)\n\n![Interpreters](http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG)\n\n**Online**: the work it does is all part of running your program.\n\nThe Interpreter produces the output with data and program directly\n\nIt doesn’t do any processing of the program before it executes the program on the input.\n\n### 2. Compilers(编译器)\n\n![Compilers](http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG)\n\n**Offline**: produces an executable\nThe executable is **another program**, might be another language or bytecode, it can be **run separately** on data.\n\n### 01-02. FORTRAN:\n\nFORTRAN ( Formula Translation Project )：**The first successful high level language**.\nMeanings : The formulas were translated into a form that the machine could execute directly.\n\nProgramming languages = fairly deep theory + good engineering skills\n\nThe structure of FORTRAN one:\n1.Lexical Analysis (词法分析)\n2.Parsing (语法分析)\n3.Semantic Analysis (语义分析)\n4.Optimization (优化)\n5.Code Generation (代码生成)\n\n#### 1.Lexical Analysis (词法分析)\n\nGoal : **divide** the program text into its **tokens** (words)(符号).\n\nExample of tokens :\n1.key words 关键词 ( like “if”)\n2.variable names 变量名 (“x”,”y”,”z”)\n3.constants 常量 (“1”,”2”)\n4.operators 运算符(“=”,”==”)\n5.punctuation 标点符号(“;” “,”)\n\n![tokens](http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG)\n\n#### 2.Parsing (语法分析)\n\nGoal : **diagramming sentences **(分析句子)\n\nThe first step : Identify the role of each word\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG)\n\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG)\n\n#### 3.Semantic Analysis (语义分析)\n\nThe compilers can only do very** limited** kinds of semantic analysis.\n\nIt generally try to catch inconsistencies. (捕捉异常)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG)\n\n![lexically scoped](http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG)\n\n#### 4.Optimization (优化)\n\nGoal : To modify the program so that it **uses less of some resource** ,(use less time, run faster or use less space)\n\nif(x and y are integers)\n![Optimization](http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG)\n\n#### 5.Code Generation (代码生成)\n\nThe most common goal : produce assembly code (生成汇编代码)\n\nGeneral goal : do a translation into some other languages.\n\n#### The proportions (比例)\n\n![proportions](http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG)\n\nFORTRAN I :\ncomplex lexical analysis phase and parsing phase,\nsmall semantic anaysis phase (very weak)\n\nToday:\nvery little in parsing and lexical analysis. ( we have good tools to help us )\nvery large optimization phase\na small code-generation phase ( we also have good tools )\n\n### 01-03. The Economy of Programming Languages\n\n1.Why are there so many programming languages\n2.Why are there new programming languages\n3.What is a good programming language\n\n#### 1. Why are there so many programming languages\n\n1.**application domains**(应用域) have distinctive and conflicting needs.\n\n![application domains](http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG)\n\nIt would be** difficult to integrate all of these into one system **that would do good job on all of these things.\n\n#### 2. Why are there new programming languages\n\n**Programmer training** is the dominant cost for a programming language\n\nHere are some facts:\n\n1. Widely-used languages are slow to change\n\n   > Design and build a compiler for a new language are not actually taht expensive.\n   > The real cost is in all the **users and educating them**.\n\n2. Easy to start a new language\n\n   > Zero or low training cost\n   > Adapt quickly to changing situations, not very costly to experiment.\n\n3. Languages adopted to fill a void\n\n   > Programming languages exist for **purpose**.\n   > There are **new application domains** coming along all the time.\n\n#### 3. What is a good programming language\n\nThere is **no universally accepted metric**(普遍接受的标准) for language design.\n\n### 02-(01-03). Cool Overview\n\n**COOL**: Classroom Object Oriented Language\n\nCOOL -> MIPS assembly language\n\n```\nclass Main\n{\n\tmain():Int { 1 };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():IO {  i.out_string(\"Hello World!\\n\") };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():Object {  i.out_string(\"Hello World!\\n\"); 1; };\n};\nclass Main\n{\n\tmain():IO {  (new IO).out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  self.out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  out_string(\"Hello World!\\n\") };\n};\n\n\n\nclass Main\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string( (new IO).in_string.concat(\"\\n\\\") )\n\t};\n};\n// in_string : 接受输入，返回string\n// concat :  连接字符串\nclass Main inherits A2I    // ascii to integer\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(\"\\n\\\")       )\n\t};\n};\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int { if(i=0) then 1 else i*fact(i-1) fi };\n};\n\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int \n\t{ \n\t\tlet fact: Int <- 1 in  // 声明局部变量\n\t\t{\n\t\t\twhile ( not (i=0) ) loop\n\t\t\t{\n\t\t\t\tfact <- fact*i;\n\t\t\t\ti <- i-1;\n\t\t\t}\n\t\t\tpool;\n\t\t\tfact;\n\t\t}\n\t};\n};\n\n\nclass List inherits A2I    //链表类\n{\n\titem : Object;    // 数据\n\tnext : List ;    // 指向下一个\n\tinit ( i: Object , n: List ): List\n\t{\n\t\titem <- i;\n\t\tnext <- n;\n\t\tself;    // 返回值为List \n\t}\n\tflatten (): String\n\t{\n\t\tlet string : String <-\n\t\t\tcase item of       // 相当于switch    关键词为 case .. of \n\t\t\t\ti : Int => i2a(i);     //  变量名+“:”+类型+操作\n\t\t\t\ts : String => s;\n\t\t\t\to : Object => { abort(); \"\"; };    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了\"\" 以返回String\n\t\t\tesac;    // case的结束标志\n\t\tin    // 局部变量范围\n\t\t\tif ( isvoid next ) then    // 若next为空\n\t\t\t\tstring\n\t\t\telse\n\t\t\t\tstring.concat(next.flatte())\n\t\t\tfi     // if的结束标志\n\t};\n};\n\t\nclass Main inherits IO\n{\n\tmain(): Object\n\t{\n\t\tlet \thello : String <- \"Hello \",\n\t\t\tworld : String <- \"World!\",\n\t\t\tnewline: String <- \"\\n\",\n\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记\n\t\t\tlist : List <-\n\t\t\t\t(new List).init(hello, \n\t\t\t\t\t(new List).init(world,\n\t\t\t\t\t\t(new List).init(newline, nil ) ) )\n\t\tin\n\t\t\tout_string(list.flatten())\n\t};\n};\n```\n\n语法：\nclass 是一系列method(函数)的集合，每个method以大括号+分号结尾\n必有Main class和main函数\n函数后用 “：”+”type” 声明函数的返回类型\n单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式\n所有类继承自Object, self相当于其它语言中的this\n用“=”作判断，用”<-“作赋值\nif以fi作为结尾\nloop以pool结尾\ncase..of以esac结尾，每个分支都要以分号结尾","slug":"Compiler1","published":1,"updated":"2018-05-25T12:41:11.535Z","photos":[],"link":"","_id":"cjleshqip0000ryfcqdew3xee","content":"<p>Stanford的CS1 Compilers 课程学习笔记</p>\n<p>学习编译知识并最终制作COOL语言的编译器</p>\n<a id=\"more\"></a>\n<h2 id=\"01-01-Introduction\"><a href=\"#01-01-Introduction\" class=\"headerlink\" title=\"01-01. Introduction\"></a>01-01. Introduction</h2><p>Two major approaches to implementing programming languages:<br><strong>Compilers(编译器)</strong> 、 <strong>Interpreters(解释器)</strong></p>\n<h3 id=\"1-Interpreters-解释器\"><a href=\"#1-Interpreters-解释器\" class=\"headerlink\" title=\"1. Interpreters(解释器)\"></a>1. Interpreters(解释器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG\" alt=\"Interpreters\"></p>\n<p><strong>Online</strong>: the work it does is all part of running your program.</p>\n<p>The Interpreter produces the output with data and program directly</p>\n<p>It doesn’t do any processing of the program before it executes the program on the input.</p>\n<h3 id=\"2-Compilers-编译器\"><a href=\"#2-Compilers-编译器\" class=\"headerlink\" title=\"2. Compilers(编译器)\"></a>2. Compilers(编译器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG\" alt=\"Compilers\"></p>\n<p><strong>Offline</strong>: produces an executable<br>The executable is <strong>another program</strong>, might be another language or bytecode, it can be <strong>run separately</strong> on data.</p>\n<h3 id=\"01-02-FORTRAN\"><a href=\"#01-02-FORTRAN\" class=\"headerlink\" title=\"01-02. FORTRAN:\"></a>01-02. FORTRAN:</h3><p>FORTRAN ( Formula Translation Project )：<strong>The first successful high level language</strong>.<br>Meanings : The formulas were translated into a form that the machine could execute directly.</p>\n<p>Programming languages = fairly deep theory + good engineering skills</p>\n<p>The structure of FORTRAN one:<br>1.Lexical Analysis (词法分析)<br>2.Parsing (语法分析)<br>3.Semantic Analysis (语义分析)<br>4.Optimization (优化)<br>5.Code Generation (代码生成)</p>\n<h4 id=\"1-Lexical-Analysis-词法分析\"><a href=\"#1-Lexical-Analysis-词法分析\" class=\"headerlink\" title=\"1.Lexical Analysis (词法分析)\"></a>1.Lexical Analysis (词法分析)</h4><p>Goal : <strong>divide</strong> the program text into its <strong>tokens</strong> (words)(符号).</p>\n<p>Example of tokens :<br>1.key words 关键词 ( like “if”)<br>2.variable names 变量名 (“x”,”y”,”z”)<br>3.constants 常量 (“1”,”2”)<br>4.operators 运算符(“=”,”==”)<br>5.punctuation 标点符号(“;” “,”)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG\" alt=\"tokens\"></p>\n<h4 id=\"2-Parsing-语法分析\"><a href=\"#2-Parsing-语法分析\" class=\"headerlink\" title=\"2.Parsing (语法分析)\"></a>2.Parsing (语法分析)</h4><p>Goal : <strong>diagramming sentences </strong>(分析句子)</p>\n<p>The first step : Identify the role of each word<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG\" alt=\"structure tree\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG\" alt=\"structure tree\"></p>\n<h4 id=\"3-Semantic-Analysis-语义分析\"><a href=\"#3-Semantic-Analysis-语义分析\" class=\"headerlink\" title=\"3.Semantic Analysis (语义分析)\"></a>3.Semantic Analysis (语义分析)</h4><p>The compilers can only do very<strong> limited</strong> kinds of semantic analysis.</p>\n<p>It generally try to catch inconsistencies. (捕捉异常)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG\" alt=\"lexically scoped\"></p>\n<h4 id=\"4-Optimization-优化\"><a href=\"#4-Optimization-优化\" class=\"headerlink\" title=\"4.Optimization (优化)\"></a>4.Optimization (优化)</h4><p>Goal : To modify the program so that it <strong>uses less of some resource</strong> ,(use less time, run faster or use less space)</p>\n<p>if(x and y are integers)<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG\" alt=\"Optimization\"></p>\n<h4 id=\"5-Code-Generation-代码生成\"><a href=\"#5-Code-Generation-代码生成\" class=\"headerlink\" title=\"5.Code Generation (代码生成)\"></a>5.Code Generation (代码生成)</h4><p>The most common goal : produce assembly code (生成汇编代码)</p>\n<p>General goal : do a translation into some other languages.</p>\n<h4 id=\"The-proportions-比例\"><a href=\"#The-proportions-比例\" class=\"headerlink\" title=\"The proportions (比例)\"></a>The proportions (比例)</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG\" alt=\"proportions\"></p>\n<p>FORTRAN I :<br>complex lexical analysis phase and parsing phase,<br>small semantic anaysis phase (very weak)</p>\n<p>Today:<br>very little in parsing and lexical analysis. ( we have good tools to help us )<br>very large optimization phase<br>a small code-generation phase ( we also have good tools )</p>\n<h3 id=\"01-03-The-Economy-of-Programming-Languages\"><a href=\"#01-03-The-Economy-of-Programming-Languages\" class=\"headerlink\" title=\"01-03. The Economy of Programming Languages\"></a>01-03. The Economy of Programming Languages</h3><p>1.Why are there so many programming languages<br>2.Why are there new programming languages<br>3.What is a good programming language</p>\n<h4 id=\"1-Why-are-there-so-many-programming-languages\"><a href=\"#1-Why-are-there-so-many-programming-languages\" class=\"headerlink\" title=\"1. Why are there so many programming languages\"></a>1. Why are there so many programming languages</h4><p>1.<strong>application domains</strong>(应用域) have distinctive and conflicting needs.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG\" alt=\"application domains\"></p>\n<p>It would be<strong> difficult to integrate all of these into one system </strong>that would do good job on all of these things.</p>\n<h4 id=\"2-Why-are-there-new-programming-languages\"><a href=\"#2-Why-are-there-new-programming-languages\" class=\"headerlink\" title=\"2. Why are there new programming languages\"></a>2. Why are there new programming languages</h4><p><strong>Programmer training</strong> is the dominant cost for a programming language</p>\n<p>Here are some facts:</p>\n<ol>\n<li><p>Widely-used languages are slow to change</p>\n<blockquote>\n<p>Design and build a compiler for a new language are not actually taht expensive.<br>The real cost is in all the <strong>users and educating them</strong>.</p>\n</blockquote>\n</li>\n<li><p>Easy to start a new language</p>\n<blockquote>\n<p>Zero or low training cost<br>Adapt quickly to changing situations, not very costly to experiment.</p>\n</blockquote>\n</li>\n<li><p>Languages adopted to fill a void</p>\n<blockquote>\n<p>Programming languages exist for <strong>purpose</strong>.<br>There are <strong>new application domains</strong> coming along all the time.</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"3-What-is-a-good-programming-language\"><a href=\"#3-What-is-a-good-programming-language\" class=\"headerlink\" title=\"3. What is a good programming language\"></a>3. What is a good programming language</h4><p>There is <strong>no universally accepted metric</strong>(普遍接受的标准) for language design.</p>\n<h3 id=\"02-01-03-Cool-Overview\"><a href=\"#02-01-03-Cool-Overview\" class=\"headerlink\" title=\"02-(01-03). Cool Overview\"></a>02-(01-03). Cool Overview</h3><p><strong>COOL</strong>: Classroom Object Oriented Language</p>\n<p>COOL -&gt; MIPS assembly language</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Int &#123; 1 &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():IO &#123;  i.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():Object &#123;  i.out_string(&quot;Hello World!\\n&quot;); 1; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  (new IO).out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  self.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string( (new IO).in_string.concat(&quot;\\n\\&quot;) )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// in_string : 接受输入，返回string</span><br><span class=\"line\">// concat :  连接字符串</span><br><span class=\"line\">class Main inherits A2I    // ascii to integer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int &#123; if(i=0) then 1 else i*fact(i-1) fi &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\tlet fact: Int &lt;- 1 in  // 声明局部变量</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\twhile ( not (i=0) ) loop</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tfact &lt;- fact*i;</span><br><span class=\"line\">\t\t\t\ti &lt;- i-1;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpool;</span><br><span class=\"line\">\t\t\tfact;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class List inherits A2I    //链表类</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\titem : Object;    // 数据</span><br><span class=\"line\">\tnext : List ;    // 指向下一个</span><br><span class=\"line\">\tinit ( i: Object , n: List ): List</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titem &lt;- i;</span><br><span class=\"line\">\t\tnext &lt;- n;</span><br><span class=\"line\">\t\tself;    // 返回值为List </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tflatten (): String</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet string : String &lt;-</span><br><span class=\"line\">\t\t\tcase item of       // 相当于switch    关键词为 case .. of </span><br><span class=\"line\">\t\t\t\ti : Int =&gt; i2a(i);     //  变量名+“:”+类型+操作</span><br><span class=\"line\">\t\t\t\ts : String =&gt; s;</span><br><span class=\"line\">\t\t\t\to : Object =&gt; &#123; abort(); &quot;&quot;; &#125;;    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了&quot;&quot; 以返回String</span><br><span class=\"line\">\t\t\tesac;    // case的结束标志</span><br><span class=\"line\">\t\tin    // 局部变量范围</span><br><span class=\"line\">\t\t\tif ( isvoid next ) then    // 若next为空</span><br><span class=\"line\">\t\t\t\tstring</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tstring.concat(next.flatte())</span><br><span class=\"line\">\t\t\tfi     // if的结束标志</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain(): Object</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet \thello : String &lt;- &quot;Hello &quot;,</span><br><span class=\"line\">\t\t\tworld : String &lt;- &quot;World!&quot;,</span><br><span class=\"line\">\t\t\tnewline: String &lt;- &quot;\\n&quot;,</span><br><span class=\"line\">\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记</span><br><span class=\"line\">\t\t\tlist : List &lt;-</span><br><span class=\"line\">\t\t\t\t(new List).init(hello, </span><br><span class=\"line\">\t\t\t\t\t(new List).init(world,</span><br><span class=\"line\">\t\t\t\t\t\t(new List).init(newline, nil ) ) )</span><br><span class=\"line\">\t\tin</span><br><span class=\"line\">\t\t\tout_string(list.flatten())</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>语法：<br>class 是一系列method(函数)的集合，每个method以大括号+分号结尾<br>必有Main class和main函数<br>函数后用 “：”+”type” 声明函数的返回类型<br>单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式<br>所有类继承自Object, self相当于其它语言中的this<br>用“=”作判断，用”&lt;-“作赋值<br>if以fi作为结尾<br>loop以pool结尾<br>case..of以esac结尾，每个分支都要以分号结尾</p>\n","site":{"data":{}},"excerpt":"<p>Stanford的CS1 Compilers 课程学习笔记</p>\n<p>学习编译知识并最终制作COOL语言的编译器</p>","more":"<h2 id=\"01-01-Introduction\"><a href=\"#01-01-Introduction\" class=\"headerlink\" title=\"01-01. Introduction\"></a>01-01. Introduction</h2><p>Two major approaches to implementing programming languages:<br><strong>Compilers(编译器)</strong> 、 <strong>Interpreters(解释器)</strong></p>\n<h3 id=\"1-Interpreters-解释器\"><a href=\"#1-Interpreters-解释器\" class=\"headerlink\" title=\"1. Interpreters(解释器)\"></a>1. Interpreters(解释器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG\" alt=\"Interpreters\"></p>\n<p><strong>Online</strong>: the work it does is all part of running your program.</p>\n<p>The Interpreter produces the output with data and program directly</p>\n<p>It doesn’t do any processing of the program before it executes the program on the input.</p>\n<h3 id=\"2-Compilers-编译器\"><a href=\"#2-Compilers-编译器\" class=\"headerlink\" title=\"2. Compilers(编译器)\"></a>2. Compilers(编译器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG\" alt=\"Compilers\"></p>\n<p><strong>Offline</strong>: produces an executable<br>The executable is <strong>another program</strong>, might be another language or bytecode, it can be <strong>run separately</strong> on data.</p>\n<h3 id=\"01-02-FORTRAN\"><a href=\"#01-02-FORTRAN\" class=\"headerlink\" title=\"01-02. FORTRAN:\"></a>01-02. FORTRAN:</h3><p>FORTRAN ( Formula Translation Project )：<strong>The first successful high level language</strong>.<br>Meanings : The formulas were translated into a form that the machine could execute directly.</p>\n<p>Programming languages = fairly deep theory + good engineering skills</p>\n<p>The structure of FORTRAN one:<br>1.Lexical Analysis (词法分析)<br>2.Parsing (语法分析)<br>3.Semantic Analysis (语义分析)<br>4.Optimization (优化)<br>5.Code Generation (代码生成)</p>\n<h4 id=\"1-Lexical-Analysis-词法分析\"><a href=\"#1-Lexical-Analysis-词法分析\" class=\"headerlink\" title=\"1.Lexical Analysis (词法分析)\"></a>1.Lexical Analysis (词法分析)</h4><p>Goal : <strong>divide</strong> the program text into its <strong>tokens</strong> (words)(符号).</p>\n<p>Example of tokens :<br>1.key words 关键词 ( like “if”)<br>2.variable names 变量名 (“x”,”y”,”z”)<br>3.constants 常量 (“1”,”2”)<br>4.operators 运算符(“=”,”==”)<br>5.punctuation 标点符号(“;” “,”)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG\" alt=\"tokens\"></p>\n<h4 id=\"2-Parsing-语法分析\"><a href=\"#2-Parsing-语法分析\" class=\"headerlink\" title=\"2.Parsing (语法分析)\"></a>2.Parsing (语法分析)</h4><p>Goal : <strong>diagramming sentences </strong>(分析句子)</p>\n<p>The first step : Identify the role of each word<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG\" alt=\"structure tree\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG\" alt=\"structure tree\"></p>\n<h4 id=\"3-Semantic-Analysis-语义分析\"><a href=\"#3-Semantic-Analysis-语义分析\" class=\"headerlink\" title=\"3.Semantic Analysis (语义分析)\"></a>3.Semantic Analysis (语义分析)</h4><p>The compilers can only do very<strong> limited</strong> kinds of semantic analysis.</p>\n<p>It generally try to catch inconsistencies. (捕捉异常)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG\" alt=\"lexically scoped\"></p>\n<h4 id=\"4-Optimization-优化\"><a href=\"#4-Optimization-优化\" class=\"headerlink\" title=\"4.Optimization (优化)\"></a>4.Optimization (优化)</h4><p>Goal : To modify the program so that it <strong>uses less of some resource</strong> ,(use less time, run faster or use less space)</p>\n<p>if(x and y are integers)<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG\" alt=\"Optimization\"></p>\n<h4 id=\"5-Code-Generation-代码生成\"><a href=\"#5-Code-Generation-代码生成\" class=\"headerlink\" title=\"5.Code Generation (代码生成)\"></a>5.Code Generation (代码生成)</h4><p>The most common goal : produce assembly code (生成汇编代码)</p>\n<p>General goal : do a translation into some other languages.</p>\n<h4 id=\"The-proportions-比例\"><a href=\"#The-proportions-比例\" class=\"headerlink\" title=\"The proportions (比例)\"></a>The proportions (比例)</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG\" alt=\"proportions\"></p>\n<p>FORTRAN I :<br>complex lexical analysis phase and parsing phase,<br>small semantic anaysis phase (very weak)</p>\n<p>Today:<br>very little in parsing and lexical analysis. ( we have good tools to help us )<br>very large optimization phase<br>a small code-generation phase ( we also have good tools )</p>\n<h3 id=\"01-03-The-Economy-of-Programming-Languages\"><a href=\"#01-03-The-Economy-of-Programming-Languages\" class=\"headerlink\" title=\"01-03. The Economy of Programming Languages\"></a>01-03. The Economy of Programming Languages</h3><p>1.Why are there so many programming languages<br>2.Why are there new programming languages<br>3.What is a good programming language</p>\n<h4 id=\"1-Why-are-there-so-many-programming-languages\"><a href=\"#1-Why-are-there-so-many-programming-languages\" class=\"headerlink\" title=\"1. Why are there so many programming languages\"></a>1. Why are there so many programming languages</h4><p>1.<strong>application domains</strong>(应用域) have distinctive and conflicting needs.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG\" alt=\"application domains\"></p>\n<p>It would be<strong> difficult to integrate all of these into one system </strong>that would do good job on all of these things.</p>\n<h4 id=\"2-Why-are-there-new-programming-languages\"><a href=\"#2-Why-are-there-new-programming-languages\" class=\"headerlink\" title=\"2. Why are there new programming languages\"></a>2. Why are there new programming languages</h4><p><strong>Programmer training</strong> is the dominant cost for a programming language</p>\n<p>Here are some facts:</p>\n<ol>\n<li><p>Widely-used languages are slow to change</p>\n<blockquote>\n<p>Design and build a compiler for a new language are not actually taht expensive.<br>The real cost is in all the <strong>users and educating them</strong>.</p>\n</blockquote>\n</li>\n<li><p>Easy to start a new language</p>\n<blockquote>\n<p>Zero or low training cost<br>Adapt quickly to changing situations, not very costly to experiment.</p>\n</blockquote>\n</li>\n<li><p>Languages adopted to fill a void</p>\n<blockquote>\n<p>Programming languages exist for <strong>purpose</strong>.<br>There are <strong>new application domains</strong> coming along all the time.</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"3-What-is-a-good-programming-language\"><a href=\"#3-What-is-a-good-programming-language\" class=\"headerlink\" title=\"3. What is a good programming language\"></a>3. What is a good programming language</h4><p>There is <strong>no universally accepted metric</strong>(普遍接受的标准) for language design.</p>\n<h3 id=\"02-01-03-Cool-Overview\"><a href=\"#02-01-03-Cool-Overview\" class=\"headerlink\" title=\"02-(01-03). Cool Overview\"></a>02-(01-03). Cool Overview</h3><p><strong>COOL</strong>: Classroom Object Oriented Language</p>\n<p>COOL -&gt; MIPS assembly language</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Int &#123; 1 &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():IO &#123;  i.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():Object &#123;  i.out_string(&quot;Hello World!\\n&quot;); 1; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  (new IO).out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  self.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string( (new IO).in_string.concat(&quot;\\n\\&quot;) )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// in_string : 接受输入，返回string</span><br><span class=\"line\">// concat :  连接字符串</span><br><span class=\"line\">class Main inherits A2I    // ascii to integer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int &#123; if(i=0) then 1 else i*fact(i-1) fi &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\tlet fact: Int &lt;- 1 in  // 声明局部变量</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\twhile ( not (i=0) ) loop</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tfact &lt;- fact*i;</span><br><span class=\"line\">\t\t\t\ti &lt;- i-1;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpool;</span><br><span class=\"line\">\t\t\tfact;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class List inherits A2I    //链表类</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\titem : Object;    // 数据</span><br><span class=\"line\">\tnext : List ;    // 指向下一个</span><br><span class=\"line\">\tinit ( i: Object , n: List ): List</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titem &lt;- i;</span><br><span class=\"line\">\t\tnext &lt;- n;</span><br><span class=\"line\">\t\tself;    // 返回值为List </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tflatten (): String</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet string : String &lt;-</span><br><span class=\"line\">\t\t\tcase item of       // 相当于switch    关键词为 case .. of </span><br><span class=\"line\">\t\t\t\ti : Int =&gt; i2a(i);     //  变量名+“:”+类型+操作</span><br><span class=\"line\">\t\t\t\ts : String =&gt; s;</span><br><span class=\"line\">\t\t\t\to : Object =&gt; &#123; abort(); &quot;&quot;; &#125;;    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了&quot;&quot; 以返回String</span><br><span class=\"line\">\t\t\tesac;    // case的结束标志</span><br><span class=\"line\">\t\tin    // 局部变量范围</span><br><span class=\"line\">\t\t\tif ( isvoid next ) then    // 若next为空</span><br><span class=\"line\">\t\t\t\tstring</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tstring.concat(next.flatte())</span><br><span class=\"line\">\t\t\tfi     // if的结束标志</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain(): Object</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet \thello : String &lt;- &quot;Hello &quot;,</span><br><span class=\"line\">\t\t\tworld : String &lt;- &quot;World!&quot;,</span><br><span class=\"line\">\t\t\tnewline: String &lt;- &quot;\\n&quot;,</span><br><span class=\"line\">\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记</span><br><span class=\"line\">\t\t\tlist : List &lt;-</span><br><span class=\"line\">\t\t\t\t(new List).init(hello, </span><br><span class=\"line\">\t\t\t\t\t(new List).init(world,</span><br><span class=\"line\">\t\t\t\t\t\t(new List).init(newline, nil ) ) )</span><br><span class=\"line\">\t\tin</span><br><span class=\"line\">\t\t\tout_string(list.flatten())</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>语法：<br>class 是一系列method(函数)的集合，每个method以大括号+分号结尾<br>必有Main class和main函数<br>函数后用 “：”+”type” 声明函数的返回类型<br>单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式<br>所有类继承自Object, self相当于其它语言中的this<br>用“=”作判断，用”&lt;-“作赋值<br>if以fi作为结尾<br>loop以pool结尾<br>case..of以esac结尾，每个分支都要以分号结尾</p>"},{"layout":"post","title":"编译原理笔记（二）：词法分析","date":"2017-08-23T16:00:00.000Z","comments":1,"_content":"\n\n## 03-01. Lexical Analysis\n\n**Goal **:\n1 - Recognize substrings corresponding to tokens. ( **lexemes**: substrings )\n2 - Identify the token class of each lexeme.\n3 - Communicate tokens to the parser.\n\n<!-- more -->\n\nWhat the likes of human being will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG)\nWhat the likes of analyzer will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG)\n\n**Token classes**: the role of different elements\nIn a programming language: Identifiers、keywords、’(‘、’)’、numbers….\n**Token classes correspond to sets of strings.**\n\n- Identifier: 标识符\n\n  > strings of letters or digits, starting with a letter\n  > like “a1”,”A0o”\n\n- Number:\n\n  > a non-empty string of digits\n  > like “9”,”001”\n\n- Keyword: 关键字\n\n  > “else” or “if” or “begin “…\n\n- Whitespace:\n\n  > a non-empty swquence of blanks, newlines, and tabs\n\n- Operator:\n\n  > “==”…\n\nThe output of the lexical analyzer: **a series of pairs **which are the token class.\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG)\n\n## 03-02. Lexical Analysis example\n\n1 - The goal is to **partition the string** . This is implemented by reading left-to-right, recognizing **one token at a time**.\n\n2 - **look ahead** may be required to decide where one token ends and the next token begins.\n\n> but we would like to **minimize** the amount of look ahead.\n\n## (extra) 03-02x 词法分析器的实现\n\n1 - 手工编码实现\n相对复杂，且容易出错\n但是目前主流的实现方式\n对词法分析器各部分掌握精确，效率高\n如 GCC、LLVM\n\n2 - 词法分析器的生成器\n可快速生成原型、代码量小\n难以控制实现细节\n如 lex、flex、jlex\n\n### 03-02x-01 手工编码实现\n\n#### 方法一：转移图算法\n\n根据需求画出状态转移图：\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG)\n而后实现该算法：\n\n```\nenum kind{IF , LPAREN , ID, INTLIT, ...};\nstruct token\n{\n\tenum kind k;\n\tchar *lexeme;\n};\ntoken nextToken()\n{\n\tc=getchar();\n\tswitch(c)\n\t{\n\t\tcase '<': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=': return LE;\n\t\t\t\tcase '>': return NE;\n\t\t\t\tdefault: rollback(); return LT;\n\t\t\t}\n\t\tcase '=': return EQ;\n\t\tcase '>': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=' return GE;\n\t\t\t\tdefault: rollback(); return GT;\n\t\t\t}\n\t}\n}\n```\n\n#### 方法二：关键字表算法\n\n对给定语言中所有关键字，构造关键字构成的哈希表H\n对所有标识符和关键字，先统一按转移图识别\n识别后，查看表H是否为关键字\n通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成\n\n## 03-03. Regular Languages (正则语言)\n\nWe must say what set of strings is in a token class.\n\n- The usual tool is to use regular languages( 正则语言 ).\n\n  **Regular expression** (正则表达式) : define the regular language\n  each regular expression is a set.\n\n**1.Basic regular expression:**\n\n- Single character\n\n  > ‘c’= {“c”}\n\n- Epsilon\n\n  > $\\epsilon$ = {“”}\n  > It is a language that has a single string namely the empty string\n  > $\\epsilon$ != $\\emptyset$\n\n**2.Compound regular expression:**\n\n- Union\n  ![union](http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG)\n\n- Concatenation\n  choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.\n  ![Concatenation](http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG)\n\n- Iteration\n  It means one concatenated with itself i times.\n  ![Iteration](http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG)\n\n  Besides:\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG)\n  A+：there has to be at least one A\n\n  There is **more than one way** to write down **the same set**.\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG)\n\n  Quiz :\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG)\n\nExplanation:\n\n> 1. The given regular expression requires every string have at least one 1.\n> 2. (10 + 11 + 1) can be replaced by 1\n> 3. (0+1)* equals to (1+0)*\n\n## 03-04. Formal Languages (形式语言)\n\nLet $\\Sigma$ be a set of characters\nA language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$\n\n### Meaning function: L\n\nL($\\epsilon$)= {“”}\nL: Expression -> Sets of Strings\nWe apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.\n\nWhy use a meaning function?\n\n- Makes clear what is syntax, what is semantics.\n- Allows us to consider notation as a seperate issue\n- Because expressions and meanings are not 1-1\n\n## 03-05. Lexical Specifications\n\n### write regular expressions\n\n1 . Keyword: “if” or “else” or “then”…\n![Keyword](http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG)\n\n2 . Integer: a non-empty string of digits\n![Integer](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG)\n\n3 . Identifier: strings of letters or digits, starting with a letter\nuse square brackets to write a range of characters.\nhave the starting character and an ending character and then separate them by a hyphen.\n\n> [ a - z ] = ‘a’+’b’+’c’…..+’z’\n> ![Identifier](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG)\n\n4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.\n![Whitespace](http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG)\n\n![digits](http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG)\n\n- Regular expressions describe many useful languages\n- Regular languages are a language specification\n\n## 04-01. Lexical Specification\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG)\n\n1 . Write a regular expression for the lexemes of each token class.\n\n> Number = digit+\n> Keyword = ‘if’ + ‘else’…\n> Identifier = letter ( letter + digit )*\n> OpenPar=’(‘….\n> 2 . Construct R, matching all lexemes for all tokens.\n> R= Keyword + Identifier + Number +…\n> = R1 + R2 …\n> 3 . Let input be x1..xn\n> For 1<=i<=n check x1..xi$\\in$L(R)?\n> 4 . If success , then we know that\n> x1..xi $\\in$ L(Rj) for some j\n> 5 . Remove x1..xn from input and go to (3)\n\n### Questions:\n\n1 . How much input is used?\nif x1..xi $\\in$ L(R)\nx1..xj $\\in$ L(R) (i!=j)\n\n> like “=” and “==”\n> **Maximal Munch**: choose the longer one\n\n2 . Whick token is used?\n\n> like “if” is both a keyword and an identifier\n\nUse a priority ordering (优先排序)\nthe rule is to **choose the one listed first**\n\n3 . What if no rule matches?\n\n**do good error handling.**\nCompilers can’t simply crash, it should be able to give the user **a feedback** about where the error is and what kind of error it is.\n\nSolution: **write a category of error strings**and put it in the last of the priority list.\n\n### Summary:\n\n- Use in lexical analysis requires small extensions\n\n  > 1. To resolve ambiguities\n  >\n  >    > 1. matches as long as possible\n  >    > 2. highest priority match\n  >\n  > 2. To handle errors\n  >\n  >    > 1. write a category of error strings and put it in the last of the priority list.\n\n- Good algorithms known\n\n  > 1. Require only single pass over the input\n  > 2. Few operations per character (table lookup)\n\n- Regular expression\n\n  > $\\epsilon$\n  > a\n  > a|b\n  > ab\n  > a*[a-z] == a|b|c…|za+ == a(a)*\n  > a? == $\\epsilon$|a\n  > “a*“ != a*\n  > e{1,3} == (e)|(ee)|(eee)\n  > . == [^\\n]\n\n## 04-02. Finite Automata (有限状态自动机)\n\n**Finite Automata**: are a very convenience as an implementation mechanism for regular expressions.\n\n### A finite automaton consists of :\n\n- An input alphabet **$\\Sigma$**\n- A finite set of states **S**\n- A start state **n**\n- A set of accepting states **F \\subseteq S**\n- A set of transitions state -> (input) state\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG)\n\nTransition s1 ->(a) -> s2\nIf end of input and in accepting state => accept state\nOtherwise => reject state\n\n> terminates in state S \\not\\in $ Final state\n> gets stuck. (no transition)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG)\n\nAnother kind of transition: **$\\epsilon$-moves**\n\nThe automaton can move to a different state without consuming any input.\n\n### Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\n\n- One transition per input per state\n- No $\\epsilon$-moves\n  A DFA takes only** one path **through the state graph\n  **DFAs are faster to execute**\n  **Every DFA is also an NFA**\n\n### Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\n\n- Can have multiple transitions for one input int a given state\n\n- Can have $\\epsilon$-moves\n  An NFA can choose\n  It accepts if some choices lead to an accepting state\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG)\n  In every step an NFA is in a set of states of the machine.\n  We can consider all the possible moves.\n  We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.\n  **NFAs are much more smaller than DFAs.**\n\n## 04-03. Regular expressions into NFAs\n\n![steps](http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG)\n\nFor each kind of regular expression, define an equivalent NFA.\n\n**Thompson Algorithm:**\n\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG)\n\n![quiz](http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG)\n\n## 04-04. NFA to DFA\n\n**$\\epsilon$-closure **\nchoose a state and look at the states that can be reached by following **only epsilon moves**.\n\n![closure](http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG)\n\nHow many different states can an NFA get into ?\n\n> if there are N states\n> The states NFA can get into at most n different states.\n> |S|<=N\n\nHow to convert an NFA to a DFA?\n\n> There are $2^n -1 $ possible subsets of n states.\n> **This is a finite set of possible configurations.**\n> Use DFA to **simulate the behaviour** of the NFA.\n> O($2^n$)\n\nDefine an NFA:\n![NFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG)\n\nDefine a DFA:\n![DFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG)\n\nTransition\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG)\n\n**子集构造算法：**\n工作表算法伪代码：\n\n```\nq0 <- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态\n// eps_closure 为找到s0的所有$\\epsilon$可到达的状态\nQ <- {q0}    // Q 为DFA的所有状态集合\nworkList <- q0   // 队列\nwhile( workList != [] )    \n{\n\tremove q from workList // 队列不为空则取队首元素\n\tforeach (character c)   // 循环判断每个字符\n\t{\n\t\tt <- e-closure( delta(q,c) ) \n\t\t  // delta函数 计算q中每个状态通过c所能到的状态\n\t\t  // t为q通过c所能到的下一个状态集合\n\t\tD[q ,c ] <- t   // 在DFA中记录：q通过c可以转换到t\n\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展\n\t\t\tadd t to Q and workList\n\t}\n}\n```\n\n## 04-05. Implementing Finite Automata\n\n### DFA -> Table-driven Implemetation\n\nNFA -> DFA -> list a 2-dimensional state table -> translate into code\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG)\n\nWe can also use 1-dimensional tables save space.\nThe table contains a pointer to a vector of moves for that particular state.\n**share the rows that are duplicated in the automaton**\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG)\n\n#### DFA 最小化\n\n**Hopcroft 最小化算法**\n伪代码\n\n```\nsplit(S)  // 集合切分\n{\t\n\tforeach (character c )\n\t\tif(c can split S) // S中某些状态通过c转移到同样的状态\n\t\t\tsplit S into T1 , ... Tk\n}\nhopcroft()\n{\n\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份\n\twhile( set is still changes ) // S是否刚刚被切分\n\t\tsplit(S)\n}\n```\n\n#### DFA 代码实现\n\nDFA是一个有向图\n可以根据转移表（类似邻接矩阵），哈希表，跳转表\n\n##### 转移表\n\n将字符和状态先填入一个二维数组table\n例如：\n\n```\ntable [0]['a']=1;\ntable [1]['b']=1;\n....\n```\n\n伪代码\n\n```\nnextToken()\n{\n\tstate=0;  // 当前到了哪个状态，如q0\n\tstack=[];  // 为了实现最长匹配机制\n\twhile( state!=ERROR )\n\t{\n\t\tc=getchar();\n\t\tif(state is ACCEPT)\n\t\t\tclear(stack) \n\t\tpush(state)\n\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态\n\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态\n\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环\n\t}\n\twhile( state is not ACCEPT )\n\t{\n\t\tstate=pop();\n\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)\n\t}\n}\n```\n\n##### 跳转表 jump table\n\n好处：不需要维护一个状态和字符的二维数组并且效率高\n伪代码\n\n```\nnextToken()\n{\n\tstate =0\n\tstack = []\n\tgoto q0\n\nq0:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush (state)\n\tif(c=='a')\n\tgoto q1\n\nq1:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush(state)\n\tif(c=='b'||c=='c')\n\t\tgoto q1\n}\n```\n\n### NFA -> Table-driven Implemetation\n\nIt is also possible that we might not want to convert to a DFA.\nIt might be that the particular specification we gave is very expensive to turn into a DFA.\n\nImplement transition via a table\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG)\n\n## Quiz\n\n### Quiz 1\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG)\n\n> We have 16 distinct strings of length 4,\n> 8 distinct strings of length 3,\n> 4 distinct strings of length 2,\n> 2 distinct strings of length 1,\n> and one empty string\n> Ans=16+8+4+2+1=31\n\n### Quiz 2\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG)\n\n> This is a priority ordering, we should check the list from the beginning to the end.\n> We also have to choose the **Maximal Munch**\n\n### Quiz 3\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG)\n\n> **Maximal Munch**: both rule 3 and 4 match the whole string\n> But the rule 3 has a higher priority.\n\n### Quiz 4\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG)\n\n### Quiz 5\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG)\n\n> We need n states to culculate the number of 0 and 2n states to culculate the number of 1\n> n+2n+1(start state)=3n+1\n\n### Quiz 6\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG)\n\n### Quiz 7\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG)\n\n### Quiz 8\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG)\n\n> b*(ab)* -> abab match better than a(ba)*\n\n### Quiz 9\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG)\n\n### Quiz 10\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG)\n\n> “11” and “1”\n>\n> ### Quiz 11\n>\n> ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim)\n>\n> DFAs must have finite states, no ϵ-moves, and one transition per input per state.\n> The last option has infinite states.\n\n### Quiz 12\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim)\n\n> NFAs must have a finite set of states, which rules out the last option. **Every DFA is also an NFA**, which is why the first option is included.","source":"_posts/Compiler2.md","raw":"---\nlayout: post\ntitle: \"编译原理笔记（二）：词法分析\"\ndate: 2017-08-24\ncomments: true\ntags: \n\t- 编译原理\n\t- 学习笔记\n---\n\n\n## 03-01. Lexical Analysis\n\n**Goal **:\n1 - Recognize substrings corresponding to tokens. ( **lexemes**: substrings )\n2 - Identify the token class of each lexeme.\n3 - Communicate tokens to the parser.\n\n<!-- more -->\n\nWhat the likes of human being will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG)\nWhat the likes of analyzer will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG)\n\n**Token classes**: the role of different elements\nIn a programming language: Identifiers、keywords、’(‘、’)’、numbers….\n**Token classes correspond to sets of strings.**\n\n- Identifier: 标识符\n\n  > strings of letters or digits, starting with a letter\n  > like “a1”,”A0o”\n\n- Number:\n\n  > a non-empty string of digits\n  > like “9”,”001”\n\n- Keyword: 关键字\n\n  > “else” or “if” or “begin “…\n\n- Whitespace:\n\n  > a non-empty swquence of blanks, newlines, and tabs\n\n- Operator:\n\n  > “==”…\n\nThe output of the lexical analyzer: **a series of pairs **which are the token class.\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG)\n\n## 03-02. Lexical Analysis example\n\n1 - The goal is to **partition the string** . This is implemented by reading left-to-right, recognizing **one token at a time**.\n\n2 - **look ahead** may be required to decide where one token ends and the next token begins.\n\n> but we would like to **minimize** the amount of look ahead.\n\n## (extra) 03-02x 词法分析器的实现\n\n1 - 手工编码实现\n相对复杂，且容易出错\n但是目前主流的实现方式\n对词法分析器各部分掌握精确，效率高\n如 GCC、LLVM\n\n2 - 词法分析器的生成器\n可快速生成原型、代码量小\n难以控制实现细节\n如 lex、flex、jlex\n\n### 03-02x-01 手工编码实现\n\n#### 方法一：转移图算法\n\n根据需求画出状态转移图：\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG)\n而后实现该算法：\n\n```\nenum kind{IF , LPAREN , ID, INTLIT, ...};\nstruct token\n{\n\tenum kind k;\n\tchar *lexeme;\n};\ntoken nextToken()\n{\n\tc=getchar();\n\tswitch(c)\n\t{\n\t\tcase '<': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=': return LE;\n\t\t\t\tcase '>': return NE;\n\t\t\t\tdefault: rollback(); return LT;\n\t\t\t}\n\t\tcase '=': return EQ;\n\t\tcase '>': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=' return GE;\n\t\t\t\tdefault: rollback(); return GT;\n\t\t\t}\n\t}\n}\n```\n\n#### 方法二：关键字表算法\n\n对给定语言中所有关键字，构造关键字构成的哈希表H\n对所有标识符和关键字，先统一按转移图识别\n识别后，查看表H是否为关键字\n通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成\n\n## 03-03. Regular Languages (正则语言)\n\nWe must say what set of strings is in a token class.\n\n- The usual tool is to use regular languages( 正则语言 ).\n\n  **Regular expression** (正则表达式) : define the regular language\n  each regular expression is a set.\n\n**1.Basic regular expression:**\n\n- Single character\n\n  > ‘c’= {“c”}\n\n- Epsilon\n\n  > $\\epsilon$ = {“”}\n  > It is a language that has a single string namely the empty string\n  > $\\epsilon$ != $\\emptyset$\n\n**2.Compound regular expression:**\n\n- Union\n  ![union](http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG)\n\n- Concatenation\n  choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.\n  ![Concatenation](http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG)\n\n- Iteration\n  It means one concatenated with itself i times.\n  ![Iteration](http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG)\n\n  Besides:\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG)\n  A+：there has to be at least one A\n\n  There is **more than one way** to write down **the same set**.\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG)\n\n  Quiz :\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG)\n\nExplanation:\n\n> 1. The given regular expression requires every string have at least one 1.\n> 2. (10 + 11 + 1) can be replaced by 1\n> 3. (0+1)* equals to (1+0)*\n\n## 03-04. Formal Languages (形式语言)\n\nLet $\\Sigma$ be a set of characters\nA language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$\n\n### Meaning function: L\n\nL($\\epsilon$)= {“”}\nL: Expression -> Sets of Strings\nWe apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.\n\nWhy use a meaning function?\n\n- Makes clear what is syntax, what is semantics.\n- Allows us to consider notation as a seperate issue\n- Because expressions and meanings are not 1-1\n\n## 03-05. Lexical Specifications\n\n### write regular expressions\n\n1 . Keyword: “if” or “else” or “then”…\n![Keyword](http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG)\n\n2 . Integer: a non-empty string of digits\n![Integer](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG)\n\n3 . Identifier: strings of letters or digits, starting with a letter\nuse square brackets to write a range of characters.\nhave the starting character and an ending character and then separate them by a hyphen.\n\n> [ a - z ] = ‘a’+’b’+’c’…..+’z’\n> ![Identifier](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG)\n\n4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.\n![Whitespace](http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG)\n\n![digits](http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG)\n\n- Regular expressions describe many useful languages\n- Regular languages are a language specification\n\n## 04-01. Lexical Specification\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG)\n\n1 . Write a regular expression for the lexemes of each token class.\n\n> Number = digit+\n> Keyword = ‘if’ + ‘else’…\n> Identifier = letter ( letter + digit )*\n> OpenPar=’(‘….\n> 2 . Construct R, matching all lexemes for all tokens.\n> R= Keyword + Identifier + Number +…\n> = R1 + R2 …\n> 3 . Let input be x1..xn\n> For 1<=i<=n check x1..xi$\\in$L(R)?\n> 4 . If success , then we know that\n> x1..xi $\\in$ L(Rj) for some j\n> 5 . Remove x1..xn from input and go to (3)\n\n### Questions:\n\n1 . How much input is used?\nif x1..xi $\\in$ L(R)\nx1..xj $\\in$ L(R) (i!=j)\n\n> like “=” and “==”\n> **Maximal Munch**: choose the longer one\n\n2 . Whick token is used?\n\n> like “if” is both a keyword and an identifier\n\nUse a priority ordering (优先排序)\nthe rule is to **choose the one listed first**\n\n3 . What if no rule matches?\n\n**do good error handling.**\nCompilers can’t simply crash, it should be able to give the user **a feedback** about where the error is and what kind of error it is.\n\nSolution: **write a category of error strings**and put it in the last of the priority list.\n\n### Summary:\n\n- Use in lexical analysis requires small extensions\n\n  > 1. To resolve ambiguities\n  >\n  >    > 1. matches as long as possible\n  >    > 2. highest priority match\n  >\n  > 2. To handle errors\n  >\n  >    > 1. write a category of error strings and put it in the last of the priority list.\n\n- Good algorithms known\n\n  > 1. Require only single pass over the input\n  > 2. Few operations per character (table lookup)\n\n- Regular expression\n\n  > $\\epsilon$\n  > a\n  > a|b\n  > ab\n  > a*[a-z] == a|b|c…|za+ == a(a)*\n  > a? == $\\epsilon$|a\n  > “a*“ != a*\n  > e{1,3} == (e)|(ee)|(eee)\n  > . == [^\\n]\n\n## 04-02. Finite Automata (有限状态自动机)\n\n**Finite Automata**: are a very convenience as an implementation mechanism for regular expressions.\n\n### A finite automaton consists of :\n\n- An input alphabet **$\\Sigma$**\n- A finite set of states **S**\n- A start state **n**\n- A set of accepting states **F \\subseteq S**\n- A set of transitions state -> (input) state\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG)\n\nTransition s1 ->(a) -> s2\nIf end of input and in accepting state => accept state\nOtherwise => reject state\n\n> terminates in state S \\not\\in $ Final state\n> gets stuck. (no transition)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG)\n\nAnother kind of transition: **$\\epsilon$-moves**\n\nThe automaton can move to a different state without consuming any input.\n\n### Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\n\n- One transition per input per state\n- No $\\epsilon$-moves\n  A DFA takes only** one path **through the state graph\n  **DFAs are faster to execute**\n  **Every DFA is also an NFA**\n\n### Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\n\n- Can have multiple transitions for one input int a given state\n\n- Can have $\\epsilon$-moves\n  An NFA can choose\n  It accepts if some choices lead to an accepting state\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG)\n  In every step an NFA is in a set of states of the machine.\n  We can consider all the possible moves.\n  We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.\n  **NFAs are much more smaller than DFAs.**\n\n## 04-03. Regular expressions into NFAs\n\n![steps](http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG)\n\nFor each kind of regular expression, define an equivalent NFA.\n\n**Thompson Algorithm:**\n\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG)\n\n![quiz](http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG)\n\n## 04-04. NFA to DFA\n\n**$\\epsilon$-closure **\nchoose a state and look at the states that can be reached by following **only epsilon moves**.\n\n![closure](http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG)\n\nHow many different states can an NFA get into ?\n\n> if there are N states\n> The states NFA can get into at most n different states.\n> |S|<=N\n\nHow to convert an NFA to a DFA?\n\n> There are $2^n -1 $ possible subsets of n states.\n> **This is a finite set of possible configurations.**\n> Use DFA to **simulate the behaviour** of the NFA.\n> O($2^n$)\n\nDefine an NFA:\n![NFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG)\n\nDefine a DFA:\n![DFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG)\n\nTransition\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG)\n\n**子集构造算法：**\n工作表算法伪代码：\n\n```\nq0 <- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态\n// eps_closure 为找到s0的所有$\\epsilon$可到达的状态\nQ <- {q0}    // Q 为DFA的所有状态集合\nworkList <- q0   // 队列\nwhile( workList != [] )    \n{\n\tremove q from workList // 队列不为空则取队首元素\n\tforeach (character c)   // 循环判断每个字符\n\t{\n\t\tt <- e-closure( delta(q,c) ) \n\t\t  // delta函数 计算q中每个状态通过c所能到的状态\n\t\t  // t为q通过c所能到的下一个状态集合\n\t\tD[q ,c ] <- t   // 在DFA中记录：q通过c可以转换到t\n\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展\n\t\t\tadd t to Q and workList\n\t}\n}\n```\n\n## 04-05. Implementing Finite Automata\n\n### DFA -> Table-driven Implemetation\n\nNFA -> DFA -> list a 2-dimensional state table -> translate into code\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG)\n\nWe can also use 1-dimensional tables save space.\nThe table contains a pointer to a vector of moves for that particular state.\n**share the rows that are duplicated in the automaton**\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG)\n\n#### DFA 最小化\n\n**Hopcroft 最小化算法**\n伪代码\n\n```\nsplit(S)  // 集合切分\n{\t\n\tforeach (character c )\n\t\tif(c can split S) // S中某些状态通过c转移到同样的状态\n\t\t\tsplit S into T1 , ... Tk\n}\nhopcroft()\n{\n\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份\n\twhile( set is still changes ) // S是否刚刚被切分\n\t\tsplit(S)\n}\n```\n\n#### DFA 代码实现\n\nDFA是一个有向图\n可以根据转移表（类似邻接矩阵），哈希表，跳转表\n\n##### 转移表\n\n将字符和状态先填入一个二维数组table\n例如：\n\n```\ntable [0]['a']=1;\ntable [1]['b']=1;\n....\n```\n\n伪代码\n\n```\nnextToken()\n{\n\tstate=0;  // 当前到了哪个状态，如q0\n\tstack=[];  // 为了实现最长匹配机制\n\twhile( state!=ERROR )\n\t{\n\t\tc=getchar();\n\t\tif(state is ACCEPT)\n\t\t\tclear(stack) \n\t\tpush(state)\n\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态\n\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态\n\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环\n\t}\n\twhile( state is not ACCEPT )\n\t{\n\t\tstate=pop();\n\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)\n\t}\n}\n```\n\n##### 跳转表 jump table\n\n好处：不需要维护一个状态和字符的二维数组并且效率高\n伪代码\n\n```\nnextToken()\n{\n\tstate =0\n\tstack = []\n\tgoto q0\n\nq0:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush (state)\n\tif(c=='a')\n\tgoto q1\n\nq1:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush(state)\n\tif(c=='b'||c=='c')\n\t\tgoto q1\n}\n```\n\n### NFA -> Table-driven Implemetation\n\nIt is also possible that we might not want to convert to a DFA.\nIt might be that the particular specification we gave is very expensive to turn into a DFA.\n\nImplement transition via a table\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG)\n\n## Quiz\n\n### Quiz 1\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG)\n\n> We have 16 distinct strings of length 4,\n> 8 distinct strings of length 3,\n> 4 distinct strings of length 2,\n> 2 distinct strings of length 1,\n> and one empty string\n> Ans=16+8+4+2+1=31\n\n### Quiz 2\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG)\n\n> This is a priority ordering, we should check the list from the beginning to the end.\n> We also have to choose the **Maximal Munch**\n\n### Quiz 3\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG)\n\n> **Maximal Munch**: both rule 3 and 4 match the whole string\n> But the rule 3 has a higher priority.\n\n### Quiz 4\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG)\n\n### Quiz 5\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG)\n\n> We need n states to culculate the number of 0 and 2n states to culculate the number of 1\n> n+2n+1(start state)=3n+1\n\n### Quiz 6\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG)\n\n### Quiz 7\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG)\n\n### Quiz 8\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG)\n\n> b*(ab)* -> abab match better than a(ba)*\n\n### Quiz 9\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG)\n\n### Quiz 10\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG)\n\n> “11” and “1”\n>\n> ### Quiz 11\n>\n> ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim)\n>\n> DFAs must have finite states, no ϵ-moves, and one transition per input per state.\n> The last option has infinite states.\n\n### Quiz 12\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim)\n\n> NFAs must have a finite set of states, which rules out the last option. **Every DFA is also an NFA**, which is why the first option is included.","slug":"Compiler2","published":1,"updated":"2018-05-25T12:41:11.924Z","photos":[],"link":"","_id":"cjleshqiv0001ryfcwfneaf1o","content":"<h2 id=\"03-01-Lexical-Analysis\"><a href=\"#03-01-Lexical-Analysis\" class=\"headerlink\" title=\"03-01. Lexical Analysis\"></a>03-01. Lexical Analysis</h2><p><strong>Goal </strong>:<br>1 - Recognize substrings corresponding to tokens. ( <strong>lexemes</strong>: substrings )<br>2 - Identify the token class of each lexeme.<br>3 - Communicate tokens to the parser.</p>\n<a id=\"more\"></a>\n<p>What the likes of human being will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG\" alt=\"mark\"><br>What the likes of analyzer will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG\" alt=\"mark\"></p>\n<p><strong>Token classes</strong>: the role of different elements<br>In a programming language: Identifiers、keywords、’(‘、’)’、numbers….<br><strong>Token classes correspond to sets of strings.</strong></p>\n<ul>\n<li><p>Identifier: 标识符</p>\n<blockquote>\n<p>strings of letters or digits, starting with a letter<br>like “a1”,”A0o”</p>\n</blockquote>\n</li>\n<li><p>Number:</p>\n<blockquote>\n<p>a non-empty string of digits<br>like “9”,”001”</p>\n</blockquote>\n</li>\n<li><p>Keyword: 关键字</p>\n<blockquote>\n<p>“else” or “if” or “begin “…</p>\n</blockquote>\n</li>\n<li><p>Whitespace:</p>\n<blockquote>\n<p>a non-empty swquence of blanks, newlines, and tabs</p>\n</blockquote>\n</li>\n<li><p>Operator:</p>\n<blockquote>\n<p>“==”…</p>\n</blockquote>\n</li>\n</ul>\n<p>The output of the lexical analyzer: <strong>a series of pairs </strong>which are the token class.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG\" alt=\"mark\"></p>\n<h2 id=\"03-02-Lexical-Analysis-example\"><a href=\"#03-02-Lexical-Analysis-example\" class=\"headerlink\" title=\"03-02. Lexical Analysis example\"></a>03-02. Lexical Analysis example</h2><p>1 - The goal is to <strong>partition the string</strong> . This is implemented by reading left-to-right, recognizing <strong>one token at a time</strong>.</p>\n<p>2 - <strong>look ahead</strong> may be required to decide where one token ends and the next token begins.</p>\n<blockquote>\n<p>but we would like to <strong>minimize</strong> the amount of look ahead.</p>\n</blockquote>\n<h2 id=\"extra-03-02x-词法分析器的实现\"><a href=\"#extra-03-02x-词法分析器的实现\" class=\"headerlink\" title=\"(extra) 03-02x 词法分析器的实现\"></a>(extra) 03-02x 词法分析器的实现</h2><p>1 - 手工编码实现<br>相对复杂，且容易出错<br>但是目前主流的实现方式<br>对词法分析器各部分掌握精确，效率高<br>如 GCC、LLVM</p>\n<p>2 - 词法分析器的生成器<br>可快速生成原型、代码量小<br>难以控制实现细节<br>如 lex、flex、jlex</p>\n<h3 id=\"03-02x-01-手工编码实现\"><a href=\"#03-02x-01-手工编码实现\" class=\"headerlink\" title=\"03-02x-01 手工编码实现\"></a>03-02x-01 手工编码实现</h3><h4 id=\"方法一：转移图算法\"><a href=\"#方法一：转移图算法\" class=\"headerlink\" title=\"方法一：转移图算法\"></a>方法一：转移图算法</h4><p>根据需求画出状态转移图：<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG\" alt=\"mark\"><br>而后实现该算法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum kind&#123;IF , LPAREN , ID, INTLIT, ...&#125;;</span><br><span class=\"line\">struct token</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tenum kind k;</span><br><span class=\"line\">\tchar *lexeme;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">token nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tc=getchar();</span><br><span class=\"line\">\tswitch(c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcase &apos;&lt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos;: return LE;</span><br><span class=\"line\">\t\t\t\tcase &apos;&gt;&apos;: return NE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return LT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;=&apos;: return EQ;</span><br><span class=\"line\">\t\tcase &apos;&gt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos; return GE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return GT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：关键字表算法\"><a href=\"#方法二：关键字表算法\" class=\"headerlink\" title=\"方法二：关键字表算法\"></a>方法二：关键字表算法</h4><p>对给定语言中所有关键字，构造关键字构成的哈希表H<br>对所有标识符和关键字，先统一按转移图识别<br>识别后，查看表H是否为关键字<br>通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成</p>\n<h2 id=\"03-03-Regular-Languages-正则语言\"><a href=\"#03-03-Regular-Languages-正则语言\" class=\"headerlink\" title=\"03-03. Regular Languages (正则语言)\"></a>03-03. Regular Languages (正则语言)</h2><p>We must say what set of strings is in a token class.</p>\n<ul>\n<li><p>The usual tool is to use regular languages( 正则语言 ).</p>\n<p><strong>Regular expression</strong> (正则表达式) : define the regular language<br>each regular expression is a set.</p>\n</li>\n</ul>\n<p><strong>1.Basic regular expression:</strong></p>\n<ul>\n<li><p>Single character</p>\n<blockquote>\n<p>‘c’= {“c”}</p>\n</blockquote>\n</li>\n<li><p>Epsilon</p>\n<blockquote>\n<p>$\\epsilon$ = {“”}<br>It is a language that has a single string namely the empty string<br>$\\epsilon$ != $\\emptyset$</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>2.Compound regular expression:</strong></p>\n<ul>\n<li><p>Union<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG\" alt=\"union\"></p>\n</li>\n<li><p>Concatenation<br>choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG\" alt=\"Concatenation\"></p>\n</li>\n<li><p>Iteration<br>It means one concatenated with itself i times.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG\" alt=\"Iteration\"></p>\n<p>Besides:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG\" alt=\"mark\"><br>A+：there has to be at least one A</p>\n<p>There is <strong>more than one way</strong> to write down <strong>the same set</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG\" alt=\"mark\"></p>\n<p>Quiz :<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG\" alt=\"mark\"></p>\n</li>\n</ul>\n<p>Explanation:</p>\n<blockquote>\n<ol>\n<li>The given regular expression requires every string have at least one 1.</li>\n<li>(10 + 11 + 1) can be replaced by 1</li>\n<li>(0+1)<em> equals to (1+0)</em></li>\n</ol>\n</blockquote>\n<h2 id=\"03-04-Formal-Languages-形式语言\"><a href=\"#03-04-Formal-Languages-形式语言\" class=\"headerlink\" title=\"03-04. Formal Languages (形式语言)\"></a>03-04. Formal Languages (形式语言)</h2><p>Let $\\Sigma$ be a set of characters<br>A language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$</p>\n<h3 id=\"Meaning-function-L\"><a href=\"#Meaning-function-L\" class=\"headerlink\" title=\"Meaning function: L\"></a>Meaning function: L</h3><p>L($\\epsilon$)= {“”}<br>L: Expression -&gt; Sets of Strings<br>We apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.</p>\n<p>Why use a meaning function?</p>\n<ul>\n<li>Makes clear what is syntax, what is semantics.</li>\n<li>Allows us to consider notation as a seperate issue</li>\n<li>Because expressions and meanings are not 1-1</li>\n</ul>\n<h2 id=\"03-05-Lexical-Specifications\"><a href=\"#03-05-Lexical-Specifications\" class=\"headerlink\" title=\"03-05. Lexical Specifications\"></a>03-05. Lexical Specifications</h2><h3 id=\"write-regular-expressions\"><a href=\"#write-regular-expressions\" class=\"headerlink\" title=\"write regular expressions\"></a>write regular expressions</h3><p>1 . Keyword: “if” or “else” or “then”…<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG\" alt=\"Keyword\"></p>\n<p>2 . Integer: a non-empty string of digits<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG\" alt=\"Integer\"></p>\n<p>3 . Identifier: strings of letters or digits, starting with a letter<br>use square brackets to write a range of characters.<br>have the starting character and an ending character and then separate them by a hyphen.</p>\n<blockquote>\n<p>[ a - z ] = ‘a’+’b’+’c’…..+’z’<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG\" alt=\"Identifier\"></p>\n</blockquote>\n<p>4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG\" alt=\"Whitespace\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG\" alt=\"digits\"></p>\n<ul>\n<li>Regular expressions describe many useful languages</li>\n<li>Regular languages are a language specification</li>\n</ul>\n<h2 id=\"04-01-Lexical-Specification\"><a href=\"#04-01-Lexical-Specification\" class=\"headerlink\" title=\"04-01. Lexical Specification\"></a>04-01. Lexical Specification</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG\" alt=\"mark\"></p>\n<p>1 . Write a regular expression for the lexemes of each token class.</p>\n<blockquote>\n<p>Number = digit+<br>Keyword = ‘if’ + ‘else’…<br>Identifier = letter ( letter + digit )*<br>OpenPar=’(‘….<br>2 . Construct R, matching all lexemes for all tokens.<br>R= Keyword + Identifier + Number +…<br>= R1 + R2 …<br>3 . Let input be x1..xn<br>For 1&lt;=i&lt;=n check x1..xi$\\in$L(R)?<br>4 . If success , then we know that<br>x1..xi $\\in$ L(Rj) for some j<br>5 . Remove x1..xn from input and go to (3)</p>\n</blockquote>\n<h3 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions:\"></a>Questions:</h3><p>1 . How much input is used?<br>if x1..xi $\\in$ L(R)<br>x1..xj $\\in$ L(R) (i!=j)</p>\n<blockquote>\n<p>like “=” and “==”<br><strong>Maximal Munch</strong>: choose the longer one</p>\n</blockquote>\n<p>2 . Whick token is used?</p>\n<blockquote>\n<p>like “if” is both a keyword and an identifier</p>\n</blockquote>\n<p>Use a priority ordering (优先排序)<br>the rule is to <strong>choose the one listed first</strong></p>\n<p>3 . What if no rule matches?</p>\n<p><strong>do good error handling.</strong><br>Compilers can’t simply crash, it should be able to give the user <strong>a feedback</strong> about where the error is and what kind of error it is.</p>\n<p>Solution: <strong>write a category of error strings</strong>and put it in the last of the priority list.</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary:\"></a>Summary:</h3><ul>\n<li><p>Use in lexical analysis requires small extensions</p>\n<blockquote>\n<ol>\n<li><p>To resolve ambiguities</p>\n<blockquote>\n<ol>\n<li>matches as long as possible</li>\n<li>highest priority match</li>\n</ol>\n</blockquote>\n</li>\n<li><p>To handle errors</p>\n<blockquote>\n<ol>\n<li>write a category of error strings and put it in the last of the priority list.</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Good algorithms known</p>\n<blockquote>\n<ol>\n<li>Require only single pass over the input</li>\n<li>Few operations per character (table lookup)</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Regular expression</p>\n<blockquote>\n<p>$\\epsilon$<br>a<br>a|b<br>ab<br>a<em>[a-z] == a|b|c…|za+ == a(a)</em><br>a? == $\\epsilon$|a<br>“a<em>“ != a</em><br>e{1,3} == (e)|(ee)|(eee)<br>. == <sup><a href=\"#fn_\\n\" id=\"reffn_\\n\">\\n</a></sup></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"04-02-Finite-Automata-有限状态自动机\"><a href=\"#04-02-Finite-Automata-有限状态自动机\" class=\"headerlink\" title=\"04-02. Finite Automata (有限状态自动机)\"></a>04-02. Finite Automata (有限状态自动机)</h2><p><strong>Finite Automata</strong>: are a very convenience as an implementation mechanism for regular expressions.</p>\n<h3 id=\"A-finite-automaton-consists-of\"><a href=\"#A-finite-automaton-consists-of\" class=\"headerlink\" title=\"A finite automaton consists of :\"></a>A finite automaton consists of :</h3><ul>\n<li>An input alphabet <strong>$\\Sigma$</strong></li>\n<li>A finite set of states <strong>S</strong></li>\n<li>A start state <strong>n</strong></li>\n<li>A set of accepting states <strong>F \\subseteq S</strong></li>\n<li>A set of transitions state -&gt; (input) state</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG\" alt=\"mark\"></p>\n<p>Transition s1 -&gt;(a) -&gt; s2<br>If end of input and in accepting state =&gt; accept state<br>Otherwise =&gt; reject state</p>\n<blockquote>\n<p>terminates in state S \\not\\in $ Final state<br>gets stuck. (no transition)</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG\" alt=\"mark\"></p>\n<p>Another kind of transition: <strong>$\\epsilon$-moves</strong></p>\n<p>The automaton can move to a different state without consuming any input.</p>\n<h3 id=\"Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\"><a href=\"#Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\" class=\"headerlink\" title=\"Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\"></a>Deterministic Finite Automata (DFA) (确定的有穷状态自动机)</h3><ul>\n<li>One transition per input per state</li>\n<li>No $\\epsilon$-moves<br>A DFA takes only<strong> one path </strong>through the state graph<br><strong>DFAs are faster to execute</strong><br><strong>Every DFA is also an NFA</strong></li>\n</ul>\n<h3 id=\"Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\"><a href=\"#Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\" class=\"headerlink\" title=\"Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\"></a>Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)</h3><ul>\n<li><p>Can have multiple transitions for one input int a given state</p>\n</li>\n<li><p>Can have $\\epsilon$-moves<br>An NFA can choose<br>It accepts if some choices lead to an accepting state</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG\" alt=\"mark\"><br>In every step an NFA is in a set of states of the machine.<br>We can consider all the possible moves.<br>We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.<br><strong>NFAs are much more smaller than DFAs.</strong></p>\n</li>\n</ul>\n<h2 id=\"04-03-Regular-expressions-into-NFAs\"><a href=\"#04-03-Regular-expressions-into-NFAs\" class=\"headerlink\" title=\"04-03. Regular expressions into NFAs\"></a>04-03. Regular expressions into NFAs</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG\" alt=\"steps\"></p>\n<p>For each kind of regular expression, define an equivalent NFA.</p>\n<p><strong>Thompson Algorithm:</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG\" alt=\"Transition\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG\" alt=\"quiz\"></p>\n<h2 id=\"04-04-NFA-to-DFA\"><a href=\"#04-04-NFA-to-DFA\" class=\"headerlink\" title=\"04-04. NFA to DFA\"></a>04-04. NFA to DFA</h2><p><strong>$\\epsilon$-closure </strong><br>choose a state and look at the states that can be reached by following <strong>only epsilon moves</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG\" alt=\"closure\"></p>\n<p>How many different states can an NFA get into ?</p>\n<blockquote>\n<p>if there are N states<br>The states NFA can get into at most n different states.<br>|S|&lt;=N</p>\n</blockquote>\n<p>How to convert an NFA to a DFA?</p>\n<blockquote>\n<p>There are $2^n -1 $ possible subsets of n states.<br><strong>This is a finite set of possible configurations.</strong><br>Use DFA to <strong>simulate the behaviour</strong> of the NFA.<br>O($2^n$)</p>\n</blockquote>\n<p>Define an NFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG\" alt=\"NFA\"></p>\n<p>Define a DFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG\" alt=\"DFA\"></p>\n<p>Transition<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG\" alt=\"Transition\"></p>\n<p><strong>子集构造算法：</strong><br>工作表算法伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q0 &lt;- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态</span><br><span class=\"line\">// eps_closure 为找到s0的所有$\\epsilon$可到达的状态</span><br><span class=\"line\">Q &lt;- &#123;q0&#125;    // Q 为DFA的所有状态集合</span><br><span class=\"line\">workList &lt;- q0   // 队列</span><br><span class=\"line\">while( workList != [] )    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tremove q from workList // 队列不为空则取队首元素</span><br><span class=\"line\">\tforeach (character c)   // 循环判断每个字符</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tt &lt;- e-closure( delta(q,c) ) </span><br><span class=\"line\">\t\t  // delta函数 计算q中每个状态通过c所能到的状态</span><br><span class=\"line\">\t\t  // t为q通过c所能到的下一个状态集合</span><br><span class=\"line\">\t\tD[q ,c ] &lt;- t   // 在DFA中记录：q通过c可以转换到t</span><br><span class=\"line\">\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展</span><br><span class=\"line\">\t\t\tadd t to Q and workList</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"04-05-Implementing-Finite-Automata\"><a href=\"#04-05-Implementing-Finite-Automata\" class=\"headerlink\" title=\"04-05. Implementing Finite Automata\"></a>04-05. Implementing Finite Automata</h2><h3 id=\"DFA-gt-Table-driven-Implemetation\"><a href=\"#DFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"DFA -&gt; Table-driven Implemetation\"></a>DFA -&gt; Table-driven Implemetation</h3><p>NFA -&gt; DFA -&gt; list a 2-dimensional state table -&gt; translate into code<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG\" alt=\"mark\"></p>\n<p>We can also use 1-dimensional tables save space.<br>The table contains a pointer to a vector of moves for that particular state.<br><strong>share the rows that are duplicated in the automaton</strong><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG\" alt=\"mark\"></p>\n<h4 id=\"DFA-最小化\"><a href=\"#DFA-最小化\" class=\"headerlink\" title=\"DFA 最小化\"></a>DFA 最小化</h4><p><strong>Hopcroft 最小化算法</strong><br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(S)  // 集合切分</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">\tforeach (character c )</span><br><span class=\"line\">\t\tif(c can split S) // S中某些状态通过c转移到同样的状态</span><br><span class=\"line\">\t\t\tsplit S into T1 , ... Tk</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hopcroft()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份</span><br><span class=\"line\">\twhile( set is still changes ) // S是否刚刚被切分</span><br><span class=\"line\">\t\tsplit(S)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DFA-代码实现\"><a href=\"#DFA-代码实现\" class=\"headerlink\" title=\"DFA 代码实现\"></a>DFA 代码实现</h4><p>DFA是一个有向图<br>可以根据转移表（类似邻接矩阵），哈希表，跳转表</p>\n<h5 id=\"转移表\"><a href=\"#转移表\" class=\"headerlink\" title=\"转移表\"></a>转移表</h5><p>将字符和状态先填入一个二维数组table<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table [0][&apos;a&apos;]=1;</span><br><span class=\"line\">table [1][&apos;b&apos;]=1;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate=0;  // 当前到了哪个状态，如q0</span><br><span class=\"line\">\tstack=[];  // 为了实现最长匹配机制</span><br><span class=\"line\">\twhile( state!=ERROR )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tc=getchar();</span><br><span class=\"line\">\t\tif(state is ACCEPT)</span><br><span class=\"line\">\t\t\tclear(stack) </span><br><span class=\"line\">\t\tpush(state)</span><br><span class=\"line\">\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态</span><br><span class=\"line\">\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态</span><br><span class=\"line\">\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( state is not ACCEPT )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstate=pop();</span><br><span class=\"line\">\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"跳转表-jump-table\"><a href=\"#跳转表-jump-table\" class=\"headerlink\" title=\"跳转表 jump table\"></a>跳转表 jump table</h5><p>好处：不需要维护一个状态和字符的二维数组并且效率高<br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate =0</span><br><span class=\"line\">\tstack = []</span><br><span class=\"line\">\tgoto q0</span><br><span class=\"line\"></span><br><span class=\"line\">q0:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush (state)</span><br><span class=\"line\">\tif(c==&apos;a&apos;)</span><br><span class=\"line\">\tgoto q1</span><br><span class=\"line\"></span><br><span class=\"line\">q1:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush(state)</span><br><span class=\"line\">\tif(c==&apos;b&apos;||c==&apos;c&apos;)</span><br><span class=\"line\">\t\tgoto q1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NFA-gt-Table-driven-Implemetation\"><a href=\"#NFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"NFA -&gt; Table-driven Implemetation\"></a>NFA -&gt; Table-driven Implemetation</h3><p>It is also possible that we might not want to convert to a DFA.<br>It might be that the particular specification we gave is very expensive to turn into a DFA.</p>\n<p>Implement transition via a table<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG\" alt=\"mark\"></p>\n<h2 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h2><h3 id=\"Quiz-1\"><a href=\"#Quiz-1\" class=\"headerlink\" title=\"Quiz 1\"></a>Quiz 1</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We have 16 distinct strings of length 4,<br>8 distinct strings of length 3,<br>4 distinct strings of length 2,<br>2 distinct strings of length 1,<br>and one empty string<br>Ans=16+8+4+2+1=31</p>\n</blockquote>\n<h3 id=\"Quiz-2\"><a href=\"#Quiz-2\" class=\"headerlink\" title=\"Quiz 2\"></a>Quiz 2</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>This is a priority ordering, we should check the list from the beginning to the end.<br>We also have to choose the <strong>Maximal Munch</strong></p>\n</blockquote>\n<h3 id=\"Quiz-3\"><a href=\"#Quiz-3\" class=\"headerlink\" title=\"Quiz 3\"></a>Quiz 3</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p><strong>Maximal Munch</strong>: both rule 3 and 4 match the whole string<br>But the rule 3 has a higher priority.</p>\n</blockquote>\n<h3 id=\"Quiz-4\"><a href=\"#Quiz-4\" class=\"headerlink\" title=\"Quiz 4\"></a>Quiz 4</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-5\"><a href=\"#Quiz-5\" class=\"headerlink\" title=\"Quiz 5\"></a>Quiz 5</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We need n states to culculate the number of 0 and 2n states to culculate the number of 1<br>n+2n+1(start state)=3n+1</p>\n</blockquote>\n<h3 id=\"Quiz-6\"><a href=\"#Quiz-6\" class=\"headerlink\" title=\"Quiz 6\"></a>Quiz 6</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-7\"><a href=\"#Quiz-7\" class=\"headerlink\" title=\"Quiz 7\"></a>Quiz 7</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-8\"><a href=\"#Quiz-8\" class=\"headerlink\" title=\"Quiz 8\"></a>Quiz 8</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>b<em>(ab)</em> -&gt; abab match better than a(ba)*</p>\n</blockquote>\n<h3 id=\"Quiz-9\"><a href=\"#Quiz-9\" class=\"headerlink\" title=\"Quiz 9\"></a>Quiz 9</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-10\"><a href=\"#Quiz-10\" class=\"headerlink\" title=\"Quiz 10\"></a>Quiz 10</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>“11” and “1”</p>\n<h3 id=\"Quiz-11\"><a href=\"#Quiz-11\" class=\"headerlink\" title=\"Quiz 11\"></a>Quiz 11</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim\" alt=\"mark\"></p>\n<p>DFAs must have finite states, no ϵ-moves, and one transition per input per state.<br>The last option has infinite states.</p>\n</blockquote>\n<h3 id=\"Quiz-12\"><a href=\"#Quiz-12\" class=\"headerlink\" title=\"Quiz 12\"></a>Quiz 12</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim\" alt=\"mark\"></p>\n<blockquote>\n<p>NFAs must have a finite set of states, which rules out the last option. <strong>Every DFA is also an NFA</strong>, which is why the first option is included.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"03-01-Lexical-Analysis\"><a href=\"#03-01-Lexical-Analysis\" class=\"headerlink\" title=\"03-01. Lexical Analysis\"></a>03-01. Lexical Analysis</h2><p><strong>Goal </strong>:<br>1 - Recognize substrings corresponding to tokens. ( <strong>lexemes</strong>: substrings )<br>2 - Identify the token class of each lexeme.<br>3 - Communicate tokens to the parser.</p>","more":"<p>What the likes of human being will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG\" alt=\"mark\"><br>What the likes of analyzer will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG\" alt=\"mark\"></p>\n<p><strong>Token classes</strong>: the role of different elements<br>In a programming language: Identifiers、keywords、’(‘、’)’、numbers….<br><strong>Token classes correspond to sets of strings.</strong></p>\n<ul>\n<li><p>Identifier: 标识符</p>\n<blockquote>\n<p>strings of letters or digits, starting with a letter<br>like “a1”,”A0o”</p>\n</blockquote>\n</li>\n<li><p>Number:</p>\n<blockquote>\n<p>a non-empty string of digits<br>like “9”,”001”</p>\n</blockquote>\n</li>\n<li><p>Keyword: 关键字</p>\n<blockquote>\n<p>“else” or “if” or “begin “…</p>\n</blockquote>\n</li>\n<li><p>Whitespace:</p>\n<blockquote>\n<p>a non-empty swquence of blanks, newlines, and tabs</p>\n</blockquote>\n</li>\n<li><p>Operator:</p>\n<blockquote>\n<p>“==”…</p>\n</blockquote>\n</li>\n</ul>\n<p>The output of the lexical analyzer: <strong>a series of pairs </strong>which are the token class.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG\" alt=\"mark\"></p>\n<h2 id=\"03-02-Lexical-Analysis-example\"><a href=\"#03-02-Lexical-Analysis-example\" class=\"headerlink\" title=\"03-02. Lexical Analysis example\"></a>03-02. Lexical Analysis example</h2><p>1 - The goal is to <strong>partition the string</strong> . This is implemented by reading left-to-right, recognizing <strong>one token at a time</strong>.</p>\n<p>2 - <strong>look ahead</strong> may be required to decide where one token ends and the next token begins.</p>\n<blockquote>\n<p>but we would like to <strong>minimize</strong> the amount of look ahead.</p>\n</blockquote>\n<h2 id=\"extra-03-02x-词法分析器的实现\"><a href=\"#extra-03-02x-词法分析器的实现\" class=\"headerlink\" title=\"(extra) 03-02x 词法分析器的实现\"></a>(extra) 03-02x 词法分析器的实现</h2><p>1 - 手工编码实现<br>相对复杂，且容易出错<br>但是目前主流的实现方式<br>对词法分析器各部分掌握精确，效率高<br>如 GCC、LLVM</p>\n<p>2 - 词法分析器的生成器<br>可快速生成原型、代码量小<br>难以控制实现细节<br>如 lex、flex、jlex</p>\n<h3 id=\"03-02x-01-手工编码实现\"><a href=\"#03-02x-01-手工编码实现\" class=\"headerlink\" title=\"03-02x-01 手工编码实现\"></a>03-02x-01 手工编码实现</h3><h4 id=\"方法一：转移图算法\"><a href=\"#方法一：转移图算法\" class=\"headerlink\" title=\"方法一：转移图算法\"></a>方法一：转移图算法</h4><p>根据需求画出状态转移图：<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG\" alt=\"mark\"><br>而后实现该算法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum kind&#123;IF , LPAREN , ID, INTLIT, ...&#125;;</span><br><span class=\"line\">struct token</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tenum kind k;</span><br><span class=\"line\">\tchar *lexeme;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">token nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tc=getchar();</span><br><span class=\"line\">\tswitch(c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcase &apos;&lt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos;: return LE;</span><br><span class=\"line\">\t\t\t\tcase &apos;&gt;&apos;: return NE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return LT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;=&apos;: return EQ;</span><br><span class=\"line\">\t\tcase &apos;&gt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos; return GE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return GT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：关键字表算法\"><a href=\"#方法二：关键字表算法\" class=\"headerlink\" title=\"方法二：关键字表算法\"></a>方法二：关键字表算法</h4><p>对给定语言中所有关键字，构造关键字构成的哈希表H<br>对所有标识符和关键字，先统一按转移图识别<br>识别后，查看表H是否为关键字<br>通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成</p>\n<h2 id=\"03-03-Regular-Languages-正则语言\"><a href=\"#03-03-Regular-Languages-正则语言\" class=\"headerlink\" title=\"03-03. Regular Languages (正则语言)\"></a>03-03. Regular Languages (正则语言)</h2><p>We must say what set of strings is in a token class.</p>\n<ul>\n<li><p>The usual tool is to use regular languages( 正则语言 ).</p>\n<p><strong>Regular expression</strong> (正则表达式) : define the regular language<br>each regular expression is a set.</p>\n</li>\n</ul>\n<p><strong>1.Basic regular expression:</strong></p>\n<ul>\n<li><p>Single character</p>\n<blockquote>\n<p>‘c’= {“c”}</p>\n</blockquote>\n</li>\n<li><p>Epsilon</p>\n<blockquote>\n<p>$\\epsilon$ = {“”}<br>It is a language that has a single string namely the empty string<br>$\\epsilon$ != $\\emptyset$</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>2.Compound regular expression:</strong></p>\n<ul>\n<li><p>Union<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG\" alt=\"union\"></p>\n</li>\n<li><p>Concatenation<br>choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG\" alt=\"Concatenation\"></p>\n</li>\n<li><p>Iteration<br>It means one concatenated with itself i times.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG\" alt=\"Iteration\"></p>\n<p>Besides:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG\" alt=\"mark\"><br>A+：there has to be at least one A</p>\n<p>There is <strong>more than one way</strong> to write down <strong>the same set</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG\" alt=\"mark\"></p>\n<p>Quiz :<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG\" alt=\"mark\"></p>\n</li>\n</ul>\n<p>Explanation:</p>\n<blockquote>\n<ol>\n<li>The given regular expression requires every string have at least one 1.</li>\n<li>(10 + 11 + 1) can be replaced by 1</li>\n<li>(0+1)<em> equals to (1+0)</em></li>\n</ol>\n</blockquote>\n<h2 id=\"03-04-Formal-Languages-形式语言\"><a href=\"#03-04-Formal-Languages-形式语言\" class=\"headerlink\" title=\"03-04. Formal Languages (形式语言)\"></a>03-04. Formal Languages (形式语言)</h2><p>Let $\\Sigma$ be a set of characters<br>A language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$</p>\n<h3 id=\"Meaning-function-L\"><a href=\"#Meaning-function-L\" class=\"headerlink\" title=\"Meaning function: L\"></a>Meaning function: L</h3><p>L($\\epsilon$)= {“”}<br>L: Expression -&gt; Sets of Strings<br>We apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.</p>\n<p>Why use a meaning function?</p>\n<ul>\n<li>Makes clear what is syntax, what is semantics.</li>\n<li>Allows us to consider notation as a seperate issue</li>\n<li>Because expressions and meanings are not 1-1</li>\n</ul>\n<h2 id=\"03-05-Lexical-Specifications\"><a href=\"#03-05-Lexical-Specifications\" class=\"headerlink\" title=\"03-05. Lexical Specifications\"></a>03-05. Lexical Specifications</h2><h3 id=\"write-regular-expressions\"><a href=\"#write-regular-expressions\" class=\"headerlink\" title=\"write regular expressions\"></a>write regular expressions</h3><p>1 . Keyword: “if” or “else” or “then”…<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG\" alt=\"Keyword\"></p>\n<p>2 . Integer: a non-empty string of digits<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG\" alt=\"Integer\"></p>\n<p>3 . Identifier: strings of letters or digits, starting with a letter<br>use square brackets to write a range of characters.<br>have the starting character and an ending character and then separate them by a hyphen.</p>\n<blockquote>\n<p>[ a - z ] = ‘a’+’b’+’c’…..+’z’<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG\" alt=\"Identifier\"></p>\n</blockquote>\n<p>4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG\" alt=\"Whitespace\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG\" alt=\"digits\"></p>\n<ul>\n<li>Regular expressions describe many useful languages</li>\n<li>Regular languages are a language specification</li>\n</ul>\n<h2 id=\"04-01-Lexical-Specification\"><a href=\"#04-01-Lexical-Specification\" class=\"headerlink\" title=\"04-01. Lexical Specification\"></a>04-01. Lexical Specification</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG\" alt=\"mark\"></p>\n<p>1 . Write a regular expression for the lexemes of each token class.</p>\n<blockquote>\n<p>Number = digit+<br>Keyword = ‘if’ + ‘else’…<br>Identifier = letter ( letter + digit )*<br>OpenPar=’(‘….<br>2 . Construct R, matching all lexemes for all tokens.<br>R= Keyword + Identifier + Number +…<br>= R1 + R2 …<br>3 . Let input be x1..xn<br>For 1&lt;=i&lt;=n check x1..xi$\\in$L(R)?<br>4 . If success , then we know that<br>x1..xi $\\in$ L(Rj) for some j<br>5 . Remove x1..xn from input and go to (3)</p>\n</blockquote>\n<h3 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions:\"></a>Questions:</h3><p>1 . How much input is used?<br>if x1..xi $\\in$ L(R)<br>x1..xj $\\in$ L(R) (i!=j)</p>\n<blockquote>\n<p>like “=” and “==”<br><strong>Maximal Munch</strong>: choose the longer one</p>\n</blockquote>\n<p>2 . Whick token is used?</p>\n<blockquote>\n<p>like “if” is both a keyword and an identifier</p>\n</blockquote>\n<p>Use a priority ordering (优先排序)<br>the rule is to <strong>choose the one listed first</strong></p>\n<p>3 . What if no rule matches?</p>\n<p><strong>do good error handling.</strong><br>Compilers can’t simply crash, it should be able to give the user <strong>a feedback</strong> about where the error is and what kind of error it is.</p>\n<p>Solution: <strong>write a category of error strings</strong>and put it in the last of the priority list.</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary:\"></a>Summary:</h3><ul>\n<li><p>Use in lexical analysis requires small extensions</p>\n<blockquote>\n<ol>\n<li><p>To resolve ambiguities</p>\n<blockquote>\n<ol>\n<li>matches as long as possible</li>\n<li>highest priority match</li>\n</ol>\n</blockquote>\n</li>\n<li><p>To handle errors</p>\n<blockquote>\n<ol>\n<li>write a category of error strings and put it in the last of the priority list.</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Good algorithms known</p>\n<blockquote>\n<ol>\n<li>Require only single pass over the input</li>\n<li>Few operations per character (table lookup)</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Regular expression</p>\n<blockquote>\n<p>$\\epsilon$<br>a<br>a|b<br>ab<br>a<em>[a-z] == a|b|c…|za+ == a(a)</em><br>a? == $\\epsilon$|a<br>“a<em>“ != a</em><br>e{1,3} == (e)|(ee)|(eee)<br>. == <sup><a href=\"#fn_\\n\" id=\"reffn_\\n\">\\n</a></sup></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"04-02-Finite-Automata-有限状态自动机\"><a href=\"#04-02-Finite-Automata-有限状态自动机\" class=\"headerlink\" title=\"04-02. Finite Automata (有限状态自动机)\"></a>04-02. Finite Automata (有限状态自动机)</h2><p><strong>Finite Automata</strong>: are a very convenience as an implementation mechanism for regular expressions.</p>\n<h3 id=\"A-finite-automaton-consists-of\"><a href=\"#A-finite-automaton-consists-of\" class=\"headerlink\" title=\"A finite automaton consists of :\"></a>A finite automaton consists of :</h3><ul>\n<li>An input alphabet <strong>$\\Sigma$</strong></li>\n<li>A finite set of states <strong>S</strong></li>\n<li>A start state <strong>n</strong></li>\n<li>A set of accepting states <strong>F \\subseteq S</strong></li>\n<li>A set of transitions state -&gt; (input) state</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG\" alt=\"mark\"></p>\n<p>Transition s1 -&gt;(a) -&gt; s2<br>If end of input and in accepting state =&gt; accept state<br>Otherwise =&gt; reject state</p>\n<blockquote>\n<p>terminates in state S \\not\\in $ Final state<br>gets stuck. (no transition)</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG\" alt=\"mark\"></p>\n<p>Another kind of transition: <strong>$\\epsilon$-moves</strong></p>\n<p>The automaton can move to a different state without consuming any input.</p>\n<h3 id=\"Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\"><a href=\"#Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\" class=\"headerlink\" title=\"Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\"></a>Deterministic Finite Automata (DFA) (确定的有穷状态自动机)</h3><ul>\n<li>One transition per input per state</li>\n<li>No $\\epsilon$-moves<br>A DFA takes only<strong> one path </strong>through the state graph<br><strong>DFAs are faster to execute</strong><br><strong>Every DFA is also an NFA</strong></li>\n</ul>\n<h3 id=\"Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\"><a href=\"#Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\" class=\"headerlink\" title=\"Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\"></a>Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)</h3><ul>\n<li><p>Can have multiple transitions for one input int a given state</p>\n</li>\n<li><p>Can have $\\epsilon$-moves<br>An NFA can choose<br>It accepts if some choices lead to an accepting state</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG\" alt=\"mark\"><br>In every step an NFA is in a set of states of the machine.<br>We can consider all the possible moves.<br>We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.<br><strong>NFAs are much more smaller than DFAs.</strong></p>\n</li>\n</ul>\n<h2 id=\"04-03-Regular-expressions-into-NFAs\"><a href=\"#04-03-Regular-expressions-into-NFAs\" class=\"headerlink\" title=\"04-03. Regular expressions into NFAs\"></a>04-03. Regular expressions into NFAs</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG\" alt=\"steps\"></p>\n<p>For each kind of regular expression, define an equivalent NFA.</p>\n<p><strong>Thompson Algorithm:</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG\" alt=\"Transition\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG\" alt=\"quiz\"></p>\n<h2 id=\"04-04-NFA-to-DFA\"><a href=\"#04-04-NFA-to-DFA\" class=\"headerlink\" title=\"04-04. NFA to DFA\"></a>04-04. NFA to DFA</h2><p><strong>$\\epsilon$-closure </strong><br>choose a state and look at the states that can be reached by following <strong>only epsilon moves</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG\" alt=\"closure\"></p>\n<p>How many different states can an NFA get into ?</p>\n<blockquote>\n<p>if there are N states<br>The states NFA can get into at most n different states.<br>|S|&lt;=N</p>\n</blockquote>\n<p>How to convert an NFA to a DFA?</p>\n<blockquote>\n<p>There are $2^n -1 $ possible subsets of n states.<br><strong>This is a finite set of possible configurations.</strong><br>Use DFA to <strong>simulate the behaviour</strong> of the NFA.<br>O($2^n$)</p>\n</blockquote>\n<p>Define an NFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG\" alt=\"NFA\"></p>\n<p>Define a DFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG\" alt=\"DFA\"></p>\n<p>Transition<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG\" alt=\"Transition\"></p>\n<p><strong>子集构造算法：</strong><br>工作表算法伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q0 &lt;- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态</span><br><span class=\"line\">// eps_closure 为找到s0的所有$\\epsilon$可到达的状态</span><br><span class=\"line\">Q &lt;- &#123;q0&#125;    // Q 为DFA的所有状态集合</span><br><span class=\"line\">workList &lt;- q0   // 队列</span><br><span class=\"line\">while( workList != [] )    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tremove q from workList // 队列不为空则取队首元素</span><br><span class=\"line\">\tforeach (character c)   // 循环判断每个字符</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tt &lt;- e-closure( delta(q,c) ) </span><br><span class=\"line\">\t\t  // delta函数 计算q中每个状态通过c所能到的状态</span><br><span class=\"line\">\t\t  // t为q通过c所能到的下一个状态集合</span><br><span class=\"line\">\t\tD[q ,c ] &lt;- t   // 在DFA中记录：q通过c可以转换到t</span><br><span class=\"line\">\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展</span><br><span class=\"line\">\t\t\tadd t to Q and workList</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"04-05-Implementing-Finite-Automata\"><a href=\"#04-05-Implementing-Finite-Automata\" class=\"headerlink\" title=\"04-05. Implementing Finite Automata\"></a>04-05. Implementing Finite Automata</h2><h3 id=\"DFA-gt-Table-driven-Implemetation\"><a href=\"#DFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"DFA -&gt; Table-driven Implemetation\"></a>DFA -&gt; Table-driven Implemetation</h3><p>NFA -&gt; DFA -&gt; list a 2-dimensional state table -&gt; translate into code<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG\" alt=\"mark\"></p>\n<p>We can also use 1-dimensional tables save space.<br>The table contains a pointer to a vector of moves for that particular state.<br><strong>share the rows that are duplicated in the automaton</strong><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG\" alt=\"mark\"></p>\n<h4 id=\"DFA-最小化\"><a href=\"#DFA-最小化\" class=\"headerlink\" title=\"DFA 最小化\"></a>DFA 最小化</h4><p><strong>Hopcroft 最小化算法</strong><br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(S)  // 集合切分</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">\tforeach (character c )</span><br><span class=\"line\">\t\tif(c can split S) // S中某些状态通过c转移到同样的状态</span><br><span class=\"line\">\t\t\tsplit S into T1 , ... Tk</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hopcroft()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份</span><br><span class=\"line\">\twhile( set is still changes ) // S是否刚刚被切分</span><br><span class=\"line\">\t\tsplit(S)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DFA-代码实现\"><a href=\"#DFA-代码实现\" class=\"headerlink\" title=\"DFA 代码实现\"></a>DFA 代码实现</h4><p>DFA是一个有向图<br>可以根据转移表（类似邻接矩阵），哈希表，跳转表</p>\n<h5 id=\"转移表\"><a href=\"#转移表\" class=\"headerlink\" title=\"转移表\"></a>转移表</h5><p>将字符和状态先填入一个二维数组table<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table [0][&apos;a&apos;]=1;</span><br><span class=\"line\">table [1][&apos;b&apos;]=1;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate=0;  // 当前到了哪个状态，如q0</span><br><span class=\"line\">\tstack=[];  // 为了实现最长匹配机制</span><br><span class=\"line\">\twhile( state!=ERROR )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tc=getchar();</span><br><span class=\"line\">\t\tif(state is ACCEPT)</span><br><span class=\"line\">\t\t\tclear(stack) </span><br><span class=\"line\">\t\tpush(state)</span><br><span class=\"line\">\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态</span><br><span class=\"line\">\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态</span><br><span class=\"line\">\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( state is not ACCEPT )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstate=pop();</span><br><span class=\"line\">\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"跳转表-jump-table\"><a href=\"#跳转表-jump-table\" class=\"headerlink\" title=\"跳转表 jump table\"></a>跳转表 jump table</h5><p>好处：不需要维护一个状态和字符的二维数组并且效率高<br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate =0</span><br><span class=\"line\">\tstack = []</span><br><span class=\"line\">\tgoto q0</span><br><span class=\"line\"></span><br><span class=\"line\">q0:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush (state)</span><br><span class=\"line\">\tif(c==&apos;a&apos;)</span><br><span class=\"line\">\tgoto q1</span><br><span class=\"line\"></span><br><span class=\"line\">q1:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush(state)</span><br><span class=\"line\">\tif(c==&apos;b&apos;||c==&apos;c&apos;)</span><br><span class=\"line\">\t\tgoto q1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NFA-gt-Table-driven-Implemetation\"><a href=\"#NFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"NFA -&gt; Table-driven Implemetation\"></a>NFA -&gt; Table-driven Implemetation</h3><p>It is also possible that we might not want to convert to a DFA.<br>It might be that the particular specification we gave is very expensive to turn into a DFA.</p>\n<p>Implement transition via a table<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG\" alt=\"mark\"></p>\n<h2 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h2><h3 id=\"Quiz-1\"><a href=\"#Quiz-1\" class=\"headerlink\" title=\"Quiz 1\"></a>Quiz 1</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We have 16 distinct strings of length 4,<br>8 distinct strings of length 3,<br>4 distinct strings of length 2,<br>2 distinct strings of length 1,<br>and one empty string<br>Ans=16+8+4+2+1=31</p>\n</blockquote>\n<h3 id=\"Quiz-2\"><a href=\"#Quiz-2\" class=\"headerlink\" title=\"Quiz 2\"></a>Quiz 2</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>This is a priority ordering, we should check the list from the beginning to the end.<br>We also have to choose the <strong>Maximal Munch</strong></p>\n</blockquote>\n<h3 id=\"Quiz-3\"><a href=\"#Quiz-3\" class=\"headerlink\" title=\"Quiz 3\"></a>Quiz 3</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p><strong>Maximal Munch</strong>: both rule 3 and 4 match the whole string<br>But the rule 3 has a higher priority.</p>\n</blockquote>\n<h3 id=\"Quiz-4\"><a href=\"#Quiz-4\" class=\"headerlink\" title=\"Quiz 4\"></a>Quiz 4</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-5\"><a href=\"#Quiz-5\" class=\"headerlink\" title=\"Quiz 5\"></a>Quiz 5</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We need n states to culculate the number of 0 and 2n states to culculate the number of 1<br>n+2n+1(start state)=3n+1</p>\n</blockquote>\n<h3 id=\"Quiz-6\"><a href=\"#Quiz-6\" class=\"headerlink\" title=\"Quiz 6\"></a>Quiz 6</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-7\"><a href=\"#Quiz-7\" class=\"headerlink\" title=\"Quiz 7\"></a>Quiz 7</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-8\"><a href=\"#Quiz-8\" class=\"headerlink\" title=\"Quiz 8\"></a>Quiz 8</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>b<em>(ab)</em> -&gt; abab match better than a(ba)*</p>\n</blockquote>\n<h3 id=\"Quiz-9\"><a href=\"#Quiz-9\" class=\"headerlink\" title=\"Quiz 9\"></a>Quiz 9</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-10\"><a href=\"#Quiz-10\" class=\"headerlink\" title=\"Quiz 10\"></a>Quiz 10</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>“11” and “1”</p>\n<h3 id=\"Quiz-11\"><a href=\"#Quiz-11\" class=\"headerlink\" title=\"Quiz 11\"></a>Quiz 11</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim\" alt=\"mark\"></p>\n<p>DFAs must have finite states, no ϵ-moves, and one transition per input per state.<br>The last option has infinite states.</p>\n</blockquote>\n<h3 id=\"Quiz-12\"><a href=\"#Quiz-12\" class=\"headerlink\" title=\"Quiz 12\"></a>Quiz 12</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim\" alt=\"mark\"></p>\n<blockquote>\n<p>NFAs must have a finite set of states, which rules out the last option. <strong>Every DFA is also an NFA</strong>, which is why the first option is included.</p>\n</blockquote>"},{"layout":"post","title":"C++大作业 Cyclooctane 2.0","date":"2017-08-27T16:00:00.000Z","comments":1,"_content":"\n游戏名：Cyclooctane 2.0\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途： C++大作业\n语言：C++\n代码量：5.0k+\n开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17->2017/08/28\n推荐分辨率：1920*1080\n\n=============================================\n\n## 写在前面的话\n\nC++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。\n本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。\n\n<!-- more -->\n\n绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。\n优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A*用二叉堆优化甚至升级用 D*等等。\n游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。\n这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。\n商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。\n此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。\n\n## 游戏概述：\n\n```\n陷入黑暗的勇者被迫进行轮回的战斗\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG)\n\n### 游戏介绍：\n\n> 房间内不断有怪物随机生成来袭击玩家。\n>\n> 在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能\n>\n> 每闯一定数目关卡有升级或切换技能机会\n>\n> 每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG)\n\n### 地形：\n\n地形分**地刺**和**岩石**\n\n#### 地刺\n\n分为间歇型地刺和永久型地刺\n地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）\n\n#### 岩石\n\n岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光\n\n### 怪物系统：\n\n怪物血量以**边数**进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n\n### 皮肤系统：\n\n共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG)\n\n### 金钱系统：\n\n金钱分为**魂**和**金币**两种\n\n#### 魂：\n\n当局存在\n获得方式：击杀怪物（不同方式、不同怪物获得的量不同）\n用途：商店内购买属性或购买、切换技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG)\n\n#### 金币：\n\n永久存在\n获得方式：通过房间\n用途：解锁皮肤或重新抽取初始技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG)\n\n### 技能介绍：\n\n#### 0：普通旋转\n\n玩家无法获得，门开后自动获得\n可旋转地图（墙壁和所有障碍物）\n旋转击杀的怪物获得额外的魂奖励\n\n#### 1：子弹\n\n可连续发射\n有限射程\n对怪物造成一点伤害\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG)\n\n#### 2：清场旋转\n\n切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。\n清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。\n切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。\n\n#### 3：穿透激光\n\n可连续发射\n有限射程\n对击中的所有怪物造成2点伤害\n碰到墙壁反弹。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG)\n\n#### 4：即死激光\n\n可连续发射\n有限射程\n立刻秒杀击中的怪物\n但是会被怪物反弹\n碰到墙壁或岩石反弹\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG)\n\n#### 5：爆弹\n\n不可连续发射\n有限射程\n达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG)\n\n#### 6：食弹\n\n自由操控悬浮子弹\n无限射程\n会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家\n体积越小速度越快\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG)\n\n### 游戏特色：\n\n1. 基础图形学函数\n2. 基于分离轴原理的碰撞检测\n3. 基于A*的怪物自动寻路算法\n4. 利用有限状态机实现游戏状态转移\n5. 存取档DES加密解密算法\n6. 6种特色攻击方式，抽技能机制，皮肤解锁机制\n7. 局部更新+双缓冲绘图\n8. 特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：切换技能\nESC：游戏中暂停、退出升级、返回\nEnter：确定\n\n```\n\n### 设计细节\n\n1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。\n2 - 每次开启游戏自动读取存档\n3 - 存档无法使用时会弹出异常并删除存档\n4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能\n5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。\n6 - **更换的第一技能会保存**。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转\n7 - 技能射程恒定：\n\n> 1: 20 3: 500 4: 550 5: 15\n\n8 - 技能速度恒定(除了食弹)\n\n> 1,5: 15 6: 22\n\n9 - 怪物击杀获得魂：\n\n> 普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3\n>\n> 清场击杀： 普通怪物+0，精英怪+0\n>\n> 旋转击杀： 普通怪物+2，精英怪+5\n>\n> 碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10\n\n### 完整实现\n\n[完整代码](https://github.com/zedom1/Cyclooctane-2)\n[游戏exe下载](https://pan.baidu.com/s/1migK4Fe)","source":"_posts/Cyclooctane 2.md","raw":"\n---\nlayout: post\ntitle: \"C++大作业 Cyclooctane 2.0\"\ndate: 2017-08-28\ncomments: true\ntags: \n\t- 游戏\n\t- c++\n---\n\n游戏名：Cyclooctane 2.0\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途： C++大作业\n语言：C++\n代码量：5.0k+\n开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17->2017/08/28\n推荐分辨率：1920*1080\n\n=============================================\n\n## 写在前面的话\n\nC++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。\n本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。\n\n<!-- more -->\n\n绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。\n优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A*用二叉堆优化甚至升级用 D*等等。\n游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。\n这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。\n商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。\n此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。\n\n## 游戏概述：\n\n```\n陷入黑暗的勇者被迫进行轮回的战斗\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG)\n\n### 游戏介绍：\n\n> 房间内不断有怪物随机生成来袭击玩家。\n>\n> 在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能\n>\n> 每闯一定数目关卡有升级或切换技能机会\n>\n> 每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG)\n\n### 地形：\n\n地形分**地刺**和**岩石**\n\n#### 地刺\n\n分为间歇型地刺和永久型地刺\n地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）\n\n#### 岩石\n\n岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光\n\n### 怪物系统：\n\n怪物血量以**边数**进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n\n### 皮肤系统：\n\n共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG)\n\n### 金钱系统：\n\n金钱分为**魂**和**金币**两种\n\n#### 魂：\n\n当局存在\n获得方式：击杀怪物（不同方式、不同怪物获得的量不同）\n用途：商店内购买属性或购买、切换技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG)\n\n#### 金币：\n\n永久存在\n获得方式：通过房间\n用途：解锁皮肤或重新抽取初始技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG)\n\n### 技能介绍：\n\n#### 0：普通旋转\n\n玩家无法获得，门开后自动获得\n可旋转地图（墙壁和所有障碍物）\n旋转击杀的怪物获得额外的魂奖励\n\n#### 1：子弹\n\n可连续发射\n有限射程\n对怪物造成一点伤害\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG)\n\n#### 2：清场旋转\n\n切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。\n清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。\n切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。\n\n#### 3：穿透激光\n\n可连续发射\n有限射程\n对击中的所有怪物造成2点伤害\n碰到墙壁反弹。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG)\n\n#### 4：即死激光\n\n可连续发射\n有限射程\n立刻秒杀击中的怪物\n但是会被怪物反弹\n碰到墙壁或岩石反弹\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG)\n\n#### 5：爆弹\n\n不可连续发射\n有限射程\n达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG)\n\n#### 6：食弹\n\n自由操控悬浮子弹\n无限射程\n会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家\n体积越小速度越快\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG)\n\n### 游戏特色：\n\n1. 基础图形学函数\n2. 基于分离轴原理的碰撞检测\n3. 基于A*的怪物自动寻路算法\n4. 利用有限状态机实现游戏状态转移\n5. 存取档DES加密解密算法\n6. 6种特色攻击方式，抽技能机制，皮肤解锁机制\n7. 局部更新+双缓冲绘图\n8. 特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：切换技能\nESC：游戏中暂停、退出升级、返回\nEnter：确定\n\n```\n\n### 设计细节\n\n1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。\n2 - 每次开启游戏自动读取存档\n3 - 存档无法使用时会弹出异常并删除存档\n4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能\n5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。\n6 - **更换的第一技能会保存**。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转\n7 - 技能射程恒定：\n\n> 1: 20 3: 500 4: 550 5: 15\n\n8 - 技能速度恒定(除了食弹)\n\n> 1,5: 15 6: 22\n\n9 - 怪物击杀获得魂：\n\n> 普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3\n>\n> 清场击杀： 普通怪物+0，精英怪+0\n>\n> 旋转击杀： 普通怪物+2，精英怪+5\n>\n> 碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10\n\n### 完整实现\n\n[完整代码](https://github.com/zedom1/Cyclooctane-2)\n[游戏exe下载](https://pan.baidu.com/s/1migK4Fe)","slug":"Cyclooctane 2","published":1,"updated":"2018-05-25T12:41:12.071Z","photos":[],"link":"","_id":"cjleshqj20003ryfcz6bhohfr","content":"<p>游戏名：Cyclooctane 2.0<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途： C++大作业<br>语言：C++<br>代码量：5.0k+<br>开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17-&gt;2017/08/28<br>推荐分辨率：1920*1080</p>\n<p>=============================================</p>\n<h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>C++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。<br>本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。</p>\n<a id=\"more\"></a>\n<p>绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。<br>优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A<em>用二叉堆优化甚至升级用 D</em>等等。<br>游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。<br>这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。<br>商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。<br>此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">陷入黑暗的勇者被迫进行轮回的战斗</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内不断有怪物随机生成来袭击玩家。</p>\n<p>在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能</p>\n<p>每闯一定数目关卡有升级或切换技能机会</p>\n<p>每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG\" alt=\"mark\"></p>\n<h3 id=\"地形：\"><a href=\"#地形：\" class=\"headerlink\" title=\"地形：\"></a>地形：</h3><p>地形分<strong>地刺</strong>和<strong>岩石</strong></p>\n<h4 id=\"地刺\"><a href=\"#地刺\" class=\"headerlink\" title=\"地刺\"></a>地刺</h4><p>分为间歇型地刺和永久型地刺<br>地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）</p>\n<h4 id=\"岩石\"><a href=\"#岩石\" class=\"headerlink\" title=\"岩石\"></a>岩石</h4><p>岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光</p>\n<h3 id=\"怪物系统：\"><a href=\"#怪物系统：\" class=\"headerlink\" title=\"怪物系统：\"></a>怪物系统：</h3><p>怪物血量以<strong>边数</strong>进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积</p>\n<h3 id=\"皮肤系统：\"><a href=\"#皮肤系统：\" class=\"headerlink\" title=\"皮肤系统：\"></a>皮肤系统：</h3><p>共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG\" alt=\"mark\"></p>\n<h3 id=\"金钱系统：\"><a href=\"#金钱系统：\" class=\"headerlink\" title=\"金钱系统：\"></a>金钱系统：</h3><p>金钱分为<strong>魂</strong>和<strong>金币</strong>两种</p>\n<h4 id=\"魂：\"><a href=\"#魂：\" class=\"headerlink\" title=\"魂：\"></a>魂：</h4><p>当局存在<br>获得方式：击杀怪物（不同方式、不同怪物获得的量不同）<br>用途：商店内购买属性或购买、切换技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG\" alt=\"mark\"></p>\n<h4 id=\"金币：\"><a href=\"#金币：\" class=\"headerlink\" title=\"金币：\"></a>金币：</h4><p>永久存在<br>获得方式：通过房间<br>用途：解锁皮肤或重新抽取初始技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG\" alt=\"mark\"></p>\n<h3 id=\"技能介绍：\"><a href=\"#技能介绍：\" class=\"headerlink\" title=\"技能介绍：\"></a>技能介绍：</h3><h4 id=\"0：普通旋转\"><a href=\"#0：普通旋转\" class=\"headerlink\" title=\"0：普通旋转\"></a>0：普通旋转</h4><p>玩家无法获得，门开后自动获得<br>可旋转地图（墙壁和所有障碍物）<br>旋转击杀的怪物获得额外的魂奖励</p>\n<h4 id=\"1：子弹\"><a href=\"#1：子弹\" class=\"headerlink\" title=\"1：子弹\"></a>1：子弹</h4><p>可连续发射<br>有限射程<br>对怪物造成一点伤害<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG\" alt=\"mark\"></p>\n<h4 id=\"2：清场旋转\"><a href=\"#2：清场旋转\" class=\"headerlink\" title=\"2：清场旋转\"></a>2：清场旋转</h4><p>切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。<br>清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。<br>切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。</p>\n<h4 id=\"3：穿透激光\"><a href=\"#3：穿透激光\" class=\"headerlink\" title=\"3：穿透激光\"></a>3：穿透激光</h4><p>可连续发射<br>有限射程<br>对击中的所有怪物造成2点伤害<br>碰到墙壁反弹。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG\" alt=\"mark\"></p>\n<h4 id=\"4：即死激光\"><a href=\"#4：即死激光\" class=\"headerlink\" title=\"4：即死激光\"></a>4：即死激光</h4><p>可连续发射<br>有限射程<br>立刻秒杀击中的怪物<br>但是会被怪物反弹<br>碰到墙壁或岩石反弹<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG\" alt=\"mark\"></p>\n<h4 id=\"5：爆弹\"><a href=\"#5：爆弹\" class=\"headerlink\" title=\"5：爆弹\"></a>5：爆弹</h4><p>不可连续发射<br>有限射程<br>达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG\" alt=\"mark\"></p>\n<h4 id=\"6：食弹\"><a href=\"#6：食弹\" class=\"headerlink\" title=\"6：食弹\"></a>6：食弹</h4><p>自由操控悬浮子弹<br>无限射程<br>会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家<br>体积越小速度越快<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><ol>\n<li>基础图形学函数</li>\n<li>基于分离轴原理的碰撞检测</li>\n<li>基于A*的怪物自动寻路算法</li>\n<li>利用有限状态机实现游戏状态转移</li>\n<li>存取档DES加密解密算法</li>\n<li>6种特色攻击方式，抽技能机制，皮肤解锁机制</li>\n<li>局部更新+双缓冲绘图</li>\n<li>特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权</li>\n</ol>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：切换技能</span><br><span class=\"line\">ESC：游戏中暂停、退出升级、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<h3 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h3><p>1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。<br>2 - 每次开启游戏自动读取存档<br>3 - 存档无法使用时会弹出异常并删除存档<br>4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能<br>5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。<br>6 - <strong>更换的第一技能会保存</strong>。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转<br>7 - 技能射程恒定：</p>\n<blockquote>\n<p>1: 20 3: 500 4: 550 5: 15</p>\n</blockquote>\n<p>8 - 技能速度恒定(除了食弹)</p>\n<blockquote>\n<p>1,5: 15 6: 22</p>\n</blockquote>\n<p>9 - 怪物击杀获得魂：</p>\n<blockquote>\n<p>普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3</p>\n<p>清场击杀： 普通怪物+0，精英怪+0</p>\n<p>旋转击杀： 普通怪物+2，精英怪+5</p>\n<p>碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10</p>\n</blockquote>\n<h3 id=\"完整实现\"><a href=\"#完整实现\" class=\"headerlink\" title=\"完整实现\"></a>完整实现</h3><p><a href=\"https://github.com/zedom1/Cyclooctane-2\" target=\"_blank\" rel=\"noopener\">完整代码</a><br><a href=\"https://pan.baidu.com/s/1migK4Fe\" target=\"_blank\" rel=\"noopener\">游戏exe下载</a></p>\n","site":{"data":{}},"excerpt":"<p>游戏名：Cyclooctane 2.0<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途： C++大作业<br>语言：C++<br>代码量：5.0k+<br>开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17-&gt;2017/08/28<br>推荐分辨率：1920*1080</p>\n<p>=============================================</p>\n<h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>C++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。<br>本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。</p>","more":"<p>绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。<br>优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A<em>用二叉堆优化甚至升级用 D</em>等等。<br>游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。<br>这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。<br>商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。<br>此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">陷入黑暗的勇者被迫进行轮回的战斗</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内不断有怪物随机生成来袭击玩家。</p>\n<p>在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能</p>\n<p>每闯一定数目关卡有升级或切换技能机会</p>\n<p>每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG\" alt=\"mark\"></p>\n<h3 id=\"地形：\"><a href=\"#地形：\" class=\"headerlink\" title=\"地形：\"></a>地形：</h3><p>地形分<strong>地刺</strong>和<strong>岩石</strong></p>\n<h4 id=\"地刺\"><a href=\"#地刺\" class=\"headerlink\" title=\"地刺\"></a>地刺</h4><p>分为间歇型地刺和永久型地刺<br>地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）</p>\n<h4 id=\"岩石\"><a href=\"#岩石\" class=\"headerlink\" title=\"岩石\"></a>岩石</h4><p>岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光</p>\n<h3 id=\"怪物系统：\"><a href=\"#怪物系统：\" class=\"headerlink\" title=\"怪物系统：\"></a>怪物系统：</h3><p>怪物血量以<strong>边数</strong>进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积</p>\n<h3 id=\"皮肤系统：\"><a href=\"#皮肤系统：\" class=\"headerlink\" title=\"皮肤系统：\"></a>皮肤系统：</h3><p>共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG\" alt=\"mark\"></p>\n<h3 id=\"金钱系统：\"><a href=\"#金钱系统：\" class=\"headerlink\" title=\"金钱系统：\"></a>金钱系统：</h3><p>金钱分为<strong>魂</strong>和<strong>金币</strong>两种</p>\n<h4 id=\"魂：\"><a href=\"#魂：\" class=\"headerlink\" title=\"魂：\"></a>魂：</h4><p>当局存在<br>获得方式：击杀怪物（不同方式、不同怪物获得的量不同）<br>用途：商店内购买属性或购买、切换技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG\" alt=\"mark\"></p>\n<h4 id=\"金币：\"><a href=\"#金币：\" class=\"headerlink\" title=\"金币：\"></a>金币：</h4><p>永久存在<br>获得方式：通过房间<br>用途：解锁皮肤或重新抽取初始技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG\" alt=\"mark\"></p>\n<h3 id=\"技能介绍：\"><a href=\"#技能介绍：\" class=\"headerlink\" title=\"技能介绍：\"></a>技能介绍：</h3><h4 id=\"0：普通旋转\"><a href=\"#0：普通旋转\" class=\"headerlink\" title=\"0：普通旋转\"></a>0：普通旋转</h4><p>玩家无法获得，门开后自动获得<br>可旋转地图（墙壁和所有障碍物）<br>旋转击杀的怪物获得额外的魂奖励</p>\n<h4 id=\"1：子弹\"><a href=\"#1：子弹\" class=\"headerlink\" title=\"1：子弹\"></a>1：子弹</h4><p>可连续发射<br>有限射程<br>对怪物造成一点伤害<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG\" alt=\"mark\"></p>\n<h4 id=\"2：清场旋转\"><a href=\"#2：清场旋转\" class=\"headerlink\" title=\"2：清场旋转\"></a>2：清场旋转</h4><p>切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。<br>清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。<br>切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。</p>\n<h4 id=\"3：穿透激光\"><a href=\"#3：穿透激光\" class=\"headerlink\" title=\"3：穿透激光\"></a>3：穿透激光</h4><p>可连续发射<br>有限射程<br>对击中的所有怪物造成2点伤害<br>碰到墙壁反弹。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG\" alt=\"mark\"></p>\n<h4 id=\"4：即死激光\"><a href=\"#4：即死激光\" class=\"headerlink\" title=\"4：即死激光\"></a>4：即死激光</h4><p>可连续发射<br>有限射程<br>立刻秒杀击中的怪物<br>但是会被怪物反弹<br>碰到墙壁或岩石反弹<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG\" alt=\"mark\"></p>\n<h4 id=\"5：爆弹\"><a href=\"#5：爆弹\" class=\"headerlink\" title=\"5：爆弹\"></a>5：爆弹</h4><p>不可连续发射<br>有限射程<br>达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG\" alt=\"mark\"></p>\n<h4 id=\"6：食弹\"><a href=\"#6：食弹\" class=\"headerlink\" title=\"6：食弹\"></a>6：食弹</h4><p>自由操控悬浮子弹<br>无限射程<br>会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家<br>体积越小速度越快<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><ol>\n<li>基础图形学函数</li>\n<li>基于分离轴原理的碰撞检测</li>\n<li>基于A*的怪物自动寻路算法</li>\n<li>利用有限状态机实现游戏状态转移</li>\n<li>存取档DES加密解密算法</li>\n<li>6种特色攻击方式，抽技能机制，皮肤解锁机制</li>\n<li>局部更新+双缓冲绘图</li>\n<li>特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权</li>\n</ol>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：切换技能</span><br><span class=\"line\">ESC：游戏中暂停、退出升级、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<h3 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h3><p>1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。<br>2 - 每次开启游戏自动读取存档<br>3 - 存档无法使用时会弹出异常并删除存档<br>4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能<br>5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。<br>6 - <strong>更换的第一技能会保存</strong>。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转<br>7 - 技能射程恒定：</p>\n<blockquote>\n<p>1: 20 3: 500 4: 550 5: 15</p>\n</blockquote>\n<p>8 - 技能速度恒定(除了食弹)</p>\n<blockquote>\n<p>1,5: 15 6: 22</p>\n</blockquote>\n<p>9 - 怪物击杀获得魂：</p>\n<blockquote>\n<p>普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3</p>\n<p>清场击杀： 普通怪物+0，精英怪+0</p>\n<p>旋转击杀： 普通怪物+2，精英怪+5</p>\n<p>碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10</p>\n</blockquote>\n<h3 id=\"完整实现\"><a href=\"#完整实现\" class=\"headerlink\" title=\"完整实现\"></a>完整实现</h3><p><a href=\"https://github.com/zedom1/Cyclooctane-2\" target=\"_blank\" rel=\"noopener\">完整代码</a><br><a href=\"https://pan.baidu.com/s/1migK4Fe\" target=\"_blank\" rel=\"noopener\">游戏exe下载</a></p>"},{"layout":"post","title":"第一个自制c++小游戏：Cyclooctane","date":"2017-05-10T16:00:00.000Z","comments":1,"_content":"\n\n游戏名：Cyclooctane\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途：黑框框比赛、C++大作业\n语言：C++\n代码量：3.6k+\n开发时间：30天，2017/04/11->2017/05/10\n推荐分辨率：1920*1080\n=============================================\n\n## 写在前面的话\n\n2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。\n\n<!-- more -->\n\n游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。\n之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。\n绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。\n游戏里的基本算法有碰撞检测、A*、快速排序等\n游戏整体框架和状态转移用基于虚继承的有限状态机\n其它包括基础图形学函数还有一些公式也是自行实现与推演的。\n游戏比较简陋，希望各位莫见笑。\n\n## 游戏概述：\n\n陷入黑暗的勇者被迫进行轮回的战斗\n\n### 游戏介绍：\n\n> 房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）\n>\n> 在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 每闯一定数目关卡有升级或切换人物机会\n>\n> 地形分地刺和岩石，地刺有间歇型地刺和永久型地刺\n>\n> 怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量\n>\n> 为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim)\n\n### 游戏特色：\n\n```\n1.自行实现的基础计算机图形学函数\n2.未使用第三方图形库、游戏引擎、STL\n3.三个主角，6种特色攻击方式\n4.无限挑战模式, 狩猎角色变更玩法\n5.人物升级、更换系统\n6.基于分离轴原理的碰撞检测\n7.局部更新绘图\n8.利用有限状态机实现的游戏状态转移\n9.存读档系统\n10.基于游戏特性而作改动的A*寻路算法\n\n```\n\n### 角色介绍：\n\n#### Benzene：（定位：灵活血厚弱攻击型）\n\n普通攻击为发射子弹，对怪物造成1点伤害\n大招为立即消灭此时出现的所有怪物并获得旋转地图能力\n无法自由切换普通攻击和大招，作为补偿大招无CD\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim)\n\n#### Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\n\n形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力\n形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射\n形态三为旋转地图能力\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim)\n\n#### Pyran：（定位：中规中矩稳健型）\n\n形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）\n形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim)\n\n### 怪物介绍：\n\n血量以边数进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim)\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：使用大招或切换形态\nESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回\nEnter：确定\n\n```\n\n涉及数据结构：链表、队列等\n\n涉及算法：快速排序、分离轴原理、A*、有限状态机等\n\n### 展望：\n\n```\n1.金钱系统、商店系统、地图系统、成就系统\n2.特色道具\n3.可攻击的特殊精英怪物、BOSS\n4.基于哈希函数的种子\n5.分层闯关打BOSS模式\n6.用IDA*或D*或导航网格优化寻路\n\n```\n\n## 完整代码\n\n<https://github.com/zedom1/Cyclooctane>","source":"_posts/Cyclooctane.md","raw":"---\nlayout: post\ntitle: \"第一个自制c++小游戏：Cyclooctane\"\ndate: 2017-05-11\ncomments: true\ntags: \n\t- 游戏\n\t- c++\n---\n\n\n游戏名：Cyclooctane\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途：黑框框比赛、C++大作业\n语言：C++\n代码量：3.6k+\n开发时间：30天，2017/04/11->2017/05/10\n推荐分辨率：1920*1080\n=============================================\n\n## 写在前面的话\n\n2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。\n\n<!-- more -->\n\n游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。\n之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。\n绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。\n游戏里的基本算法有碰撞检测、A*、快速排序等\n游戏整体框架和状态转移用基于虚继承的有限状态机\n其它包括基础图形学函数还有一些公式也是自行实现与推演的。\n游戏比较简陋，希望各位莫见笑。\n\n## 游戏概述：\n\n陷入黑暗的勇者被迫进行轮回的战斗\n\n### 游戏介绍：\n\n> 房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）\n>\n> 在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 每闯一定数目关卡有升级或切换人物机会\n>\n> 地形分地刺和岩石，地刺有间歇型地刺和永久型地刺\n>\n> 怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量\n>\n> 为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim)\n\n### 游戏特色：\n\n```\n1.自行实现的基础计算机图形学函数\n2.未使用第三方图形库、游戏引擎、STL\n3.三个主角，6种特色攻击方式\n4.无限挑战模式, 狩猎角色变更玩法\n5.人物升级、更换系统\n6.基于分离轴原理的碰撞检测\n7.局部更新绘图\n8.利用有限状态机实现的游戏状态转移\n9.存读档系统\n10.基于游戏特性而作改动的A*寻路算法\n\n```\n\n### 角色介绍：\n\n#### Benzene：（定位：灵活血厚弱攻击型）\n\n普通攻击为发射子弹，对怪物造成1点伤害\n大招为立即消灭此时出现的所有怪物并获得旋转地图能力\n无法自由切换普通攻击和大招，作为补偿大招无CD\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim)\n\n#### Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\n\n形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力\n形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射\n形态三为旋转地图能力\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim)\n\n#### Pyran：（定位：中规中矩稳健型）\n\n形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）\n形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim)\n\n### 怪物介绍：\n\n血量以边数进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim)\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：使用大招或切换形态\nESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回\nEnter：确定\n\n```\n\n涉及数据结构：链表、队列等\n\n涉及算法：快速排序、分离轴原理、A*、有限状态机等\n\n### 展望：\n\n```\n1.金钱系统、商店系统、地图系统、成就系统\n2.特色道具\n3.可攻击的特殊精英怪物、BOSS\n4.基于哈希函数的种子\n5.分层闯关打BOSS模式\n6.用IDA*或D*或导航网格优化寻路\n\n```\n\n## 完整代码\n\n<https://github.com/zedom1/Cyclooctane>","slug":"Cyclooctane","published":1,"updated":"2018-05-25T12:41:11.994Z","photos":[],"link":"","_id":"cjleshqj30004ryfcvv4cs901","content":"<p>游戏名：Cyclooctane<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途：黑框框比赛、C++大作业<br>语言：C++<br>代码量：3.6k+<br>开发时间：30天，2017/04/11-&gt;2017/05/10</p>\n<h1 id=\"推荐分辨率：1920-1080\"><a href=\"#推荐分辨率：1920-1080\" class=\"headerlink\" title=\"推荐分辨率：1920*1080\"></a>推荐分辨率：1920*1080</h1><h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。</p>\n<a id=\"more\"></a>\n<p>游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。<br>之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。<br>绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。<br>游戏里的基本算法有碰撞检测、A*、快速排序等<br>游戏整体框架和状态转移用基于虚继承的有限状态机<br>其它包括基础图形学函数还有一些公式也是自行实现与推演的。<br>游戏比较简陋，希望各位莫见笑。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><p>陷入黑暗的勇者被迫进行轮回的战斗</p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）</p>\n<p>在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>每闯一定数目关卡有升级或切换人物机会</p>\n<p>地形分地刺和岩石，地刺有间歇型地刺和永久型地刺</p>\n<p>怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量</p>\n<p>为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.自行实现的基础计算机图形学函数</span><br><span class=\"line\">2.未使用第三方图形库、游戏引擎、STL</span><br><span class=\"line\">3.三个主角，6种特色攻击方式</span><br><span class=\"line\">4.无限挑战模式, 狩猎角色变更玩法</span><br><span class=\"line\">5.人物升级、更换系统</span><br><span class=\"line\">6.基于分离轴原理的碰撞检测</span><br><span class=\"line\">7.局部更新绘图</span><br><span class=\"line\">8.利用有限状态机实现的游戏状态转移</span><br><span class=\"line\">9.存读档系统</span><br><span class=\"line\">10.基于游戏特性而作改动的A*寻路算法</span><br></pre></td></tr></table></figure>\n<h3 id=\"角色介绍：\"><a href=\"#角色介绍：\" class=\"headerlink\" title=\"角色介绍：\"></a>角色介绍：</h3><h4 id=\"Benzene：（定位：灵活血厚弱攻击型）\"><a href=\"#Benzene：（定位：灵活血厚弱攻击型）\" class=\"headerlink\" title=\"Benzene：（定位：灵活血厚弱攻击型）\"></a>Benzene：（定位：灵活血厚弱攻击型）</h4><p>普通攻击为发射子弹，对怪物造成1点伤害<br>大招为立即消灭此时出现的所有怪物并获得旋转地图能力<br>无法自由切换普通攻击和大招，作为补偿大招无CD<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"><a href=\"#Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\" class=\"headerlink\" title=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"></a>Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）</h4><p>形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力<br>形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射<br>形态三为旋转地图能力<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Pyran：（定位：中规中矩稳健型）\"><a href=\"#Pyran：（定位：中规中矩稳健型）\" class=\"headerlink\" title=\"Pyran：（定位：中规中矩稳健型）\"></a>Pyran：（定位：中规中矩稳健型）</h4><p>形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）<br>形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"怪物介绍：\"><a href=\"#怪物介绍：\" class=\"headerlink\" title=\"怪物介绍：\"></a>怪物介绍：</h3><p>血量以边数进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：使用大招或切换形态</span><br><span class=\"line\">ESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<p>涉及数据结构：链表、队列等</p>\n<p>涉及算法：快速排序、分离轴原理、A*、有限状态机等</p>\n<h3 id=\"展望：\"><a href=\"#展望：\" class=\"headerlink\" title=\"展望：\"></a>展望：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.金钱系统、商店系统、地图系统、成就系统</span><br><span class=\"line\">2.特色道具</span><br><span class=\"line\">3.可攻击的特殊精英怪物、BOSS</span><br><span class=\"line\">4.基于哈希函数的种子</span><br><span class=\"line\">5.分层闯关打BOSS模式</span><br><span class=\"line\">6.用IDA*或D*或导航网格优化寻路</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/zedom1/Cyclooctane\" target=\"_blank\" rel=\"noopener\">https://github.com/zedom1/Cyclooctane</a></p>\n","site":{"data":{}},"excerpt":"<p>游戏名：Cyclooctane<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途：黑框框比赛、C++大作业<br>语言：C++<br>代码量：3.6k+<br>开发时间：30天，2017/04/11-&gt;2017/05/10</p>\n<h1 id=\"推荐分辨率：1920-1080\"><a href=\"#推荐分辨率：1920-1080\" class=\"headerlink\" title=\"推荐分辨率：1920*1080\"></a>推荐分辨率：1920*1080</h1><h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。</p>","more":"<p>游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。<br>之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。<br>绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。<br>游戏里的基本算法有碰撞检测、A*、快速排序等<br>游戏整体框架和状态转移用基于虚继承的有限状态机<br>其它包括基础图形学函数还有一些公式也是自行实现与推演的。<br>游戏比较简陋，希望各位莫见笑。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><p>陷入黑暗的勇者被迫进行轮回的战斗</p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）</p>\n<p>在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>每闯一定数目关卡有升级或切换人物机会</p>\n<p>地形分地刺和岩石，地刺有间歇型地刺和永久型地刺</p>\n<p>怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量</p>\n<p>为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.自行实现的基础计算机图形学函数</span><br><span class=\"line\">2.未使用第三方图形库、游戏引擎、STL</span><br><span class=\"line\">3.三个主角，6种特色攻击方式</span><br><span class=\"line\">4.无限挑战模式, 狩猎角色变更玩法</span><br><span class=\"line\">5.人物升级、更换系统</span><br><span class=\"line\">6.基于分离轴原理的碰撞检测</span><br><span class=\"line\">7.局部更新绘图</span><br><span class=\"line\">8.利用有限状态机实现的游戏状态转移</span><br><span class=\"line\">9.存读档系统</span><br><span class=\"line\">10.基于游戏特性而作改动的A*寻路算法</span><br></pre></td></tr></table></figure>\n<h3 id=\"角色介绍：\"><a href=\"#角色介绍：\" class=\"headerlink\" title=\"角色介绍：\"></a>角色介绍：</h3><h4 id=\"Benzene：（定位：灵活血厚弱攻击型）\"><a href=\"#Benzene：（定位：灵活血厚弱攻击型）\" class=\"headerlink\" title=\"Benzene：（定位：灵活血厚弱攻击型）\"></a>Benzene：（定位：灵活血厚弱攻击型）</h4><p>普通攻击为发射子弹，对怪物造成1点伤害<br>大招为立即消灭此时出现的所有怪物并获得旋转地图能力<br>无法自由切换普通攻击和大招，作为补偿大招无CD<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"><a href=\"#Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\" class=\"headerlink\" title=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"></a>Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）</h4><p>形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力<br>形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射<br>形态三为旋转地图能力<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Pyran：（定位：中规中矩稳健型）\"><a href=\"#Pyran：（定位：中规中矩稳健型）\" class=\"headerlink\" title=\"Pyran：（定位：中规中矩稳健型）\"></a>Pyran：（定位：中规中矩稳健型）</h4><p>形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）<br>形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"怪物介绍：\"><a href=\"#怪物介绍：\" class=\"headerlink\" title=\"怪物介绍：\"></a>怪物介绍：</h3><p>血量以边数进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：使用大招或切换形态</span><br><span class=\"line\">ESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<p>涉及数据结构：链表、队列等</p>\n<p>涉及算法：快速排序、分离轴原理、A*、有限状态机等</p>\n<h3 id=\"展望：\"><a href=\"#展望：\" class=\"headerlink\" title=\"展望：\"></a>展望：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.金钱系统、商店系统、地图系统、成就系统</span><br><span class=\"line\">2.特色道具</span><br><span class=\"line\">3.可攻击的特殊精英怪物、BOSS</span><br><span class=\"line\">4.基于哈希函数的种子</span><br><span class=\"line\">5.分层闯关打BOSS模式</span><br><span class=\"line\">6.用IDA*或D*或导航网格优化寻路</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/zedom1/Cyclooctane\" target=\"_blank\" rel=\"noopener\">https://github.com/zedom1/Cyclooctane</a></p>"},{"layout":"post","title":"数据结构笔记（四）：图","date":"2017-08-18T16:00:00.000Z","comments":1,"_content":"\n\n## **概念**\n\n什么是图(Graph)：\n表示多对多的关系\n包含\n一组顶点：通常用V(Vertex)表示顶点集合\n一组边：通常用E(Edge)表示边的集合\n边是顶点对\n无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V\n有向边 表示从v指向w的边\n不考虑重边和自回路\n\n<!-- more -->\n\n此前学过的树、线性序列，均可视作图的**特例**。\n在线性序列中，只有直接前驱和后继有邻接关系\n在树中，只有父节点和子节点之间定义邻接关系\n\n![序列、树、图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim)\n\n**分类：**\n1.**无向图(undigraph)**：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)\n2.**有向图(digraph)**：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u->v 即 (u,v) u为尾(tail)，v为头(head)\n3.**混合图**：邻接关系中有的与次序有关，有的与次序无关\n4.**网络(network)**：边有权重\n\n以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。\n\n![分类图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim)\n\n概念：\n\n- **路径 **：\n\n  定义：顶点按依次邻接的关系连成的序列\n  简单路径：不含重复节点的路径\n  一般路径：可能含重复节点\n  环路：起点和终点重合\n\n  - **彼此邻接**：\n    彼此间存在边的两个顶点\n\n  - **连通**：\n    若v到w存在一条路径，则称v和w是连通的\n    强连通：\n\n    ```\n    有向图中v和w存在双向路径\n\n    ```\n\n    **连通分量**：\n\n    ```\n    无向图的**极大**连通子图\n        极大顶点数：再加1个顶点就不连通\n        极大边数：包含子图中所有顶点相连的所有边\n    **强连通分量**：\n        有向图的极大强连通子图\n\n    ```\n\n    **连通图**：\n\n    ```\n    图中任意两顶点均连通\n    **强连通图**：\n        有向图中所有顶点都是强连通\n\n    ```\n\n  - **有向无环图**(directed acyclic graph DAG)：\n    图为有向图且不包含任何环路\n\n  - **欧拉环路**：\n    经过所有边且恰好只经过所有边一次的环路\n\n  - **哈密尔顿环路**：\n    经过所有节点且只经过所有点一次\n\n  - **简单图**：\n    所有节点均不含自环的图\n\n## 抽象数据类型定义\n\n名称： 图 Graph\n数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成\n操作集：\n\n```\n- Graph Create();\n    建立并返回空图\n- Graph InsertVertex(Graph G, Vertex v);\n    把顶点V插入G\n- Graph InsertEdge(Graph G, Edge e);\n    把顶点E插入G    \n- void DFS(Graph G , Vertex v);\n    从v出发深度优先遍历G\n- void BFS(Graph G , Vertex v);\n    从v出发广度优先遍历G\n- void ShortestPath(Graph G , Vertex v, int Dist[]);\n    计算图G中顶点v到任意其它顶点的最短距离\n- void MST(Graph G);\n    计算图G的最小生成树\n\n```\n\n## 表示\n\n### 邻接矩阵\n\n邻接矩阵：G[N][N]——N个顶点从0到N-1编号\n\n```\n- G[i][j]=1 <vi,vj>是边\n- G[i][j]=0 <vi,vj>不是边\n\n```\n\n优点\n\n```\n- 方便、直观\n- 方便检查任意一对顶点间是否有边\n- 方便找任一顶点所有邻接点\n- 方便计算任一顶点的度\n    入度：指向该点的边数\n    出度：从该点发出的边数\n\n```\n\n缺点\n\n```\n- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素\n- 浪费时间，统计稀疏图中共多少条边\n\n```\n\n基本定义与建图：\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct Graph\n{\n\tVertex vertex[MaxSize];      // 顶点表\n\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表\n\tint n , e;                   // 顶点总数和边总数\n\tGraphType type;\n};\n\nvoid CreateGraph ( Graph * g)\n{\n\tg->type = UN;\n\tint i,j,w;\n\tscanf(\"%d%d\",&g->n,&g->e);   // 顶点数和边数\n\tfor( i=0; i<g->n; i++ )\n\t\tscanf(\"%c\",&(g->vertex[i]));\n\tfor( i=0; i<g->n ; i++ )     // 初始化\n\t\tfor( j=0; j<g->n ; j++ )\n\t\t\tg->edge[i][j]=INF;\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d%d%d\",&i,&j,&w);  // 输入e条边的权值\n\t\tg->edge[i][j]=w;\n\t\tg->edge[j][i]=w;\n\t}\n}\n```\n\n### 邻接表\n\n邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素\n优点：\n\n```\n- 方便找任一顶点的所有邻接点\n- 节约稀疏图的空间\n    需要N个头指针，2E个结点（每个节点至少两个域）\n    E < n(n-1)/4 时省空间\n- 方便计算无向图的度\n    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）\n\n```\n\n基本定义与实现\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct ENode\n{\n\tint adjv;    // 指向顶点的序号\n\tENode * next;\n\tint weight;\n};\n\nstruct VNode\n{\n\tVertex vertex;\n\tENode *firstEdge;\n};\n\nstruct Graph\n{\n\tVNode nodeList[MaxSize];\n\tint n,e;\n\tGraphType type;\n};\n\nvoid CreateGraph( Graph *g )\n{\n\tint i,j;\n\tENode *edge;\n\tg->type = DG;\n\tscanf(\"%d%d\",&(g->n),&(g->e));\n\tfor( i=0 ; i<g->n ; i++)\n\t{\n\t\tscanf(\"%c\",&(g->nodeList[i].vertex));\n\t\tg->nodeList[i].firstEdge=NULL;\n\t}\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d %d\",&i,&j);\n\t\tedge = new ENode();\n\t\tedge->adjv = j;\n\t\tedge->next = g->nodeList[i].firstEdge;\n\t\tg->nodeList[i].firstEdge = edge;\n\t}\n}\n```\n\n## 遍历\n\n### 深度优先搜索 DFS (Depth First Search)\n\n相当于树的先序遍历\n\nN个顶点，E条边，时间复杂度：\n用邻接表存储时，为O(N+E)\n用邻接矩阵存储时，为O($N^2$);\n\n伪代码:\n\n```\nvoid DFS( Vertex v )\n{\n\tvisited[v]=true;\n\tfor( v的每个邻接点w )\n\t\tif(!visited[w])\n\t\t\tDFS(w);\n}\n```\n\n### 广度优先搜索 BFS (Breadth First Search)\n\n相当于树的层序遍历\n\n用**队列**实现，把起始结点加入队列后\n每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过\n\nN个顶点，E条边，时间复杂度和DFS相同：\n\n```\n- 用邻接表存储时，为O(N+E)\n- 用邻接矩阵存储时，为O($N^2$);\n\n```\n\n伪代码：\n\n```\nvoid BFS( Vertex v )\n{\n\tvisited[v]=true;\n\tqueue.enqueue(v);\n\twhile(!q.empty())\n\t{\n\t\tv=q.dequeue();\n\t\tfor( v 的每个邻接点w )\n\t\t\tif(!visited[w])\n\t\t\t{\n\t\t\t\tvisited[w]=true;\n\t\t\t\tq.enqueue(w);\n\t\t\t}\n\t}\n\n}\n```\n\nBFS适合找最优解\nDFS适合找任意一解\n\n## 最短路径\n\n定义：\n在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径\n\n```\n- 该路径就是两点之间的最短路径\n- 第一个顶点为源点\n\n```\n\n分类：\n\n```\n1. 单源最短路：\n    从某固定源点出发，求其到所有其他顶点的最短路径\n    - 无权图\n    - 有权图\n2. 多源最短路：\n    求任意两顶点之间的最短路径\n\n```\n\n### 无权图的单源最短路算法\n\n按照**递增（非递减）**的顺序找出到各个顶点的最短路\n\n伪代码\n\n```\n// dist[w] = s到w的最短距离\n// dist[s] = 0\n// path[w] = s到w路径的倒数第二个顶点\n\nvoid　Unweighted( int s )\n{\n\tqueue.enqueue(s);\n\twhile(!queue.empty())\n\t{\n\t\tv = queue.dequeue();\n\t\tfor( v的每个邻接点w )\n\t\t{\n\t\t\tif( dist[w]==-1 )\n\t\t\t{\n\t\t\t\tdist[w]=dist[v]+1;\n\t\t\t\tpath[w]=v;\n\t\t\t\tqueue.enqueue(w);\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid print(int s , int w)\n{\n\tif(path[w]==-1) return;\n\twhile(path[w]!=s)\n\t{\n\t\tstack.push(path[w]);\n\t\tw=path[w];\n\t}\n\twhile(!stack.empty())\n\t\tprintf(\"%d\\n\",stack.pop());\n}\n```\n\n时间复杂度： O( v + e )\n\n### 有权图的单源最短路算法\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG)\n\n不考虑**负值圈(negative-cost cycle)**\n\n按照递增顺序找到各个顶点的最短路： Dijkstra算法\n\n#### Dijkstra:\n\n```\n- 令 S = { 源点S + 已经确定了最短路径的顶点vi }\n- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径{s -> (vi$\\in$s) -> v}的最小长度\n- 路径按照递增（非递减）的顺序生成\n    - 真正的最短路一定只经过s中的顶点\n    - 每次从未收录的顶点中选一个dist最小的收录\n    - 增加一个v进入s，可能影响w的最小值\n        dist[w]=min(dist[w]+<v,w>);\n    - 初始化为INF\n\n```\n\n伪代码\n\n```\nvoid Dijkstra( int s )\n{\n\twhile(1)\n\t{\n\t\tv = 未收录顶点中dist最小的\n\t\tif( v 不存在 )\n\t\t\tbreak;\n\t\tcollected[v]=true;\n\t\tfor( v 的每个顶点w )\n\t\t\tif( collected[w]==false )\n\t\t\t\tif( dist[v]+E<v,w> < dist[w])\n\t\t\t\t{\n\t\t\t\t\tdist[w]=dist[v]+E<v,w>;\n\t\t\t\t\tpath[w]=v;\n\t\t\t\t}\n\t}\n}\n```\n\n时间复杂度：取决于如何找到dist最小的节点\n\n方法1： 直接扫描所有未收录节点 O(v)\nO($v^2$+e) (稠密图效果好)\n方法2： 把dist存入最小堆中 O(logv)\n更新dist[w]的值： O(logv)\nO(elogv) (稀疏图效果好)\n\n### 多源最短路\n\n方法1： 把单源最短路调用V遍 O( v3+e*v )\n\n方法2： Floyd算法 O( v3 )\n\n#### Floyd算法：\n\n```\n- D(k)[i][j] = 路径 { i -> {l<=k} -> j }的最小长度 (从i到j只经过编号<=k的顶点)\n- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离\n- 初始化D为带权值的邻接矩阵，对角元为0\n- 若i,j之间无直接边，则初始化为INF\n- 若D(k-1)已完成，递推D(k):\n    - 若k$\\notin$最短路径，则 D(K)=D(K-1)\n    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：\n        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]\n\n```\n\n伪代码：\n\n```\nvoid Floyd()\n{\n\tfor( int i=0; i<n ; i++ )\n\t\tfor( int j=0; j<n ; j++ )\n\t\t{\t\n\t\t\tD[i][j]=G[i][j]\n\t\t\tpath[i][j]=-1;\n\t\t}\n\tfor( int k=0; k<n ; k++ )\n\t\tfor( int i=0; i<n ; i++ )\n\t\t\tfor( int j=0; j<n ; j++ )\n\t\t\t\tif(D[i][k]+D[k][j]<D[i][j])\n\t\t\t\t{\t\n\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];\n\t\t\t\t\tpath[i][j]=k;\n\t\t\t\t}\n}\nvoid print( int i , int j )\n{\n\tif(i==j) return;\n\tprint(i,path[i][j]);\n\tprintf(path[i][j]);\n\tprint(path[i][j],j);\n}\n```\n\n## 最小生成树 Minimum Spanning Tree\n\n定义：\n\n```\n- 一棵树：\n    - 无回路\n    - V个顶点一定有V-1条边\n- 生成树：\n    - 包含所有顶点\n    - V-1条边都包含在图里\n    - 生成树中任加一条边都一定构成回路\n- 最小：\n    - 边的权重和最小\n\n```\n\n最小生成树存在 <=> 图连通\n\n方法：**贪心**\n\n约束条件：\n\n```\n1. 只能用图里的边\n2. 只能正好用掉V-1条边\n3. 不能有回路\n\n```\n\n### Prim算法\n\n核心思想：让小树长大\n\n思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中\n\n适用场景：稠密图\n\n伪代码：\n\n```\nvoid Prim()\n{\n\tMST = {s}  // 初始化，树中只有初始结点\n\twhile(1)\n\t{\n\t\tv = 未收录结点中到树距离最小的\n\t\tif( v不存在 )\n\t\t\tbreak;\n\t\t把v收入MST中： dist[v]=0\n\t\tfor( v的所有邻接点w )\n\t\t\tif( w 未被收录：dist[w]!=0 && E<v,w> < dist[w] )\n\t\t\t{\n\t\t\t\tdist[w]=E<v,w>;\n\t\t\t\tparent[w]=v;\n\t\t\t}\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)\n\n不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1\n\n时间复杂度： O($v^2$)\n\n### Kruskal算法\n\n核心思想：森林合并成树\n\n思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边\n\n适用场景：稀疏图\n\n伪代码：\n\n```\nvoid Kruskal (Graph G)\n{\n\tMST = {}\n\twhile( MST不到V-1条边 && E中还有边 )\n\t{\n\t\tE中选取权重最小的边E<v,w>;   // 用最小堆\n\t\t把E<v,w>从e中删除\n\t\tif( E<v,w> 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）\n\t\t\t将E<v,w>加入MST；\n\t\telse\n\t\t\t无视E<v,w>\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n时间复杂度： O( E*logE )\n\n## 拓扑排序\n\nAOV （Activity On Vertex）网络\n\n拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列\n\n拓扑排序: 获得一个拓扑序的过程为\n\nAOV若有**合理**的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)\n\n思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出\n\n用途：拓扑排序，还可以用于检测有向图是否为DAG\n\n伪代码：\n\n```\nvoid TopSort()\n{\n\tfor( 每个顶点v )\n\t\tif( Indegree[v]==0 )\n\t\t\tqueue.enqueue(v);\n\twhile(!queue.empty())\n\t{\n\t\tv=queue.dequeue();\n\t\t输出或记录v;\n\t\tcnt++;\n\t\tfor( v的每个结点w )\n\t\t\tif( --Indegree[w]==0 )\n\t\t\t\tqueue.enqueue(w);\n\t}\n\tif( cnt!=v )\n\t{\n\t\tError(图中有回路)\n\t\tbreak;\n\t}\n}\n```\n\n时间复杂度： O(v+e)\n\n### 关键路径问题\n\nAOE( Activity On Edge )网络\n\n```\n- 一般用于安排项目的工序\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG)\n\nEarliestTime[0]=0\nEarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG)\n\nLastTime[i]=min($\\in$E) { LastTime[j]-C}\n\n机动时间： D = LastTime[j]-EarlistTime[i]-C\n\n关键路径：绝对不允许延误的活动组成的路径","source":"_posts/DataStructure_Graph.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（四）：图\"\ndate: 2017-08-19\ncomments: true\ntags: \n\t- 学习笔记\n\t- c++\n\t- 数据结构\n---\n\n\n## **概念**\n\n什么是图(Graph)：\n表示多对多的关系\n包含\n一组顶点：通常用V(Vertex)表示顶点集合\n一组边：通常用E(Edge)表示边的集合\n边是顶点对\n无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V\n有向边 表示从v指向w的边\n不考虑重边和自回路\n\n<!-- more -->\n\n此前学过的树、线性序列，均可视作图的**特例**。\n在线性序列中，只有直接前驱和后继有邻接关系\n在树中，只有父节点和子节点之间定义邻接关系\n\n![序列、树、图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim)\n\n**分类：**\n1.**无向图(undigraph)**：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)\n2.**有向图(digraph)**：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u->v 即 (u,v) u为尾(tail)，v为头(head)\n3.**混合图**：邻接关系中有的与次序有关，有的与次序无关\n4.**网络(network)**：边有权重\n\n以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。\n\n![分类图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim)\n\n概念：\n\n- **路径 **：\n\n  定义：顶点按依次邻接的关系连成的序列\n  简单路径：不含重复节点的路径\n  一般路径：可能含重复节点\n  环路：起点和终点重合\n\n  - **彼此邻接**：\n    彼此间存在边的两个顶点\n\n  - **连通**：\n    若v到w存在一条路径，则称v和w是连通的\n    强连通：\n\n    ```\n    有向图中v和w存在双向路径\n\n    ```\n\n    **连通分量**：\n\n    ```\n    无向图的**极大**连通子图\n        极大顶点数：再加1个顶点就不连通\n        极大边数：包含子图中所有顶点相连的所有边\n    **强连通分量**：\n        有向图的极大强连通子图\n\n    ```\n\n    **连通图**：\n\n    ```\n    图中任意两顶点均连通\n    **强连通图**：\n        有向图中所有顶点都是强连通\n\n    ```\n\n  - **有向无环图**(directed acyclic graph DAG)：\n    图为有向图且不包含任何环路\n\n  - **欧拉环路**：\n    经过所有边且恰好只经过所有边一次的环路\n\n  - **哈密尔顿环路**：\n    经过所有节点且只经过所有点一次\n\n  - **简单图**：\n    所有节点均不含自环的图\n\n## 抽象数据类型定义\n\n名称： 图 Graph\n数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成\n操作集：\n\n```\n- Graph Create();\n    建立并返回空图\n- Graph InsertVertex(Graph G, Vertex v);\n    把顶点V插入G\n- Graph InsertEdge(Graph G, Edge e);\n    把顶点E插入G    \n- void DFS(Graph G , Vertex v);\n    从v出发深度优先遍历G\n- void BFS(Graph G , Vertex v);\n    从v出发广度优先遍历G\n- void ShortestPath(Graph G , Vertex v, int Dist[]);\n    计算图G中顶点v到任意其它顶点的最短距离\n- void MST(Graph G);\n    计算图G的最小生成树\n\n```\n\n## 表示\n\n### 邻接矩阵\n\n邻接矩阵：G[N][N]——N个顶点从0到N-1编号\n\n```\n- G[i][j]=1 <vi,vj>是边\n- G[i][j]=0 <vi,vj>不是边\n\n```\n\n优点\n\n```\n- 方便、直观\n- 方便检查任意一对顶点间是否有边\n- 方便找任一顶点所有邻接点\n- 方便计算任一顶点的度\n    入度：指向该点的边数\n    出度：从该点发出的边数\n\n```\n\n缺点\n\n```\n- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素\n- 浪费时间，统计稀疏图中共多少条边\n\n```\n\n基本定义与建图：\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct Graph\n{\n\tVertex vertex[MaxSize];      // 顶点表\n\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表\n\tint n , e;                   // 顶点总数和边总数\n\tGraphType type;\n};\n\nvoid CreateGraph ( Graph * g)\n{\n\tg->type = UN;\n\tint i,j,w;\n\tscanf(\"%d%d\",&g->n,&g->e);   // 顶点数和边数\n\tfor( i=0; i<g->n; i++ )\n\t\tscanf(\"%c\",&(g->vertex[i]));\n\tfor( i=0; i<g->n ; i++ )     // 初始化\n\t\tfor( j=0; j<g->n ; j++ )\n\t\t\tg->edge[i][j]=INF;\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d%d%d\",&i,&j,&w);  // 输入e条边的权值\n\t\tg->edge[i][j]=w;\n\t\tg->edge[j][i]=w;\n\t}\n}\n```\n\n### 邻接表\n\n邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素\n优点：\n\n```\n- 方便找任一顶点的所有邻接点\n- 节约稀疏图的空间\n    需要N个头指针，2E个结点（每个节点至少两个域）\n    E < n(n-1)/4 时省空间\n- 方便计算无向图的度\n    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）\n\n```\n\n基本定义与实现\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct ENode\n{\n\tint adjv;    // 指向顶点的序号\n\tENode * next;\n\tint weight;\n};\n\nstruct VNode\n{\n\tVertex vertex;\n\tENode *firstEdge;\n};\n\nstruct Graph\n{\n\tVNode nodeList[MaxSize];\n\tint n,e;\n\tGraphType type;\n};\n\nvoid CreateGraph( Graph *g )\n{\n\tint i,j;\n\tENode *edge;\n\tg->type = DG;\n\tscanf(\"%d%d\",&(g->n),&(g->e));\n\tfor( i=0 ; i<g->n ; i++)\n\t{\n\t\tscanf(\"%c\",&(g->nodeList[i].vertex));\n\t\tg->nodeList[i].firstEdge=NULL;\n\t}\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d %d\",&i,&j);\n\t\tedge = new ENode();\n\t\tedge->adjv = j;\n\t\tedge->next = g->nodeList[i].firstEdge;\n\t\tg->nodeList[i].firstEdge = edge;\n\t}\n}\n```\n\n## 遍历\n\n### 深度优先搜索 DFS (Depth First Search)\n\n相当于树的先序遍历\n\nN个顶点，E条边，时间复杂度：\n用邻接表存储时，为O(N+E)\n用邻接矩阵存储时，为O($N^2$);\n\n伪代码:\n\n```\nvoid DFS( Vertex v )\n{\n\tvisited[v]=true;\n\tfor( v的每个邻接点w )\n\t\tif(!visited[w])\n\t\t\tDFS(w);\n}\n```\n\n### 广度优先搜索 BFS (Breadth First Search)\n\n相当于树的层序遍历\n\n用**队列**实现，把起始结点加入队列后\n每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过\n\nN个顶点，E条边，时间复杂度和DFS相同：\n\n```\n- 用邻接表存储时，为O(N+E)\n- 用邻接矩阵存储时，为O($N^2$);\n\n```\n\n伪代码：\n\n```\nvoid BFS( Vertex v )\n{\n\tvisited[v]=true;\n\tqueue.enqueue(v);\n\twhile(!q.empty())\n\t{\n\t\tv=q.dequeue();\n\t\tfor( v 的每个邻接点w )\n\t\t\tif(!visited[w])\n\t\t\t{\n\t\t\t\tvisited[w]=true;\n\t\t\t\tq.enqueue(w);\n\t\t\t}\n\t}\n\n}\n```\n\nBFS适合找最优解\nDFS适合找任意一解\n\n## 最短路径\n\n定义：\n在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径\n\n```\n- 该路径就是两点之间的最短路径\n- 第一个顶点为源点\n\n```\n\n分类：\n\n```\n1. 单源最短路：\n    从某固定源点出发，求其到所有其他顶点的最短路径\n    - 无权图\n    - 有权图\n2. 多源最短路：\n    求任意两顶点之间的最短路径\n\n```\n\n### 无权图的单源最短路算法\n\n按照**递增（非递减）**的顺序找出到各个顶点的最短路\n\n伪代码\n\n```\n// dist[w] = s到w的最短距离\n// dist[s] = 0\n// path[w] = s到w路径的倒数第二个顶点\n\nvoid　Unweighted( int s )\n{\n\tqueue.enqueue(s);\n\twhile(!queue.empty())\n\t{\n\t\tv = queue.dequeue();\n\t\tfor( v的每个邻接点w )\n\t\t{\n\t\t\tif( dist[w]==-1 )\n\t\t\t{\n\t\t\t\tdist[w]=dist[v]+1;\n\t\t\t\tpath[w]=v;\n\t\t\t\tqueue.enqueue(w);\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid print(int s , int w)\n{\n\tif(path[w]==-1) return;\n\twhile(path[w]!=s)\n\t{\n\t\tstack.push(path[w]);\n\t\tw=path[w];\n\t}\n\twhile(!stack.empty())\n\t\tprintf(\"%d\\n\",stack.pop());\n}\n```\n\n时间复杂度： O( v + e )\n\n### 有权图的单源最短路算法\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG)\n\n不考虑**负值圈(negative-cost cycle)**\n\n按照递增顺序找到各个顶点的最短路： Dijkstra算法\n\n#### Dijkstra:\n\n```\n- 令 S = { 源点S + 已经确定了最短路径的顶点vi }\n- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径{s -> (vi$\\in$s) -> v}的最小长度\n- 路径按照递增（非递减）的顺序生成\n    - 真正的最短路一定只经过s中的顶点\n    - 每次从未收录的顶点中选一个dist最小的收录\n    - 增加一个v进入s，可能影响w的最小值\n        dist[w]=min(dist[w]+<v,w>);\n    - 初始化为INF\n\n```\n\n伪代码\n\n```\nvoid Dijkstra( int s )\n{\n\twhile(1)\n\t{\n\t\tv = 未收录顶点中dist最小的\n\t\tif( v 不存在 )\n\t\t\tbreak;\n\t\tcollected[v]=true;\n\t\tfor( v 的每个顶点w )\n\t\t\tif( collected[w]==false )\n\t\t\t\tif( dist[v]+E<v,w> < dist[w])\n\t\t\t\t{\n\t\t\t\t\tdist[w]=dist[v]+E<v,w>;\n\t\t\t\t\tpath[w]=v;\n\t\t\t\t}\n\t}\n}\n```\n\n时间复杂度：取决于如何找到dist最小的节点\n\n方法1： 直接扫描所有未收录节点 O(v)\nO($v^2$+e) (稠密图效果好)\n方法2： 把dist存入最小堆中 O(logv)\n更新dist[w]的值： O(logv)\nO(elogv) (稀疏图效果好)\n\n### 多源最短路\n\n方法1： 把单源最短路调用V遍 O( v3+e*v )\n\n方法2： Floyd算法 O( v3 )\n\n#### Floyd算法：\n\n```\n- D(k)[i][j] = 路径 { i -> {l<=k} -> j }的最小长度 (从i到j只经过编号<=k的顶点)\n- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离\n- 初始化D为带权值的邻接矩阵，对角元为0\n- 若i,j之间无直接边，则初始化为INF\n- 若D(k-1)已完成，递推D(k):\n    - 若k$\\notin$最短路径，则 D(K)=D(K-1)\n    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：\n        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]\n\n```\n\n伪代码：\n\n```\nvoid Floyd()\n{\n\tfor( int i=0; i<n ; i++ )\n\t\tfor( int j=0; j<n ; j++ )\n\t\t{\t\n\t\t\tD[i][j]=G[i][j]\n\t\t\tpath[i][j]=-1;\n\t\t}\n\tfor( int k=0; k<n ; k++ )\n\t\tfor( int i=0; i<n ; i++ )\n\t\t\tfor( int j=0; j<n ; j++ )\n\t\t\t\tif(D[i][k]+D[k][j]<D[i][j])\n\t\t\t\t{\t\n\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];\n\t\t\t\t\tpath[i][j]=k;\n\t\t\t\t}\n}\nvoid print( int i , int j )\n{\n\tif(i==j) return;\n\tprint(i,path[i][j]);\n\tprintf(path[i][j]);\n\tprint(path[i][j],j);\n}\n```\n\n## 最小生成树 Minimum Spanning Tree\n\n定义：\n\n```\n- 一棵树：\n    - 无回路\n    - V个顶点一定有V-1条边\n- 生成树：\n    - 包含所有顶点\n    - V-1条边都包含在图里\n    - 生成树中任加一条边都一定构成回路\n- 最小：\n    - 边的权重和最小\n\n```\n\n最小生成树存在 <=> 图连通\n\n方法：**贪心**\n\n约束条件：\n\n```\n1. 只能用图里的边\n2. 只能正好用掉V-1条边\n3. 不能有回路\n\n```\n\n### Prim算法\n\n核心思想：让小树长大\n\n思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中\n\n适用场景：稠密图\n\n伪代码：\n\n```\nvoid Prim()\n{\n\tMST = {s}  // 初始化，树中只有初始结点\n\twhile(1)\n\t{\n\t\tv = 未收录结点中到树距离最小的\n\t\tif( v不存在 )\n\t\t\tbreak;\n\t\t把v收入MST中： dist[v]=0\n\t\tfor( v的所有邻接点w )\n\t\t\tif( w 未被收录：dist[w]!=0 && E<v,w> < dist[w] )\n\t\t\t{\n\t\t\t\tdist[w]=E<v,w>;\n\t\t\t\tparent[w]=v;\n\t\t\t}\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)\n\n不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1\n\n时间复杂度： O($v^2$)\n\n### Kruskal算法\n\n核心思想：森林合并成树\n\n思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边\n\n适用场景：稀疏图\n\n伪代码：\n\n```\nvoid Kruskal (Graph G)\n{\n\tMST = {}\n\twhile( MST不到V-1条边 && E中还有边 )\n\t{\n\t\tE中选取权重最小的边E<v,w>;   // 用最小堆\n\t\t把E<v,w>从e中删除\n\t\tif( E<v,w> 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）\n\t\t\t将E<v,w>加入MST；\n\t\telse\n\t\t\t无视E<v,w>\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n时间复杂度： O( E*logE )\n\n## 拓扑排序\n\nAOV （Activity On Vertex）网络\n\n拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列\n\n拓扑排序: 获得一个拓扑序的过程为\n\nAOV若有**合理**的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)\n\n思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出\n\n用途：拓扑排序，还可以用于检测有向图是否为DAG\n\n伪代码：\n\n```\nvoid TopSort()\n{\n\tfor( 每个顶点v )\n\t\tif( Indegree[v]==0 )\n\t\t\tqueue.enqueue(v);\n\twhile(!queue.empty())\n\t{\n\t\tv=queue.dequeue();\n\t\t输出或记录v;\n\t\tcnt++;\n\t\tfor( v的每个结点w )\n\t\t\tif( --Indegree[w]==0 )\n\t\t\t\tqueue.enqueue(w);\n\t}\n\tif( cnt!=v )\n\t{\n\t\tError(图中有回路)\n\t\tbreak;\n\t}\n}\n```\n\n时间复杂度： O(v+e)\n\n### 关键路径问题\n\nAOE( Activity On Edge )网络\n\n```\n- 一般用于安排项目的工序\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG)\n\nEarliestTime[0]=0\nEarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG)\n\nLastTime[i]=min($\\in$E) { LastTime[j]-C}\n\n机动时间： D = LastTime[j]-EarlistTime[i]-C\n\n关键路径：绝对不允许延误的活动组成的路径","slug":"DataStructure_Graph","published":1,"updated":"2018-05-25T12:41:12.161Z","photos":[],"link":"","_id":"cjleshqj60005ryfcxqcr0yhg","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>什么是图(Graph)：<br>表示多对多的关系<br>包含<br>一组顶点：通常用V(Vertex)表示顶点集合<br>一组边：通常用E(Edge)表示边的集合<br>边是顶点对<br>无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V<br>有向边 表示从v指向w的边<br>不考虑重边和自回路</p>\n<a id=\"more\"></a>\n<p>此前学过的树、线性序列，均可视作图的<strong>特例</strong>。<br>在线性序列中，只有直接前驱和后继有邻接关系<br>在树中，只有父节点和子节点之间定义邻接关系</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim\" alt=\"序列、树、图\"></p>\n<p><strong>分类：</strong><br>1.<strong>无向图(undigraph)</strong>：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)<br>2.<strong>有向图(digraph)</strong>：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u-&gt;v 即 (u,v) u为尾(tail)，v为头(head)<br>3.<strong>混合图</strong>：邻接关系中有的与次序有关，有的与次序无关<br>4.<strong>网络(network)</strong>：边有权重</p>\n<p>以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim\" alt=\"分类图\"></p>\n<p>概念：</p>\n<ul>\n<li><p><strong>路径 </strong>：</p>\n<p>定义：顶点按依次邻接的关系连成的序列<br>简单路径：不含重复节点的路径<br>一般路径：可能含重复节点<br>环路：起点和终点重合</p>\n<ul>\n<li><p><strong>彼此邻接</strong>：<br>彼此间存在边的两个顶点</p>\n</li>\n<li><p><strong>连通</strong>：<br>若v到w存在一条路径，则称v和w是连通的<br>强连通：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有向图中v和w存在双向路径</span><br></pre></td></tr></table></figure>\n<p><strong>连通分量</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无向图的**极大**连通子图</span><br><span class=\"line\">    极大顶点数：再加1个顶点就不连通</span><br><span class=\"line\">    极大边数：包含子图中所有顶点相连的所有边</span><br><span class=\"line\">**强连通分量**：</span><br><span class=\"line\">    有向图的极大强连通子图</span><br></pre></td></tr></table></figure>\n<p><strong>连通图</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">图中任意两顶点均连通</span><br><span class=\"line\">**强连通图**：</span><br><span class=\"line\">    有向图中所有顶点都是强连通</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>有向无环图</strong>(directed acyclic graph DAG)：<br>图为有向图且不包含任何环路</p>\n</li>\n<li><p><strong>欧拉环路</strong>：<br>经过所有边且恰好只经过所有边一次的环路</p>\n</li>\n<li><p><strong>哈密尔顿环路</strong>：<br>经过所有节点且只经过所有点一次</p>\n</li>\n<li><p><strong>简单图</strong>：<br>所有节点均不含自环的图</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象数据类型定义\"><a href=\"#抽象数据类型定义\" class=\"headerlink\" title=\"抽象数据类型定义\"></a>抽象数据类型定义</h2><p>名称： 图 Graph<br>数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成<br>操作集：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Graph Create();</span><br><span class=\"line\">    建立并返回空图</span><br><span class=\"line\">- Graph InsertVertex(Graph G, Vertex v);</span><br><span class=\"line\">    把顶点V插入G</span><br><span class=\"line\">- Graph InsertEdge(Graph G, Edge e);</span><br><span class=\"line\">    把顶点E插入G    </span><br><span class=\"line\">- void DFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发深度优先遍历G</span><br><span class=\"line\">- void BFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发广度优先遍历G</span><br><span class=\"line\">- void ShortestPath(Graph G , Vertex v, int Dist[]);</span><br><span class=\"line\">    计算图G中顶点v到任意其它顶点的最短距离</span><br><span class=\"line\">- void MST(Graph G);</span><br><span class=\"line\">    计算图G的最小生成树</span><br></pre></td></tr></table></figure>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a>表示</h2><h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><p>邻接矩阵：G[N][N]——N个顶点从0到N-1编号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- G[i][j]=1 &lt;vi,vj&gt;是边</span><br><span class=\"line\">- G[i][j]=0 &lt;vi,vj&gt;不是边</span><br></pre></td></tr></table></figure>\n<p>优点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便、直观</span><br><span class=\"line\">- 方便检查任意一对顶点间是否有边</span><br><span class=\"line\">- 方便找任一顶点所有邻接点</span><br><span class=\"line\">- 方便计算任一顶点的度</span><br><span class=\"line\">    入度：指向该点的边数</span><br><span class=\"line\">    出度：从该点发出的边数</span><br></pre></td></tr></table></figure>\n<p>缺点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素</span><br><span class=\"line\">- 浪费时间，统计稀疏图中共多少条边</span><br></pre></td></tr></table></figure>\n<p>基本定义与建图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex[MaxSize];      // 顶点表</span><br><span class=\"line\">\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表</span><br><span class=\"line\">\tint n , e;                   // 顶点总数和边总数</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph ( Graph * g)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tg-&gt;type = UN;</span><br><span class=\"line\">\tint i,j,w;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;g-&gt;n,&amp;g-&gt;e);   // 顶点数和边数</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n; i++ )</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;vertex[i]));</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n ; i++ )     // 初始化</span><br><span class=\"line\">\t\tfor( j=0; j&lt;g-&gt;n ; j++ )</span><br><span class=\"line\">\t\t\tg-&gt;edge[i][j]=INF;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;w);  // 输入e条边的权值</span><br><span class=\"line\">\t\tg-&gt;edge[i][j]=w;</span><br><span class=\"line\">\t\tg-&gt;edge[j][i]=w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>优点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便找任一顶点的所有邻接点</span><br><span class=\"line\">- 节约稀疏图的空间</span><br><span class=\"line\">    需要N个头指针，2E个结点（每个节点至少两个域）</span><br><span class=\"line\">    E &lt; n(n-1)/4 时省空间</span><br><span class=\"line\">- 方便计算无向图的度</span><br><span class=\"line\">    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）</span><br></pre></td></tr></table></figure>\n<p>基本定义与实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct ENode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint adjv;    // 指向顶点的序号</span><br><span class=\"line\">\tENode * next;</span><br><span class=\"line\">\tint weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct VNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex;</span><br><span class=\"line\">\tENode *firstEdge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVNode nodeList[MaxSize];</span><br><span class=\"line\">\tint n,e;</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph( Graph *g )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i,j;</span><br><span class=\"line\">\tENode *edge;</span><br><span class=\"line\">\tg-&gt;type = DG;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;(g-&gt;n),&amp;(g-&gt;e));</span><br><span class=\"line\">\tfor( i=0 ; i&lt;g-&gt;n ; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;nodeList[i].vertex));</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d %d&quot;,&amp;i,&amp;j);</span><br><span class=\"line\">\t\tedge = new ENode();</span><br><span class=\"line\">\t\tedge-&gt;adjv = j;</span><br><span class=\"line\">\t\tedge-&gt;next = g-&gt;nodeList[i].firstEdge;</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge = edge;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><h3 id=\"深度优先搜索-DFS-Depth-First-Search\"><a href=\"#深度优先搜索-DFS-Depth-First-Search\" class=\"headerlink\" title=\"深度优先搜索 DFS (Depth First Search)\"></a>深度优先搜索 DFS (Depth First Search)</h3><p>相当于树的先序遍历</p>\n<p>N个顶点，E条边，时间复杂度：<br>用邻接表存储时，为O(N+E)<br>用邻接矩阵存储时，为O($N^2$);</p>\n<p>伪代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\tDFS(w);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"广度优先搜索-BFS-Breadth-First-Search\"><a href=\"#广度优先搜索-BFS-Breadth-First-Search\" class=\"headerlink\" title=\"广度优先搜索 BFS (Breadth First Search)\"></a>广度优先搜索 BFS (Breadth First Search)</h3><p>相当于树的层序遍历</p>\n<p>用<strong>队列</strong>实现，把起始结点加入队列后<br>每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过</p>\n<p>N个顶点，E条边，时间复杂度和DFS相同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 用邻接表存储时，为O(N+E)</span><br><span class=\"line\">- 用邻接矩阵存储时，为O($N^2$);</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!q.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=q.dequeue();</span><br><span class=\"line\">\t\tfor( v 的每个邻接点w )</span><br><span class=\"line\">\t\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tvisited[w]=true;</span><br><span class=\"line\">\t\t\t\tq.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BFS适合找最优解<br>DFS适合找任意一解</p>\n<h2 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h2><p>定义：<br>在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 该路径就是两点之间的最短路径</span><br><span class=\"line\">- 第一个顶点为源点</span><br></pre></td></tr></table></figure>\n<p>分类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 单源最短路：</span><br><span class=\"line\">    从某固定源点出发，求其到所有其他顶点的最短路径</span><br><span class=\"line\">    - 无权图</span><br><span class=\"line\">    - 有权图</span><br><span class=\"line\">2. 多源最短路：</span><br><span class=\"line\">    求任意两顶点之间的最短路径</span><br></pre></td></tr></table></figure>\n<h3 id=\"无权图的单源最短路算法\"><a href=\"#无权图的单源最短路算法\" class=\"headerlink\" title=\"无权图的单源最短路算法\"></a>无权图的单源最短路算法</h3><p>按照<strong>递增（非递减）</strong>的顺序找出到各个顶点的最短路</p>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// dist[w] = s到w的最短距离</span><br><span class=\"line\">// dist[s] = 0</span><br><span class=\"line\">// path[w] = s到w路径的倒数第二个顶点</span><br><span class=\"line\"></span><br><span class=\"line\">void　Unweighted( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueue.enqueue(s);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = queue.dequeue();</span><br><span class=\"line\">\t\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( dist[w]==-1 )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=dist[v]+1;</span><br><span class=\"line\">\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print(int s , int w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(path[w]==-1) return;</span><br><span class=\"line\">\twhile(path[w]!=s)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack.push(path[w]);</span><br><span class=\"line\">\t\tw=path[w];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(!stack.empty())</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;,stack.pop());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( v + e )</p>\n<h3 id=\"有权图的单源最短路算法\"><a href=\"#有权图的单源最短路算法\" class=\"headerlink\" title=\"有权图的单源最短路算法\"></a>有权图的单源最短路算法</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG\" alt=\"mark\"></p>\n<p>不考虑<strong>负值圈(negative-cost cycle)</strong></p>\n<p>按照递增顺序找到各个顶点的最短路： Dijkstra算法</p>\n<h4 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra:\"></a>Dijkstra:</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 令 S = &#123; 源点S + 已经确定了最短路径的顶点vi &#125;</span><br><span class=\"line\">- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径&#123;s -&gt; (vi$\\in$s) -&gt; v&#125;的最小长度</span><br><span class=\"line\">- 路径按照递增（非递减）的顺序生成</span><br><span class=\"line\">    - 真正的最短路一定只经过s中的顶点</span><br><span class=\"line\">    - 每次从未收录的顶点中选一个dist最小的收录</span><br><span class=\"line\">    - 增加一个v进入s，可能影响w的最小值</span><br><span class=\"line\">        dist[w]=min(dist[w]+&lt;v,w&gt;);</span><br><span class=\"line\">    - 初始化为INF</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Dijkstra( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录顶点中dist最小的</span><br><span class=\"line\">\t\tif( v 不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcollected[v]=true;</span><br><span class=\"line\">\t\tfor( v 的每个顶点w )</span><br><span class=\"line\">\t\t\tif( collected[w]==false )</span><br><span class=\"line\">\t\t\t\tif( dist[v]+E&lt;v,w&gt; &lt; dist[w])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tdist[w]=dist[v]+E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：取决于如何找到dist最小的节点</p>\n<p>方法1： 直接扫描所有未收录节点 O(v)<br>O($v^2$+e) (稠密图效果好)<br>方法2： 把dist存入最小堆中 O(logv)<br>更新dist[w]的值： O(logv)<br>O(elogv) (稀疏图效果好)</p>\n<h3 id=\"多源最短路\"><a href=\"#多源最短路\" class=\"headerlink\" title=\"多源最短路\"></a>多源最短路</h3><p>方法1： 把单源最短路调用V遍 O( v3+e*v )</p>\n<p>方法2： Floyd算法 O( v3 )</p>\n<h4 id=\"Floyd算法：\"><a href=\"#Floyd算法：\" class=\"headerlink\" title=\"Floyd算法：\"></a>Floyd算法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- D(k)[i][j] = 路径 &#123; i -&gt; &#123;l&lt;=k&#125; -&gt; j &#125;的最小长度 (从i到j只经过编号&lt;=k的顶点)</span><br><span class=\"line\">- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离</span><br><span class=\"line\">- 初始化D为带权值的邻接矩阵，对角元为0</span><br><span class=\"line\">- 若i,j之间无直接边，则初始化为INF</span><br><span class=\"line\">- 若D(k-1)已完成，递推D(k):</span><br><span class=\"line\">    - 若k$\\notin$最短路径，则 D(K)=D(K-1)</span><br><span class=\"line\">    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：</span><br><span class=\"line\">        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Floyd()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tD[i][j]=G[i][j]</span><br><span class=\"line\">\t\t\tpath[i][j]=-1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;n ; k++ )</span><br><span class=\"line\">\t\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t\t\tif(D[i][k]+D[k][j]&lt;D[i][j])</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];</span><br><span class=\"line\">\t\t\t\t\tpath[i][j]=k;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print( int i , int j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(i==j) return;</span><br><span class=\"line\">\tprint(i,path[i][j]);</span><br><span class=\"line\">\tprintf(path[i][j]);</span><br><span class=\"line\">\tprint(path[i][j],j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最小生成树-Minimum-Spanning-Tree\"><a href=\"#最小生成树-Minimum-Spanning-Tree\" class=\"headerlink\" title=\"最小生成树 Minimum Spanning Tree\"></a>最小生成树 Minimum Spanning Tree</h2><p>定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一棵树：</span><br><span class=\"line\">    - 无回路</span><br><span class=\"line\">    - V个顶点一定有V-1条边</span><br><span class=\"line\">- 生成树：</span><br><span class=\"line\">    - 包含所有顶点</span><br><span class=\"line\">    - V-1条边都包含在图里</span><br><span class=\"line\">    - 生成树中任加一条边都一定构成回路</span><br><span class=\"line\">- 最小：</span><br><span class=\"line\">    - 边的权重和最小</span><br></pre></td></tr></table></figure>\n<p>最小生成树存在 &lt;=&gt; 图连通</p>\n<p>方法：<strong>贪心</strong></p>\n<p>约束条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 只能用图里的边</span><br><span class=\"line\">2. 只能正好用掉V-1条边</span><br><span class=\"line\">3. 不能有回路</span><br></pre></td></tr></table></figure>\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>核心思想：让小树长大</p>\n<p>思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中</p>\n<p>适用场景：稠密图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Prim()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;s&#125;  // 初始化，树中只有初始结点</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录结点中到树距离最小的</span><br><span class=\"line\">\t\tif( v不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t把v收入MST中： dist[v]=0</span><br><span class=\"line\">\t\tfor( v的所有邻接点w )</span><br><span class=\"line\">\t\t\tif( w 未被收录：dist[w]!=0 &amp;&amp; E&lt;v,w&gt; &lt; dist[w] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\tparent[w]=v;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)</p>\n<p>不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1</p>\n<p>时间复杂度： O($v^2$)</p>\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>核心思想：森林合并成树</p>\n<p>思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边</p>\n<p>适用场景：稀疏图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Kruskal (Graph G)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;&#125;</span><br><span class=\"line\">\twhile( MST不到V-1条边 &amp;&amp; E中还有边 )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tE中选取权重最小的边E&lt;v,w&gt;;   // 用最小堆</span><br><span class=\"line\">\t\t把E&lt;v,w&gt;从e中删除</span><br><span class=\"line\">\t\tif( E&lt;v,w&gt; 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）</span><br><span class=\"line\">\t\t\t将E&lt;v,w&gt;加入MST；</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\t无视E&lt;v,w&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( E*logE )</p>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><p>AOV （Activity On Vertex）网络</p>\n<p>拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列</p>\n<p>拓扑排序: 获得一个拓扑序的过程为</p>\n<p>AOV若有<strong>合理</strong>的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)</p>\n<p>思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出</p>\n<p>用途：拓扑排序，还可以用于检测有向图是否为DAG</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TopSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( 每个顶点v )</span><br><span class=\"line\">\t\tif( Indegree[v]==0 )</span><br><span class=\"line\">\t\t\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=queue.dequeue();</span><br><span class=\"line\">\t\t输出或记录v;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t\tfor( v的每个结点w )</span><br><span class=\"line\">\t\t\tif( --Indegree[w]==0 )</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( cnt!=v )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tError(图中有回路)</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O(v+e)</p>\n<h3 id=\"关键路径问题\"><a href=\"#关键路径问题\" class=\"headerlink\" title=\"关键路径问题\"></a>关键路径问题</h3><p>AOE( Activity On Edge )网络</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一般用于安排项目的工序</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG\" alt=\"mark\"></p>\n<p>EarliestTime[0]=0<br>EarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG\" alt=\"mark\"></p>\n<p>LastTime[i]=min($\\in$E) { LastTime[j]-C}</p>\n<p>机动时间： D = LastTime[j]-EarlistTime[i]-C</p>\n<p>关键路径：绝对不允许延误的活动组成的路径</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>什么是图(Graph)：<br>表示多对多的关系<br>包含<br>一组顶点：通常用V(Vertex)表示顶点集合<br>一组边：通常用E(Edge)表示边的集合<br>边是顶点对<br>无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V<br>有向边 表示从v指向w的边<br>不考虑重边和自回路</p>","more":"<p>此前学过的树、线性序列，均可视作图的<strong>特例</strong>。<br>在线性序列中，只有直接前驱和后继有邻接关系<br>在树中，只有父节点和子节点之间定义邻接关系</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim\" alt=\"序列、树、图\"></p>\n<p><strong>分类：</strong><br>1.<strong>无向图(undigraph)</strong>：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)<br>2.<strong>有向图(digraph)</strong>：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u-&gt;v 即 (u,v) u为尾(tail)，v为头(head)<br>3.<strong>混合图</strong>：邻接关系中有的与次序有关，有的与次序无关<br>4.<strong>网络(network)</strong>：边有权重</p>\n<p>以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim\" alt=\"分类图\"></p>\n<p>概念：</p>\n<ul>\n<li><p><strong>路径 </strong>：</p>\n<p>定义：顶点按依次邻接的关系连成的序列<br>简单路径：不含重复节点的路径<br>一般路径：可能含重复节点<br>环路：起点和终点重合</p>\n<ul>\n<li><p><strong>彼此邻接</strong>：<br>彼此间存在边的两个顶点</p>\n</li>\n<li><p><strong>连通</strong>：<br>若v到w存在一条路径，则称v和w是连通的<br>强连通：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有向图中v和w存在双向路径</span><br></pre></td></tr></table></figure>\n<p><strong>连通分量</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无向图的**极大**连通子图</span><br><span class=\"line\">    极大顶点数：再加1个顶点就不连通</span><br><span class=\"line\">    极大边数：包含子图中所有顶点相连的所有边</span><br><span class=\"line\">**强连通分量**：</span><br><span class=\"line\">    有向图的极大强连通子图</span><br></pre></td></tr></table></figure>\n<p><strong>连通图</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">图中任意两顶点均连通</span><br><span class=\"line\">**强连通图**：</span><br><span class=\"line\">    有向图中所有顶点都是强连通</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>有向无环图</strong>(directed acyclic graph DAG)：<br>图为有向图且不包含任何环路</p>\n</li>\n<li><p><strong>欧拉环路</strong>：<br>经过所有边且恰好只经过所有边一次的环路</p>\n</li>\n<li><p><strong>哈密尔顿环路</strong>：<br>经过所有节点且只经过所有点一次</p>\n</li>\n<li><p><strong>简单图</strong>：<br>所有节点均不含自环的图</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象数据类型定义\"><a href=\"#抽象数据类型定义\" class=\"headerlink\" title=\"抽象数据类型定义\"></a>抽象数据类型定义</h2><p>名称： 图 Graph<br>数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成<br>操作集：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Graph Create();</span><br><span class=\"line\">    建立并返回空图</span><br><span class=\"line\">- Graph InsertVertex(Graph G, Vertex v);</span><br><span class=\"line\">    把顶点V插入G</span><br><span class=\"line\">- Graph InsertEdge(Graph G, Edge e);</span><br><span class=\"line\">    把顶点E插入G    </span><br><span class=\"line\">- void DFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发深度优先遍历G</span><br><span class=\"line\">- void BFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发广度优先遍历G</span><br><span class=\"line\">- void ShortestPath(Graph G , Vertex v, int Dist[]);</span><br><span class=\"line\">    计算图G中顶点v到任意其它顶点的最短距离</span><br><span class=\"line\">- void MST(Graph G);</span><br><span class=\"line\">    计算图G的最小生成树</span><br></pre></td></tr></table></figure>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a>表示</h2><h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><p>邻接矩阵：G[N][N]——N个顶点从0到N-1编号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- G[i][j]=1 &lt;vi,vj&gt;是边</span><br><span class=\"line\">- G[i][j]=0 &lt;vi,vj&gt;不是边</span><br></pre></td></tr></table></figure>\n<p>优点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便、直观</span><br><span class=\"line\">- 方便检查任意一对顶点间是否有边</span><br><span class=\"line\">- 方便找任一顶点所有邻接点</span><br><span class=\"line\">- 方便计算任一顶点的度</span><br><span class=\"line\">    入度：指向该点的边数</span><br><span class=\"line\">    出度：从该点发出的边数</span><br></pre></td></tr></table></figure>\n<p>缺点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素</span><br><span class=\"line\">- 浪费时间，统计稀疏图中共多少条边</span><br></pre></td></tr></table></figure>\n<p>基本定义与建图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex[MaxSize];      // 顶点表</span><br><span class=\"line\">\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表</span><br><span class=\"line\">\tint n , e;                   // 顶点总数和边总数</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph ( Graph * g)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tg-&gt;type = UN;</span><br><span class=\"line\">\tint i,j,w;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;g-&gt;n,&amp;g-&gt;e);   // 顶点数和边数</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n; i++ )</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;vertex[i]));</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n ; i++ )     // 初始化</span><br><span class=\"line\">\t\tfor( j=0; j&lt;g-&gt;n ; j++ )</span><br><span class=\"line\">\t\t\tg-&gt;edge[i][j]=INF;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;w);  // 输入e条边的权值</span><br><span class=\"line\">\t\tg-&gt;edge[i][j]=w;</span><br><span class=\"line\">\t\tg-&gt;edge[j][i]=w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>优点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便找任一顶点的所有邻接点</span><br><span class=\"line\">- 节约稀疏图的空间</span><br><span class=\"line\">    需要N个头指针，2E个结点（每个节点至少两个域）</span><br><span class=\"line\">    E &lt; n(n-1)/4 时省空间</span><br><span class=\"line\">- 方便计算无向图的度</span><br><span class=\"line\">    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）</span><br></pre></td></tr></table></figure>\n<p>基本定义与实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct ENode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint adjv;    // 指向顶点的序号</span><br><span class=\"line\">\tENode * next;</span><br><span class=\"line\">\tint weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct VNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex;</span><br><span class=\"line\">\tENode *firstEdge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVNode nodeList[MaxSize];</span><br><span class=\"line\">\tint n,e;</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph( Graph *g )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i,j;</span><br><span class=\"line\">\tENode *edge;</span><br><span class=\"line\">\tg-&gt;type = DG;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;(g-&gt;n),&amp;(g-&gt;e));</span><br><span class=\"line\">\tfor( i=0 ; i&lt;g-&gt;n ; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;nodeList[i].vertex));</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d %d&quot;,&amp;i,&amp;j);</span><br><span class=\"line\">\t\tedge = new ENode();</span><br><span class=\"line\">\t\tedge-&gt;adjv = j;</span><br><span class=\"line\">\t\tedge-&gt;next = g-&gt;nodeList[i].firstEdge;</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge = edge;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><h3 id=\"深度优先搜索-DFS-Depth-First-Search\"><a href=\"#深度优先搜索-DFS-Depth-First-Search\" class=\"headerlink\" title=\"深度优先搜索 DFS (Depth First Search)\"></a>深度优先搜索 DFS (Depth First Search)</h3><p>相当于树的先序遍历</p>\n<p>N个顶点，E条边，时间复杂度：<br>用邻接表存储时，为O(N+E)<br>用邻接矩阵存储时，为O($N^2$);</p>\n<p>伪代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\tDFS(w);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"广度优先搜索-BFS-Breadth-First-Search\"><a href=\"#广度优先搜索-BFS-Breadth-First-Search\" class=\"headerlink\" title=\"广度优先搜索 BFS (Breadth First Search)\"></a>广度优先搜索 BFS (Breadth First Search)</h3><p>相当于树的层序遍历</p>\n<p>用<strong>队列</strong>实现，把起始结点加入队列后<br>每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过</p>\n<p>N个顶点，E条边，时间复杂度和DFS相同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 用邻接表存储时，为O(N+E)</span><br><span class=\"line\">- 用邻接矩阵存储时，为O($N^2$);</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!q.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=q.dequeue();</span><br><span class=\"line\">\t\tfor( v 的每个邻接点w )</span><br><span class=\"line\">\t\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tvisited[w]=true;</span><br><span class=\"line\">\t\t\t\tq.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BFS适合找最优解<br>DFS适合找任意一解</p>\n<h2 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h2><p>定义：<br>在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 该路径就是两点之间的最短路径</span><br><span class=\"line\">- 第一个顶点为源点</span><br></pre></td></tr></table></figure>\n<p>分类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 单源最短路：</span><br><span class=\"line\">    从某固定源点出发，求其到所有其他顶点的最短路径</span><br><span class=\"line\">    - 无权图</span><br><span class=\"line\">    - 有权图</span><br><span class=\"line\">2. 多源最短路：</span><br><span class=\"line\">    求任意两顶点之间的最短路径</span><br></pre></td></tr></table></figure>\n<h3 id=\"无权图的单源最短路算法\"><a href=\"#无权图的单源最短路算法\" class=\"headerlink\" title=\"无权图的单源最短路算法\"></a>无权图的单源最短路算法</h3><p>按照<strong>递增（非递减）</strong>的顺序找出到各个顶点的最短路</p>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// dist[w] = s到w的最短距离</span><br><span class=\"line\">// dist[s] = 0</span><br><span class=\"line\">// path[w] = s到w路径的倒数第二个顶点</span><br><span class=\"line\"></span><br><span class=\"line\">void　Unweighted( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueue.enqueue(s);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = queue.dequeue();</span><br><span class=\"line\">\t\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( dist[w]==-1 )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=dist[v]+1;</span><br><span class=\"line\">\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print(int s , int w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(path[w]==-1) return;</span><br><span class=\"line\">\twhile(path[w]!=s)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack.push(path[w]);</span><br><span class=\"line\">\t\tw=path[w];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(!stack.empty())</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;,stack.pop());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( v + e )</p>\n<h3 id=\"有权图的单源最短路算法\"><a href=\"#有权图的单源最短路算法\" class=\"headerlink\" title=\"有权图的单源最短路算法\"></a>有权图的单源最短路算法</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG\" alt=\"mark\"></p>\n<p>不考虑<strong>负值圈(negative-cost cycle)</strong></p>\n<p>按照递增顺序找到各个顶点的最短路： Dijkstra算法</p>\n<h4 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra:\"></a>Dijkstra:</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 令 S = &#123; 源点S + 已经确定了最短路径的顶点vi &#125;</span><br><span class=\"line\">- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径&#123;s -&gt; (vi$\\in$s) -&gt; v&#125;的最小长度</span><br><span class=\"line\">- 路径按照递增（非递减）的顺序生成</span><br><span class=\"line\">    - 真正的最短路一定只经过s中的顶点</span><br><span class=\"line\">    - 每次从未收录的顶点中选一个dist最小的收录</span><br><span class=\"line\">    - 增加一个v进入s，可能影响w的最小值</span><br><span class=\"line\">        dist[w]=min(dist[w]+&lt;v,w&gt;);</span><br><span class=\"line\">    - 初始化为INF</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Dijkstra( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录顶点中dist最小的</span><br><span class=\"line\">\t\tif( v 不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcollected[v]=true;</span><br><span class=\"line\">\t\tfor( v 的每个顶点w )</span><br><span class=\"line\">\t\t\tif( collected[w]==false )</span><br><span class=\"line\">\t\t\t\tif( dist[v]+E&lt;v,w&gt; &lt; dist[w])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tdist[w]=dist[v]+E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：取决于如何找到dist最小的节点</p>\n<p>方法1： 直接扫描所有未收录节点 O(v)<br>O($v^2$+e) (稠密图效果好)<br>方法2： 把dist存入最小堆中 O(logv)<br>更新dist[w]的值： O(logv)<br>O(elogv) (稀疏图效果好)</p>\n<h3 id=\"多源最短路\"><a href=\"#多源最短路\" class=\"headerlink\" title=\"多源最短路\"></a>多源最短路</h3><p>方法1： 把单源最短路调用V遍 O( v3+e*v )</p>\n<p>方法2： Floyd算法 O( v3 )</p>\n<h4 id=\"Floyd算法：\"><a href=\"#Floyd算法：\" class=\"headerlink\" title=\"Floyd算法：\"></a>Floyd算法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- D(k)[i][j] = 路径 &#123; i -&gt; &#123;l&lt;=k&#125; -&gt; j &#125;的最小长度 (从i到j只经过编号&lt;=k的顶点)</span><br><span class=\"line\">- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离</span><br><span class=\"line\">- 初始化D为带权值的邻接矩阵，对角元为0</span><br><span class=\"line\">- 若i,j之间无直接边，则初始化为INF</span><br><span class=\"line\">- 若D(k-1)已完成，递推D(k):</span><br><span class=\"line\">    - 若k$\\notin$最短路径，则 D(K)=D(K-1)</span><br><span class=\"line\">    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：</span><br><span class=\"line\">        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Floyd()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tD[i][j]=G[i][j]</span><br><span class=\"line\">\t\t\tpath[i][j]=-1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;n ; k++ )</span><br><span class=\"line\">\t\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t\t\tif(D[i][k]+D[k][j]&lt;D[i][j])</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];</span><br><span class=\"line\">\t\t\t\t\tpath[i][j]=k;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print( int i , int j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(i==j) return;</span><br><span class=\"line\">\tprint(i,path[i][j]);</span><br><span class=\"line\">\tprintf(path[i][j]);</span><br><span class=\"line\">\tprint(path[i][j],j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最小生成树-Minimum-Spanning-Tree\"><a href=\"#最小生成树-Minimum-Spanning-Tree\" class=\"headerlink\" title=\"最小生成树 Minimum Spanning Tree\"></a>最小生成树 Minimum Spanning Tree</h2><p>定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一棵树：</span><br><span class=\"line\">    - 无回路</span><br><span class=\"line\">    - V个顶点一定有V-1条边</span><br><span class=\"line\">- 生成树：</span><br><span class=\"line\">    - 包含所有顶点</span><br><span class=\"line\">    - V-1条边都包含在图里</span><br><span class=\"line\">    - 生成树中任加一条边都一定构成回路</span><br><span class=\"line\">- 最小：</span><br><span class=\"line\">    - 边的权重和最小</span><br></pre></td></tr></table></figure>\n<p>最小生成树存在 &lt;=&gt; 图连通</p>\n<p>方法：<strong>贪心</strong></p>\n<p>约束条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 只能用图里的边</span><br><span class=\"line\">2. 只能正好用掉V-1条边</span><br><span class=\"line\">3. 不能有回路</span><br></pre></td></tr></table></figure>\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>核心思想：让小树长大</p>\n<p>思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中</p>\n<p>适用场景：稠密图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Prim()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;s&#125;  // 初始化，树中只有初始结点</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录结点中到树距离最小的</span><br><span class=\"line\">\t\tif( v不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t把v收入MST中： dist[v]=0</span><br><span class=\"line\">\t\tfor( v的所有邻接点w )</span><br><span class=\"line\">\t\t\tif( w 未被收录：dist[w]!=0 &amp;&amp; E&lt;v,w&gt; &lt; dist[w] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\tparent[w]=v;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)</p>\n<p>不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1</p>\n<p>时间复杂度： O($v^2$)</p>\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>核心思想：森林合并成树</p>\n<p>思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边</p>\n<p>适用场景：稀疏图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Kruskal (Graph G)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;&#125;</span><br><span class=\"line\">\twhile( MST不到V-1条边 &amp;&amp; E中还有边 )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tE中选取权重最小的边E&lt;v,w&gt;;   // 用最小堆</span><br><span class=\"line\">\t\t把E&lt;v,w&gt;从e中删除</span><br><span class=\"line\">\t\tif( E&lt;v,w&gt; 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）</span><br><span class=\"line\">\t\t\t将E&lt;v,w&gt;加入MST；</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\t无视E&lt;v,w&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( E*logE )</p>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><p>AOV （Activity On Vertex）网络</p>\n<p>拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列</p>\n<p>拓扑排序: 获得一个拓扑序的过程为</p>\n<p>AOV若有<strong>合理</strong>的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)</p>\n<p>思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出</p>\n<p>用途：拓扑排序，还可以用于检测有向图是否为DAG</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TopSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( 每个顶点v )</span><br><span class=\"line\">\t\tif( Indegree[v]==0 )</span><br><span class=\"line\">\t\t\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=queue.dequeue();</span><br><span class=\"line\">\t\t输出或记录v;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t\tfor( v的每个结点w )</span><br><span class=\"line\">\t\t\tif( --Indegree[w]==0 )</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( cnt!=v )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tError(图中有回路)</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O(v+e)</p>\n<h3 id=\"关键路径问题\"><a href=\"#关键路径问题\" class=\"headerlink\" title=\"关键路径问题\"></a>关键路径问题</h3><p>AOE( Activity On Edge )网络</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一般用于安排项目的工序</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG\" alt=\"mark\"></p>\n<p>EarliestTime[0]=0<br>EarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG\" alt=\"mark\"></p>\n<p>LastTime[i]=min($\\in$E) { LastTime[j]-C}</p>\n<p>机动时间： D = LastTime[j]-EarlistTime[i]-C</p>\n<p>关键路径：绝对不允许延误的活动组成的路径</p>"},{"layout":"post","title":"数据结构笔记（一）：线性表","date":"2017-08-11T16:00:00.000Z","comments":1,"_content":"\n# **写在前面的话**\n\n开始数据结构的学习，将学习过程中的思维过程和代码记录下来。\n教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》\n辅以清华大学以及浙江大学的mooc。\n\n<!-- more -->\n\n# **概述**\n\n## 线性表 List\n\n线性表的定义：由同类型**数据元素**构成**有序序列**的线性结构\n\n```\n- 表中元素的个数称为线性表的**长度**\n- 线性表中没有元素时称为**空表**\n- 表起始位置称为**表头**，表结束为止称为**表尾**\n\n```\n\n线性表的操作类型：\n\n1. 静态操作：仅读取，内容和组成一般不变，如get、search\n2. 动态操作：需写入，局部或整体将改变，如insert、remove\n\n基本操作：\n\n```\n1. List MakeList()\n> 初始化一个空的线性表\n2. Element FindIndex(int index)\n> 根据位序k返回相应元素\n3. int Find(Element x)\n> 查找x第一次出现的位置\n4. void Insert(Element x , int index)\n> 在位序index前插入一个新元素x\n5. void Delete(int index)\n> 删除指定位序的元素\n\n```\n\n实现方式：\n\n```\n1. 顺序存储实现：数组\n\n```\n\n```\ntypedef struct ListNode * List\nstruct ListNode\n{\n\tElement data[MAX_SIZE];\n\tint last;\n}\n```\n\n```\n2. 链式存储实现：链表\n> 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系\n\n```\n\n以下以链表为主介绍并实现线性表\n\n## **链表特点：**\n\n动态存储：\n\n1. 各元素动态地分配和回收空间\n2. 逻辑上相邻的元素记录彼此的物理地址\n3. 动态操作高效，静态操作费时，循秩访问低效\n\n各节点通过指针或引用连接，在逻辑上形成线性序列\n\n**链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。**\n\n以下均用c++实现。\n\n# **分类**\n\n1.单向链表\n\n> 仅有succ指针\n\n2.双向链表\n\n> 有pred和succ指针\n\n3.循环单链表\n\n> 单向链表 + 末节点和首节点相连\n\n4.循环双链表\n\n> 双向链表 + 末节点和首节点相连\n\n5.静态链表\n\n> 在没有指针的语言中使用，借用数组模拟链表\n\n## **建议**\n\n使用**哨兵**节点\n\n单向链表增加**首**哨兵\n\n双向链表增加**首末**哨兵\n\n哨兵不对外公开，在一开始创建，最后销毁\n\n**优点：简化边界条件，增加鲁棒性**\n\n# **单链表**\n\n**基本定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n};\n\ntemplate < typename T >\nstruct list\n{\n    node<T> *header;\n    int _size;\n}\n```\n\n**带接口完整定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n    node( T const & e , node<T> * suc=NULL):data(e),succ(suc) {}\n    node() {succ=NULL;}\n    node<T> * insertAft( T const & e );\n};\n\ntemplate < typename T >\nstruct list\n{\nprivate:\n    node<T> *header;\n    int _size;\npublic:\n    void init ();\n    int clear ();\n    void copyNodes ( node<T> *p , int n );     \n    //从p开始复制n个节点到链表末尾\n    void merge ( node<T> *& p1, int n1, node<T> *&p2, int n2 );\n    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( node<T> *&p, int n );      \n    // 对从p开始连续的n个节点归并排序\n\n    list() { init(); }\n    list( node<T> *p , int n );     // 从p开始复制n个节点\n    ~list();\n\n    // 只读接口\n    bool empty() { return _size==0; }\n    int size() { return _size; }\n    T& operator[] ( int r ) const;    // 实现寻秩访问\n    node<T> * find( T const&e ) const;\n    node<T> * find( T const& e,  node<T>* p, int n ) const;\n    // (无序)从节点p向后n个节点（不含p）内找e\n    node<T> * search( T const & e , node<T> * p , int n ) const;\n    // (有序) 不大于e的最后一个\n    void show();\n\n    // 可写接口\n    node<T> * insertBefore( node<T> *p, T const & e );\n    node<T> * insertAfter( node<T> *p, T const & e );\n    node<T> * insertLast( T const & e );\n    node<T> * insertFirst( T const & e );\n    void createListT( T const * e , int n ); // 尾插法创建链表\n    void createListH( T const * e , int n ); // 头插法创建链表\n    T remove( node<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    void sort(); // 排序\n};\n```\n\n**基本接口**：\n\n\\1. 创建链表\n\n> 分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表\n\n\\2. 插入单节点\n\n> 分为在某节点前、后插入，在表头、表尾插入\n\n\\3. 查找数据\n\n> 无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素\n\n\\4. 循秩访问第n个节点\n\n> 可重载[]运算符，也可单独使用一个函数\n\n\\5. 删除单个节点\n\n\\6. 清空链表\n\n> 思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL\n\n\\7. 打印链表\n\n\\8. 检查链表是否为空\n\n\\9. 返回链表长度\n\n\\10. 排序（归并、插入、选择等）\n\n\\11. 去重（无序、有序版）\n\n\\12. 反转\n\n## 具体实现\n\n### 1. 创建链表\n\n1-1 创建空链表\n\n```\ntemplate < typename T >\nvoid list<T>::init()\n{\n    header = new node<T>; //构造函数已将后继默认置位NULL\n    _size=0;\n}\n```\n\n1-2 尾插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListT( T const *& e , int n )\n{\n    node<T> * last=header; // last作为链表最后一个节点\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i] );\n        last->succ=tem;  // 顺序不可反\n        last=tem;\n    }\n    return;\n}\n```\n\n1-3 头插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListH( T const *& e , int n )\n{\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i], header->succ );\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n1-4 复制链表\n\n```\ntemplate < typename T >\nlist<T>::list( node<T> * p, int n )\n{\n    init();\n    copyNodes( p , n );\n}\n\ntemplate < typename T >\nvoid list<T>::copyNodes( node<T> * p, int n )\n{\n    node<T> *tem=header;\n    while( tem->succ ) // 先探好路再迈步\n        tem=tem->succ;  // tem指向存在的最后一个元素\n    node<T> *create;\n    _size+=n;\n    while(n--)\n    {\n        create=new node<T> ( p->data );\n        tem->succ=create;\n        p=p->succ;\n        tem=tem->succ;  // 实时更新链表尾\n    }\n    return;\n}\n```\n\n### 2. 插入单节点\n\n2-0. 准备：node类的插入函数\n\n```\ntemplate < typename T >\nnode<T> * node<T>::insertAft( T const & e )\n{\n    node<T> *tem=new node<T>( e , succ );\n    succ=tem;\n    return tem;\n}\n```\n\n2-1. 在某节点前插入\n\n```\ntemplate < typename T >\nnode<T> * insertBefore( node<T> *p, T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( (tem=tem->succ)!=p );\n    return tem->insertAft(e);\n}\n```\n\n2-2. 在某节点后插入\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertAfter( node<T> *p, T const & e)\n{\n    _size++;\n    return p->insertAft(e);\n}\n```\n\n2-3. 插入表头\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertFirst( T const & e )\n{\n    _size++;\n    return header->insertAft(e);\n}\n```\n\n2-4. 插入表尾\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertLast( T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( tem->succ )\n        tem=tem->succ;\n    return tem->insertAft(e);\n}\n```\n\n### 3. 查找元素\n\n3-1. 无序链表查找\n\n3-1-0. 整链表查找\n\n```\ntemplate < typename T >\nnode<T> * list<T>::find( T const& e ) const\n{\n    return find( e, header, ,_size );\n}\n```\n\n3-1-1. 部分链表查找\n\n```\ntemplate <typename T>\nnode<T> * list<T>::find( T const& e, node<T>* p , int n ) const\n{  ( p , p+n ]\n    while(n--)\n        if( e==( p=p->succ )->data )\n            return p;\n    return NULL;\n}\n```\n\n3-2. 有序链表查找\n\n返回不大于e的最后一个元素，方便后续插入操作\n\n此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低\n\n```\ntemplate <typename T>\nnode<T> * list<T>::search( T const & e, node<T> * p, int n ) const\n{  [ p , p+n )\n    node<T> *tem=header;  // tem作为p的直接前驱\n    while( tem->succ != p )\n        tem=tem->succ;\n    while( n-- &&p )\n    {\n        if( p->data>e )\n            break;\n        p=p->succ;\n        tem=tem->succ;\n    }\n    return tem;\n}\n```\n\n### 4. 循秩访问单个节点\n\n方式：重载()运算符\n\n```\ntemplate <typename T>\nT & list<T>::operator [] (int r) const\n{\n    node<T> *p=header;\n    while( ( p=p->succ ) && r-- );\n    return p->data;\n}\n```\n\n此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问**本质不同**。\n\n链表的为披着循秩访问外皮的按位置访问。\n\n而顺序表 V[i] = V + i*s (s为单个元素大小)\n\n时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。\n\n### 5. 删除单个节点\n\n```\ntemplate <typename T>\nT list<T>::remove( node<T> * p )\n{\n    T tem=p->data;\n    node<T> *pre=header;\n    while( pre->succ!=p )\n        pre=pre->succ;\n    pre->succ=p->succ;\n    delete p;\n    _size--;\n    return tem;\n}\n```\n\n### 6. 清空链表\n\n```\ntemplate <typename T>\nint list<T>::clear()\n{\n    int old_size=_size;\n    if( header->succ==NULL )\n        return 0;\n    while( header->succ )\n        remove( header->succ );\n    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零\n    return old_size;\n}\n```\n\n### 10. 排序\n\n10-1 归并排序\n\n归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾\n\n该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上\n\n```\ntemplate <typename T>\nvoid list<T>::merge ( node<T> * &p1, int n1, node<T> *&p2, int n2 ) //使用引用绑定节点防止丢失\n{\n    node<T> *head;\n    node<T> *pree=header;\n    while( pree->succ!=p1 )\n        pree=pree->succ;\n    head=pree;\n    node<T> *px1=p1,*px2=p2,*px3;\n    for(int i=0; i<n1-1 ; i++)\n        px1=px1->succ;\n    for(int i=0; i<n2-1 ; i++)\n        px2=px2->succ;\n    px3=px2->succ;\n    px1->succ=px2->succ=NULL;\n    px1=p1;\n    while( n1&&n2 )\n    {\n        if( px1->data<=p2->data )\n        {\n            pree->succ=px1;\n            pree=pree->succ;\n            px1=px1->succ;\n            n1--;\n        }\n        else\n        {\n            pree->succ=p2;\n            pree=pree->succ;\n            p2=p2->succ;\n            n2--;\n        }\n    }\n    if( n1 )\n        pree->succ=px1;\n    if( n2 )\n        pree->succ=p2;\n    while( pree->succ )\n        pree=pree->succ;\n    pree->succ=px3;\n    p1=head->succ;  // 最后设置好排序后的头结点\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::mergeSort( node<T> *&p, int n )\n{ // [ p, p+n ]\n    if(n<2) return;\n    int mid=n/2;\n    node<T> *tem=p;\n    for(int i=0; i<mid; i++)  tem=tem->succ;\n    mergeSort( p, mid );\n    mergeSort( tem, n-mid );\n    merge( p,mid, tem , n-mid );\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::sort( )\n{\n    mergeSort( header->succ , _size );\n}\n```\n\n### 11. 去重\n\n11-1. 无序链表\n\n常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)\n\n其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)\n\n```\ntemplate <typename T>\nint list<T>::deduplicate()\n{\n    if( _size<2 ) // 少于2个节点无需去重\n        return;\n    node<T> *p=header->succ->succ; //第一个节点必定已去重\n    node<T> *pre=header->succ;\n    int old_size=_size;  // 保存_size，方便返回删除数目\n    int r=1;  // 已去重数目\n    while( p )\n    {\n        if( find( p->data , header , r )!=NULL )\n        {    // 借用find接口\n            pre->succ=p->succ;\n            delete p;\n            p=pre->succ;\n            continue;\n        }\n        r++;\n        p=p->succ;\n        pre=pre->succ;\n    }\n    return old_size-_size;\n}\n```\n\n11-2. 有序链表\n\n思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)\n\n```\ntemplate <typename T>\nint list<T>::uniquify()\n{\n    if(_size<2)\n        return 0;\n    int old_size=_size;\n    node<T> *p=header->succ,*q;\n    while( NULL != ( q = p->succ ) ) // q作为p的直接后继，检测是否重复\n        (p->data == q->data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步\n    return old_size-_size;\n}\n```\n\n### 12. 反转\n\n思路：固定目前的首节点，即header->succ，每次将它的直接后继重新绑定至header的直接后继。\n\n```\ntemplate <typename T>\nvoid list<T>::reverse()\n{\n    if(_size<2)\n        return;\n    node<T> *fir=header->succ;\n    node<T> *tem;\n    while( fir->succ )\n    {\n        tem=fir->succ;\n        fir->succ=tem->succ;\n        tem->succ=header->succ;\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n# **双向链表**\n\n双链表和单链表类似，但不同在于有**首末**两个哨兵，每个节点有**前驱**和**后缀**指针，可以省去从头访问到某节点的前驱的时间。\n\n代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。\n\n**基本定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n};\ntemplate <typename T>\nstruct List\n{\n    int _size ;\n    ListNode<T> * header,*trailer;\n};\n```\n\n**带接口定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n    //列表节点模板类（以双向链表形式实现）\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n\n    ListNode () {}\n    ListNode ( T const & e, ListNode<T> * p = NULL, ListNode<T> *a = NULL)\n        :data(e),pred(p),succ(a){}\n\n    ListNode<T> * insertAsPred ( T const & e );\n    ListNode<T> * insertAsSucc ( T const & e );\n};\n\ntemplate <typename T>\nstruct List\n{\nprivate:\n\n    int _size ;\n    ListNode<T> * header,*trailer;\n\nprotected:\n    void init ();\n    void merge ( ListNode<T> * p1, int n1 , List<T>&L,  ListNode<T> *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( ListNode<T> *p, int n );      // 对从p开始连续的n个节点归并排序\n    void selectionSort ( ListNode<T> *p, int n );   // [ p,p+n ) 选择排序\n    void insertionSort ( ListNode<T> *p, int n );   // 对从p开始连续的n个节点插入排序\n\npublic:\n    List() { init(); }\n    List( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    List( T *p , int n );\n    ~List();\n\n    // 只读接口\n    int size() const { return _size; }\n    bool empty() { return _size==0; }\n    T & operator [] ( int r ) const;    // 实现寻秩访问\n    ListNode<T> * first()const\n        {return header->succ;}\n    ListNode<T> * last() const\n        {return trailer->pred;}\n    ListNode<T> * find( T const&e ) const\n        {return find(e,_size,trailer);}\n    ListNode<T> * find( T const& e, int n, ListNode<T>* p ) const; // (无序)从节点p向前n个节点（不含p）内找e\n    ListNode<T> * search( T const & e , int n , ListNode<T> * p ) const; // (有序) 不大于e的最后一个\n    ListNode<T> * selectMax ( ListNode<T> *p , int n )const ;\n    void show() const;\n\n    // 可写接口\n    ListNode<T> * insertBefore( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsPred(e); }\n    ListNode<T> * insertAfter( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsSucc(e); }\n    ListNode<T> * insertLast( T const & e )\n        { _size++; return trailer->insertAsPred(e);}\n    ListNode<T> * insertFirst( T const & e )\n        { _size++; return header->insertAsSucc(e);}\n    T remove( ListNode<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    int clear ();\n    void copyNodes ( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    void sort( ListNode<T> *p, int n, int mod );\n};\n```\n\n## 1. 排序\n\n1-1. 插入排序\n\n思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。\n\n```\ntemplate <typename T>\nvoid List<T>::insertionSort( ListNode<T> * p , int n )\n{\n    for(int r=0; r<n; r++)\n    {\n        insertAfter( search( p->data , r , p ) , p->data );\n        p=p->succ;\n        remove( p->pred );\n    }\n}\n\ntemplate <typename T>\nT List<T>::remove( ListNode<T> * p )\n{\n    T tem=p->data;\n    p->pred->succ=p->succ;\n    p->succ->pred=p->pred;\n    delete p;\n    _size--;\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsSucc( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, this, succ );\n    succ->pred=a;\n    succ=a;\n    return a;\n}\n```\n\n1-2. 选择排序\n\n思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。\n\n```\ntemplate <typename T>\nvoid List<T>::selectionSort( ListNode<T> *p, int n )\n{\n    if(n<2) return;\n    ListNode<T> *head=p->pred , *tail=p;\n    for( int i=0; i<n; i++ )\n        tail=tail->succ;\n    while( 1<n )\n    {\n        insertBefore( tail, remove( selectMax( head->succ , n ) ) );\n        tail=tail->pred;\n        n--;\n    }\n    return;\n}\ntemplate <typename T>\nListNode<T> * List<T>::selectMax ( ListNode<T> *p , int n )const\n{\n    ListNode<T> *tem=p;\n    while(n--&&p)\n    {\n        if(p->data>=tem->data)\n            tem=p;\n        p=p->succ;\n    }\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsPred( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, pred, this );\n    pred->succ=a;\n    pred=a;\n    return a;\n}\n```\n\n# **常见的链表问题**\n\n最常用方法：\n\n> 1. **快慢指针法**\n> 2. **数组过渡法**\n> 3. **先断后接、先接后断法**\n\n\\1. 单链表反转\n\n> 两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。\n\n\\2. 找单链表倒数第n个元素、或中间元素\n\n> 快慢指针法。\n>\n> 找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）\n>\n> 找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。\n>\n> 找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。\n\n\\3. 删除无头单链表的某个节点\n\n> 题意为不知header，但需要删除目前current指针指向的节点。\n>\n> 思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。\n\n\\4. 在无头单链表某节点前增加节点\n\n> 思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。\n\n\\5. 判断单链表是否有环(可能是部分环，非循环单链表)\n\n> 快慢指针法\n>\n> 一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。\n\n\\6. 判断两单链表是否相交\n\n> 首先明确：两单链表一旦相交，自交点之后的节点将完全相同！\n>\n> 时间复杂度均为O( len1+len2 )\n>\n> 1. 法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素\n> 2. 法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。\n> 3. 法3：直接法：直接判断两链表末节点是否相同\n\n\\7. 已知两单链表相交，求相交点\n\n> 快慢指针法\n>\n> 先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点\n\n\\8. 求两递增单链表AB差集A-B(元素在A而不在B)\n\n> 归并的思想\n>\n> 每次取表头元素进行大小判断，若A’<’B则通过，若A==B则剃除，若A>B则将B指针向后移动直至A’<’B或A==B\n\n# **完整实现代码**\n\n[单向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/single_list.cpp)\n\n[双向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/double_list.cpp)","source":"_posts/DataStructure_List.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（一）：线性表\"\ndate: 2017-08-12\ncomments: true\ntags: \n    - 学习笔记\n    - c++\n    - 数据结构\n\n---\n\n# **写在前面的话**\n\n开始数据结构的学习，将学习过程中的思维过程和代码记录下来。\n教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》\n辅以清华大学以及浙江大学的mooc。\n\n<!-- more -->\n\n# **概述**\n\n## 线性表 List\n\n线性表的定义：由同类型**数据元素**构成**有序序列**的线性结构\n\n```\n- 表中元素的个数称为线性表的**长度**\n- 线性表中没有元素时称为**空表**\n- 表起始位置称为**表头**，表结束为止称为**表尾**\n\n```\n\n线性表的操作类型：\n\n1. 静态操作：仅读取，内容和组成一般不变，如get、search\n2. 动态操作：需写入，局部或整体将改变，如insert、remove\n\n基本操作：\n\n```\n1. List MakeList()\n> 初始化一个空的线性表\n2. Element FindIndex(int index)\n> 根据位序k返回相应元素\n3. int Find(Element x)\n> 查找x第一次出现的位置\n4. void Insert(Element x , int index)\n> 在位序index前插入一个新元素x\n5. void Delete(int index)\n> 删除指定位序的元素\n\n```\n\n实现方式：\n\n```\n1. 顺序存储实现：数组\n\n```\n\n```\ntypedef struct ListNode * List\nstruct ListNode\n{\n\tElement data[MAX_SIZE];\n\tint last;\n}\n```\n\n```\n2. 链式存储实现：链表\n> 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系\n\n```\n\n以下以链表为主介绍并实现线性表\n\n## **链表特点：**\n\n动态存储：\n\n1. 各元素动态地分配和回收空间\n2. 逻辑上相邻的元素记录彼此的物理地址\n3. 动态操作高效，静态操作费时，循秩访问低效\n\n各节点通过指针或引用连接，在逻辑上形成线性序列\n\n**链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。**\n\n以下均用c++实现。\n\n# **分类**\n\n1.单向链表\n\n> 仅有succ指针\n\n2.双向链表\n\n> 有pred和succ指针\n\n3.循环单链表\n\n> 单向链表 + 末节点和首节点相连\n\n4.循环双链表\n\n> 双向链表 + 末节点和首节点相连\n\n5.静态链表\n\n> 在没有指针的语言中使用，借用数组模拟链表\n\n## **建议**\n\n使用**哨兵**节点\n\n单向链表增加**首**哨兵\n\n双向链表增加**首末**哨兵\n\n哨兵不对外公开，在一开始创建，最后销毁\n\n**优点：简化边界条件，增加鲁棒性**\n\n# **单链表**\n\n**基本定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n};\n\ntemplate < typename T >\nstruct list\n{\n    node<T> *header;\n    int _size;\n}\n```\n\n**带接口完整定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n    node( T const & e , node<T> * suc=NULL):data(e),succ(suc) {}\n    node() {succ=NULL;}\n    node<T> * insertAft( T const & e );\n};\n\ntemplate < typename T >\nstruct list\n{\nprivate:\n    node<T> *header;\n    int _size;\npublic:\n    void init ();\n    int clear ();\n    void copyNodes ( node<T> *p , int n );     \n    //从p开始复制n个节点到链表末尾\n    void merge ( node<T> *& p1, int n1, node<T> *&p2, int n2 );\n    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( node<T> *&p, int n );      \n    // 对从p开始连续的n个节点归并排序\n\n    list() { init(); }\n    list( node<T> *p , int n );     // 从p开始复制n个节点\n    ~list();\n\n    // 只读接口\n    bool empty() { return _size==0; }\n    int size() { return _size; }\n    T& operator[] ( int r ) const;    // 实现寻秩访问\n    node<T> * find( T const&e ) const;\n    node<T> * find( T const& e,  node<T>* p, int n ) const;\n    // (无序)从节点p向后n个节点（不含p）内找e\n    node<T> * search( T const & e , node<T> * p , int n ) const;\n    // (有序) 不大于e的最后一个\n    void show();\n\n    // 可写接口\n    node<T> * insertBefore( node<T> *p, T const & e );\n    node<T> * insertAfter( node<T> *p, T const & e );\n    node<T> * insertLast( T const & e );\n    node<T> * insertFirst( T const & e );\n    void createListT( T const * e , int n ); // 尾插法创建链表\n    void createListH( T const * e , int n ); // 头插法创建链表\n    T remove( node<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    void sort(); // 排序\n};\n```\n\n**基本接口**：\n\n\\1. 创建链表\n\n> 分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表\n\n\\2. 插入单节点\n\n> 分为在某节点前、后插入，在表头、表尾插入\n\n\\3. 查找数据\n\n> 无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素\n\n\\4. 循秩访问第n个节点\n\n> 可重载[]运算符，也可单独使用一个函数\n\n\\5. 删除单个节点\n\n\\6. 清空链表\n\n> 思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL\n\n\\7. 打印链表\n\n\\8. 检查链表是否为空\n\n\\9. 返回链表长度\n\n\\10. 排序（归并、插入、选择等）\n\n\\11. 去重（无序、有序版）\n\n\\12. 反转\n\n## 具体实现\n\n### 1. 创建链表\n\n1-1 创建空链表\n\n```\ntemplate < typename T >\nvoid list<T>::init()\n{\n    header = new node<T>; //构造函数已将后继默认置位NULL\n    _size=0;\n}\n```\n\n1-2 尾插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListT( T const *& e , int n )\n{\n    node<T> * last=header; // last作为链表最后一个节点\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i] );\n        last->succ=tem;  // 顺序不可反\n        last=tem;\n    }\n    return;\n}\n```\n\n1-3 头插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListH( T const *& e , int n )\n{\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i], header->succ );\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n1-4 复制链表\n\n```\ntemplate < typename T >\nlist<T>::list( node<T> * p, int n )\n{\n    init();\n    copyNodes( p , n );\n}\n\ntemplate < typename T >\nvoid list<T>::copyNodes( node<T> * p, int n )\n{\n    node<T> *tem=header;\n    while( tem->succ ) // 先探好路再迈步\n        tem=tem->succ;  // tem指向存在的最后一个元素\n    node<T> *create;\n    _size+=n;\n    while(n--)\n    {\n        create=new node<T> ( p->data );\n        tem->succ=create;\n        p=p->succ;\n        tem=tem->succ;  // 实时更新链表尾\n    }\n    return;\n}\n```\n\n### 2. 插入单节点\n\n2-0. 准备：node类的插入函数\n\n```\ntemplate < typename T >\nnode<T> * node<T>::insertAft( T const & e )\n{\n    node<T> *tem=new node<T>( e , succ );\n    succ=tem;\n    return tem;\n}\n```\n\n2-1. 在某节点前插入\n\n```\ntemplate < typename T >\nnode<T> * insertBefore( node<T> *p, T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( (tem=tem->succ)!=p );\n    return tem->insertAft(e);\n}\n```\n\n2-2. 在某节点后插入\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertAfter( node<T> *p, T const & e)\n{\n    _size++;\n    return p->insertAft(e);\n}\n```\n\n2-3. 插入表头\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertFirst( T const & e )\n{\n    _size++;\n    return header->insertAft(e);\n}\n```\n\n2-4. 插入表尾\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertLast( T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( tem->succ )\n        tem=tem->succ;\n    return tem->insertAft(e);\n}\n```\n\n### 3. 查找元素\n\n3-1. 无序链表查找\n\n3-1-0. 整链表查找\n\n```\ntemplate < typename T >\nnode<T> * list<T>::find( T const& e ) const\n{\n    return find( e, header, ,_size );\n}\n```\n\n3-1-1. 部分链表查找\n\n```\ntemplate <typename T>\nnode<T> * list<T>::find( T const& e, node<T>* p , int n ) const\n{  ( p , p+n ]\n    while(n--)\n        if( e==( p=p->succ )->data )\n            return p;\n    return NULL;\n}\n```\n\n3-2. 有序链表查找\n\n返回不大于e的最后一个元素，方便后续插入操作\n\n此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低\n\n```\ntemplate <typename T>\nnode<T> * list<T>::search( T const & e, node<T> * p, int n ) const\n{  [ p , p+n )\n    node<T> *tem=header;  // tem作为p的直接前驱\n    while( tem->succ != p )\n        tem=tem->succ;\n    while( n-- &&p )\n    {\n        if( p->data>e )\n            break;\n        p=p->succ;\n        tem=tem->succ;\n    }\n    return tem;\n}\n```\n\n### 4. 循秩访问单个节点\n\n方式：重载()运算符\n\n```\ntemplate <typename T>\nT & list<T>::operator [] (int r) const\n{\n    node<T> *p=header;\n    while( ( p=p->succ ) && r-- );\n    return p->data;\n}\n```\n\n此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问**本质不同**。\n\n链表的为披着循秩访问外皮的按位置访问。\n\n而顺序表 V[i] = V + i*s (s为单个元素大小)\n\n时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。\n\n### 5. 删除单个节点\n\n```\ntemplate <typename T>\nT list<T>::remove( node<T> * p )\n{\n    T tem=p->data;\n    node<T> *pre=header;\n    while( pre->succ!=p )\n        pre=pre->succ;\n    pre->succ=p->succ;\n    delete p;\n    _size--;\n    return tem;\n}\n```\n\n### 6. 清空链表\n\n```\ntemplate <typename T>\nint list<T>::clear()\n{\n    int old_size=_size;\n    if( header->succ==NULL )\n        return 0;\n    while( header->succ )\n        remove( header->succ );\n    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零\n    return old_size;\n}\n```\n\n### 10. 排序\n\n10-1 归并排序\n\n归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾\n\n该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上\n\n```\ntemplate <typename T>\nvoid list<T>::merge ( node<T> * &p1, int n1, node<T> *&p2, int n2 ) //使用引用绑定节点防止丢失\n{\n    node<T> *head;\n    node<T> *pree=header;\n    while( pree->succ!=p1 )\n        pree=pree->succ;\n    head=pree;\n    node<T> *px1=p1,*px2=p2,*px3;\n    for(int i=0; i<n1-1 ; i++)\n        px1=px1->succ;\n    for(int i=0; i<n2-1 ; i++)\n        px2=px2->succ;\n    px3=px2->succ;\n    px1->succ=px2->succ=NULL;\n    px1=p1;\n    while( n1&&n2 )\n    {\n        if( px1->data<=p2->data )\n        {\n            pree->succ=px1;\n            pree=pree->succ;\n            px1=px1->succ;\n            n1--;\n        }\n        else\n        {\n            pree->succ=p2;\n            pree=pree->succ;\n            p2=p2->succ;\n            n2--;\n        }\n    }\n    if( n1 )\n        pree->succ=px1;\n    if( n2 )\n        pree->succ=p2;\n    while( pree->succ )\n        pree=pree->succ;\n    pree->succ=px3;\n    p1=head->succ;  // 最后设置好排序后的头结点\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::mergeSort( node<T> *&p, int n )\n{ // [ p, p+n ]\n    if(n<2) return;\n    int mid=n/2;\n    node<T> *tem=p;\n    for(int i=0; i<mid; i++)  tem=tem->succ;\n    mergeSort( p, mid );\n    mergeSort( tem, n-mid );\n    merge( p,mid, tem , n-mid );\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::sort( )\n{\n    mergeSort( header->succ , _size );\n}\n```\n\n### 11. 去重\n\n11-1. 无序链表\n\n常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)\n\n其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)\n\n```\ntemplate <typename T>\nint list<T>::deduplicate()\n{\n    if( _size<2 ) // 少于2个节点无需去重\n        return;\n    node<T> *p=header->succ->succ; //第一个节点必定已去重\n    node<T> *pre=header->succ;\n    int old_size=_size;  // 保存_size，方便返回删除数目\n    int r=1;  // 已去重数目\n    while( p )\n    {\n        if( find( p->data , header , r )!=NULL )\n        {    // 借用find接口\n            pre->succ=p->succ;\n            delete p;\n            p=pre->succ;\n            continue;\n        }\n        r++;\n        p=p->succ;\n        pre=pre->succ;\n    }\n    return old_size-_size;\n}\n```\n\n11-2. 有序链表\n\n思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)\n\n```\ntemplate <typename T>\nint list<T>::uniquify()\n{\n    if(_size<2)\n        return 0;\n    int old_size=_size;\n    node<T> *p=header->succ,*q;\n    while( NULL != ( q = p->succ ) ) // q作为p的直接后继，检测是否重复\n        (p->data == q->data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步\n    return old_size-_size;\n}\n```\n\n### 12. 反转\n\n思路：固定目前的首节点，即header->succ，每次将它的直接后继重新绑定至header的直接后继。\n\n```\ntemplate <typename T>\nvoid list<T>::reverse()\n{\n    if(_size<2)\n        return;\n    node<T> *fir=header->succ;\n    node<T> *tem;\n    while( fir->succ )\n    {\n        tem=fir->succ;\n        fir->succ=tem->succ;\n        tem->succ=header->succ;\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n# **双向链表**\n\n双链表和单链表类似，但不同在于有**首末**两个哨兵，每个节点有**前驱**和**后缀**指针，可以省去从头访问到某节点的前驱的时间。\n\n代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。\n\n**基本定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n};\ntemplate <typename T>\nstruct List\n{\n    int _size ;\n    ListNode<T> * header,*trailer;\n};\n```\n\n**带接口定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n    //列表节点模板类（以双向链表形式实现）\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n\n    ListNode () {}\n    ListNode ( T const & e, ListNode<T> * p = NULL, ListNode<T> *a = NULL)\n        :data(e),pred(p),succ(a){}\n\n    ListNode<T> * insertAsPred ( T const & e );\n    ListNode<T> * insertAsSucc ( T const & e );\n};\n\ntemplate <typename T>\nstruct List\n{\nprivate:\n\n    int _size ;\n    ListNode<T> * header,*trailer;\n\nprotected:\n    void init ();\n    void merge ( ListNode<T> * p1, int n1 , List<T>&L,  ListNode<T> *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( ListNode<T> *p, int n );      // 对从p开始连续的n个节点归并排序\n    void selectionSort ( ListNode<T> *p, int n );   // [ p,p+n ) 选择排序\n    void insertionSort ( ListNode<T> *p, int n );   // 对从p开始连续的n个节点插入排序\n\npublic:\n    List() { init(); }\n    List( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    List( T *p , int n );\n    ~List();\n\n    // 只读接口\n    int size() const { return _size; }\n    bool empty() { return _size==0; }\n    T & operator [] ( int r ) const;    // 实现寻秩访问\n    ListNode<T> * first()const\n        {return header->succ;}\n    ListNode<T> * last() const\n        {return trailer->pred;}\n    ListNode<T> * find( T const&e ) const\n        {return find(e,_size,trailer);}\n    ListNode<T> * find( T const& e, int n, ListNode<T>* p ) const; // (无序)从节点p向前n个节点（不含p）内找e\n    ListNode<T> * search( T const & e , int n , ListNode<T> * p ) const; // (有序) 不大于e的最后一个\n    ListNode<T> * selectMax ( ListNode<T> *p , int n )const ;\n    void show() const;\n\n    // 可写接口\n    ListNode<T> * insertBefore( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsPred(e); }\n    ListNode<T> * insertAfter( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsSucc(e); }\n    ListNode<T> * insertLast( T const & e )\n        { _size++; return trailer->insertAsPred(e);}\n    ListNode<T> * insertFirst( T const & e )\n        { _size++; return header->insertAsSucc(e);}\n    T remove( ListNode<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    int clear ();\n    void copyNodes ( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    void sort( ListNode<T> *p, int n, int mod );\n};\n```\n\n## 1. 排序\n\n1-1. 插入排序\n\n思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。\n\n```\ntemplate <typename T>\nvoid List<T>::insertionSort( ListNode<T> * p , int n )\n{\n    for(int r=0; r<n; r++)\n    {\n        insertAfter( search( p->data , r , p ) , p->data );\n        p=p->succ;\n        remove( p->pred );\n    }\n}\n\ntemplate <typename T>\nT List<T>::remove( ListNode<T> * p )\n{\n    T tem=p->data;\n    p->pred->succ=p->succ;\n    p->succ->pred=p->pred;\n    delete p;\n    _size--;\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsSucc( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, this, succ );\n    succ->pred=a;\n    succ=a;\n    return a;\n}\n```\n\n1-2. 选择排序\n\n思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。\n\n```\ntemplate <typename T>\nvoid List<T>::selectionSort( ListNode<T> *p, int n )\n{\n    if(n<2) return;\n    ListNode<T> *head=p->pred , *tail=p;\n    for( int i=0; i<n; i++ )\n        tail=tail->succ;\n    while( 1<n )\n    {\n        insertBefore( tail, remove( selectMax( head->succ , n ) ) );\n        tail=tail->pred;\n        n--;\n    }\n    return;\n}\ntemplate <typename T>\nListNode<T> * List<T>::selectMax ( ListNode<T> *p , int n )const\n{\n    ListNode<T> *tem=p;\n    while(n--&&p)\n    {\n        if(p->data>=tem->data)\n            tem=p;\n        p=p->succ;\n    }\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsPred( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, pred, this );\n    pred->succ=a;\n    pred=a;\n    return a;\n}\n```\n\n# **常见的链表问题**\n\n最常用方法：\n\n> 1. **快慢指针法**\n> 2. **数组过渡法**\n> 3. **先断后接、先接后断法**\n\n\\1. 单链表反转\n\n> 两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。\n\n\\2. 找单链表倒数第n个元素、或中间元素\n\n> 快慢指针法。\n>\n> 找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）\n>\n> 找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。\n>\n> 找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。\n\n\\3. 删除无头单链表的某个节点\n\n> 题意为不知header，但需要删除目前current指针指向的节点。\n>\n> 思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。\n\n\\4. 在无头单链表某节点前增加节点\n\n> 思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。\n\n\\5. 判断单链表是否有环(可能是部分环，非循环单链表)\n\n> 快慢指针法\n>\n> 一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。\n\n\\6. 判断两单链表是否相交\n\n> 首先明确：两单链表一旦相交，自交点之后的节点将完全相同！\n>\n> 时间复杂度均为O( len1+len2 )\n>\n> 1. 法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素\n> 2. 法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。\n> 3. 法3：直接法：直接判断两链表末节点是否相同\n\n\\7. 已知两单链表相交，求相交点\n\n> 快慢指针法\n>\n> 先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点\n\n\\8. 求两递增单链表AB差集A-B(元素在A而不在B)\n\n> 归并的思想\n>\n> 每次取表头元素进行大小判断，若A’<’B则通过，若A==B则剃除，若A>B则将B指针向后移动直至A’<’B或A==B\n\n# **完整实现代码**\n\n[单向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/single_list.cpp)\n\n[双向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/double_list.cpp)","slug":"DataStructure_List","published":1,"updated":"2018-05-25T12:41:12.233Z","photos":[],"link":"","_id":"cjleshqj90007ryfctwgswupg","content":"<h1 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a><strong>写在前面的话</strong></h1><p>开始数据结构的学习，将学习过程中的思维过程和代码记录下来。<br>教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》<br>辅以清华大学以及浙江大学的mooc。</p>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><h2 id=\"线性表-List\"><a href=\"#线性表-List\" class=\"headerlink\" title=\"线性表 List\"></a>线性表 List</h2><p>线性表的定义：由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表中元素的个数称为线性表的**长度**</span><br><span class=\"line\">- 线性表中没有元素时称为**空表**</span><br><span class=\"line\">- 表起始位置称为**表头**，表结束为止称为**表尾**</span><br></pre></td></tr></table></figure>\n<p>线性表的操作类型：</p>\n<ol>\n<li>静态操作：仅读取，内容和组成一般不变，如get、search</li>\n<li>动态操作：需写入，局部或整体将改变，如insert、remove</li>\n</ol>\n<p>基本操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. List MakeList()</span><br><span class=\"line\">&gt; 初始化一个空的线性表</span><br><span class=\"line\">2. Element FindIndex(int index)</span><br><span class=\"line\">&gt; 根据位序k返回相应元素</span><br><span class=\"line\">3. int Find(Element x)</span><br><span class=\"line\">&gt; 查找x第一次出现的位置</span><br><span class=\"line\">4. void Insert(Element x , int index)</span><br><span class=\"line\">&gt; 在位序index前插入一个新元素x</span><br><span class=\"line\">5. void Delete(int index)</span><br><span class=\"line\">&gt; 删除指定位序的元素</span><br></pre></td></tr></table></figure>\n<p>实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 顺序存储实现：数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct ListNode * List</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tElement data[MAX_SIZE];</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 链式存储实现：链表</span><br><span class=\"line\">&gt; 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系</span><br></pre></td></tr></table></figure>\n<p>以下以链表为主介绍并实现线性表</p>\n<h2 id=\"链表特点：\"><a href=\"#链表特点：\" class=\"headerlink\" title=\"链表特点：\"></a><strong>链表特点：</strong></h2><p>动态存储：</p>\n<ol>\n<li>各元素动态地分配和回收空间</li>\n<li>逻辑上相邻的元素记录彼此的物理地址</li>\n<li>动态操作高效，静态操作费时，循秩访问低效</li>\n</ol>\n<p>各节点通过指针或引用连接，在逻辑上形成线性序列</p>\n<p><strong>链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。</strong></p>\n<p>以下均用c++实现。</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a><strong>分类</strong></h1><p>1.单向链表</p>\n<blockquote>\n<p>仅有succ指针</p>\n</blockquote>\n<p>2.双向链表</p>\n<blockquote>\n<p>有pred和succ指针</p>\n</blockquote>\n<p>3.循环单链表</p>\n<blockquote>\n<p>单向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>4.循环双链表</p>\n<blockquote>\n<p>双向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>5.静态链表</p>\n<blockquote>\n<p>在没有指针的语言中使用，借用数组模拟链表</p>\n</blockquote>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a><strong>建议</strong></h2><p>使用<strong>哨兵</strong>节点</p>\n<p>单向链表增加<strong>首</strong>哨兵</p>\n<p>双向链表增加<strong>首末</strong>哨兵</p>\n<p>哨兵不对外公开，在一开始创建，最后销毁</p>\n<p><strong>优点：简化边界条件，增加鲁棒性</strong></p>\n<h1 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a><strong>单链表</strong></h1><p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口完整定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">    node( T const &amp; e , node&lt;T&gt; * suc=NULL):data(e),succ(suc) &#123;&#125;</span><br><span class=\"line\">    node() &#123;succ=NULL;&#125;</span><br><span class=\"line\">    node&lt;T&gt; * insertAft( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( node&lt;T&gt; *p , int n );     </span><br><span class=\"line\">    //从p开始复制n个节点到链表末尾</span><br><span class=\"line\">    void merge ( node&lt;T&gt; *&amp; p1, int n1, node&lt;T&gt; *&amp;p2, int n2 );</span><br><span class=\"line\">    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( node&lt;T&gt; *&amp;p, int n );      </span><br><span class=\"line\">    // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\"></span><br><span class=\"line\">    list() &#123; init(); &#125;</span><br><span class=\"line\">    list( node&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    ~list();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    int size() &#123; return _size; &#125;</span><br><span class=\"line\">    T&amp; operator[] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp;e ) const;</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp; e,  node&lt;T&gt;* p, int n ) const;</span><br><span class=\"line\">    // (无序)从节点p向后n个节点（不含p）内找e</span><br><span class=\"line\">    node&lt;T&gt; * search( T const &amp; e , node&lt;T&gt; * p , int n ) const;</span><br><span class=\"line\">    // (有序) 不大于e的最后一个</span><br><span class=\"line\">    void show();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertAfter( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertLast( T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertFirst( T const &amp; e );</span><br><span class=\"line\">    void createListT( T const * e , int n ); // 尾插法创建链表</span><br><span class=\"line\">    void createListH( T const * e , int n ); // 头插法创建链表</span><br><span class=\"line\">    T remove( node&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    void sort(); // 排序</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>基本接口</strong>：</p>\n<p>\\1. 创建链表</p>\n<blockquote>\n<p>分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表</p>\n</blockquote>\n<p>\\2. 插入单节点</p>\n<blockquote>\n<p>分为在某节点前、后插入，在表头、表尾插入</p>\n</blockquote>\n<p>\\3. 查找数据</p>\n<blockquote>\n<p>无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素</p>\n</blockquote>\n<p>\\4. 循秩访问第n个节点</p>\n<blockquote>\n<p>可重载[]运算符，也可单独使用一个函数</p>\n</blockquote>\n<p>\\5. 删除单个节点</p>\n<p>\\6. 清空链表</p>\n<blockquote>\n<p>思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL</p>\n</blockquote>\n<p>\\7. 打印链表</p>\n<p>\\8. 检查链表是否为空</p>\n<p>\\9. 返回链表长度</p>\n<p>\\10. 排序（归并、插入、选择等）</p>\n<p>\\11. 去重（无序、有序版）</p>\n<p>\\12. 反转</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"1-创建链表\"><a href=\"#1-创建链表\" class=\"headerlink\" title=\"1. 创建链表\"></a>1. 创建链表</h3><p>1-1 创建空链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    header = new node&lt;T&gt;; //构造函数已将后继默认置位NULL</span><br><span class=\"line\">    _size=0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2 尾插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListT( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * last=header; // last作为链表最后一个节点</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i] );</span><br><span class=\"line\">        last-&gt;succ=tem;  // 顺序不可反</span><br><span class=\"line\">        last=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-3 头插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListH( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i], header-&gt;succ );</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-4 复制链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">list&lt;T&gt;::list( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    copyNodes( p , n );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::copyNodes( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ ) // 先探好路再迈步</span><br><span class=\"line\">        tem=tem-&gt;succ;  // tem指向存在的最后一个元素</span><br><span class=\"line\">    node&lt;T&gt; *create;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        create=new node&lt;T&gt; ( p-&gt;data );</span><br><span class=\"line\">        tem-&gt;succ=create;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;  // 实时更新链表尾</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-插入单节点\"><a href=\"#2-插入单节点\" class=\"headerlink\" title=\"2. 插入单节点\"></a>2. 插入单节点</h3><p>2-0. 准备：node类的插入函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * node&lt;T&gt;::insertAft( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=new node&lt;T&gt;( e , succ );</span><br><span class=\"line\">    succ=tem;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-1. 在某节点前插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( (tem=tem-&gt;succ)!=p );</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-2. 在某节点后插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertAfter( node&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return p-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-3. 插入表头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertFirst( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return header-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-4. 插入表尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertLast( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-查找元素\"><a href=\"#3-查找元素\" class=\"headerlink\" title=\"3. 查找元素\"></a>3. 查找元素</h3><p>3-1. 无序链表查找</p>\n<p>3-1-0. 整链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return find( e, header, ,_size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-1-1. 部分链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e, node&lt;T&gt;* p , int n ) const</span><br><span class=\"line\">&#123;  ( p , p+n ]</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">        if( e==( p=p-&gt;succ )-&gt;data )</span><br><span class=\"line\">            return p;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-2. 有序链表查找</p>\n<p>返回不大于e的最后一个元素，方便后续插入操作</p>\n<p>此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::search( T const &amp; e, node&lt;T&gt; * p, int n ) const</span><br><span class=\"line\">&#123;  [ p , p+n )</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;  // tem作为p的直接前驱</span><br><span class=\"line\">    while( tem-&gt;succ != p )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    while( n-- &amp;&amp;p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( p-&gt;data&gt;e )</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-循秩访问单个节点\"><a href=\"#4-循秩访问单个节点\" class=\"headerlink\" title=\"4. 循秩访问单个节点\"></a>4. 循秩访问单个节点</h3><p>方式：重载()运算符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T &amp; list&lt;T&gt;::operator [] (int r) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *p=header;</span><br><span class=\"line\">    while( ( p=p-&gt;succ ) &amp;&amp; r-- );</span><br><span class=\"line\">    return p-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问<strong>本质不同</strong>。</p>\n<p>链表的为披着循秩访问外皮的按位置访问。</p>\n<p>而顺序表 V[i] = V + i*s (s为单个元素大小)</p>\n<p>时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。</p>\n<h3 id=\"5-删除单个节点\"><a href=\"#5-删除单个节点\" class=\"headerlink\" title=\"5. 删除单个节点\"></a>5. 删除单个节点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T list&lt;T&gt;::remove( node&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    node&lt;T&gt; *pre=header;</span><br><span class=\"line\">    while( pre-&gt;succ!=p )</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-清空链表\"><a href=\"#6-清空链表\" class=\"headerlink\" title=\"6. 清空链表\"></a>6. 清空链表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::clear()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    if( header-&gt;succ==NULL )</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    while( header-&gt;succ )</span><br><span class=\"line\">        remove( header-&gt;succ );</span><br><span class=\"line\">    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零</span><br><span class=\"line\">    return old_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-排序\"><a href=\"#10-排序\" class=\"headerlink\" title=\"10. 排序\"></a>10. 排序</h3><p>10-1 归并排序</p>\n<p>归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾</p>\n<p>该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::merge ( node&lt;T&gt; * &amp;p1, int n1, node&lt;T&gt; *&amp;p2, int n2 ) //使用引用绑定节点防止丢失</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *head;</span><br><span class=\"line\">    node&lt;T&gt; *pree=header;</span><br><span class=\"line\">    while( pree-&gt;succ!=p1 )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    head=pree;</span><br><span class=\"line\">    node&lt;T&gt; *px1=p1,*px2=p2,*px3;</span><br><span class=\"line\">    for(int i=0; i&lt;n1-1 ; i++)</span><br><span class=\"line\">        px1=px1-&gt;succ;</span><br><span class=\"line\">    for(int i=0; i&lt;n2-1 ; i++)</span><br><span class=\"line\">        px2=px2-&gt;succ;</span><br><span class=\"line\">    px3=px2-&gt;succ;</span><br><span class=\"line\">    px1-&gt;succ=px2-&gt;succ=NULL;</span><br><span class=\"line\">    px1=p1;</span><br><span class=\"line\">    while( n1&amp;&amp;n2 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( px1-&gt;data&lt;=p2-&gt;data )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=px1;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            px1=px1-&gt;succ;</span><br><span class=\"line\">            n1--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=p2;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            p2=p2-&gt;succ;</span><br><span class=\"line\">            n2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if( n1 )</span><br><span class=\"line\">        pree-&gt;succ=px1;</span><br><span class=\"line\">    if( n2 )</span><br><span class=\"line\">        pree-&gt;succ=p2;</span><br><span class=\"line\">    while( pree-&gt;succ )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    pree-&gt;succ=px3;</span><br><span class=\"line\">    p1=head-&gt;succ;  // 最后设置好排序后的头结点</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::mergeSort( node&lt;T&gt; *&amp;p, int n )</span><br><span class=\"line\">&#123; // [ p, p+n ]</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    int mid=n/2;</span><br><span class=\"line\">    node&lt;T&gt; *tem=p;</span><br><span class=\"line\">    for(int i=0; i&lt;mid; i++)  tem=tem-&gt;succ;</span><br><span class=\"line\">    mergeSort( p, mid );</span><br><span class=\"line\">    mergeSort( tem, n-mid );</span><br><span class=\"line\">    merge( p,mid, tem , n-mid );</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::sort( )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mergeSort( header-&gt;succ , _size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-去重\"><a href=\"#11-去重\" class=\"headerlink\" title=\"11. 去重\"></a>11. 去重</h3><p>11-1. 无序链表</p>\n<p>常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)</p>\n<p>其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::deduplicate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( _size&lt;2 ) // 少于2个节点无需去重</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ-&gt;succ; //第一个节点必定已去重</span><br><span class=\"line\">    node&lt;T&gt; *pre=header-&gt;succ;</span><br><span class=\"line\">    int old_size=_size;  // 保存_size，方便返回删除数目</span><br><span class=\"line\">    int r=1;  // 已去重数目</span><br><span class=\"line\">    while( p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( find( p-&gt;data , header , r )!=NULL )</span><br><span class=\"line\">        &#123;    // 借用find接口</span><br><span class=\"line\">            pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">            delete p;</span><br><span class=\"line\">            p=pre-&gt;succ;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r++;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>11-2. 有序链表</p>\n<p>思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::uniquify()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ,*q;</span><br><span class=\"line\">    while( NULL != ( q = p-&gt;succ ) ) // q作为p的直接后继，检测是否重复</span><br><span class=\"line\">        (p-&gt;data == q-&gt;data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-反转\"><a href=\"#12-反转\" class=\"headerlink\" title=\"12. 反转\"></a>12. 反转</h3><p>思路：固定目前的首节点，即header-&gt;succ，每次将它的直接后继重新绑定至header的直接后继。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::reverse()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *fir=header-&gt;succ;</span><br><span class=\"line\">    node&lt;T&gt; *tem;</span><br><span class=\"line\">    while( fir-&gt;succ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem=fir-&gt;succ;</span><br><span class=\"line\">        fir-&gt;succ=tem-&gt;succ;</span><br><span class=\"line\">        tem-&gt;succ=header-&gt;succ;</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a><strong>双向链表</strong></h1><p>双链表和单链表类似，但不同在于有<strong>首末</strong>两个哨兵，每个节点有<strong>前驱</strong>和<strong>后缀</strong>指针，可以省去从头访问到某节点的前驱的时间。</p>\n<p>代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。</p>\n<p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">    //列表节点模板类（以双向链表形式实现）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode () &#123;&#125;</span><br><span class=\"line\">    ListNode ( T const &amp; e, ListNode&lt;T&gt; * p = NULL, ListNode&lt;T&gt; *a = NULL)</span><br><span class=\"line\">        :data(e),pred(p),succ(a)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsPred ( T const &amp; e );</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsSucc ( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\"></span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    void merge ( ListNode&lt;T&gt; * p1, int n1 , List&lt;T&gt;&amp;L,  ListNode&lt;T&gt; *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( ListNode&lt;T&gt; *p, int n );      // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\">    void selectionSort ( ListNode&lt;T&gt; *p, int n );   // [ p,p+n ) 选择排序</span><br><span class=\"line\">    void insertionSort ( ListNode&lt;T&gt; *p, int n );   // 对从p开始连续的n个节点插入排序</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    List() &#123; init(); &#125;</span><br><span class=\"line\">    List( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    List( T *p , int n );</span><br><span class=\"line\">    ~List();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    int size() const &#123; return _size; &#125;</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    T &amp; operator [] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    ListNode&lt;T&gt; * first()const</span><br><span class=\"line\">        &#123;return header-&gt;succ;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * last() const</span><br><span class=\"line\">        &#123;return trailer-&gt;pred;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp;e ) const</span><br><span class=\"line\">        &#123;return find(e,_size,trailer);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp; e, int n, ListNode&lt;T&gt;* p ) const; // (无序)从节点p向前n个节点（不含p）内找e</span><br><span class=\"line\">    ListNode&lt;T&gt; * search( T const &amp; e , int n , ListNode&lt;T&gt; * p ) const; // (有序) 不大于e的最后一个</span><br><span class=\"line\">    ListNode&lt;T&gt; * selectMax ( ListNode&lt;T&gt; *p , int n )const ;</span><br><span class=\"line\">    void show() const;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertBefore( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsPred(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAfter( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsSucc(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertLast( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return trailer-&gt;insertAsPred(e);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertFirst( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return header-&gt;insertAsSucc(e);&#125;</span><br><span class=\"line\">    T remove( ListNode&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    void sort( ListNode&lt;T&gt; *p, int n, int mod );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-排序\"><a href=\"#1-排序\" class=\"headerlink\" title=\"1. 排序\"></a>1. 排序</h2><p>1-1. 插入排序</p>\n<p>思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::insertionSort( ListNode&lt;T&gt; * p , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int r=0; r&lt;n; r++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertAfter( search( p-&gt;data , r , p ) , p-&gt;data );</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        remove( p-&gt;pred );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T List&lt;T&gt;::remove( ListNode&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    p-&gt;pred-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    p-&gt;succ-&gt;pred=p-&gt;pred;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsSucc( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, this, succ );</span><br><span class=\"line\">    succ-&gt;pred=a;</span><br><span class=\"line\">    succ=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2. 选择排序</p>\n<p>思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::selectionSort( ListNode&lt;T&gt; *p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    ListNode&lt;T&gt; *head=p-&gt;pred , *tail=p;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">        tail=tail-&gt;succ;</span><br><span class=\"line\">    while( 1&lt;n )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertBefore( tail, remove( selectMax( head-&gt;succ , n ) ) );</span><br><span class=\"line\">        tail=tail-&gt;pred;</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt; * List&lt;T&gt;::selectMax ( ListNode&lt;T&gt; *p , int n )const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *tem=p;</span><br><span class=\"line\">    while(n--&amp;&amp;p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(p-&gt;data&gt;=tem-&gt;data)</span><br><span class=\"line\">            tem=p;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsPred( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, pred, this );</span><br><span class=\"line\">    pred-&gt;succ=a;</span><br><span class=\"line\">    pred=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"常见的链表问题\"><a href=\"#常见的链表问题\" class=\"headerlink\" title=\"常见的链表问题\"></a><strong>常见的链表问题</strong></h1><p>最常用方法：</p>\n<blockquote>\n<ol>\n<li><strong>快慢指针法</strong></li>\n<li><strong>数组过渡法</strong></li>\n<li><strong>先断后接、先接后断法</strong></li>\n</ol>\n</blockquote>\n<p>\\1. 单链表反转</p>\n<blockquote>\n<p>两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。</p>\n</blockquote>\n<p>\\2. 找单链表倒数第n个元素、或中间元素</p>\n<blockquote>\n<p>快慢指针法。</p>\n<p>找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）</p>\n<p>找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。</p>\n<p>找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。</p>\n</blockquote>\n<p>\\3. 删除无头单链表的某个节点</p>\n<blockquote>\n<p>题意为不知header，但需要删除目前current指针指向的节点。</p>\n<p>思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。</p>\n</blockquote>\n<p>\\4. 在无头单链表某节点前增加节点</p>\n<blockquote>\n<p>思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。</p>\n</blockquote>\n<p>\\5. 判断单链表是否有环(可能是部分环，非循环单链表)</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。</p>\n</blockquote>\n<p>\\6. 判断两单链表是否相交</p>\n<blockquote>\n<p>首先明确：两单链表一旦相交，自交点之后的节点将完全相同！</p>\n<p>时间复杂度均为O( len1+len2 )</p>\n<ol>\n<li>法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素</li>\n<li>法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。</li>\n<li>法3：直接法：直接判断两链表末节点是否相同</li>\n</ol>\n</blockquote>\n<p>\\7. 已知两单链表相交，求相交点</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点</p>\n</blockquote>\n<p>\\8. 求两递增单链表AB差集A-B(元素在A而不在B)</p>\n<blockquote>\n<p>归并的思想</p>\n<p>每次取表头元素进行大小判断，若A’&lt;’B则通过，若A==B则剃除，若A&gt;B则将B指针向后移动直至A’&lt;’B或A==B</p>\n</blockquote>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/list/single_list.cpp\" target=\"_blank\" rel=\"noopener\">单向链表的完整实现</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/list/double_list.cpp\" target=\"_blank\" rel=\"noopener\">双向链表的完整实现</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a><strong>写在前面的话</strong></h1><p>开始数据结构的学习，将学习过程中的思维过程和代码记录下来。<br>教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》<br>辅以清华大学以及浙江大学的mooc。</p>","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><h2 id=\"线性表-List\"><a href=\"#线性表-List\" class=\"headerlink\" title=\"线性表 List\"></a>线性表 List</h2><p>线性表的定义：由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表中元素的个数称为线性表的**长度**</span><br><span class=\"line\">- 线性表中没有元素时称为**空表**</span><br><span class=\"line\">- 表起始位置称为**表头**，表结束为止称为**表尾**</span><br></pre></td></tr></table></figure>\n<p>线性表的操作类型：</p>\n<ol>\n<li>静态操作：仅读取，内容和组成一般不变，如get、search</li>\n<li>动态操作：需写入，局部或整体将改变，如insert、remove</li>\n</ol>\n<p>基本操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. List MakeList()</span><br><span class=\"line\">&gt; 初始化一个空的线性表</span><br><span class=\"line\">2. Element FindIndex(int index)</span><br><span class=\"line\">&gt; 根据位序k返回相应元素</span><br><span class=\"line\">3. int Find(Element x)</span><br><span class=\"line\">&gt; 查找x第一次出现的位置</span><br><span class=\"line\">4. void Insert(Element x , int index)</span><br><span class=\"line\">&gt; 在位序index前插入一个新元素x</span><br><span class=\"line\">5. void Delete(int index)</span><br><span class=\"line\">&gt; 删除指定位序的元素</span><br></pre></td></tr></table></figure>\n<p>实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 顺序存储实现：数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct ListNode * List</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tElement data[MAX_SIZE];</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 链式存储实现：链表</span><br><span class=\"line\">&gt; 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系</span><br></pre></td></tr></table></figure>\n<p>以下以链表为主介绍并实现线性表</p>\n<h2 id=\"链表特点：\"><a href=\"#链表特点：\" class=\"headerlink\" title=\"链表特点：\"></a><strong>链表特点：</strong></h2><p>动态存储：</p>\n<ol>\n<li>各元素动态地分配和回收空间</li>\n<li>逻辑上相邻的元素记录彼此的物理地址</li>\n<li>动态操作高效，静态操作费时，循秩访问低效</li>\n</ol>\n<p>各节点通过指针或引用连接，在逻辑上形成线性序列</p>\n<p><strong>链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。</strong></p>\n<p>以下均用c++实现。</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a><strong>分类</strong></h1><p>1.单向链表</p>\n<blockquote>\n<p>仅有succ指针</p>\n</blockquote>\n<p>2.双向链表</p>\n<blockquote>\n<p>有pred和succ指针</p>\n</blockquote>\n<p>3.循环单链表</p>\n<blockquote>\n<p>单向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>4.循环双链表</p>\n<blockquote>\n<p>双向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>5.静态链表</p>\n<blockquote>\n<p>在没有指针的语言中使用，借用数组模拟链表</p>\n</blockquote>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a><strong>建议</strong></h2><p>使用<strong>哨兵</strong>节点</p>\n<p>单向链表增加<strong>首</strong>哨兵</p>\n<p>双向链表增加<strong>首末</strong>哨兵</p>\n<p>哨兵不对外公开，在一开始创建，最后销毁</p>\n<p><strong>优点：简化边界条件，增加鲁棒性</strong></p>\n<h1 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a><strong>单链表</strong></h1><p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口完整定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">    node( T const &amp; e , node&lt;T&gt; * suc=NULL):data(e),succ(suc) &#123;&#125;</span><br><span class=\"line\">    node() &#123;succ=NULL;&#125;</span><br><span class=\"line\">    node&lt;T&gt; * insertAft( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( node&lt;T&gt; *p , int n );     </span><br><span class=\"line\">    //从p开始复制n个节点到链表末尾</span><br><span class=\"line\">    void merge ( node&lt;T&gt; *&amp; p1, int n1, node&lt;T&gt; *&amp;p2, int n2 );</span><br><span class=\"line\">    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( node&lt;T&gt; *&amp;p, int n );      </span><br><span class=\"line\">    // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\"></span><br><span class=\"line\">    list() &#123; init(); &#125;</span><br><span class=\"line\">    list( node&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    ~list();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    int size() &#123; return _size; &#125;</span><br><span class=\"line\">    T&amp; operator[] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp;e ) const;</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp; e,  node&lt;T&gt;* p, int n ) const;</span><br><span class=\"line\">    // (无序)从节点p向后n个节点（不含p）内找e</span><br><span class=\"line\">    node&lt;T&gt; * search( T const &amp; e , node&lt;T&gt; * p , int n ) const;</span><br><span class=\"line\">    // (有序) 不大于e的最后一个</span><br><span class=\"line\">    void show();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertAfter( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertLast( T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertFirst( T const &amp; e );</span><br><span class=\"line\">    void createListT( T const * e , int n ); // 尾插法创建链表</span><br><span class=\"line\">    void createListH( T const * e , int n ); // 头插法创建链表</span><br><span class=\"line\">    T remove( node&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    void sort(); // 排序</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>基本接口</strong>：</p>\n<p>\\1. 创建链表</p>\n<blockquote>\n<p>分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表</p>\n</blockquote>\n<p>\\2. 插入单节点</p>\n<blockquote>\n<p>分为在某节点前、后插入，在表头、表尾插入</p>\n</blockquote>\n<p>\\3. 查找数据</p>\n<blockquote>\n<p>无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素</p>\n</blockquote>\n<p>\\4. 循秩访问第n个节点</p>\n<blockquote>\n<p>可重载[]运算符，也可单独使用一个函数</p>\n</blockquote>\n<p>\\5. 删除单个节点</p>\n<p>\\6. 清空链表</p>\n<blockquote>\n<p>思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL</p>\n</blockquote>\n<p>\\7. 打印链表</p>\n<p>\\8. 检查链表是否为空</p>\n<p>\\9. 返回链表长度</p>\n<p>\\10. 排序（归并、插入、选择等）</p>\n<p>\\11. 去重（无序、有序版）</p>\n<p>\\12. 反转</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"1-创建链表\"><a href=\"#1-创建链表\" class=\"headerlink\" title=\"1. 创建链表\"></a>1. 创建链表</h3><p>1-1 创建空链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    header = new node&lt;T&gt;; //构造函数已将后继默认置位NULL</span><br><span class=\"line\">    _size=0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2 尾插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListT( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * last=header; // last作为链表最后一个节点</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i] );</span><br><span class=\"line\">        last-&gt;succ=tem;  // 顺序不可反</span><br><span class=\"line\">        last=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-3 头插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListH( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i], header-&gt;succ );</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-4 复制链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">list&lt;T&gt;::list( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    copyNodes( p , n );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::copyNodes( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ ) // 先探好路再迈步</span><br><span class=\"line\">        tem=tem-&gt;succ;  // tem指向存在的最后一个元素</span><br><span class=\"line\">    node&lt;T&gt; *create;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        create=new node&lt;T&gt; ( p-&gt;data );</span><br><span class=\"line\">        tem-&gt;succ=create;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;  // 实时更新链表尾</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-插入单节点\"><a href=\"#2-插入单节点\" class=\"headerlink\" title=\"2. 插入单节点\"></a>2. 插入单节点</h3><p>2-0. 准备：node类的插入函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * node&lt;T&gt;::insertAft( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=new node&lt;T&gt;( e , succ );</span><br><span class=\"line\">    succ=tem;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-1. 在某节点前插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( (tem=tem-&gt;succ)!=p );</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-2. 在某节点后插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertAfter( node&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return p-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-3. 插入表头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertFirst( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return header-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-4. 插入表尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertLast( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-查找元素\"><a href=\"#3-查找元素\" class=\"headerlink\" title=\"3. 查找元素\"></a>3. 查找元素</h3><p>3-1. 无序链表查找</p>\n<p>3-1-0. 整链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return find( e, header, ,_size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-1-1. 部分链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e, node&lt;T&gt;* p , int n ) const</span><br><span class=\"line\">&#123;  ( p , p+n ]</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">        if( e==( p=p-&gt;succ )-&gt;data )</span><br><span class=\"line\">            return p;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-2. 有序链表查找</p>\n<p>返回不大于e的最后一个元素，方便后续插入操作</p>\n<p>此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::search( T const &amp; e, node&lt;T&gt; * p, int n ) const</span><br><span class=\"line\">&#123;  [ p , p+n )</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;  // tem作为p的直接前驱</span><br><span class=\"line\">    while( tem-&gt;succ != p )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    while( n-- &amp;&amp;p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( p-&gt;data&gt;e )</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-循秩访问单个节点\"><a href=\"#4-循秩访问单个节点\" class=\"headerlink\" title=\"4. 循秩访问单个节点\"></a>4. 循秩访问单个节点</h3><p>方式：重载()运算符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T &amp; list&lt;T&gt;::operator [] (int r) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *p=header;</span><br><span class=\"line\">    while( ( p=p-&gt;succ ) &amp;&amp; r-- );</span><br><span class=\"line\">    return p-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问<strong>本质不同</strong>。</p>\n<p>链表的为披着循秩访问外皮的按位置访问。</p>\n<p>而顺序表 V[i] = V + i*s (s为单个元素大小)</p>\n<p>时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。</p>\n<h3 id=\"5-删除单个节点\"><a href=\"#5-删除单个节点\" class=\"headerlink\" title=\"5. 删除单个节点\"></a>5. 删除单个节点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T list&lt;T&gt;::remove( node&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    node&lt;T&gt; *pre=header;</span><br><span class=\"line\">    while( pre-&gt;succ!=p )</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-清空链表\"><a href=\"#6-清空链表\" class=\"headerlink\" title=\"6. 清空链表\"></a>6. 清空链表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::clear()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    if( header-&gt;succ==NULL )</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    while( header-&gt;succ )</span><br><span class=\"line\">        remove( header-&gt;succ );</span><br><span class=\"line\">    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零</span><br><span class=\"line\">    return old_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-排序\"><a href=\"#10-排序\" class=\"headerlink\" title=\"10. 排序\"></a>10. 排序</h3><p>10-1 归并排序</p>\n<p>归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾</p>\n<p>该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::merge ( node&lt;T&gt; * &amp;p1, int n1, node&lt;T&gt; *&amp;p2, int n2 ) //使用引用绑定节点防止丢失</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *head;</span><br><span class=\"line\">    node&lt;T&gt; *pree=header;</span><br><span class=\"line\">    while( pree-&gt;succ!=p1 )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    head=pree;</span><br><span class=\"line\">    node&lt;T&gt; *px1=p1,*px2=p2,*px3;</span><br><span class=\"line\">    for(int i=0; i&lt;n1-1 ; i++)</span><br><span class=\"line\">        px1=px1-&gt;succ;</span><br><span class=\"line\">    for(int i=0; i&lt;n2-1 ; i++)</span><br><span class=\"line\">        px2=px2-&gt;succ;</span><br><span class=\"line\">    px3=px2-&gt;succ;</span><br><span class=\"line\">    px1-&gt;succ=px2-&gt;succ=NULL;</span><br><span class=\"line\">    px1=p1;</span><br><span class=\"line\">    while( n1&amp;&amp;n2 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( px1-&gt;data&lt;=p2-&gt;data )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=px1;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            px1=px1-&gt;succ;</span><br><span class=\"line\">            n1--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=p2;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            p2=p2-&gt;succ;</span><br><span class=\"line\">            n2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if( n1 )</span><br><span class=\"line\">        pree-&gt;succ=px1;</span><br><span class=\"line\">    if( n2 )</span><br><span class=\"line\">        pree-&gt;succ=p2;</span><br><span class=\"line\">    while( pree-&gt;succ )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    pree-&gt;succ=px3;</span><br><span class=\"line\">    p1=head-&gt;succ;  // 最后设置好排序后的头结点</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::mergeSort( node&lt;T&gt; *&amp;p, int n )</span><br><span class=\"line\">&#123; // [ p, p+n ]</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    int mid=n/2;</span><br><span class=\"line\">    node&lt;T&gt; *tem=p;</span><br><span class=\"line\">    for(int i=0; i&lt;mid; i++)  tem=tem-&gt;succ;</span><br><span class=\"line\">    mergeSort( p, mid );</span><br><span class=\"line\">    mergeSort( tem, n-mid );</span><br><span class=\"line\">    merge( p,mid, tem , n-mid );</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::sort( )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mergeSort( header-&gt;succ , _size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-去重\"><a href=\"#11-去重\" class=\"headerlink\" title=\"11. 去重\"></a>11. 去重</h3><p>11-1. 无序链表</p>\n<p>常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)</p>\n<p>其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::deduplicate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( _size&lt;2 ) // 少于2个节点无需去重</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ-&gt;succ; //第一个节点必定已去重</span><br><span class=\"line\">    node&lt;T&gt; *pre=header-&gt;succ;</span><br><span class=\"line\">    int old_size=_size;  // 保存_size，方便返回删除数目</span><br><span class=\"line\">    int r=1;  // 已去重数目</span><br><span class=\"line\">    while( p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( find( p-&gt;data , header , r )!=NULL )</span><br><span class=\"line\">        &#123;    // 借用find接口</span><br><span class=\"line\">            pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">            delete p;</span><br><span class=\"line\">            p=pre-&gt;succ;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r++;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>11-2. 有序链表</p>\n<p>思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::uniquify()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ,*q;</span><br><span class=\"line\">    while( NULL != ( q = p-&gt;succ ) ) // q作为p的直接后继，检测是否重复</span><br><span class=\"line\">        (p-&gt;data == q-&gt;data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-反转\"><a href=\"#12-反转\" class=\"headerlink\" title=\"12. 反转\"></a>12. 反转</h3><p>思路：固定目前的首节点，即header-&gt;succ，每次将它的直接后继重新绑定至header的直接后继。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::reverse()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *fir=header-&gt;succ;</span><br><span class=\"line\">    node&lt;T&gt; *tem;</span><br><span class=\"line\">    while( fir-&gt;succ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem=fir-&gt;succ;</span><br><span class=\"line\">        fir-&gt;succ=tem-&gt;succ;</span><br><span class=\"line\">        tem-&gt;succ=header-&gt;succ;</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a><strong>双向链表</strong></h1><p>双链表和单链表类似，但不同在于有<strong>首末</strong>两个哨兵，每个节点有<strong>前驱</strong>和<strong>后缀</strong>指针，可以省去从头访问到某节点的前驱的时间。</p>\n<p>代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。</p>\n<p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">    //列表节点模板类（以双向链表形式实现）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode () &#123;&#125;</span><br><span class=\"line\">    ListNode ( T const &amp; e, ListNode&lt;T&gt; * p = NULL, ListNode&lt;T&gt; *a = NULL)</span><br><span class=\"line\">        :data(e),pred(p),succ(a)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsPred ( T const &amp; e );</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsSucc ( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\"></span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    void merge ( ListNode&lt;T&gt; * p1, int n1 , List&lt;T&gt;&amp;L,  ListNode&lt;T&gt; *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( ListNode&lt;T&gt; *p, int n );      // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\">    void selectionSort ( ListNode&lt;T&gt; *p, int n );   // [ p,p+n ) 选择排序</span><br><span class=\"line\">    void insertionSort ( ListNode&lt;T&gt; *p, int n );   // 对从p开始连续的n个节点插入排序</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    List() &#123; init(); &#125;</span><br><span class=\"line\">    List( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    List( T *p , int n );</span><br><span class=\"line\">    ~List();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    int size() const &#123; return _size; &#125;</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    T &amp; operator [] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    ListNode&lt;T&gt; * first()const</span><br><span class=\"line\">        &#123;return header-&gt;succ;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * last() const</span><br><span class=\"line\">        &#123;return trailer-&gt;pred;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp;e ) const</span><br><span class=\"line\">        &#123;return find(e,_size,trailer);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp; e, int n, ListNode&lt;T&gt;* p ) const; // (无序)从节点p向前n个节点（不含p）内找e</span><br><span class=\"line\">    ListNode&lt;T&gt; * search( T const &amp; e , int n , ListNode&lt;T&gt; * p ) const; // (有序) 不大于e的最后一个</span><br><span class=\"line\">    ListNode&lt;T&gt; * selectMax ( ListNode&lt;T&gt; *p , int n )const ;</span><br><span class=\"line\">    void show() const;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertBefore( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsPred(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAfter( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsSucc(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertLast( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return trailer-&gt;insertAsPred(e);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertFirst( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return header-&gt;insertAsSucc(e);&#125;</span><br><span class=\"line\">    T remove( ListNode&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    void sort( ListNode&lt;T&gt; *p, int n, int mod );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-排序\"><a href=\"#1-排序\" class=\"headerlink\" title=\"1. 排序\"></a>1. 排序</h2><p>1-1. 插入排序</p>\n<p>思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::insertionSort( ListNode&lt;T&gt; * p , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int r=0; r&lt;n; r++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertAfter( search( p-&gt;data , r , p ) , p-&gt;data );</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        remove( p-&gt;pred );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T List&lt;T&gt;::remove( ListNode&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    p-&gt;pred-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    p-&gt;succ-&gt;pred=p-&gt;pred;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsSucc( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, this, succ );</span><br><span class=\"line\">    succ-&gt;pred=a;</span><br><span class=\"line\">    succ=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2. 选择排序</p>\n<p>思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::selectionSort( ListNode&lt;T&gt; *p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    ListNode&lt;T&gt; *head=p-&gt;pred , *tail=p;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">        tail=tail-&gt;succ;</span><br><span class=\"line\">    while( 1&lt;n )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertBefore( tail, remove( selectMax( head-&gt;succ , n ) ) );</span><br><span class=\"line\">        tail=tail-&gt;pred;</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt; * List&lt;T&gt;::selectMax ( ListNode&lt;T&gt; *p , int n )const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *tem=p;</span><br><span class=\"line\">    while(n--&amp;&amp;p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(p-&gt;data&gt;=tem-&gt;data)</span><br><span class=\"line\">            tem=p;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsPred( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, pred, this );</span><br><span class=\"line\">    pred-&gt;succ=a;</span><br><span class=\"line\">    pred=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"常见的链表问题\"><a href=\"#常见的链表问题\" class=\"headerlink\" title=\"常见的链表问题\"></a><strong>常见的链表问题</strong></h1><p>最常用方法：</p>\n<blockquote>\n<ol>\n<li><strong>快慢指针法</strong></li>\n<li><strong>数组过渡法</strong></li>\n<li><strong>先断后接、先接后断法</strong></li>\n</ol>\n</blockquote>\n<p>\\1. 单链表反转</p>\n<blockquote>\n<p>两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。</p>\n</blockquote>\n<p>\\2. 找单链表倒数第n个元素、或中间元素</p>\n<blockquote>\n<p>快慢指针法。</p>\n<p>找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）</p>\n<p>找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。</p>\n<p>找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。</p>\n</blockquote>\n<p>\\3. 删除无头单链表的某个节点</p>\n<blockquote>\n<p>题意为不知header，但需要删除目前current指针指向的节点。</p>\n<p>思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。</p>\n</blockquote>\n<p>\\4. 在无头单链表某节点前增加节点</p>\n<blockquote>\n<p>思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。</p>\n</blockquote>\n<p>\\5. 判断单链表是否有环(可能是部分环，非循环单链表)</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。</p>\n</blockquote>\n<p>\\6. 判断两单链表是否相交</p>\n<blockquote>\n<p>首先明确：两单链表一旦相交，自交点之后的节点将完全相同！</p>\n<p>时间复杂度均为O( len1+len2 )</p>\n<ol>\n<li>法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素</li>\n<li>法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。</li>\n<li>法3：直接法：直接判断两链表末节点是否相同</li>\n</ol>\n</blockquote>\n<p>\\7. 已知两单链表相交，求相交点</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点</p>\n</blockquote>\n<p>\\8. 求两递增单链表AB差集A-B(元素在A而不在B)</p>\n<blockquote>\n<p>归并的思想</p>\n<p>每次取表头元素进行大小判断，若A’&lt;’B则通过，若A==B则剃除，若A&gt;B则将B指针向后移动直至A’&lt;’B或A==B</p>\n</blockquote>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/list/single_list.cpp\" target=\"_blank\" rel=\"noopener\">单向链表的完整实现</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/list/double_list.cpp\" target=\"_blank\" rel=\"noopener\">双向链表的完整实现</a></p>"},{"layout":"post","title":"数据结构笔记（二）：栈和队列","date":"2017-08-13T16:00:00.000Z","comments":1,"_content":"\n\n# **概述**\n\n**栈**(stack)和**队列**(queue)均属于**线性存储**结构\n\n栈特性：\n\n> 1. LIFO ( last in first out ) 后进先出\n> 2. 元素插入和删除仅在一端进行\n\n队列特性：\n\n> 1. FIFO ( first in first out ) 先进先出\n> 2. 元素在队尾插入，在队头删除\n\n![栈和队列](http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg)\n\n这两种结构均可以用数组或链表实现\n\n本文主要介绍栈，以下实现均为c++.\n\n<!-- more -->\n\n# **栈**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名     | 功能        |\n| ---- | ------- | --------- |\n| bool | empty() | 判断是否为空    |\n| int  | size()  | 获取栈的大小    |\n| void | push(n) | 将n压入栈     |\n| T&   | top()   | 取栈顶元素而不弹出 |\n| T    | pop()   | 弹出栈顶元素    |\n\n## **二. 基本定义：**\n\n本文用数组实现栈。\n在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。\n\n（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）\n\n栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。\n\n```\ntemplate <typename T>\nstruct Stack\n{\nprivate:\n\tT *data;\n\tint _size,maxsize;   // 当前规模和最大规模\n\nprotected:\n\tvoid expand();  // 扩容\n\tvoid shrink();  // 缩容\n\npublic:\n\tStack(){ _size =0 ; maxsize=4; data=new T[maxsize]; };\n\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶\n\t~Stack() { delete []data; }\n\tvoid push( T const & e ) { expand(); data[_size++]=e;  }\n\tT pop( ) { shrink(); return data[--_size];   }\n\tT & top( ) { return data[_size-1];};\n\tint empty()const {return _size==0;}\n\tint size()const {return _size;}\n\tint find( T const & e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题\n};\n```\n\n## **三. 典型应用：**\n\n**一. 逆序输出**\n\n输出次序和处理过程颠倒\n\n例如：进制转换\n\n**二. 递归嵌套**\n\n具有自相似性 ( 总体和局部相似 )\n\n例如：括号匹配、栈混洗(stack permutation)\n\n**三. 延迟缓冲**\n\n线性扫描算法模式\n\n例如：中缀表达式求值\n\n**四. 栈式计算**\n\n例如：逆波兰表达式转换（RPN Reverse Polish Notation）\n\n**五. 试探回溯**\n\n例如：n皇后问题、寻路\n\n下面开始一一介绍这些应用：\n\n### **3-1. 进制转换：**\n\n思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。\n\n借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。\n\n```\nvoid convert(  int n , int base ) \n{\n\tStack<char>s;\n\tstatic char digit[]=\n\t{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\t// 进制限定在2-16，有需要可以继续扩展\n\twhile(n)\n\t{\n\t\ts.push( digit[n%base]);\n\t\tn/=base;\n\t}\n\twhile( !s.empty() )\n\t\tcout<<s.pop();\n\tcout<<endl;\n}\n```\n\n### **3-2. 括号匹配：**\n\n判断某一表达式内的括号是否完全匹配\n\n对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。\n\n然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。\n\n而借助栈我们能够很轻松地完成多括号匹配的任务。\n\n思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。\n\n显示为流程图即是\n\n![流程图](http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG)\n\n下面来看一下代码\n\n```\nbool judge ( char *s , int n ) \n{\n\tStack<char>a;\n\tfor(int i=0 ; i<n; i++)\n\t{\n\t\tif( s[i]!='(' && s[i]!=')' && s[i]!='[' && s[i]!=']' )\n\t\t\tcontinue;\n\t\tif( s[i]=='('|| s[i]=='[')\n\t\t\ta.push(s[i]);\n\t\telse if(a.empty())\n\t\t\treturn false;\n\t\telse if( (s[i]==')'&&a.top()=='(') || (s[i]==']'&&a.top()=='[') )\n\t\t\ta.pop();\n\t}\n\tif(\ta.empty() )\n\t\treturn true;\n\treturn false;\n}\n```\n\n### **3-3. 栈混洗：**\n\n#### **3-3-0. 概念：**\n\n栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。\n\n栈混洗的过程中只允许以下两个操作：\n\n> 1. A栈顶弹出并压入栈S S.push(A.pop())\n> 2. S栈顶弹出并压入栈B B.push(S.pop())\n\n#### **3-3-1. 排列种数：**\n\n先来计算一下栈通过栈混洗操作后有多少种排列方式：\n\n设总数为n的栈有SP(n)种排列方式\n\n推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]\n对于第一个元素而言，它的排列方式有SP(n)种。\n\n$$SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)$$\n\n解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$\n\n#### **3-3-2. 甄别栈混洗：**\n\n如何甄别一个序列是否是栈混洗呢？\n\n三个元素栈混洗有5种，全排列有6种, <1,2,3] 非栈混洗的排列为 <2,1,3] ( ‘<’为栈顶方向 )\n\n而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关\n\n对于 1<=i < j < k<=n,若出现 k i j的排列，则非栈混洗 （称为**禁形**）\n\n![禁形1](http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg)\n\n通过证明，禁形对于是否是栈混洗为 **充要条件**\n\n![禁形2](http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg)\n\n那么我们可以得到如下的判别方法：\n\nO(n3)判别方法：分别枚举i，j，k\n\nO(n2)判别方法：枚举 i , j , j+1\n\nO(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗\n\n以下为O(n)的判别方法的实现：\n\n```\ntemplate <typename T>\nbool stackPermutation( T *origin, T * b , int n )\n{\n\tStack<T> s;\n\tStack<T> ori( origin ,n );\n\tfor( int j=0; j<n ; j++ )\n\t{\t\n\t\tif( s.empty() )\n\t\t{\t\n\t\t\tif( ori.empty() ) \n\t\t\t\treturn false;\n\t\t\ts.push( ori.pop() );\n\t\t\tcout<<\"push\\n\";\n\t\t}\n\t\twhile( !s.empty() )\n\t\t{\n\t\t\tif( s.top()==b[j] )\n\t\t\t{\n\t\t\t\ts.pop();\n\t\t\t\tcout<<\"pop\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( ori.empty() ) \n\t\t\t\t\treturn false;\n\t\t\t\ts.push( ori.pop() );\n\t\t\t\tcout<<\"push\\n\";\n\t\t\t}\n\t\t}\n\t}\n\tif( !s.empty() || !ori.empty() )\n\t\treturn false;\n\treturn true;\n}\n```\n\n#### **3-3-3. 栈混洗与括号匹配：**\n\n值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。\n\n![栈混洗与括号匹配](http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg)\n\n结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配\n\n同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种\n\n### **3-4. 中缀表达式求值：**\n\n#### **3-4-0. 概述：**\n\n中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。\n例如 1+1 即是一个中缀表达式\n\n#### **3-4-1. 算法：**\n\n主体思路：用两个栈分别保存**操作数**和**运算符**，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。\n\n此外，值得注意的是\n\n一：为了方便判断优先级，在优先级表中**同一阶级的运算符根据出现次序不同优先级也不同**，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.\n\n二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)\n\n三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。\n\n四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。\n\n```\nconst char Prior[9][9] = \n{  \n//        +   -   *   /   ^   !   (   )  \\0\n/* + */  '>','>','<','<','<','<','<','>','>',\n/* - */  '>','>','<','<','<','<','<','>','>',\n/* * */  '>','>','>','>','<','<','<','>','>',\n/* / */  '>','>','>','>','<','<','<','>','>',\n/* ^ */  '>','>','>','>','<','<','<','>','>',\n/* ! */  '>','>','>','>','>','>',' ','>','>',\n/* ( */  '<','<','<','<','<','<','<','=',' ',\n/* ) */  ' ',' ',' ',' ',' ',' ',' ',' ',' ',\n/* \\0*/  '<','<','<','<','<','<','<',' ','='\n};\n\nvoid readNumber( char *&s , Stack<float>& opnd)\n{\n\tfloat ans=0;\n\topnd.push( *s-'0' );\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop()*10 + *s-'0' );\n\tif(*s!='.')   // 可能是小数\n\t\treturn;\n\tfloat f=1;\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop() + (*s-'0')*(f/=10.0) );\n\treturn;\n}\nvoid getnum( char a, int & num)\n{\n\tswitch(a)\n\t{\n\tcase '+': num=0;return;\n\tcase '-': num=1;return;\n\tcase '*': num=2;return;\n\tcase '/': num=3;return;\n\tcase '^': num=4;return;\n\tcase '!': num=5;return;\n\tcase '(': num=6;return;\n\tcase ')': num=7;return;\n\tcase '\\0': num=8;return;\n\t}\n}\nchar orderBetween ( char a, char b)\n{\n\tint num1,num2;\n\tgetnum( a, num1 );\n\tgetnum( b, num2 );\n\treturn Prior[num1][num2];\n}\nfloat cal( float num1, char op , float num2)\n{\n\tswitch (op)\n\t{\n\tcase '+': return num1+num2;\n\tcase '-': return num1-num2;\n\tcase '*': return num1*num2;\n\tcase '/': return num1/num2;\n\tcase '^': return pow(num1,num2);\n\tdefault : exit(1);\n\t}\n}\nfloat cal( char op, float num1)\n{\n\tif( abs(num1-0)<1e-6 )\n\t\treturn 1;\n\tfor(int i=1; i<num1 ; i++)\n\t\tnum1*=i;\n\treturn num1;\n}\nfloat evaluate ( char * s )\n{\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t// 逆向取数，可能是'-'号这些和次序相关的运算符\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了\n}\n```\n\n### **3-5. 逆波兰表达式：**\n\n中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。\n\n#### **3-5-0. 概念：**\n\n逆波兰表达式 ( RPN : Reverse Polish Notation )\n\n没有括号和约定俗成的优先级，从左至右扫描表达式，运算符**谁先出现算谁**。\n\n运算符位于参与运算的运算数之后。\n\n例如：\n\n0！1+2 3！*4+5-^\n\n值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。\n\n以上表达式翻译成中缀表达式即是：\n\n( 0! + 1 )^( 2 * 3! +4 - 5 )\n\n和中缀表达式相比，逆波兰表达式的优点在于**计算速度更快**。\n\n在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。\n\n#### **3-5-2. 计算：**\n\n计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。\n\n```\nfloat rpnEvaluate( char * RPN )\n{\n\tStack<float> opnd;\n\tfloat num1,num2;\n\tint len=strlen(RPN);\n\tRPN[len++]='\\0';\n\twhile(len--)\n\t{\n\t\tif( (*RPN)<='9'&&(*RPN)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( RPN, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar op=*RPN;\n\t\t\tif(op=='!')\n\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum2=opnd.pop();\n\t\t\t\tnum1=opnd.pop();\n\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t}\n\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n#### **3-5-2. 手工转换：**\n\n手工将中缀表达式转换成逆波兰表达式的方法如下：\n\n1.用括号显式界定所有运算符\n\n2.将所有运算符移到对应的右括号后面\n\n3.去掉所有括号\n\n4.稍加整理\n\n![手工转换](http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg)\n\n#### **3-5-3. 转换算法：**\n\n非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。\n\n```\n// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上\nvoid append( char *&RPN, float num )\n{\n\tint len=strlen(RPN);\n\tchar buf[64];\n\tif( num!= (float)(int)num )   // 判断是否为整数\n\t\tsprintf( buf, \"%.2f \\0\",num); // 小数暂取两位\n\telse\n\t\tsprintf( buf, \"%d \\0\",(int)num);\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容\n\tstrcat( RPN,buf );\n}\nvoid append( char *&RPN, char op )\n{\n\tint len=strlen( RPN );\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );\n\tsprintf( RPN+len, \"%c \\0\",op );\n}\nfloat evaluate ( char * s , char *&RPN )\n{ // s：中缀表达式， RPN：需要存放转换后表达式的位置\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\tRPN[0]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n//////// RPN转换 ////////\n\t\t\tappend( RPN, opnd.top());\n//////// RPN转换 ////////\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n//////// RPN转换 ////////\n\t\t\t\tappend( RPN, op );\n//////// RPN转换 ////////\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n### **3-6. n皇后问题：**\n\n#### **3-6-0. 概述：**\n\n试探：逐步增加候选解的长度 ，逐步向目标解靠近\n\n回溯：一旦发现和目标解不同，则回溯到上一步继续试探\n\n一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。\n\nn皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。\n\n![n皇后问题](http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg)\n\n#### **3-6-1. 算法：**\n\n用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。\n\n```\ntemplate <typename T>\nint Stack<T>::find( T const & e ) const\n{\n\tfor( int i=0 ; i<_size ; i++)\n\t\tif( data[i] == e )\n\t\t\treturn i;\n\treturn -1;\n}\nstruct Queen\n{\n\tint x,y;\n\tQueen( int xx=0, int yy=0 ):x(xx),y(yy){}\n\tbool operator == ( Queen const & a ) const\n\t{\n\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tbool operator != ( Queen const & a ) const { return !( *this == a );}\n};\nint placeQueens( int n ) // n皇后\n{\n\tint num_solution=0;\n\tStack< Queen >a; \n\tQueen q(0,0);  //当前寻求位置放的皇后\n\tdo\n\t{\n\t\tif( a.size()>=n || q.y>=n ) // 若是列数超出边界或已经构成一个解\n\t\t{\t\n\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试\n\t\t\tq.y++;\n\t\t}\n\t\twhile( q.y<n && a.find(q)>=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突\n\t\t\tq.y++;\n\t\tif( q.y<n )  // 找到位置放置皇后\n\t\t{\n\t\t\ta.push( q );\n\t\t\tif( a.size()>=n )\n\t\t\t\tnum_solution++;\n\t\t\tq.x++;  // 前往下一行找解，列数重置\n\t\t\tq.y=0;\n\t\t}\n\t}\n\twhile( !( q.x==0 && q.y>=n ) );\n\treturn num_solution;\n}\n```\n\n# **队列**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名        | 功能      |\n| ---- | ---------- | ------- |\n| bool | empty()    | 判断是否为空  |\n| int  | size()     | 获取队列的大小 |\n| void | enqueue(n) | 将n入队    |\n| T&   | front()    | 查看队头元素  |\n| T    | dequeue()  | 删除队头元素  |\n| T&   | rear()     | 查看队尾元素  |\n\n## **二. 基本定义：**\n\n队列同样可以用数组或链表实现\n\n### **2-1. 版本一：继承List类**\n\n在这里选择继承[笔记一](https://zedom1.github.io/2017/08/12/list/)中实现的双向链表List类\n\n```\ntemplate <typename T>\nstruct queue:public List<T> //利用双向链表版\n{ // size和empty直接沿用\n\tvoid enqueue ( T const& e ) {insertAsLast(e);}\n\tT dequeue() { return remove(first()); }\n\tT& front() { return first()->data; }\n\tT& rear() { return last()->data; }\n};\n```\n\n### **2-2. 版本二：从零开始的数组版**\n\n用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。\n\n```\ntemplate <typename T>\nstruct queue  // 数组模拟版\n{\nprivate:\n\tT *data;\n\tint first,last,maxsize;\n\nprotected:\n\tvoid expand();\n// expand()判断 last 或 last-first 是否接近maxsize\npublic:\n\tqueue();\n\t~queue() {delete []data;}\n\tbool empty()const {return first==last;}\n\tint size()const {return last-first;}\n\tT& front()const { if(!empty())return data[first]; else exit(1);}\n\tT& rear()const { if(!empty())return data[last-1]; else exit(1);}\n\tvoid enqueue( T const & e) { expand(); data[last++]=e; }\n\tT dequeue() { return data[(first++)-1]; }\n};\n```\n\n### **2-3. 版本三：环状数组版**\n\n与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了\n\n适用于已知数据的规模的情况\n\n数组在逻辑上相连而在物理上不相连，用取余size实现\n\n```\ntemplate <typename T>\nstruct Queue\n{\nprivate:\n\tT *data;\n\tint maxsize;\n\tint first;\n\tint last;\n\tint size;\n\npublic:\n\tQueue(int size=0)\n\t{\n\t\tmaxsize=size+1;\n\t\tlast=0;\n\t\tfirst=1;\n\t\tdata= new T[maxsize];\n\t}\n\t~Queue()\n\t{\n\t\tdelete []data;\n\t}\n\tvoid clear()\n\t{\n\t\tlast=first=0;\n\t}\n\tvoid enqueue(const T & it)\n\t{\n\t\tlast=(last+1)%maxsize;\n\t\tdata[last]=it;\n\t}\n\tT dequeue()\n\t{\n\t\tT it = data[first];\n\t\tfirst = (first+1)%maxsize;\n\t\treturn it;\n\t}\n\tconst T firstValue()\n\t{\n\t\treturn data[first];\n\t}\n\tint length()\n\t{\n\t\treturn ((last+maxsize)-first+1)%maxsize;\n\t}\n\n};\n```\n\n# **完整实现代码**\n\n[栈的完整实现 ( 附带应用的实现 )](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp)\n\n[队列的完整实现](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp)","source":"_posts/DataStructure_Stack.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（二）：栈和队列\"\ndate: 2017-08-14\ncomments: true\ntags: \n\t- 学习笔记\n\t- c++\n\t- 数据结构\n---\n\n\n# **概述**\n\n**栈**(stack)和**队列**(queue)均属于**线性存储**结构\n\n栈特性：\n\n> 1. LIFO ( last in first out ) 后进先出\n> 2. 元素插入和删除仅在一端进行\n\n队列特性：\n\n> 1. FIFO ( first in first out ) 先进先出\n> 2. 元素在队尾插入，在队头删除\n\n![栈和队列](http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg)\n\n这两种结构均可以用数组或链表实现\n\n本文主要介绍栈，以下实现均为c++.\n\n<!-- more -->\n\n# **栈**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名     | 功能        |\n| ---- | ------- | --------- |\n| bool | empty() | 判断是否为空    |\n| int  | size()  | 获取栈的大小    |\n| void | push(n) | 将n压入栈     |\n| T&   | top()   | 取栈顶元素而不弹出 |\n| T    | pop()   | 弹出栈顶元素    |\n\n## **二. 基本定义：**\n\n本文用数组实现栈。\n在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。\n\n（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）\n\n栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。\n\n```\ntemplate <typename T>\nstruct Stack\n{\nprivate:\n\tT *data;\n\tint _size,maxsize;   // 当前规模和最大规模\n\nprotected:\n\tvoid expand();  // 扩容\n\tvoid shrink();  // 缩容\n\npublic:\n\tStack(){ _size =0 ; maxsize=4; data=new T[maxsize]; };\n\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶\n\t~Stack() { delete []data; }\n\tvoid push( T const & e ) { expand(); data[_size++]=e;  }\n\tT pop( ) { shrink(); return data[--_size];   }\n\tT & top( ) { return data[_size-1];};\n\tint empty()const {return _size==0;}\n\tint size()const {return _size;}\n\tint find( T const & e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题\n};\n```\n\n## **三. 典型应用：**\n\n**一. 逆序输出**\n\n输出次序和处理过程颠倒\n\n例如：进制转换\n\n**二. 递归嵌套**\n\n具有自相似性 ( 总体和局部相似 )\n\n例如：括号匹配、栈混洗(stack permutation)\n\n**三. 延迟缓冲**\n\n线性扫描算法模式\n\n例如：中缀表达式求值\n\n**四. 栈式计算**\n\n例如：逆波兰表达式转换（RPN Reverse Polish Notation）\n\n**五. 试探回溯**\n\n例如：n皇后问题、寻路\n\n下面开始一一介绍这些应用：\n\n### **3-1. 进制转换：**\n\n思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。\n\n借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。\n\n```\nvoid convert(  int n , int base ) \n{\n\tStack<char>s;\n\tstatic char digit[]=\n\t{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\t// 进制限定在2-16，有需要可以继续扩展\n\twhile(n)\n\t{\n\t\ts.push( digit[n%base]);\n\t\tn/=base;\n\t}\n\twhile( !s.empty() )\n\t\tcout<<s.pop();\n\tcout<<endl;\n}\n```\n\n### **3-2. 括号匹配：**\n\n判断某一表达式内的括号是否完全匹配\n\n对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。\n\n然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。\n\n而借助栈我们能够很轻松地完成多括号匹配的任务。\n\n思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。\n\n显示为流程图即是\n\n![流程图](http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG)\n\n下面来看一下代码\n\n```\nbool judge ( char *s , int n ) \n{\n\tStack<char>a;\n\tfor(int i=0 ; i<n; i++)\n\t{\n\t\tif( s[i]!='(' && s[i]!=')' && s[i]!='[' && s[i]!=']' )\n\t\t\tcontinue;\n\t\tif( s[i]=='('|| s[i]=='[')\n\t\t\ta.push(s[i]);\n\t\telse if(a.empty())\n\t\t\treturn false;\n\t\telse if( (s[i]==')'&&a.top()=='(') || (s[i]==']'&&a.top()=='[') )\n\t\t\ta.pop();\n\t}\n\tif(\ta.empty() )\n\t\treturn true;\n\treturn false;\n}\n```\n\n### **3-3. 栈混洗：**\n\n#### **3-3-0. 概念：**\n\n栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。\n\n栈混洗的过程中只允许以下两个操作：\n\n> 1. A栈顶弹出并压入栈S S.push(A.pop())\n> 2. S栈顶弹出并压入栈B B.push(S.pop())\n\n#### **3-3-1. 排列种数：**\n\n先来计算一下栈通过栈混洗操作后有多少种排列方式：\n\n设总数为n的栈有SP(n)种排列方式\n\n推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]\n对于第一个元素而言，它的排列方式有SP(n)种。\n\n$$SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)$$\n\n解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$\n\n#### **3-3-2. 甄别栈混洗：**\n\n如何甄别一个序列是否是栈混洗呢？\n\n三个元素栈混洗有5种，全排列有6种, <1,2,3] 非栈混洗的排列为 <2,1,3] ( ‘<’为栈顶方向 )\n\n而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关\n\n对于 1<=i < j < k<=n,若出现 k i j的排列，则非栈混洗 （称为**禁形**）\n\n![禁形1](http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg)\n\n通过证明，禁形对于是否是栈混洗为 **充要条件**\n\n![禁形2](http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg)\n\n那么我们可以得到如下的判别方法：\n\nO(n3)判别方法：分别枚举i，j，k\n\nO(n2)判别方法：枚举 i , j , j+1\n\nO(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗\n\n以下为O(n)的判别方法的实现：\n\n```\ntemplate <typename T>\nbool stackPermutation( T *origin, T * b , int n )\n{\n\tStack<T> s;\n\tStack<T> ori( origin ,n );\n\tfor( int j=0; j<n ; j++ )\n\t{\t\n\t\tif( s.empty() )\n\t\t{\t\n\t\t\tif( ori.empty() ) \n\t\t\t\treturn false;\n\t\t\ts.push( ori.pop() );\n\t\t\tcout<<\"push\\n\";\n\t\t}\n\t\twhile( !s.empty() )\n\t\t{\n\t\t\tif( s.top()==b[j] )\n\t\t\t{\n\t\t\t\ts.pop();\n\t\t\t\tcout<<\"pop\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( ori.empty() ) \n\t\t\t\t\treturn false;\n\t\t\t\ts.push( ori.pop() );\n\t\t\t\tcout<<\"push\\n\";\n\t\t\t}\n\t\t}\n\t}\n\tif( !s.empty() || !ori.empty() )\n\t\treturn false;\n\treturn true;\n}\n```\n\n#### **3-3-3. 栈混洗与括号匹配：**\n\n值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。\n\n![栈混洗与括号匹配](http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg)\n\n结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配\n\n同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种\n\n### **3-4. 中缀表达式求值：**\n\n#### **3-4-0. 概述：**\n\n中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。\n例如 1+1 即是一个中缀表达式\n\n#### **3-4-1. 算法：**\n\n主体思路：用两个栈分别保存**操作数**和**运算符**，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。\n\n此外，值得注意的是\n\n一：为了方便判断优先级，在优先级表中**同一阶级的运算符根据出现次序不同优先级也不同**，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.\n\n二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)\n\n三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。\n\n四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。\n\n```\nconst char Prior[9][9] = \n{  \n//        +   -   *   /   ^   !   (   )  \\0\n/* + */  '>','>','<','<','<','<','<','>','>',\n/* - */  '>','>','<','<','<','<','<','>','>',\n/* * */  '>','>','>','>','<','<','<','>','>',\n/* / */  '>','>','>','>','<','<','<','>','>',\n/* ^ */  '>','>','>','>','<','<','<','>','>',\n/* ! */  '>','>','>','>','>','>',' ','>','>',\n/* ( */  '<','<','<','<','<','<','<','=',' ',\n/* ) */  ' ',' ',' ',' ',' ',' ',' ',' ',' ',\n/* \\0*/  '<','<','<','<','<','<','<',' ','='\n};\n\nvoid readNumber( char *&s , Stack<float>& opnd)\n{\n\tfloat ans=0;\n\topnd.push( *s-'0' );\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop()*10 + *s-'0' );\n\tif(*s!='.')   // 可能是小数\n\t\treturn;\n\tfloat f=1;\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop() + (*s-'0')*(f/=10.0) );\n\treturn;\n}\nvoid getnum( char a, int & num)\n{\n\tswitch(a)\n\t{\n\tcase '+': num=0;return;\n\tcase '-': num=1;return;\n\tcase '*': num=2;return;\n\tcase '/': num=3;return;\n\tcase '^': num=4;return;\n\tcase '!': num=5;return;\n\tcase '(': num=6;return;\n\tcase ')': num=7;return;\n\tcase '\\0': num=8;return;\n\t}\n}\nchar orderBetween ( char a, char b)\n{\n\tint num1,num2;\n\tgetnum( a, num1 );\n\tgetnum( b, num2 );\n\treturn Prior[num1][num2];\n}\nfloat cal( float num1, char op , float num2)\n{\n\tswitch (op)\n\t{\n\tcase '+': return num1+num2;\n\tcase '-': return num1-num2;\n\tcase '*': return num1*num2;\n\tcase '/': return num1/num2;\n\tcase '^': return pow(num1,num2);\n\tdefault : exit(1);\n\t}\n}\nfloat cal( char op, float num1)\n{\n\tif( abs(num1-0)<1e-6 )\n\t\treturn 1;\n\tfor(int i=1; i<num1 ; i++)\n\t\tnum1*=i;\n\treturn num1;\n}\nfloat evaluate ( char * s )\n{\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t// 逆向取数，可能是'-'号这些和次序相关的运算符\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了\n}\n```\n\n### **3-5. 逆波兰表达式：**\n\n中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。\n\n#### **3-5-0. 概念：**\n\n逆波兰表达式 ( RPN : Reverse Polish Notation )\n\n没有括号和约定俗成的优先级，从左至右扫描表达式，运算符**谁先出现算谁**。\n\n运算符位于参与运算的运算数之后。\n\n例如：\n\n0！1+2 3！*4+5-^\n\n值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。\n\n以上表达式翻译成中缀表达式即是：\n\n( 0! + 1 )^( 2 * 3! +4 - 5 )\n\n和中缀表达式相比，逆波兰表达式的优点在于**计算速度更快**。\n\n在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。\n\n#### **3-5-2. 计算：**\n\n计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。\n\n```\nfloat rpnEvaluate( char * RPN )\n{\n\tStack<float> opnd;\n\tfloat num1,num2;\n\tint len=strlen(RPN);\n\tRPN[len++]='\\0';\n\twhile(len--)\n\t{\n\t\tif( (*RPN)<='9'&&(*RPN)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( RPN, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar op=*RPN;\n\t\t\tif(op=='!')\n\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum2=opnd.pop();\n\t\t\t\tnum1=opnd.pop();\n\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t}\n\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n#### **3-5-2. 手工转换：**\n\n手工将中缀表达式转换成逆波兰表达式的方法如下：\n\n1.用括号显式界定所有运算符\n\n2.将所有运算符移到对应的右括号后面\n\n3.去掉所有括号\n\n4.稍加整理\n\n![手工转换](http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg)\n\n#### **3-5-3. 转换算法：**\n\n非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。\n\n```\n// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上\nvoid append( char *&RPN, float num )\n{\n\tint len=strlen(RPN);\n\tchar buf[64];\n\tif( num!= (float)(int)num )   // 判断是否为整数\n\t\tsprintf( buf, \"%.2f \\0\",num); // 小数暂取两位\n\telse\n\t\tsprintf( buf, \"%d \\0\",(int)num);\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容\n\tstrcat( RPN,buf );\n}\nvoid append( char *&RPN, char op )\n{\n\tint len=strlen( RPN );\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );\n\tsprintf( RPN+len, \"%c \\0\",op );\n}\nfloat evaluate ( char * s , char *&RPN )\n{ // s：中缀表达式， RPN：需要存放转换后表达式的位置\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\tRPN[0]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n//////// RPN转换 ////////\n\t\t\tappend( RPN, opnd.top());\n//////// RPN转换 ////////\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n//////// RPN转换 ////////\n\t\t\t\tappend( RPN, op );\n//////// RPN转换 ////////\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n### **3-6. n皇后问题：**\n\n#### **3-6-0. 概述：**\n\n试探：逐步增加候选解的长度 ，逐步向目标解靠近\n\n回溯：一旦发现和目标解不同，则回溯到上一步继续试探\n\n一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。\n\nn皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。\n\n![n皇后问题](http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg)\n\n#### **3-6-1. 算法：**\n\n用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。\n\n```\ntemplate <typename T>\nint Stack<T>::find( T const & e ) const\n{\n\tfor( int i=0 ; i<_size ; i++)\n\t\tif( data[i] == e )\n\t\t\treturn i;\n\treturn -1;\n}\nstruct Queen\n{\n\tint x,y;\n\tQueen( int xx=0, int yy=0 ):x(xx),y(yy){}\n\tbool operator == ( Queen const & a ) const\n\t{\n\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tbool operator != ( Queen const & a ) const { return !( *this == a );}\n};\nint placeQueens( int n ) // n皇后\n{\n\tint num_solution=0;\n\tStack< Queen >a; \n\tQueen q(0,0);  //当前寻求位置放的皇后\n\tdo\n\t{\n\t\tif( a.size()>=n || q.y>=n ) // 若是列数超出边界或已经构成一个解\n\t\t{\t\n\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试\n\t\t\tq.y++;\n\t\t}\n\t\twhile( q.y<n && a.find(q)>=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突\n\t\t\tq.y++;\n\t\tif( q.y<n )  // 找到位置放置皇后\n\t\t{\n\t\t\ta.push( q );\n\t\t\tif( a.size()>=n )\n\t\t\t\tnum_solution++;\n\t\t\tq.x++;  // 前往下一行找解，列数重置\n\t\t\tq.y=0;\n\t\t}\n\t}\n\twhile( !( q.x==0 && q.y>=n ) );\n\treturn num_solution;\n}\n```\n\n# **队列**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名        | 功能      |\n| ---- | ---------- | ------- |\n| bool | empty()    | 判断是否为空  |\n| int  | size()     | 获取队列的大小 |\n| void | enqueue(n) | 将n入队    |\n| T&   | front()    | 查看队头元素  |\n| T    | dequeue()  | 删除队头元素  |\n| T&   | rear()     | 查看队尾元素  |\n\n## **二. 基本定义：**\n\n队列同样可以用数组或链表实现\n\n### **2-1. 版本一：继承List类**\n\n在这里选择继承[笔记一](https://zedom1.github.io/2017/08/12/list/)中实现的双向链表List类\n\n```\ntemplate <typename T>\nstruct queue:public List<T> //利用双向链表版\n{ // size和empty直接沿用\n\tvoid enqueue ( T const& e ) {insertAsLast(e);}\n\tT dequeue() { return remove(first()); }\n\tT& front() { return first()->data; }\n\tT& rear() { return last()->data; }\n};\n```\n\n### **2-2. 版本二：从零开始的数组版**\n\n用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。\n\n```\ntemplate <typename T>\nstruct queue  // 数组模拟版\n{\nprivate:\n\tT *data;\n\tint first,last,maxsize;\n\nprotected:\n\tvoid expand();\n// expand()判断 last 或 last-first 是否接近maxsize\npublic:\n\tqueue();\n\t~queue() {delete []data;}\n\tbool empty()const {return first==last;}\n\tint size()const {return last-first;}\n\tT& front()const { if(!empty())return data[first]; else exit(1);}\n\tT& rear()const { if(!empty())return data[last-1]; else exit(1);}\n\tvoid enqueue( T const & e) { expand(); data[last++]=e; }\n\tT dequeue() { return data[(first++)-1]; }\n};\n```\n\n### **2-3. 版本三：环状数组版**\n\n与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了\n\n适用于已知数据的规模的情况\n\n数组在逻辑上相连而在物理上不相连，用取余size实现\n\n```\ntemplate <typename T>\nstruct Queue\n{\nprivate:\n\tT *data;\n\tint maxsize;\n\tint first;\n\tint last;\n\tint size;\n\npublic:\n\tQueue(int size=0)\n\t{\n\t\tmaxsize=size+1;\n\t\tlast=0;\n\t\tfirst=1;\n\t\tdata= new T[maxsize];\n\t}\n\t~Queue()\n\t{\n\t\tdelete []data;\n\t}\n\tvoid clear()\n\t{\n\t\tlast=first=0;\n\t}\n\tvoid enqueue(const T & it)\n\t{\n\t\tlast=(last+1)%maxsize;\n\t\tdata[last]=it;\n\t}\n\tT dequeue()\n\t{\n\t\tT it = data[first];\n\t\tfirst = (first+1)%maxsize;\n\t\treturn it;\n\t}\n\tconst T firstValue()\n\t{\n\t\treturn data[first];\n\t}\n\tint length()\n\t{\n\t\treturn ((last+maxsize)-first+1)%maxsize;\n\t}\n\n};\n```\n\n# **完整实现代码**\n\n[栈的完整实现 ( 附带应用的实现 )](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp)\n\n[队列的完整实现](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp)","slug":"DataStructure_Stack","published":1,"updated":"2018-05-25T12:41:12.313Z","photos":[],"link":"","_id":"cjleshqja0008ryfctetc3iop","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><p><strong>栈</strong>(stack)和<strong>队列</strong>(queue)均属于<strong>线性存储</strong>结构</p>\n<p>栈特性：</p>\n<blockquote>\n<ol>\n<li>LIFO ( last in first out ) 后进先出</li>\n<li>元素插入和删除仅在一端进行</li>\n</ol>\n</blockquote>\n<p>队列特性：</p>\n<blockquote>\n<ol>\n<li>FIFO ( first in first out ) 先进先出</li>\n<li>元素在队尾插入，在队头删除</li>\n</ol>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg\" alt=\"栈和队列\"></p>\n<p>这两种结构均可以用数组或链表实现</p>\n<p>本文主要介绍栈，以下实现均为c++.</p>\n<a id=\"more\"></a>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a><strong>栈</strong></h1><h2 id=\"一-常用接口：\"><a href=\"#一-常用接口：\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取栈的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>push(n)</td>\n<td>将n压入栈</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>top()</td>\n<td>取栈顶元素而不弹出</td>\n</tr>\n<tr>\n<td>T</td>\n<td>pop()</td>\n<td>弹出栈顶元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：\"><a href=\"#二-基本定义：\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>本文用数组实现栈。<br>在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。</p>\n<p>（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）</p>\n<p>栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Stack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint _size,maxsize;   // 当前规模和最大规模</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();  // 扩容</span><br><span class=\"line\">\tvoid shrink();  // 缩容</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tStack()&#123; _size =0 ; maxsize=4; data=new T[maxsize]; &#125;;</span><br><span class=\"line\">\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶</span><br><span class=\"line\">\t~Stack() &#123; delete []data; &#125;</span><br><span class=\"line\">\tvoid push( T const &amp; e ) &#123; expand(); data[_size++]=e;  &#125;</span><br><span class=\"line\">\tT pop( ) &#123; shrink(); return data[--_size];   &#125;</span><br><span class=\"line\">\tT &amp; top( ) &#123; return data[_size-1];&#125;;</span><br><span class=\"line\">\tint empty()const &#123;return _size==0;&#125;</span><br><span class=\"line\">\tint size()const &#123;return _size;&#125;</span><br><span class=\"line\">\tint find( T const &amp; e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-典型应用：\"><a href=\"#三-典型应用：\" class=\"headerlink\" title=\"三. 典型应用：\"></a><strong>三. 典型应用：</strong></h2><p><strong>一. 逆序输出</strong></p>\n<p>输出次序和处理过程颠倒</p>\n<p>例如：进制转换</p>\n<p><strong>二. 递归嵌套</strong></p>\n<p>具有自相似性 ( 总体和局部相似 )</p>\n<p>例如：括号匹配、栈混洗(stack permutation)</p>\n<p><strong>三. 延迟缓冲</strong></p>\n<p>线性扫描算法模式</p>\n<p>例如：中缀表达式求值</p>\n<p><strong>四. 栈式计算</strong></p>\n<p>例如：逆波兰表达式转换（RPN Reverse Polish Notation）</p>\n<p><strong>五. 试探回溯</strong></p>\n<p>例如：n皇后问题、寻路</p>\n<p>下面开始一一介绍这些应用：</p>\n<h3 id=\"3-1-进制转换：\"><a href=\"#3-1-进制转换：\" class=\"headerlink\" title=\"3-1. 进制转换：\"></a><strong>3-1. 进制转换：</strong></h3><p>思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。</p>\n<p>借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void convert(  int n , int base ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;s;</span><br><span class=\"line\">\tstatic char digit[]=</span><br><span class=\"line\">\t&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;;</span><br><span class=\"line\">\t// 进制限定在2-16，有需要可以继续扩展</span><br><span class=\"line\">\twhile(n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts.push( digit[n%base]);</span><br><span class=\"line\">\t\tn/=base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t\tcout&lt;&lt;s.pop();</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-括号匹配：\"><a href=\"#3-2-括号匹配：\" class=\"headerlink\" title=\"3-2. 括号匹配：\"></a><strong>3-2. 括号匹配：</strong></h3><p>判断某一表达式内的括号是否完全匹配</p>\n<p>对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。</p>\n<p>然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。</p>\n<p>而借助栈我们能够很轻松地完成多括号匹配的任务。</p>\n<p>思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。</p>\n<p>显示为流程图即是</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG\" alt=\"流程图\"></p>\n<p>下面来看一下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool judge ( char *s , int n ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;a;</span><br><span class=\"line\">\tfor(int i=0 ; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( s[i]!=&apos;(&apos; &amp;&amp; s[i]!=&apos;)&apos; &amp;&amp; s[i]!=&apos;[&apos; &amp;&amp; s[i]!=&apos;]&apos; )</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tif( s[i]==&apos;(&apos;|| s[i]==&apos;[&apos;)</span><br><span class=\"line\">\t\t\ta.push(s[i]);</span><br><span class=\"line\">\t\telse if(a.empty())</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\telse if( (s[i]==&apos;)&apos;&amp;&amp;a.top()==&apos;(&apos;) || (s[i]==&apos;]&apos;&amp;&amp;a.top()==&apos;[&apos;) )</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(\ta.empty() )</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-栈混洗：\"><a href=\"#3-3-栈混洗：\" class=\"headerlink\" title=\"3-3. 栈混洗：\"></a><strong>3-3. 栈混洗：</strong></h3><h4 id=\"3-3-0-概念：\"><a href=\"#3-3-0-概念：\" class=\"headerlink\" title=\"3-3-0. 概念：\"></a><strong>3-3-0. 概念：</strong></h4><p>栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。</p>\n<p>栈混洗的过程中只允许以下两个操作：</p>\n<blockquote>\n<ol>\n<li>A栈顶弹出并压入栈S S.push(A.pop())</li>\n<li>S栈顶弹出并压入栈B B.push(S.pop())</li>\n</ol>\n</blockquote>\n<h4 id=\"3-3-1-排列种数：\"><a href=\"#3-3-1-排列种数：\" class=\"headerlink\" title=\"3-3-1. 排列种数：\"></a><strong>3-3-1. 排列种数：</strong></h4><p>先来计算一下栈通过栈混洗操作后有多少种排列方式：</p>\n<p>设总数为n的栈有SP(n)种排列方式</p>\n<p>推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]<br>对于第一个元素而言，它的排列方式有SP(n)种。</p>\n<script type=\"math/tex; mode=display\">SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)</script><p>解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$</p>\n<h4 id=\"3-3-2-甄别栈混洗：\"><a href=\"#3-3-2-甄别栈混洗：\" class=\"headerlink\" title=\"3-3-2. 甄别栈混洗：\"></a><strong>3-3-2. 甄别栈混洗：</strong></h4><p>如何甄别一个序列是否是栈混洗呢？</p>\n<p>三个元素栈混洗有5种，全排列有6种, &lt;1,2,3] 非栈混洗的排列为 &lt;2,1,3] ( ‘&lt;’为栈顶方向 )</p>\n<p>而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关</p>\n<p>对于 1&lt;=i &lt; j &lt; k&lt;=n,若出现 k i j的排列，则非栈混洗 （称为<strong>禁形</strong>）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg\" alt=\"禁形1\"></p>\n<p>通过证明，禁形对于是否是栈混洗为 <strong>充要条件</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg\" alt=\"禁形2\"></p>\n<p>那么我们可以得到如下的判别方法：</p>\n<p>O(n3)判别方法：分别枚举i，j，k</p>\n<p>O(n2)判别方法：枚举 i , j , j+1</p>\n<p>O(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗</p>\n<p>以下为O(n)的判别方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool stackPermutation( T *origin, T * b , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;T&gt; s;</span><br><span class=\"line\">\tStack&lt;T&gt; ori( origin ,n );</span><br><span class=\"line\">\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s.empty() )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( !s.empty() )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( s.top()==b[j] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ts.pop();</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;pop\\n&quot;;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s.empty() || !ori.empty() )</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-栈混洗与括号匹配：\"><a href=\"#3-3-3-栈混洗与括号匹配：\" class=\"headerlink\" title=\"3-3-3. 栈混洗与括号匹配：\"></a><strong>3-3-3. 栈混洗与括号匹配：</strong></h4><p>值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg\" alt=\"栈混洗与括号匹配\"></p>\n<p>结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配</p>\n<p>同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种</p>\n<h3 id=\"3-4-中缀表达式求值：\"><a href=\"#3-4-中缀表达式求值：\" class=\"headerlink\" title=\"3-4. 中缀表达式求值：\"></a><strong>3-4. 中缀表达式求值：</strong></h3><h4 id=\"3-4-0-概述：\"><a href=\"#3-4-0-概述：\" class=\"headerlink\" title=\"3-4-0. 概述：\"></a><strong>3-4-0. 概述：</strong></h4><p>中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。<br>例如 1+1 即是一个中缀表达式</p>\n<h4 id=\"3-4-1-算法：\"><a href=\"#3-4-1-算法：\" class=\"headerlink\" title=\"3-4-1. 算法：\"></a><strong>3-4-1. 算法：</strong></h4><p>主体思路：用两个栈分别保存<strong>操作数</strong>和<strong>运算符</strong>，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。</p>\n<p>此外，值得注意的是</p>\n<p>一：为了方便判断优先级，在优先级表中<strong>同一阶级的运算符根据出现次序不同优先级也不同</strong>，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.</p>\n<p>二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)</p>\n<p>三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。</p>\n<p>四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const char Prior[9][9] = </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">//        +   -   *   /   ^   !   (   )  \\0</span><br><span class=\"line\">/* + */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* - */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* * */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* / */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ^ */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ! */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos; &apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ( */  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;=&apos;,&apos; &apos;,</span><br><span class=\"line\">/* ) */  &apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,</span><br><span class=\"line\">/* \\0*/  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos; &apos;,&apos;=&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void readNumber( char *&amp;s , Stack&lt;float&gt;&amp; opnd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat ans=0;</span><br><span class=\"line\">\topnd.push( *s-&apos;0&apos; );</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop()*10 + *s-&apos;0&apos; );</span><br><span class=\"line\">\tif(*s!=&apos;.&apos;)   // 可能是小数</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfloat f=1;</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop() + (*s-&apos;0&apos;)*(f/=10.0) );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void getnum( char a, int &amp; num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch(a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: num=0;return;</span><br><span class=\"line\">\tcase &apos;-&apos;: num=1;return;</span><br><span class=\"line\">\tcase &apos;*&apos;: num=2;return;</span><br><span class=\"line\">\tcase &apos;/&apos;: num=3;return;</span><br><span class=\"line\">\tcase &apos;^&apos;: num=4;return;</span><br><span class=\"line\">\tcase &apos;!&apos;: num=5;return;</span><br><span class=\"line\">\tcase &apos;(&apos;: num=6;return;</span><br><span class=\"line\">\tcase &apos;)&apos;: num=7;return;</span><br><span class=\"line\">\tcase &apos;\\0&apos;: num=8;return;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char orderBetween ( char a, char b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num1,num2;</span><br><span class=\"line\">\tgetnum( a, num1 );</span><br><span class=\"line\">\tgetnum( b, num2 );</span><br><span class=\"line\">\treturn Prior[num1][num2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( float num1, char op , float num2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch (op)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: return num1+num2;</span><br><span class=\"line\">\tcase &apos;-&apos;: return num1-num2;</span><br><span class=\"line\">\tcase &apos;*&apos;: return num1*num2;</span><br><span class=\"line\">\tcase &apos;/&apos;: return num1/num2;</span><br><span class=\"line\">\tcase &apos;^&apos;: return pow(num1,num2);</span><br><span class=\"line\">\tdefault : exit(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( char op, float num1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( abs(num1-0)&lt;1e-6 )</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;num1 ; i++)</span><br><span class=\"line\">\t\tnum1*=i;</span><br><span class=\"line\">\treturn num1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t// 逆向取数，可能是&apos;-&apos;号这些和次序相关的运算符</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-逆波兰表达式：\"><a href=\"#3-5-逆波兰表达式：\" class=\"headerlink\" title=\"3-5. 逆波兰表达式：\"></a><strong>3-5. 逆波兰表达式：</strong></h3><p>中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。</p>\n<h4 id=\"3-5-0-概念：\"><a href=\"#3-5-0-概念：\" class=\"headerlink\" title=\"3-5-0. 概念：\"></a><strong>3-5-0. 概念：</strong></h4><p>逆波兰表达式 ( RPN : Reverse Polish Notation )</p>\n<p>没有括号和约定俗成的优先级，从左至右扫描表达式，运算符<strong>谁先出现算谁</strong>。</p>\n<p>运算符位于参与运算的运算数之后。</p>\n<p>例如：</p>\n<p>0！1+2 3！*4+5-^</p>\n<p>值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。</p>\n<p>以上表达式翻译成中缀表达式即是：</p>\n<p>( 0! + 1 )^( 2 * 3! +4 - 5 )</p>\n<p>和中缀表达式相比，逆波兰表达式的优点在于<strong>计算速度更快</strong>。</p>\n<p>在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。</p>\n<h4 id=\"3-5-2-计算：\"><a href=\"#3-5-2-计算：\" class=\"headerlink\" title=\"3-5-2. 计算：\"></a><strong>3-5-2. 计算：</strong></h4><p>计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float rpnEvaluate( char * RPN )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tRPN[len++]=&apos;\\0&apos;;</span><br><span class=\"line\">\twhile(len--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*RPN)&lt;=&apos;9&apos;&amp;&amp;(*RPN)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( RPN, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchar op=*RPN;</span><br><span class=\"line\">\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-5-2-手工转换：\"><a href=\"#3-5-2-手工转换：\" class=\"headerlink\" title=\"3-5-2. 手工转换：\"></a><strong>3-5-2. 手工转换：</strong></h4><p>手工将中缀表达式转换成逆波兰表达式的方法如下：</p>\n<p>1.用括号显式界定所有运算符</p>\n<p>2.将所有运算符移到对应的右括号后面</p>\n<p>3.去掉所有括号</p>\n<p>4.稍加整理</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg\" alt=\"手工转换\"></p>\n<h4 id=\"3-5-3-转换算法：\"><a href=\"#3-5-3-转换算法：\" class=\"headerlink\" title=\"3-5-3. 转换算法：\"></a><strong>3-5-3. 转换算法：</strong></h4><p>非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上</span><br><span class=\"line\">void append( char *&amp;RPN, float num )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tchar buf[64];</span><br><span class=\"line\">\tif( num!= (float)(int)num )   // 判断是否为整数</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%.2f \\0&quot;,num); // 小数暂取两位</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%d \\0&quot;,(int)num);</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容</span><br><span class=\"line\">\tstrcat( RPN,buf );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void append( char *&amp;RPN, char op )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen( RPN );</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );</span><br><span class=\"line\">\tsprintf( RPN+len, &quot;%c \\0&quot;,op );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s , char *&amp;RPN )</span><br><span class=\"line\">&#123; // s：中缀表达式， RPN：需要存放转换后表达式的位置</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\tRPN[0]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\tappend( RPN, opnd.top());</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tappend( RPN, op );</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-n皇后问题：\"><a href=\"#3-6-n皇后问题：\" class=\"headerlink\" title=\"3-6. n皇后问题：\"></a><strong>3-6. n皇后问题：</strong></h3><h4 id=\"3-6-0-概述：\"><a href=\"#3-6-0-概述：\" class=\"headerlink\" title=\"3-6-0. 概述：\"></a><strong>3-6-0. 概述：</strong></h4><p>试探：逐步增加候选解的长度 ，逐步向目标解靠近</p>\n<p>回溯：一旦发现和目标解不同，则回溯到上一步继续试探</p>\n<p>一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。</p>\n<p>n皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg\" alt=\"n皇后问题\"></p>\n<h4 id=\"3-6-1-算法：\"><a href=\"#3-6-1-算法：\" class=\"headerlink\" title=\"3-6-1. 算法：\"></a><strong>3-6-1. 算法：</strong></h4><p>用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Stack&lt;T&gt;::find( T const &amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0 ; i&lt;_size ; i++)</span><br><span class=\"line\">\t\tif( data[i] == e )</span><br><span class=\"line\">\t\t\treturn i;</span><br><span class=\"line\">\treturn -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct Queen</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint x,y;</span><br><span class=\"line\">\tQueen( int xx=0, int yy=0 ):x(xx),y(yy)&#123;&#125;</span><br><span class=\"line\">\tbool operator == ( Queen const &amp; a ) const</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbool operator != ( Queen const &amp; a ) const &#123; return !( *this == a );&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int placeQueens( int n ) // n皇后</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num_solution=0;</span><br><span class=\"line\">\tStack&lt; Queen &gt;a; </span><br><span class=\"line\">\tQueen q(0,0);  //当前寻求位置放的皇后</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( a.size()&gt;=n || q.y&gt;=n ) // 若是列数超出边界或已经构成一个解</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( q.y&lt;n &amp;&amp; a.find(q)&gt;=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\tif( q.y&lt;n )  // 找到位置放置皇后</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta.push( q );</span><br><span class=\"line\">\t\t\tif( a.size()&gt;=n )</span><br><span class=\"line\">\t\t\t\tnum_solution++;</span><br><span class=\"line\">\t\t\tq.x++;  // 前往下一行找解，列数重置</span><br><span class=\"line\">\t\t\tq.y=0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !( q.x==0 &amp;&amp; q.y&gt;=n ) );</span><br><span class=\"line\">\treturn num_solution;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a><strong>队列</strong></h1><h2 id=\"一-常用接口：-1\"><a href=\"#一-常用接口：-1\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取队列的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>enqueue(n)</td>\n<td>将n入队</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>front()</td>\n<td>查看队头元素</td>\n</tr>\n<tr>\n<td>T</td>\n<td>dequeue()</td>\n<td>删除队头元素</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>rear()</td>\n<td>查看队尾元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：-1\"><a href=\"#二-基本定义：-1\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>队列同样可以用数组或链表实现</p>\n<h3 id=\"2-1-版本一：继承List类\"><a href=\"#2-1-版本一：继承List类\" class=\"headerlink\" title=\"2-1. 版本一：继承List类\"></a><strong>2-1. 版本一：继承List类</strong></h3><p>在这里选择继承<a href=\"https://zedom1.github.io/2017/08/12/list/\">笔记一</a>中实现的双向链表List类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue:public List&lt;T&gt; //利用双向链表版</span><br><span class=\"line\">&#123; // size和empty直接沿用</span><br><span class=\"line\">\tvoid enqueue ( T const&amp; e ) &#123;insertAsLast(e);&#125;</span><br><span class=\"line\">\tT dequeue() &#123; return remove(first()); &#125;</span><br><span class=\"line\">\tT&amp; front() &#123; return first()-&gt;data; &#125;</span><br><span class=\"line\">\tT&amp; rear() &#123; return last()-&gt;data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-版本二：从零开始的数组版\"><a href=\"#2-2-版本二：从零开始的数组版\" class=\"headerlink\" title=\"2-2. 版本二：从零开始的数组版\"></a><strong>2-2. 版本二：从零开始的数组版</strong></h3><p>用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue  // 数组模拟版</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint first,last,maxsize;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();</span><br><span class=\"line\">// expand()判断 last 或 last-first 是否接近maxsize</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tqueue();</span><br><span class=\"line\">\t~queue() &#123;delete []data;&#125;</span><br><span class=\"line\">\tbool empty()const &#123;return first==last;&#125;</span><br><span class=\"line\">\tint size()const &#123;return last-first;&#125;</span><br><span class=\"line\">\tT&amp; front()const &#123; if(!empty())return data[first]; else exit(1);&#125;</span><br><span class=\"line\">\tT&amp; rear()const &#123; if(!empty())return data[last-1]; else exit(1);&#125;</span><br><span class=\"line\">\tvoid enqueue( T const &amp; e) &#123; expand(); data[last++]=e; &#125;</span><br><span class=\"line\">\tT dequeue() &#123; return data[(first++)-1]; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-版本三：环状数组版\"><a href=\"#2-3-版本三：环状数组版\" class=\"headerlink\" title=\"2-3. 版本三：环状数组版\"></a><strong>2-3. 版本三：环状数组版</strong></h3><p>与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了</p>\n<p>适用于已知数据的规模的情况</p>\n<p>数组在逻辑上相连而在物理上不相连，用取余size实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Queue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint maxsize;</span><br><span class=\"line\">\tint first;</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tQueue(int size=0)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmaxsize=size+1;</span><br><span class=\"line\">\t\tlast=0;</span><br><span class=\"line\">\t\tfirst=1;</span><br><span class=\"line\">\t\tdata= new T[maxsize];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Queue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdelete []data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid clear()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=first=0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid enqueue(const T &amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=(last+1)%maxsize;</span><br><span class=\"line\">\t\tdata[last]=it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tT dequeue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tT it = data[first];</span><br><span class=\"line\">\t\tfirst = (first+1)%maxsize;</span><br><span class=\"line\">\t\treturn it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconst T firstValue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn data[first];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint length()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn ((last+maxsize)-first+1)%maxsize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp\" target=\"_blank\" rel=\"noopener\">栈的完整实现 ( 附带应用的实现 )</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp\" target=\"_blank\" rel=\"noopener\">队列的完整实现</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><p><strong>栈</strong>(stack)和<strong>队列</strong>(queue)均属于<strong>线性存储</strong>结构</p>\n<p>栈特性：</p>\n<blockquote>\n<ol>\n<li>LIFO ( last in first out ) 后进先出</li>\n<li>元素插入和删除仅在一端进行</li>\n</ol>\n</blockquote>\n<p>队列特性：</p>\n<blockquote>\n<ol>\n<li>FIFO ( first in first out ) 先进先出</li>\n<li>元素在队尾插入，在队头删除</li>\n</ol>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg\" alt=\"栈和队列\"></p>\n<p>这两种结构均可以用数组或链表实现</p>\n<p>本文主要介绍栈，以下实现均为c++.</p>","more":"<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a><strong>栈</strong></h1><h2 id=\"一-常用接口：\"><a href=\"#一-常用接口：\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取栈的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>push(n)</td>\n<td>将n压入栈</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>top()</td>\n<td>取栈顶元素而不弹出</td>\n</tr>\n<tr>\n<td>T</td>\n<td>pop()</td>\n<td>弹出栈顶元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：\"><a href=\"#二-基本定义：\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>本文用数组实现栈。<br>在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。</p>\n<p>（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）</p>\n<p>栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Stack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint _size,maxsize;   // 当前规模和最大规模</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();  // 扩容</span><br><span class=\"line\">\tvoid shrink();  // 缩容</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tStack()&#123; _size =0 ; maxsize=4; data=new T[maxsize]; &#125;;</span><br><span class=\"line\">\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶</span><br><span class=\"line\">\t~Stack() &#123; delete []data; &#125;</span><br><span class=\"line\">\tvoid push( T const &amp; e ) &#123; expand(); data[_size++]=e;  &#125;</span><br><span class=\"line\">\tT pop( ) &#123; shrink(); return data[--_size];   &#125;</span><br><span class=\"line\">\tT &amp; top( ) &#123; return data[_size-1];&#125;;</span><br><span class=\"line\">\tint empty()const &#123;return _size==0;&#125;</span><br><span class=\"line\">\tint size()const &#123;return _size;&#125;</span><br><span class=\"line\">\tint find( T const &amp; e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-典型应用：\"><a href=\"#三-典型应用：\" class=\"headerlink\" title=\"三. 典型应用：\"></a><strong>三. 典型应用：</strong></h2><p><strong>一. 逆序输出</strong></p>\n<p>输出次序和处理过程颠倒</p>\n<p>例如：进制转换</p>\n<p><strong>二. 递归嵌套</strong></p>\n<p>具有自相似性 ( 总体和局部相似 )</p>\n<p>例如：括号匹配、栈混洗(stack permutation)</p>\n<p><strong>三. 延迟缓冲</strong></p>\n<p>线性扫描算法模式</p>\n<p>例如：中缀表达式求值</p>\n<p><strong>四. 栈式计算</strong></p>\n<p>例如：逆波兰表达式转换（RPN Reverse Polish Notation）</p>\n<p><strong>五. 试探回溯</strong></p>\n<p>例如：n皇后问题、寻路</p>\n<p>下面开始一一介绍这些应用：</p>\n<h3 id=\"3-1-进制转换：\"><a href=\"#3-1-进制转换：\" class=\"headerlink\" title=\"3-1. 进制转换：\"></a><strong>3-1. 进制转换：</strong></h3><p>思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。</p>\n<p>借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void convert(  int n , int base ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;s;</span><br><span class=\"line\">\tstatic char digit[]=</span><br><span class=\"line\">\t&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;;</span><br><span class=\"line\">\t// 进制限定在2-16，有需要可以继续扩展</span><br><span class=\"line\">\twhile(n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts.push( digit[n%base]);</span><br><span class=\"line\">\t\tn/=base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t\tcout&lt;&lt;s.pop();</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-括号匹配：\"><a href=\"#3-2-括号匹配：\" class=\"headerlink\" title=\"3-2. 括号匹配：\"></a><strong>3-2. 括号匹配：</strong></h3><p>判断某一表达式内的括号是否完全匹配</p>\n<p>对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。</p>\n<p>然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。</p>\n<p>而借助栈我们能够很轻松地完成多括号匹配的任务。</p>\n<p>思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。</p>\n<p>显示为流程图即是</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG\" alt=\"流程图\"></p>\n<p>下面来看一下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool judge ( char *s , int n ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;a;</span><br><span class=\"line\">\tfor(int i=0 ; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( s[i]!=&apos;(&apos; &amp;&amp; s[i]!=&apos;)&apos; &amp;&amp; s[i]!=&apos;[&apos; &amp;&amp; s[i]!=&apos;]&apos; )</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tif( s[i]==&apos;(&apos;|| s[i]==&apos;[&apos;)</span><br><span class=\"line\">\t\t\ta.push(s[i]);</span><br><span class=\"line\">\t\telse if(a.empty())</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\telse if( (s[i]==&apos;)&apos;&amp;&amp;a.top()==&apos;(&apos;) || (s[i]==&apos;]&apos;&amp;&amp;a.top()==&apos;[&apos;) )</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(\ta.empty() )</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-栈混洗：\"><a href=\"#3-3-栈混洗：\" class=\"headerlink\" title=\"3-3. 栈混洗：\"></a><strong>3-3. 栈混洗：</strong></h3><h4 id=\"3-3-0-概念：\"><a href=\"#3-3-0-概念：\" class=\"headerlink\" title=\"3-3-0. 概念：\"></a><strong>3-3-0. 概念：</strong></h4><p>栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。</p>\n<p>栈混洗的过程中只允许以下两个操作：</p>\n<blockquote>\n<ol>\n<li>A栈顶弹出并压入栈S S.push(A.pop())</li>\n<li>S栈顶弹出并压入栈B B.push(S.pop())</li>\n</ol>\n</blockquote>\n<h4 id=\"3-3-1-排列种数：\"><a href=\"#3-3-1-排列种数：\" class=\"headerlink\" title=\"3-3-1. 排列种数：\"></a><strong>3-3-1. 排列种数：</strong></h4><p>先来计算一下栈通过栈混洗操作后有多少种排列方式：</p>\n<p>设总数为n的栈有SP(n)种排列方式</p>\n<p>推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]<br>对于第一个元素而言，它的排列方式有SP(n)种。</p>\n<script type=\"math/tex; mode=display\">SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)</script><p>解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$</p>\n<h4 id=\"3-3-2-甄别栈混洗：\"><a href=\"#3-3-2-甄别栈混洗：\" class=\"headerlink\" title=\"3-3-2. 甄别栈混洗：\"></a><strong>3-3-2. 甄别栈混洗：</strong></h4><p>如何甄别一个序列是否是栈混洗呢？</p>\n<p>三个元素栈混洗有5种，全排列有6种, &lt;1,2,3] 非栈混洗的排列为 &lt;2,1,3] ( ‘&lt;’为栈顶方向 )</p>\n<p>而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关</p>\n<p>对于 1&lt;=i &lt; j &lt; k&lt;=n,若出现 k i j的排列，则非栈混洗 （称为<strong>禁形</strong>）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg\" alt=\"禁形1\"></p>\n<p>通过证明，禁形对于是否是栈混洗为 <strong>充要条件</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg\" alt=\"禁形2\"></p>\n<p>那么我们可以得到如下的判别方法：</p>\n<p>O(n3)判别方法：分别枚举i，j，k</p>\n<p>O(n2)判别方法：枚举 i , j , j+1</p>\n<p>O(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗</p>\n<p>以下为O(n)的判别方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool stackPermutation( T *origin, T * b , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;T&gt; s;</span><br><span class=\"line\">\tStack&lt;T&gt; ori( origin ,n );</span><br><span class=\"line\">\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s.empty() )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( !s.empty() )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( s.top()==b[j] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ts.pop();</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;pop\\n&quot;;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s.empty() || !ori.empty() )</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-栈混洗与括号匹配：\"><a href=\"#3-3-3-栈混洗与括号匹配：\" class=\"headerlink\" title=\"3-3-3. 栈混洗与括号匹配：\"></a><strong>3-3-3. 栈混洗与括号匹配：</strong></h4><p>值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg\" alt=\"栈混洗与括号匹配\"></p>\n<p>结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配</p>\n<p>同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种</p>\n<h3 id=\"3-4-中缀表达式求值：\"><a href=\"#3-4-中缀表达式求值：\" class=\"headerlink\" title=\"3-4. 中缀表达式求值：\"></a><strong>3-4. 中缀表达式求值：</strong></h3><h4 id=\"3-4-0-概述：\"><a href=\"#3-4-0-概述：\" class=\"headerlink\" title=\"3-4-0. 概述：\"></a><strong>3-4-0. 概述：</strong></h4><p>中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。<br>例如 1+1 即是一个中缀表达式</p>\n<h4 id=\"3-4-1-算法：\"><a href=\"#3-4-1-算法：\" class=\"headerlink\" title=\"3-4-1. 算法：\"></a><strong>3-4-1. 算法：</strong></h4><p>主体思路：用两个栈分别保存<strong>操作数</strong>和<strong>运算符</strong>，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。</p>\n<p>此外，值得注意的是</p>\n<p>一：为了方便判断优先级，在优先级表中<strong>同一阶级的运算符根据出现次序不同优先级也不同</strong>，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.</p>\n<p>二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)</p>\n<p>三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。</p>\n<p>四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const char Prior[9][9] = </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">//        +   -   *   /   ^   !   (   )  \\0</span><br><span class=\"line\">/* + */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* - */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* * */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* / */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ^ */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ! */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos; &apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ( */  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;=&apos;,&apos; &apos;,</span><br><span class=\"line\">/* ) */  &apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,</span><br><span class=\"line\">/* \\0*/  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos; &apos;,&apos;=&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void readNumber( char *&amp;s , Stack&lt;float&gt;&amp; opnd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat ans=0;</span><br><span class=\"line\">\topnd.push( *s-&apos;0&apos; );</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop()*10 + *s-&apos;0&apos; );</span><br><span class=\"line\">\tif(*s!=&apos;.&apos;)   // 可能是小数</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfloat f=1;</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop() + (*s-&apos;0&apos;)*(f/=10.0) );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void getnum( char a, int &amp; num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch(a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: num=0;return;</span><br><span class=\"line\">\tcase &apos;-&apos;: num=1;return;</span><br><span class=\"line\">\tcase &apos;*&apos;: num=2;return;</span><br><span class=\"line\">\tcase &apos;/&apos;: num=3;return;</span><br><span class=\"line\">\tcase &apos;^&apos;: num=4;return;</span><br><span class=\"line\">\tcase &apos;!&apos;: num=5;return;</span><br><span class=\"line\">\tcase &apos;(&apos;: num=6;return;</span><br><span class=\"line\">\tcase &apos;)&apos;: num=7;return;</span><br><span class=\"line\">\tcase &apos;\\0&apos;: num=8;return;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char orderBetween ( char a, char b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num1,num2;</span><br><span class=\"line\">\tgetnum( a, num1 );</span><br><span class=\"line\">\tgetnum( b, num2 );</span><br><span class=\"line\">\treturn Prior[num1][num2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( float num1, char op , float num2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch (op)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: return num1+num2;</span><br><span class=\"line\">\tcase &apos;-&apos;: return num1-num2;</span><br><span class=\"line\">\tcase &apos;*&apos;: return num1*num2;</span><br><span class=\"line\">\tcase &apos;/&apos;: return num1/num2;</span><br><span class=\"line\">\tcase &apos;^&apos;: return pow(num1,num2);</span><br><span class=\"line\">\tdefault : exit(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( char op, float num1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( abs(num1-0)&lt;1e-6 )</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;num1 ; i++)</span><br><span class=\"line\">\t\tnum1*=i;</span><br><span class=\"line\">\treturn num1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t// 逆向取数，可能是&apos;-&apos;号这些和次序相关的运算符</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-逆波兰表达式：\"><a href=\"#3-5-逆波兰表达式：\" class=\"headerlink\" title=\"3-5. 逆波兰表达式：\"></a><strong>3-5. 逆波兰表达式：</strong></h3><p>中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。</p>\n<h4 id=\"3-5-0-概念：\"><a href=\"#3-5-0-概念：\" class=\"headerlink\" title=\"3-5-0. 概念：\"></a><strong>3-5-0. 概念：</strong></h4><p>逆波兰表达式 ( RPN : Reverse Polish Notation )</p>\n<p>没有括号和约定俗成的优先级，从左至右扫描表达式，运算符<strong>谁先出现算谁</strong>。</p>\n<p>运算符位于参与运算的运算数之后。</p>\n<p>例如：</p>\n<p>0！1+2 3！*4+5-^</p>\n<p>值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。</p>\n<p>以上表达式翻译成中缀表达式即是：</p>\n<p>( 0! + 1 )^( 2 * 3! +4 - 5 )</p>\n<p>和中缀表达式相比，逆波兰表达式的优点在于<strong>计算速度更快</strong>。</p>\n<p>在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。</p>\n<h4 id=\"3-5-2-计算：\"><a href=\"#3-5-2-计算：\" class=\"headerlink\" title=\"3-5-2. 计算：\"></a><strong>3-5-2. 计算：</strong></h4><p>计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float rpnEvaluate( char * RPN )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tRPN[len++]=&apos;\\0&apos;;</span><br><span class=\"line\">\twhile(len--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*RPN)&lt;=&apos;9&apos;&amp;&amp;(*RPN)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( RPN, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchar op=*RPN;</span><br><span class=\"line\">\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-5-2-手工转换：\"><a href=\"#3-5-2-手工转换：\" class=\"headerlink\" title=\"3-5-2. 手工转换：\"></a><strong>3-5-2. 手工转换：</strong></h4><p>手工将中缀表达式转换成逆波兰表达式的方法如下：</p>\n<p>1.用括号显式界定所有运算符</p>\n<p>2.将所有运算符移到对应的右括号后面</p>\n<p>3.去掉所有括号</p>\n<p>4.稍加整理</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg\" alt=\"手工转换\"></p>\n<h4 id=\"3-5-3-转换算法：\"><a href=\"#3-5-3-转换算法：\" class=\"headerlink\" title=\"3-5-3. 转换算法：\"></a><strong>3-5-3. 转换算法：</strong></h4><p>非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上</span><br><span class=\"line\">void append( char *&amp;RPN, float num )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tchar buf[64];</span><br><span class=\"line\">\tif( num!= (float)(int)num )   // 判断是否为整数</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%.2f \\0&quot;,num); // 小数暂取两位</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%d \\0&quot;,(int)num);</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容</span><br><span class=\"line\">\tstrcat( RPN,buf );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void append( char *&amp;RPN, char op )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen( RPN );</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );</span><br><span class=\"line\">\tsprintf( RPN+len, &quot;%c \\0&quot;,op );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s , char *&amp;RPN )</span><br><span class=\"line\">&#123; // s：中缀表达式， RPN：需要存放转换后表达式的位置</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\tRPN[0]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\tappend( RPN, opnd.top());</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tappend( RPN, op );</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-n皇后问题：\"><a href=\"#3-6-n皇后问题：\" class=\"headerlink\" title=\"3-6. n皇后问题：\"></a><strong>3-6. n皇后问题：</strong></h3><h4 id=\"3-6-0-概述：\"><a href=\"#3-6-0-概述：\" class=\"headerlink\" title=\"3-6-0. 概述：\"></a><strong>3-6-0. 概述：</strong></h4><p>试探：逐步增加候选解的长度 ，逐步向目标解靠近</p>\n<p>回溯：一旦发现和目标解不同，则回溯到上一步继续试探</p>\n<p>一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。</p>\n<p>n皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg\" alt=\"n皇后问题\"></p>\n<h4 id=\"3-6-1-算法：\"><a href=\"#3-6-1-算法：\" class=\"headerlink\" title=\"3-6-1. 算法：\"></a><strong>3-6-1. 算法：</strong></h4><p>用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Stack&lt;T&gt;::find( T const &amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0 ; i&lt;_size ; i++)</span><br><span class=\"line\">\t\tif( data[i] == e )</span><br><span class=\"line\">\t\t\treturn i;</span><br><span class=\"line\">\treturn -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct Queen</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint x,y;</span><br><span class=\"line\">\tQueen( int xx=0, int yy=0 ):x(xx),y(yy)&#123;&#125;</span><br><span class=\"line\">\tbool operator == ( Queen const &amp; a ) const</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbool operator != ( Queen const &amp; a ) const &#123; return !( *this == a );&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int placeQueens( int n ) // n皇后</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num_solution=0;</span><br><span class=\"line\">\tStack&lt; Queen &gt;a; </span><br><span class=\"line\">\tQueen q(0,0);  //当前寻求位置放的皇后</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( a.size()&gt;=n || q.y&gt;=n ) // 若是列数超出边界或已经构成一个解</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( q.y&lt;n &amp;&amp; a.find(q)&gt;=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\tif( q.y&lt;n )  // 找到位置放置皇后</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta.push( q );</span><br><span class=\"line\">\t\t\tif( a.size()&gt;=n )</span><br><span class=\"line\">\t\t\t\tnum_solution++;</span><br><span class=\"line\">\t\t\tq.x++;  // 前往下一行找解，列数重置</span><br><span class=\"line\">\t\t\tq.y=0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !( q.x==0 &amp;&amp; q.y&gt;=n ) );</span><br><span class=\"line\">\treturn num_solution;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a><strong>队列</strong></h1><h2 id=\"一-常用接口：-1\"><a href=\"#一-常用接口：-1\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取队列的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>enqueue(n)</td>\n<td>将n入队</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>front()</td>\n<td>查看队头元素</td>\n</tr>\n<tr>\n<td>T</td>\n<td>dequeue()</td>\n<td>删除队头元素</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>rear()</td>\n<td>查看队尾元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：-1\"><a href=\"#二-基本定义：-1\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>队列同样可以用数组或链表实现</p>\n<h3 id=\"2-1-版本一：继承List类\"><a href=\"#2-1-版本一：继承List类\" class=\"headerlink\" title=\"2-1. 版本一：继承List类\"></a><strong>2-1. 版本一：继承List类</strong></h3><p>在这里选择继承<a href=\"https://zedom1.github.io/2017/08/12/list/\">笔记一</a>中实现的双向链表List类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue:public List&lt;T&gt; //利用双向链表版</span><br><span class=\"line\">&#123; // size和empty直接沿用</span><br><span class=\"line\">\tvoid enqueue ( T const&amp; e ) &#123;insertAsLast(e);&#125;</span><br><span class=\"line\">\tT dequeue() &#123; return remove(first()); &#125;</span><br><span class=\"line\">\tT&amp; front() &#123; return first()-&gt;data; &#125;</span><br><span class=\"line\">\tT&amp; rear() &#123; return last()-&gt;data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-版本二：从零开始的数组版\"><a href=\"#2-2-版本二：从零开始的数组版\" class=\"headerlink\" title=\"2-2. 版本二：从零开始的数组版\"></a><strong>2-2. 版本二：从零开始的数组版</strong></h3><p>用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue  // 数组模拟版</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint first,last,maxsize;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();</span><br><span class=\"line\">// expand()判断 last 或 last-first 是否接近maxsize</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tqueue();</span><br><span class=\"line\">\t~queue() &#123;delete []data;&#125;</span><br><span class=\"line\">\tbool empty()const &#123;return first==last;&#125;</span><br><span class=\"line\">\tint size()const &#123;return last-first;&#125;</span><br><span class=\"line\">\tT&amp; front()const &#123; if(!empty())return data[first]; else exit(1);&#125;</span><br><span class=\"line\">\tT&amp; rear()const &#123; if(!empty())return data[last-1]; else exit(1);&#125;</span><br><span class=\"line\">\tvoid enqueue( T const &amp; e) &#123; expand(); data[last++]=e; &#125;</span><br><span class=\"line\">\tT dequeue() &#123; return data[(first++)-1]; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-版本三：环状数组版\"><a href=\"#2-3-版本三：环状数组版\" class=\"headerlink\" title=\"2-3. 版本三：环状数组版\"></a><strong>2-3. 版本三：环状数组版</strong></h3><p>与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了</p>\n<p>适用于已知数据的规模的情况</p>\n<p>数组在逻辑上相连而在物理上不相连，用取余size实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Queue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint maxsize;</span><br><span class=\"line\">\tint first;</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tQueue(int size=0)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmaxsize=size+1;</span><br><span class=\"line\">\t\tlast=0;</span><br><span class=\"line\">\t\tfirst=1;</span><br><span class=\"line\">\t\tdata= new T[maxsize];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Queue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdelete []data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid clear()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=first=0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid enqueue(const T &amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=(last+1)%maxsize;</span><br><span class=\"line\">\t\tdata[last]=it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tT dequeue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tT it = data[first];</span><br><span class=\"line\">\t\tfirst = (first+1)%maxsize;</span><br><span class=\"line\">\t\treturn it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconst T firstValue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn data[first];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint length()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn ((last+maxsize)-first+1)%maxsize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp\" target=\"_blank\" rel=\"noopener\">栈的完整实现 ( 附带应用的实现 )</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp\" target=\"_blank\" rel=\"noopener\">队列的完整实现</a></p>"},{"layout":"post","title":"Hello,World","date":"2017-05-09T16:00:00.000Z","comments":1,"_content":"\n自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.\n\n开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。\n\nStart From Zero, End With Infinite.","source":"_posts/Hello,World.md","raw":"---\nlayout: post\ntitle: \"Hello,World\"\ndate: 2017-05-10\ncomments: true\ntags: \n\t- others\n---\n\n自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.\n\n开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。\n\nStart From Zero, End With Infinite.","slug":"Hello,World","published":1,"updated":"2018-05-25T12:41:12.717Z","photos":[],"link":"","_id":"cjleshqjc000aryfcyaedqfhp","content":"<p>自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.</p>\n<p>开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。</p>\n<p>Start From Zero, End With Infinite.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.</p>\n<p>开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。</p>\n<p>Start From Zero, End With Infinite.</p>\n"},{"layout":"post","title":"数据结构笔记（三）：树","date":"2017-08-14T16:00:00.000Z","comments":1,"_content":"\n# **树**\n\n## **概述**\n\n### 出现原因：\n\n向量在静态操作速度快O(1)，在动态操作速度慢O(n)\n列表在静态操作速度慢O(n)，在动态操作速度快O(1)\n树结合了两者的优点，可看作是一种**半线性的结构**\n应用：组织层次关系，如文件系统、学院层级关系等\n\n<!-- more -->\n\n### 树的分类：\n\n![树的分类](http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim)\n\n### 概念1. 有根树rooted tree\n\n指定任一结点为根\n可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树\n\n![子树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim)\n\nri 为r的孩子( child )， ri之间互为兄弟( sibling )\nr为父亲( parent ),\nd=degree(r)为r的度=一结点拥有的孩子的数目\n任何一棵树中边数e和结点数目n同阶\n\n![边数和结点数同阶](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim)\n\n### 概念2. 有序树\n\n指定Ti为T的第i棵子树，ri为r的第i个孩子\n\n即是：兄弟之间有明显**次序**\n\n### 概念3. 连通性和无环性：\n\n任何两结点之间都有路径，则称为**连通图**（connected）\n不含环路则称为**无环图**（acyclic）\n\n树的特点：\n\n> 1 .无环连通图：在无环性和连通性之间平衡\n> 2 .极小连通图：在连通的情况下边数尽可能少\n> 3 .极大无环图：在无环的情况下边数尽可能多\n\n结论： 任何结点和根之间存在**唯一一条**路径\n即 $path(v,r)=path(v)$\n我们用一个指标 **深度( depth )** 记录下每个结点到根的距离\npath(v)上的结点均为v的**祖先**( ancestor )\nv是它们的**后代** ( descendent )\n对于v而言，若**祖先存在，则必定唯一**。若**后代存在，却未必唯一**，因此是半线性结构。\n而对于图而言，祖先和后代都未必唯一，因此图为非线性结构\n**叶子结点**（leaf）：没有后代的结点\n\n叶子深度最大的称为**树的高度**\n**深度**是**结点v到总树根结点r**的距离\n即height（v）=max( height (v_son) ) +1\n结点v的**高度**为**以结点v为根结点**的子树的高度\n即 height（v）=height（subtree（v））\n约定俗成：空树的高度取作**-1**，一个结点的树高度取作**0**\n对于任一结点：depth（v）+height（v）<=height(T)\n（高度向下看，深度向上看）\n![树的深度和高度](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim)\n\n## **表示**\n\n### 1. 接口\n\n| 返回值   | 结点            | 功能            |\n| ----- | ------------- | ------------- |\n| node* | root()        | 根结点           |\n| node* | parent()      | 父结点           |\n| node* | firstchild()  | 长子            |\n| node* | nextSibling() | 兄弟            |\n| void  | insert( i,e ) | 将e作为第i个孩子插入   |\n| int   | remove(i)     | 删除第i个孩子(及其后代) |\n| void  | traverse      | 遍历            |\n\n### 2. 构造方法\n\n不妨用数组进行模拟\n\n**长子兄弟法**：\n\n每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩\n\n```\ntemplate <typename T>\nstruct node\n{\n\tT data;\n\tint father, child, nextSibling;\n};\nnode  *tree;\n```\n\n# **二叉树**\n\n## **概念**\n\n结点度数**不超过2**（孩子数目<=2）的树\n\n同一结点的孩子和子树以**左右**区分\n\n二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。\n\n基于二叉树的概念，我们可以得到下列关系：\n1.深度为k的结点最多有$2^k$个\n2.高度为h的二叉树的结点数n满足$h’<’n’<’2^(h+1)$\n1.当n=h+1时，二叉树退化为一条单链\n2.当$n=2^(h+1)-1$时，二叉树为满二叉树\n\n二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点\n\n而高度h涨得很慢，与结点n的关系为$h=logn$\n\n## **真二叉树(Proper binary tree)**\n\n定义：所有结点的度数均为偶数的二叉树。\n\n很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点**虚拟地**补上孩子。\n\n## **完全二叉树(complete binary tree)**\n\n定义：叶结点只出现在**最后两层**，并且最底层的叶结点均在次底层叶结点的**左侧**。\n\n![完全二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG)\n\n## **满二叉树(full binary tree)**\n\n定义：所有叶结点都在**最后一层**，每层结点都达到饱和。\n\n特性：\n1.结点数目n和高度h的关系：$n=2^(h+1)-1$\n2.叶子结点数=内部结点数+1\n3.满二叉树是**特殊**的**完全二叉树**\n\n![满二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG)\n\n## **用二叉树描述多叉树**\n\n先上结论：**凡是有根且有序的树，均可以用二叉树实现**\n\n为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG)\n\n可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG)\n\n这就将一棵树变成了二叉树！\n\n这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。\n\n## **基本定义**\n\n**结点类的基本定义：**\n\n```\ntemplate <typename T>\nstruct BinNode\n{\n\tT data;\n\tBinNode<T>* lChild,*rChild,*parent;\n\tint height;\n\n\tBinNode() { lChild=rChild=parent= NULL ; height=0; }\n\tBinNode( T e , BinNode<T>* pa=NULL , BinNode<T>* lc=NULL, BinNode<T>* rc=NULL)\n\t\t:data(e),parent(pa),lChild(lc),rChild(rc) {}\n\tint size() const ;\n\tBinNode<T> * insertAsLC( T const & e ) //作为左孩子插入\n\t{ return lChild=new BinNode(e,this); }\n\tBinNode<T> * insertAsRC( T const & e ) //作为右孩子插入\n\t{ return rChild=new BinNode(e,this); }\n\t\n\tBinNode<T> * succ();   // 中序遍历时的直接后继\n\t\n\ttemplate <typename V>\n\tvoid travLevel( V & visit );  // 子树层级遍历\n\ttemplate <typename V>\n\tvoid travPre( V & visit );   // 子树先序遍历\n\ttemplate <typename V>\n\tvoid travIn( V & visit );    // 子树中序遍历\n\ttemplate <typename V>\n\tvoid travPost( V & visit );   // 子树后序遍历\n};\n\ntemplate <typename T>\nint BinNode<T>::size()\n{\n\tint s=1;\n\tif(lChild)\n\t\ts+=lChild->size();\n\tif(rChild)\n\t\ts+=rChild->size();\n\treturn s;\n}\n```\n\n每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。\n\nsize函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。\n\n**树的基础定义：**\n\n```\ntemplate <typename T>\nstruct BinTree\n{\nprotected:\n\tint _size;\n\tBinNode<T>* _root;\n\tvirtual int updateHeight( BinNode<T>* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）\n\tvoid updateHeightAbove( BinNode<T>* x);  // 更新x及x的祖先的高度\n\npublic:\n\tBinTree() {_size=0; _root=NULL;}\n\t~BinTree() { remove(_root); }\n\tBinTree( T const& e) {_size=1; _root=new BinNode<T> (e);}\n\tint size() const {return _size;}\n\tbool empty() const {return !_root;}\n\tBinNode<T> * root() const {return _root;}\n\tBinNode<T> * insertAsRC ( BinNode<T>* x , T const& e );  // 构造右孩子\n\tBinNode<T> * insertAsLC ( BinNode<T>* x , T const& e );  // 构造左孩子\n\tBinNode<T> * attachAsLC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为左孩子\n\tBinNode<T> * attachAsRC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为右孩子\n\tint remove( BinNode<T>* x );   // 删除某个结点（及其子树）\n\tvoid removeAt( BinNode<T>* x );\n\tBinTree<T> * secede( BinNode<T>* x );    // 分离子树，返回子树头\n\n\ttemplate <typename V>\n\tvoid travLevel( V & visit )  // 层级遍历\n\t{ _root->travLevel(visit); }\n\ttemplate <typename V>\n\tvoid travPre( V & visit )  // 先序遍历\n\t{ _root->travPre(visit); }\n\ttemplate <typename V>\n\tvoid travIn( V & visit )  // 中序遍历\n\t{ _root->travIn(visit); }\n\ttemplate <typename V>\n\tvoid travPost( V & visit )   // 后序遍历\n\t{ _root->travPost(visit); }\n};\n```\n\n## **遍历**\n\n定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次\n\n**遍历方式：**\n\n> 1. 先序遍历( preorder )：中->左->右\n> 2. 中序遍历( inorder )：左->中->右\n> 3. 后序遍历( postorder )：左->右->中\n> 4. 层次遍历：自上而下，自左而右\n>\n> 先序中序后序原则：必定先左后右，根结点访问次序如名字所示\n\n### **1. 先序遍历( 中 左 右 )**\n\n#### **1. 递归版本**\n\n根据先序遍历的定义，我们很容易写出递归版本的遍历函数：\n\n```\n// V为函数模板类  visit是相应的函数对象\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_R( V & visit )\n{\n\tvisit(data);\n\tif(lChild) lChild->travPre_R(visit);\n\tif(rChild) rChild->travPre_R(visit);\n}\n```\n\n然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。\n\n因此如果能够将**递归版**改成**迭代版**，就能够提高很多效率。\n\n#### **2. 迭代版本1**\n\n因为在递归版本中，向左右子树的递归出现在最后，即是**尾递归**，那么我们只需要引入一个**栈**，把左右子树的递归改成将左右子树入栈即可。\n\n值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要**先让右子树入栈，再让左子树入栈**\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_V1( V & visit )\n{\n\tStack <BinNode<T> *> s;\n\tBinNode<T>* x=this;\n\tif(x) \n\t\ts.push(x);\n\twhile(!s.empty())\n\t{\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tif(x->rChild) s.push(x->rChild); // 先入后出\n\t\tif(x->lChild) s.push(x->lChild);\n\t}\n}\n```\n\n#### **3. 迭代版本2**\n\n看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。\n\n通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子->它父亲的右孩子->父亲的父亲的右孩子…->根结点的右孩子。\n\n于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。\n\n![左侧链示意图](http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG)\n\n这样，我们就有了如下算法流程：\n\n1.访问该结点\n2.将右孩子入栈\n3.目光转向它的左孩子\n若左孩子存在，回到步骤1\n4.若栈不为空，取出栈顶元素，回到步骤1\n\n代码实现如下\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\twhile( !s.empty() )\n\t{\n\t\tx=s.pop();\n\t\twhile(x)\n\t\t{\n\t\t\tvisit(x->data);\n\t\t\tif(x->rChild) \n\t\t\t\ts.push(x->rChild);\n\t\t\tx=x->lChild;\n\t\t}\n\t}\n}\n```\n\n### **2. 中序遍历( 左 中 右 )**\n\n#### **1. 迭代版本1**\n\n先来观察一下中序遍历的流程：\n\n每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。\n\n中序和先序不同在于：**父结点不是立即被访问**，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。\n\n那右结点怎么办呢？\n\n右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。\n\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG)\n\n算法的流程如下：\n\n1.将该结点入栈\n2.转向该结点的左孩子\n若左孩子存在，返回步骤1\n3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子\n若右孩子存在，返回步骤1\n若右孩子不存在，重新开始步骤3\n\n现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\twhile(1)\n\t{\n\t\twhile(x)\n\t\t{\n\t\t\ts.push(x);\n\t\t\tx=x->lChild;\n\t\t}\n\t\tif(s.empty()) \n\t\t\tbreak;\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tx=x->rChild;\n\t} \n}\n```\n\n此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本\n\n#### **2. 迭代版本2**\n\n当把二叉树横向伸展地足够开后，如下图所示\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim)\n从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序\n左右规则如下:\n\n左子树左孩子>左子树根结点>左子树右孩子>根结点>右子树左孩子>右子树根结点>右子树右孩子\n\n根据这个规则，我们就可以得到每个结点在中序遍历时的**直接后继**，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)\n\n那么要怎么得到这个直接后继呢？\n显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。\n而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个**结点是它父结点左孩子**的结点，直接后继就是这个结点的父结点。\n简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。\n\n将上述流程翻译成代码就是\n\n```\ntemplate <typename T>\nBinNode<T> *BinNode<T>::succ()\n{\n\tBinNode<T>* s=this;\n\tif(rChild)   // 若有右孩子\n\t{\n\t\ts=rChild;\n\t\twhile(s->lChild)   // 在右子树的左侧链一路到底\n\t\t\ts=s->lChild;\n\t}\n\telse\n\t{\n\t\twhile( s->parent && s==s->parent->rChild )\n\t\t\ts=s->parent;    // 此时是左子树的根结点\n\t\ts=s->parent;   // 再向上到左子树的父亲结点(也可能是NULL)\n\t}\n\treturn s;\n}\n```\n\n有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_S(  V & visit )\n{\n\tBinNode<T>* x=this;\n\twhile(x->lChild)\n\t\tx=x->lChild;\n\tdo\n\t{\n\t\tvisit(x->data);\n\t\tx=x->succ();\n\t}\n\twhile(x);\n}\n```\n\n### **3. 后序遍历( 左 右 中 )**\n\n基于后序遍历的定义，我们可以导出如下流程：\n1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。\n2.访问结点\n3.若右兄弟存在，转向右兄弟，返回步骤1\n4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程\n\n可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPost_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\tBinNode<T> * c=s.top();\n\twhile(1)\n\t{\n\t\tif(s.empty()) break;\n\t\tif(s.top()!=x->parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树\n\t\t{\n\t\t\tc=s.top();\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(c->rChild) \n\t\t\t\t\ts.push(c->rChild);\n\t\t\t\tif(c->lChild) \n\t\t\t\t{\n\t\t\t\t\ts.push(c->lChild);\n\t\t\t\t\tc=c->lChild;   // 尽可能向左走\n\t\t\t\t}\n\t\t\t\telse if(c->rChild)  // 如果实在只有右孩子，那就向右\n\t\t\t\t\tc=c->rChild;\n\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t}\n}\n```\n\n### **4. 层次遍历**\n\n层次遍历的规则很简单：自上而下，自左而右\n\n![层次遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim)\n\n对此，我们可以引入**队列**来解决它。\n\n每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travLevel( V & e )\n{\n\tQueue<BinNode<T>*> q;\n\tBinNode<T>* x=this;\n\tq.enqueue(x);\n\twhile( !q.empty() )\n\t{\n\t\tx=q.dequeue();\n\t\tif(x->lChild)  q.enqueue(x->lChild);\n\t\tif(x->rChild)  q.enqueue(x->rChild);\n\t\te(x->data);\n\t}\n\treturn;\n}\n```\n\n## **重构**\n\n如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？\n\n### **一. 中序+(先序|后序)**\n\n结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。\n\n现在我们来用数学归纳法证明一下：\n假设结论在结点数n’<’N的情况下都成立\n在n==N时\n先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。\n那么在先序遍历和中序遍历中分别如下图所示：\n\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG)\n\n可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。\n这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’<’N的左右子树中结论均成立，由此n==N时结论也成立。\n\n而有后续和中序遍历的序列的证明也同理可得了。\n\n```\n// 先序+中序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PI( T* pre, T* ins, int len )\n{\n\t_root=rebuildSub_PI(pre,ins,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PI( T* pre, T* ins, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(pre); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PI( pre+1, ins, i );\n\ts->rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );\n\treturn s;\n}\n```\n\n```\n// 中序+后序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_IP( T* ins, T* post, int len )\n{\n\t_root=rebuildSub_IP(ins,post,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_IP( T* ins, T* post, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(* (post+len-1) );\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+len-1); i++);\n\ts=new BinNode<T>(*(post+len-1));\n\ts->lChild=rebuildSub_IP( ins, post, i );\n\ts->rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );\n\treturn s;\n}\n```\n\n### **二. (先序+后序)\\*真二叉树**\n\n结论二：在只有先序和后序序列时，若是该二叉树是一棵**真二叉树**(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。\n\n那么要怎么做呢？\n\n在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。\n在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。\n这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG)\n\n```\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PP( T *pre,T *post,int len )\n{\n\t_root=new BinNode<T> (pre[0]);\n\trebuildSub_PP( _root,pre,post,len );\n\treturn;\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PP( T *pre , T *post, int len )\n{ \n\tBinNode<T> *s=NULL;\n\tif( len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PP(pre+1,post,i+1);\n\ts->rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n# **完整实现代码**\n\n[二叉树的完整实现 ( 附带遍历和重构 )](https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp)\n\n# 二叉搜索树BST ( Binary Search Tree )\n\n## 概述\n\n### 循关键码访问 call-by-key\n\n数据项之间，依照各自的关键码(key)彼此区分\n\n条件：关键码之间支持**大小比较**和**相等比对**\n\n### 性质\n\n二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：\n\n```\n1. 非空左子树所有键值小于根结点的键值\n2. 非空右子树所有键值大于根结点的键值\n3. 左右子树都是二叉搜索树\n\n```\n\n基本框架：\n\n```\ntemplate <typename T>\nstruct TreeNode\n{\n\tT data;\n\tTreeNode<T> * left;\n\tTreeNode<T> * right;\n};\n```\n\n## 接口\n\n```\n1. BinTree Find( T x , BinTree BST);\n\n```\n\n> 从BST中查找元素x,返回所在结点的地址\n\n```\n2. BinTree FindMin(BinTree BST);\n\n```\n\n> 从BST中查找并返回最小元素所在结点的地址\n\n```\n3. BinTree FindMax(BinTree BST);\n\n```\n\n> 从BST中查找并返回最大元素所在结点的地址\n\n```\n4. BinTree Insert( T x , BinTree BST);\n\n```\n\n> 将元素x插入BST中，返回插入后的BST\n\n```\n5. BinTree Delete( T x , BinTree BST);\n\n```\n\n> 从BST中删除元素x\n\n### 查找操作： Find\n\n```\n- 查找从根结点开始，若树为空则返回NULL\n- 若树非空，则将根结点键值和x比较：\n    - 若 x < root.data ，在左子树中搜索\n    - 若 x > root.data ，在右子树中搜索\n    - 若两者相等，则返回指向该结点的指针\n- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式\n- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**\n\n```\n\n代码实现：\n\n```\ntemplate <typename T>\nTreeNode<T> * Find(T x , TreeNode<T> * BST)\n{\n\twhile(BST)\n\t{\n\t\tif(x>BST->data)\n\t\t\tBST=BST->right;\n\t\telse if(x<BST->data)\n\t\t\tBST=BST->left;\n\t\telse\n\t\t\treturn BST;\n\t}\n\treturn NULL;\n}\n```\n\n### 查找最大和最小元素\n\n根据二叉搜索树的性质：\n\n```\n- 最大元素一定在树的最右分支的端结点上\n- 最小元素一定在树的最左分支的端结点上\n\n```\n\n同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本\n\n```\ntemplate <typename T>\nTreeNode<T> * FindMax( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->right)\n\t\t\tBST=BST->right;\n\treturn BST;\n}\ntemplate <typename T>\nTreeNode<T> * FindMin( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->left)\n\t\t\tBST=BST->left;\n\treturn BST;\n}\n```\n\n### 插入结点\n\n关键：要找到元素应该插入的位置，可以采用和Find类似的方法\n\n思路：\n\n```\ntemplate <typename T>\nTreeNode<T> * Insert( T x , TreeNode<T> * BST)\n{\n\tif(!BST)\n\t{\n\t\tBST = new TreeNode<T>();\n\t\tBST->data=x;\n\t\tBST->left=BST->right=NULL;\n\t}\n\telse\n\t{\n\t\tif(x<BST->data)\n\t\t\tBST->left=Insert(x,BST->left);\n\t\telse if(x>BST->data)\n\t\t\tBST->right=Insert(x,BST->right);\n\t}\n\treturn BST;\n}\n```\n\n### 删除结点\n\n考虑情况\n\n```\n1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL\n2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子\n3. 要删除的结点有左右两棵子树\n    用另一结点代替被删除结点：左子树最大元素或右子树最小元素\n\n```\n\n```\ntemplate <typename T>\nTreeNode<T> * Delete( T x , TreeNode<T> * BST)\n{\n\tTreeNode<T> *tmp;\n\tif(!BST) return NULL;\n\telse if(x<BST->data)\n\t\tBST->left=Delete(x,BST->left);\n\telse if(x>BST->data)\n\t\tBST->right=Delete(x,BST->right);\n\telse\n\t{\n\t\tif(BST->left && BST->right)\n\t\t{\n\t\t\ttmp=FindMin(BST->right);\n\t\t\tBST->data=tmp->data;\n\t\t\tBST->right=delete(BST->data,BST->right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=BST;\n\t\t\tif(!BST->left)\n\t\t\t\tBST=BST->right;\n\t\t\telse if(!BST->right)\n\t\t\t\tBST=BST->left;\n\t\t\tdelete tmp;\n\t\t}\n\t}\n\treturn BST;\n}\n```\n\n# 平衡二叉树 AVL树 (Balanced Binary Tree)\n\n定义：\n空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|<=1\n\n**平衡因子（BF:Balance Factor）**: BF(T)=Hl - Hr\nHl和Hr分别为T的左右子树的高度\n\n推算高度为h的平衡二叉树最少结点数：\n\n```\n高度为1时 h(1)=1;\n高度为2时 h(2)=2;\n高度为3时 h(3)=h(1)+h(2)+1=4;\n...\n高度为n时 h(n)=h(n-1)+h(n-2)+1;\n原因：\n    > 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值<=1\n    > 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )\n由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$\n\n```\n\n结点数为n的平衡二叉树的最大高度为O(logn)\n\n## 平衡二叉树的调整\n\n**核心思想：选择中间值作为根结点**\n\n**RR插入**：插入结点在右子树的右边，需要RR旋转（右单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG)\n\n大小关系为： 根结点 < 右子树根结点 < 右子树的右边\n\n因此选取右子树的根结点作为新的平衡二叉树的根结点\n\n**LL插入**：插入结点在左子树的左边，需要LL旋转（左单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG)\n\n大小关系为： 左子树的左边 < 左子树根结点 < 根结点\n\n因此选取左子树的根结点作为新的平衡二叉树的根结点\n\n**LR插入**：插入结点在左子树的右边，需要LR旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG)\n\n大小关系为： 左子树的根结点 < 左子树的右边 < 根结点\n\n因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点\n\n**RL插入**：插入结点在右子树的左边，需要RL旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG)\n\n大小关系为： 根结点 < 右子树的左边 < 右子树的根结点\n\n因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点\n\n# 堆 heap\n\n## 概述\n\n**优先队列( Priority Queue )**\n特殊的队列，取出元素的顺序是依照元素的**优先权（关键字）**的大小，而不是元素进入队列的先后顺序\n\n堆的特性：\n**结构性**：用数组表示的完全二叉树\n**有序性**：任一结点的关键字是其子树所有结点的最大值（或最小值）\n从根结点到任意结点路径上结点序列的有序性\n最大堆（MaxHeap）：根结点为最大值\n最小堆（MinHeap）：根结点为最小值\n\n## 接口\n\n数据对象集：完全二叉树\n\n接口：\nMaxHeap Create( int Maxsize );\n创建一个空的最大堆\nBoolean IsFull( MaxHeap H );\n判断最大堆H是否满\nvoid Insert( MaxHeap H , T data );\n将data插入最大堆H\nBoolean IsEmpty( MaxHeap H );\n判断最大堆H是否为空\nT DeleteMax( MaxHeap H );\n返回H中最大元素（高优先级）\n\n### Insert\n\n思路：\n\n> 将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点\n\n```\ntemplate <typename T>\nvoid Insert( Heap<T>* h, T item)\n{\n\tint i;\n\tif( IsFull(h) ) // 若堆已满，则不做插入操作\n\t\treturn;\n\ti = ++h->size;\n\tfor( ; h->data[i/2]<item ; i/=2 )\n\t\th->data[i] = h->data[i/2];\n\th->data[i] = item;\n}\n```\n\n### Delete\n\n思路：\n\n> 取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作\n\n```\ntemplate <typename T>\nvoid Delete( Heap<T>* h , T item )\n{\n\tint parent , child;\n\tT maxn,tem;\n\tif( IsEmpty(h) ) \n\t\treturn;\n\tmaxn = h->data[1];\n\ttem = h->data[h->size--];\n\tfor( parent=1 ; parent*2<= h->size ; parent = child )\n\t{\n\t\tchild = parent *2;\n\t\tif( child != h->size  && h->data[child]<h.data[child+1])\n\t\t\tchild++;   // 寻找左右孩子中较大的那个\n\t\tif( tem>= h->data[child] ) \n\t\t\tbreak;\n\t\telse\n\t\t\th->data[parent] = h->data[child];\n\t}\n\th->data[parent]=tem;\n}\n```\n\n### 建立最大堆\n\n将已经存在的N个元素按最大堆的要求存放在一个一维数组\n\n方法1：\n通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)\n\n方法2：\n\n```\n1. n个元素按输入顺序存入，先满足完全二叉树\n2. 调整各结点位置\n\n```\n\n#### 方法二：\n\n自底向上调整\n\n从倒数第二行的结点开始自右向左调整\n\n而后再到倒数第三行、倒数第四行…直到根结点\n\n这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可\n\n这样就只需要O(n)的时间即可完成建堆\n\n# 哈夫曼树\n\n带权路径长度（WPL）\n设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk\n\n哈夫曼树（最优二叉树）：WPL值最小的二叉树\n\n## 哈夫曼树的构造\n\n每次把**权值最小**的两棵二叉树合并\n\n## 特点\n\n```\n1. 没有度为1的结点\n2. n个叶子结点的哈夫曼树有2n-1个结点\n    设 n0: 叶子结点总数\n    设 n1: 只有一个儿子的结点总数\n    设 n2: 有2个儿子的结点总数\n    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1\n3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树\n4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）\n\n```\n\n## 哈夫曼编码\n\n```\n给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少\n\n避免二义性：\n    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀\n\n利用二叉树进行编码：\n    1. 左右分支：0、1\n    2. 字符只在叶结点上\n\n构造方法：根据字符的权值构造哈夫曼树\n\n```\n\n# 集合\n\n```\n集合运算：交、并、补、差、判定一个元素是否属于某个集合\n并查集：集合并、查某元素属于什么集合\n并查集实现：\n    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）\n    2. 利用数组存储，两个一维数组分别存储数据和父亲下标\n\n```\n\n利用数组存储的定义：\n\n```\ntemplate <typename T>\nstruct Node\n{\n\tT data;\n\tint parent;\n\tNode( T d , int parent = -1 ):data(d){}\n\tNode(){parent=-1;}\n};\n```\n\n每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标\n\n## 查找当前结点所属集合\n\n思路：\n首先在数组中找到目标结点\n而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );   // 在数组中寻找值为x的结点\n\tif( i>=MaxSize ) return -1;    // 没找到，返回-1\n\tfor( ; s[i].parent>=0; i=s[i].parent );  // 顺着父结点指针一路向上找\n\treturn i;\n}\n```\n\n优化：\n通过**路径压缩**，每次查找时把沿途所有节点的parent都设为根节点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );\n\tif( i>=MaxSize ) return -1;\n\tint tem=i,tem1=s[tem].parent;\n\tfor( ; s[i].parent>=0; i=s[i].parent );\n\twhile( tem1!=-1 && tem1!=i )\n\t{\n\t\ts[tem].parent = i;\n\t\ttem=tem1;\n\t\ttem1=s[tem].parent;\n\t}\n\treturn i;\n}\n```\n\n## 集合的并运算\n\n思路：\n首先分别找到两个元素所在的集合树的根结点\n若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标\n\n```\ntemplate <typename T>\nvoid Union( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t\ts[root2].parent = root1;\n}\n```\n\n优化：\n为了改善合并后的查找效率，把小的集合并入大的集合\n方法1：每个结点额外维护一个值：以该结点为根的结点总数\n缺点：只有根节点才需要用到该值，造成大量空间浪费\n方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数\n\n```\ntemplate <typename T>\nvoid Union1( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t{\t\n\t\tif( s[root1].parent<s[root2].parent )\n\t\t{\t\n\t\t\ts[root1].parent += s[root2].parent;\n\t\t\ts[root2].parent = root1;\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\ts[root2].parent += s[root1].parent;\n\t\t\ts[root1].parent = root2;\n\t\t}\n\t}\n}\n```","source":"_posts/DataStructure_Tree.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（三）：树\"\ndate: 2017-08-15\ncomments: true\ntags: \n\t- 学习笔记\n\t- c++\n\t- 数据结构\n---\n\n# **树**\n\n## **概述**\n\n### 出现原因：\n\n向量在静态操作速度快O(1)，在动态操作速度慢O(n)\n列表在静态操作速度慢O(n)，在动态操作速度快O(1)\n树结合了两者的优点，可看作是一种**半线性的结构**\n应用：组织层次关系，如文件系统、学院层级关系等\n\n<!-- more -->\n\n### 树的分类：\n\n![树的分类](http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim)\n\n### 概念1. 有根树rooted tree\n\n指定任一结点为根\n可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树\n\n![子树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim)\n\nri 为r的孩子( child )， ri之间互为兄弟( sibling )\nr为父亲( parent ),\nd=degree(r)为r的度=一结点拥有的孩子的数目\n任何一棵树中边数e和结点数目n同阶\n\n![边数和结点数同阶](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim)\n\n### 概念2. 有序树\n\n指定Ti为T的第i棵子树，ri为r的第i个孩子\n\n即是：兄弟之间有明显**次序**\n\n### 概念3. 连通性和无环性：\n\n任何两结点之间都有路径，则称为**连通图**（connected）\n不含环路则称为**无环图**（acyclic）\n\n树的特点：\n\n> 1 .无环连通图：在无环性和连通性之间平衡\n> 2 .极小连通图：在连通的情况下边数尽可能少\n> 3 .极大无环图：在无环的情况下边数尽可能多\n\n结论： 任何结点和根之间存在**唯一一条**路径\n即 $path(v,r)=path(v)$\n我们用一个指标 **深度( depth )** 记录下每个结点到根的距离\npath(v)上的结点均为v的**祖先**( ancestor )\nv是它们的**后代** ( descendent )\n对于v而言，若**祖先存在，则必定唯一**。若**后代存在，却未必唯一**，因此是半线性结构。\n而对于图而言，祖先和后代都未必唯一，因此图为非线性结构\n**叶子结点**（leaf）：没有后代的结点\n\n叶子深度最大的称为**树的高度**\n**深度**是**结点v到总树根结点r**的距离\n即height（v）=max( height (v_son) ) +1\n结点v的**高度**为**以结点v为根结点**的子树的高度\n即 height（v）=height（subtree（v））\n约定俗成：空树的高度取作**-1**，一个结点的树高度取作**0**\n对于任一结点：depth（v）+height（v）<=height(T)\n（高度向下看，深度向上看）\n![树的深度和高度](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim)\n\n## **表示**\n\n### 1. 接口\n\n| 返回值   | 结点            | 功能            |\n| ----- | ------------- | ------------- |\n| node* | root()        | 根结点           |\n| node* | parent()      | 父结点           |\n| node* | firstchild()  | 长子            |\n| node* | nextSibling() | 兄弟            |\n| void  | insert( i,e ) | 将e作为第i个孩子插入   |\n| int   | remove(i)     | 删除第i个孩子(及其后代) |\n| void  | traverse      | 遍历            |\n\n### 2. 构造方法\n\n不妨用数组进行模拟\n\n**长子兄弟法**：\n\n每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩\n\n```\ntemplate <typename T>\nstruct node\n{\n\tT data;\n\tint father, child, nextSibling;\n};\nnode  *tree;\n```\n\n# **二叉树**\n\n## **概念**\n\n结点度数**不超过2**（孩子数目<=2）的树\n\n同一结点的孩子和子树以**左右**区分\n\n二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。\n\n基于二叉树的概念，我们可以得到下列关系：\n1.深度为k的结点最多有$2^k$个\n2.高度为h的二叉树的结点数n满足$h’<’n’<’2^(h+1)$\n1.当n=h+1时，二叉树退化为一条单链\n2.当$n=2^(h+1)-1$时，二叉树为满二叉树\n\n二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点\n\n而高度h涨得很慢，与结点n的关系为$h=logn$\n\n## **真二叉树(Proper binary tree)**\n\n定义：所有结点的度数均为偶数的二叉树。\n\n很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点**虚拟地**补上孩子。\n\n## **完全二叉树(complete binary tree)**\n\n定义：叶结点只出现在**最后两层**，并且最底层的叶结点均在次底层叶结点的**左侧**。\n\n![完全二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG)\n\n## **满二叉树(full binary tree)**\n\n定义：所有叶结点都在**最后一层**，每层结点都达到饱和。\n\n特性：\n1.结点数目n和高度h的关系：$n=2^(h+1)-1$\n2.叶子结点数=内部结点数+1\n3.满二叉树是**特殊**的**完全二叉树**\n\n![满二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG)\n\n## **用二叉树描述多叉树**\n\n先上结论：**凡是有根且有序的树，均可以用二叉树实现**\n\n为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG)\n\n可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG)\n\n这就将一棵树变成了二叉树！\n\n这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。\n\n## **基本定义**\n\n**结点类的基本定义：**\n\n```\ntemplate <typename T>\nstruct BinNode\n{\n\tT data;\n\tBinNode<T>* lChild,*rChild,*parent;\n\tint height;\n\n\tBinNode() { lChild=rChild=parent= NULL ; height=0; }\n\tBinNode( T e , BinNode<T>* pa=NULL , BinNode<T>* lc=NULL, BinNode<T>* rc=NULL)\n\t\t:data(e),parent(pa),lChild(lc),rChild(rc) {}\n\tint size() const ;\n\tBinNode<T> * insertAsLC( T const & e ) //作为左孩子插入\n\t{ return lChild=new BinNode(e,this); }\n\tBinNode<T> * insertAsRC( T const & e ) //作为右孩子插入\n\t{ return rChild=new BinNode(e,this); }\n\t\n\tBinNode<T> * succ();   // 中序遍历时的直接后继\n\t\n\ttemplate <typename V>\n\tvoid travLevel( V & visit );  // 子树层级遍历\n\ttemplate <typename V>\n\tvoid travPre( V & visit );   // 子树先序遍历\n\ttemplate <typename V>\n\tvoid travIn( V & visit );    // 子树中序遍历\n\ttemplate <typename V>\n\tvoid travPost( V & visit );   // 子树后序遍历\n};\n\ntemplate <typename T>\nint BinNode<T>::size()\n{\n\tint s=1;\n\tif(lChild)\n\t\ts+=lChild->size();\n\tif(rChild)\n\t\ts+=rChild->size();\n\treturn s;\n}\n```\n\n每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。\n\nsize函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。\n\n**树的基础定义：**\n\n```\ntemplate <typename T>\nstruct BinTree\n{\nprotected:\n\tint _size;\n\tBinNode<T>* _root;\n\tvirtual int updateHeight( BinNode<T>* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）\n\tvoid updateHeightAbove( BinNode<T>* x);  // 更新x及x的祖先的高度\n\npublic:\n\tBinTree() {_size=0; _root=NULL;}\n\t~BinTree() { remove(_root); }\n\tBinTree( T const& e) {_size=1; _root=new BinNode<T> (e);}\n\tint size() const {return _size;}\n\tbool empty() const {return !_root;}\n\tBinNode<T> * root() const {return _root;}\n\tBinNode<T> * insertAsRC ( BinNode<T>* x , T const& e );  // 构造右孩子\n\tBinNode<T> * insertAsLC ( BinNode<T>* x , T const& e );  // 构造左孩子\n\tBinNode<T> * attachAsLC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为左孩子\n\tBinNode<T> * attachAsRC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为右孩子\n\tint remove( BinNode<T>* x );   // 删除某个结点（及其子树）\n\tvoid removeAt( BinNode<T>* x );\n\tBinTree<T> * secede( BinNode<T>* x );    // 分离子树，返回子树头\n\n\ttemplate <typename V>\n\tvoid travLevel( V & visit )  // 层级遍历\n\t{ _root->travLevel(visit); }\n\ttemplate <typename V>\n\tvoid travPre( V & visit )  // 先序遍历\n\t{ _root->travPre(visit); }\n\ttemplate <typename V>\n\tvoid travIn( V & visit )  // 中序遍历\n\t{ _root->travIn(visit); }\n\ttemplate <typename V>\n\tvoid travPost( V & visit )   // 后序遍历\n\t{ _root->travPost(visit); }\n};\n```\n\n## **遍历**\n\n定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次\n\n**遍历方式：**\n\n> 1. 先序遍历( preorder )：中->左->右\n> 2. 中序遍历( inorder )：左->中->右\n> 3. 后序遍历( postorder )：左->右->中\n> 4. 层次遍历：自上而下，自左而右\n>\n> 先序中序后序原则：必定先左后右，根结点访问次序如名字所示\n\n### **1. 先序遍历( 中 左 右 )**\n\n#### **1. 递归版本**\n\n根据先序遍历的定义，我们很容易写出递归版本的遍历函数：\n\n```\n// V为函数模板类  visit是相应的函数对象\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_R( V & visit )\n{\n\tvisit(data);\n\tif(lChild) lChild->travPre_R(visit);\n\tif(rChild) rChild->travPre_R(visit);\n}\n```\n\n然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。\n\n因此如果能够将**递归版**改成**迭代版**，就能够提高很多效率。\n\n#### **2. 迭代版本1**\n\n因为在递归版本中，向左右子树的递归出现在最后，即是**尾递归**，那么我们只需要引入一个**栈**，把左右子树的递归改成将左右子树入栈即可。\n\n值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要**先让右子树入栈，再让左子树入栈**\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_V1( V & visit )\n{\n\tStack <BinNode<T> *> s;\n\tBinNode<T>* x=this;\n\tif(x) \n\t\ts.push(x);\n\twhile(!s.empty())\n\t{\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tif(x->rChild) s.push(x->rChild); // 先入后出\n\t\tif(x->lChild) s.push(x->lChild);\n\t}\n}\n```\n\n#### **3. 迭代版本2**\n\n看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。\n\n通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子->它父亲的右孩子->父亲的父亲的右孩子…->根结点的右孩子。\n\n于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。\n\n![左侧链示意图](http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG)\n\n这样，我们就有了如下算法流程：\n\n1.访问该结点\n2.将右孩子入栈\n3.目光转向它的左孩子\n若左孩子存在，回到步骤1\n4.若栈不为空，取出栈顶元素，回到步骤1\n\n代码实现如下\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\twhile( !s.empty() )\n\t{\n\t\tx=s.pop();\n\t\twhile(x)\n\t\t{\n\t\t\tvisit(x->data);\n\t\t\tif(x->rChild) \n\t\t\t\ts.push(x->rChild);\n\t\t\tx=x->lChild;\n\t\t}\n\t}\n}\n```\n\n### **2. 中序遍历( 左 中 右 )**\n\n#### **1. 迭代版本1**\n\n先来观察一下中序遍历的流程：\n\n每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。\n\n中序和先序不同在于：**父结点不是立即被访问**，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。\n\n那右结点怎么办呢？\n\n右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。\n\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG)\n\n算法的流程如下：\n\n1.将该结点入栈\n2.转向该结点的左孩子\n若左孩子存在，返回步骤1\n3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子\n若右孩子存在，返回步骤1\n若右孩子不存在，重新开始步骤3\n\n现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\twhile(1)\n\t{\n\t\twhile(x)\n\t\t{\n\t\t\ts.push(x);\n\t\t\tx=x->lChild;\n\t\t}\n\t\tif(s.empty()) \n\t\t\tbreak;\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tx=x->rChild;\n\t} \n}\n```\n\n此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本\n\n#### **2. 迭代版本2**\n\n当把二叉树横向伸展地足够开后，如下图所示\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim)\n从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序\n左右规则如下:\n\n左子树左孩子>左子树根结点>左子树右孩子>根结点>右子树左孩子>右子树根结点>右子树右孩子\n\n根据这个规则，我们就可以得到每个结点在中序遍历时的**直接后继**，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)\n\n那么要怎么得到这个直接后继呢？\n显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。\n而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个**结点是它父结点左孩子**的结点，直接后继就是这个结点的父结点。\n简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。\n\n将上述流程翻译成代码就是\n\n```\ntemplate <typename T>\nBinNode<T> *BinNode<T>::succ()\n{\n\tBinNode<T>* s=this;\n\tif(rChild)   // 若有右孩子\n\t{\n\t\ts=rChild;\n\t\twhile(s->lChild)   // 在右子树的左侧链一路到底\n\t\t\ts=s->lChild;\n\t}\n\telse\n\t{\n\t\twhile( s->parent && s==s->parent->rChild )\n\t\t\ts=s->parent;    // 此时是左子树的根结点\n\t\ts=s->parent;   // 再向上到左子树的父亲结点(也可能是NULL)\n\t}\n\treturn s;\n}\n```\n\n有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_S(  V & visit )\n{\n\tBinNode<T>* x=this;\n\twhile(x->lChild)\n\t\tx=x->lChild;\n\tdo\n\t{\n\t\tvisit(x->data);\n\t\tx=x->succ();\n\t}\n\twhile(x);\n}\n```\n\n### **3. 后序遍历( 左 右 中 )**\n\n基于后序遍历的定义，我们可以导出如下流程：\n1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。\n2.访问结点\n3.若右兄弟存在，转向右兄弟，返回步骤1\n4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程\n\n可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPost_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\tBinNode<T> * c=s.top();\n\twhile(1)\n\t{\n\t\tif(s.empty()) break;\n\t\tif(s.top()!=x->parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树\n\t\t{\n\t\t\tc=s.top();\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(c->rChild) \n\t\t\t\t\ts.push(c->rChild);\n\t\t\t\tif(c->lChild) \n\t\t\t\t{\n\t\t\t\t\ts.push(c->lChild);\n\t\t\t\t\tc=c->lChild;   // 尽可能向左走\n\t\t\t\t}\n\t\t\t\telse if(c->rChild)  // 如果实在只有右孩子，那就向右\n\t\t\t\t\tc=c->rChild;\n\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t}\n}\n```\n\n### **4. 层次遍历**\n\n层次遍历的规则很简单：自上而下，自左而右\n\n![层次遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim)\n\n对此，我们可以引入**队列**来解决它。\n\n每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travLevel( V & e )\n{\n\tQueue<BinNode<T>*> q;\n\tBinNode<T>* x=this;\n\tq.enqueue(x);\n\twhile( !q.empty() )\n\t{\n\t\tx=q.dequeue();\n\t\tif(x->lChild)  q.enqueue(x->lChild);\n\t\tif(x->rChild)  q.enqueue(x->rChild);\n\t\te(x->data);\n\t}\n\treturn;\n}\n```\n\n## **重构**\n\n如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？\n\n### **一. 中序+(先序|后序)**\n\n结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。\n\n现在我们来用数学归纳法证明一下：\n假设结论在结点数n’<’N的情况下都成立\n在n==N时\n先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。\n那么在先序遍历和中序遍历中分别如下图所示：\n\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG)\n\n可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。\n这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’<’N的左右子树中结论均成立，由此n==N时结论也成立。\n\n而有后续和中序遍历的序列的证明也同理可得了。\n\n```\n// 先序+中序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PI( T* pre, T* ins, int len )\n{\n\t_root=rebuildSub_PI(pre,ins,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PI( T* pre, T* ins, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(pre); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PI( pre+1, ins, i );\n\ts->rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );\n\treturn s;\n}\n```\n\n```\n// 中序+后序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_IP( T* ins, T* post, int len )\n{\n\t_root=rebuildSub_IP(ins,post,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_IP( T* ins, T* post, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(* (post+len-1) );\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+len-1); i++);\n\ts=new BinNode<T>(*(post+len-1));\n\ts->lChild=rebuildSub_IP( ins, post, i );\n\ts->rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );\n\treturn s;\n}\n```\n\n### **二. (先序+后序)\\*真二叉树**\n\n结论二：在只有先序和后序序列时，若是该二叉树是一棵**真二叉树**(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。\n\n那么要怎么做呢？\n\n在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。\n在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。\n这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG)\n\n```\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PP( T *pre,T *post,int len )\n{\n\t_root=new BinNode<T> (pre[0]);\n\trebuildSub_PP( _root,pre,post,len );\n\treturn;\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PP( T *pre , T *post, int len )\n{ \n\tBinNode<T> *s=NULL;\n\tif( len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PP(pre+1,post,i+1);\n\ts->rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n# **完整实现代码**\n\n[二叉树的完整实现 ( 附带遍历和重构 )](https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp)\n\n# 二叉搜索树BST ( Binary Search Tree )\n\n## 概述\n\n### 循关键码访问 call-by-key\n\n数据项之间，依照各自的关键码(key)彼此区分\n\n条件：关键码之间支持**大小比较**和**相等比对**\n\n### 性质\n\n二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：\n\n```\n1. 非空左子树所有键值小于根结点的键值\n2. 非空右子树所有键值大于根结点的键值\n3. 左右子树都是二叉搜索树\n\n```\n\n基本框架：\n\n```\ntemplate <typename T>\nstruct TreeNode\n{\n\tT data;\n\tTreeNode<T> * left;\n\tTreeNode<T> * right;\n};\n```\n\n## 接口\n\n```\n1. BinTree Find( T x , BinTree BST);\n\n```\n\n> 从BST中查找元素x,返回所在结点的地址\n\n```\n2. BinTree FindMin(BinTree BST);\n\n```\n\n> 从BST中查找并返回最小元素所在结点的地址\n\n```\n3. BinTree FindMax(BinTree BST);\n\n```\n\n> 从BST中查找并返回最大元素所在结点的地址\n\n```\n4. BinTree Insert( T x , BinTree BST);\n\n```\n\n> 将元素x插入BST中，返回插入后的BST\n\n```\n5. BinTree Delete( T x , BinTree BST);\n\n```\n\n> 从BST中删除元素x\n\n### 查找操作： Find\n\n```\n- 查找从根结点开始，若树为空则返回NULL\n- 若树非空，则将根结点键值和x比较：\n    - 若 x < root.data ，在左子树中搜索\n    - 若 x > root.data ，在右子树中搜索\n    - 若两者相等，则返回指向该结点的指针\n- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式\n- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**\n\n```\n\n代码实现：\n\n```\ntemplate <typename T>\nTreeNode<T> * Find(T x , TreeNode<T> * BST)\n{\n\twhile(BST)\n\t{\n\t\tif(x>BST->data)\n\t\t\tBST=BST->right;\n\t\telse if(x<BST->data)\n\t\t\tBST=BST->left;\n\t\telse\n\t\t\treturn BST;\n\t}\n\treturn NULL;\n}\n```\n\n### 查找最大和最小元素\n\n根据二叉搜索树的性质：\n\n```\n- 最大元素一定在树的最右分支的端结点上\n- 最小元素一定在树的最左分支的端结点上\n\n```\n\n同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本\n\n```\ntemplate <typename T>\nTreeNode<T> * FindMax( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->right)\n\t\t\tBST=BST->right;\n\treturn BST;\n}\ntemplate <typename T>\nTreeNode<T> * FindMin( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->left)\n\t\t\tBST=BST->left;\n\treturn BST;\n}\n```\n\n### 插入结点\n\n关键：要找到元素应该插入的位置，可以采用和Find类似的方法\n\n思路：\n\n```\ntemplate <typename T>\nTreeNode<T> * Insert( T x , TreeNode<T> * BST)\n{\n\tif(!BST)\n\t{\n\t\tBST = new TreeNode<T>();\n\t\tBST->data=x;\n\t\tBST->left=BST->right=NULL;\n\t}\n\telse\n\t{\n\t\tif(x<BST->data)\n\t\t\tBST->left=Insert(x,BST->left);\n\t\telse if(x>BST->data)\n\t\t\tBST->right=Insert(x,BST->right);\n\t}\n\treturn BST;\n}\n```\n\n### 删除结点\n\n考虑情况\n\n```\n1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL\n2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子\n3. 要删除的结点有左右两棵子树\n    用另一结点代替被删除结点：左子树最大元素或右子树最小元素\n\n```\n\n```\ntemplate <typename T>\nTreeNode<T> * Delete( T x , TreeNode<T> * BST)\n{\n\tTreeNode<T> *tmp;\n\tif(!BST) return NULL;\n\telse if(x<BST->data)\n\t\tBST->left=Delete(x,BST->left);\n\telse if(x>BST->data)\n\t\tBST->right=Delete(x,BST->right);\n\telse\n\t{\n\t\tif(BST->left && BST->right)\n\t\t{\n\t\t\ttmp=FindMin(BST->right);\n\t\t\tBST->data=tmp->data;\n\t\t\tBST->right=delete(BST->data,BST->right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=BST;\n\t\t\tif(!BST->left)\n\t\t\t\tBST=BST->right;\n\t\t\telse if(!BST->right)\n\t\t\t\tBST=BST->left;\n\t\t\tdelete tmp;\n\t\t}\n\t}\n\treturn BST;\n}\n```\n\n# 平衡二叉树 AVL树 (Balanced Binary Tree)\n\n定义：\n空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|<=1\n\n**平衡因子（BF:Balance Factor）**: BF(T)=Hl - Hr\nHl和Hr分别为T的左右子树的高度\n\n推算高度为h的平衡二叉树最少结点数：\n\n```\n高度为1时 h(1)=1;\n高度为2时 h(2)=2;\n高度为3时 h(3)=h(1)+h(2)+1=4;\n...\n高度为n时 h(n)=h(n-1)+h(n-2)+1;\n原因：\n    > 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值<=1\n    > 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )\n由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$\n\n```\n\n结点数为n的平衡二叉树的最大高度为O(logn)\n\n## 平衡二叉树的调整\n\n**核心思想：选择中间值作为根结点**\n\n**RR插入**：插入结点在右子树的右边，需要RR旋转（右单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG)\n\n大小关系为： 根结点 < 右子树根结点 < 右子树的右边\n\n因此选取右子树的根结点作为新的平衡二叉树的根结点\n\n**LL插入**：插入结点在左子树的左边，需要LL旋转（左单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG)\n\n大小关系为： 左子树的左边 < 左子树根结点 < 根结点\n\n因此选取左子树的根结点作为新的平衡二叉树的根结点\n\n**LR插入**：插入结点在左子树的右边，需要LR旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG)\n\n大小关系为： 左子树的根结点 < 左子树的右边 < 根结点\n\n因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点\n\n**RL插入**：插入结点在右子树的左边，需要RL旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG)\n\n大小关系为： 根结点 < 右子树的左边 < 右子树的根结点\n\n因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点\n\n# 堆 heap\n\n## 概述\n\n**优先队列( Priority Queue )**\n特殊的队列，取出元素的顺序是依照元素的**优先权（关键字）**的大小，而不是元素进入队列的先后顺序\n\n堆的特性：\n**结构性**：用数组表示的完全二叉树\n**有序性**：任一结点的关键字是其子树所有结点的最大值（或最小值）\n从根结点到任意结点路径上结点序列的有序性\n最大堆（MaxHeap）：根结点为最大值\n最小堆（MinHeap）：根结点为最小值\n\n## 接口\n\n数据对象集：完全二叉树\n\n接口：\nMaxHeap Create( int Maxsize );\n创建一个空的最大堆\nBoolean IsFull( MaxHeap H );\n判断最大堆H是否满\nvoid Insert( MaxHeap H , T data );\n将data插入最大堆H\nBoolean IsEmpty( MaxHeap H );\n判断最大堆H是否为空\nT DeleteMax( MaxHeap H );\n返回H中最大元素（高优先级）\n\n### Insert\n\n思路：\n\n> 将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点\n\n```\ntemplate <typename T>\nvoid Insert( Heap<T>* h, T item)\n{\n\tint i;\n\tif( IsFull(h) ) // 若堆已满，则不做插入操作\n\t\treturn;\n\ti = ++h->size;\n\tfor( ; h->data[i/2]<item ; i/=2 )\n\t\th->data[i] = h->data[i/2];\n\th->data[i] = item;\n}\n```\n\n### Delete\n\n思路：\n\n> 取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作\n\n```\ntemplate <typename T>\nvoid Delete( Heap<T>* h , T item )\n{\n\tint parent , child;\n\tT maxn,tem;\n\tif( IsEmpty(h) ) \n\t\treturn;\n\tmaxn = h->data[1];\n\ttem = h->data[h->size--];\n\tfor( parent=1 ; parent*2<= h->size ; parent = child )\n\t{\n\t\tchild = parent *2;\n\t\tif( child != h->size  && h->data[child]<h.data[child+1])\n\t\t\tchild++;   // 寻找左右孩子中较大的那个\n\t\tif( tem>= h->data[child] ) \n\t\t\tbreak;\n\t\telse\n\t\t\th->data[parent] = h->data[child];\n\t}\n\th->data[parent]=tem;\n}\n```\n\n### 建立最大堆\n\n将已经存在的N个元素按最大堆的要求存放在一个一维数组\n\n方法1：\n通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)\n\n方法2：\n\n```\n1. n个元素按输入顺序存入，先满足完全二叉树\n2. 调整各结点位置\n\n```\n\n#### 方法二：\n\n自底向上调整\n\n从倒数第二行的结点开始自右向左调整\n\n而后再到倒数第三行、倒数第四行…直到根结点\n\n这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可\n\n这样就只需要O(n)的时间即可完成建堆\n\n# 哈夫曼树\n\n带权路径长度（WPL）\n设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk\n\n哈夫曼树（最优二叉树）：WPL值最小的二叉树\n\n## 哈夫曼树的构造\n\n每次把**权值最小**的两棵二叉树合并\n\n## 特点\n\n```\n1. 没有度为1的结点\n2. n个叶子结点的哈夫曼树有2n-1个结点\n    设 n0: 叶子结点总数\n    设 n1: 只有一个儿子的结点总数\n    设 n2: 有2个儿子的结点总数\n    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1\n3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树\n4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）\n\n```\n\n## 哈夫曼编码\n\n```\n给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少\n\n避免二义性：\n    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀\n\n利用二叉树进行编码：\n    1. 左右分支：0、1\n    2. 字符只在叶结点上\n\n构造方法：根据字符的权值构造哈夫曼树\n\n```\n\n# 集合\n\n```\n集合运算：交、并、补、差、判定一个元素是否属于某个集合\n并查集：集合并、查某元素属于什么集合\n并查集实现：\n    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）\n    2. 利用数组存储，两个一维数组分别存储数据和父亲下标\n\n```\n\n利用数组存储的定义：\n\n```\ntemplate <typename T>\nstruct Node\n{\n\tT data;\n\tint parent;\n\tNode( T d , int parent = -1 ):data(d){}\n\tNode(){parent=-1;}\n};\n```\n\n每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标\n\n## 查找当前结点所属集合\n\n思路：\n首先在数组中找到目标结点\n而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );   // 在数组中寻找值为x的结点\n\tif( i>=MaxSize ) return -1;    // 没找到，返回-1\n\tfor( ; s[i].parent>=0; i=s[i].parent );  // 顺着父结点指针一路向上找\n\treturn i;\n}\n```\n\n优化：\n通过**路径压缩**，每次查找时把沿途所有节点的parent都设为根节点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );\n\tif( i>=MaxSize ) return -1;\n\tint tem=i,tem1=s[tem].parent;\n\tfor( ; s[i].parent>=0; i=s[i].parent );\n\twhile( tem1!=-1 && tem1!=i )\n\t{\n\t\ts[tem].parent = i;\n\t\ttem=tem1;\n\t\ttem1=s[tem].parent;\n\t}\n\treturn i;\n}\n```\n\n## 集合的并运算\n\n思路：\n首先分别找到两个元素所在的集合树的根结点\n若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标\n\n```\ntemplate <typename T>\nvoid Union( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t\ts[root2].parent = root1;\n}\n```\n\n优化：\n为了改善合并后的查找效率，把小的集合并入大的集合\n方法1：每个结点额外维护一个值：以该结点为根的结点总数\n缺点：只有根节点才需要用到该值，造成大量空间浪费\n方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数\n\n```\ntemplate <typename T>\nvoid Union1( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t{\t\n\t\tif( s[root1].parent<s[root2].parent )\n\t\t{\t\n\t\t\ts[root1].parent += s[root2].parent;\n\t\t\ts[root2].parent = root1;\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\ts[root2].parent += s[root1].parent;\n\t\t\ts[root1].parent = root2;\n\t\t}\n\t}\n}\n```","slug":"DataStructure_Tree","published":1,"updated":"2018-05-25T12:41:12.394Z","photos":[],"link":"","_id":"cjleshqje000cryfcmknuskzl","content":"<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a><strong>树</strong></h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h2><h3 id=\"出现原因：\"><a href=\"#出现原因：\" class=\"headerlink\" title=\"出现原因：\"></a>出现原因：</h3><p>向量在静态操作速度快O(1)，在动态操作速度慢O(n)<br>列表在静态操作速度慢O(n)，在动态操作速度快O(1)<br>树结合了两者的优点，可看作是一种<strong>半线性的结构</strong><br>应用：组织层次关系，如文件系统、学院层级关系等</p>\n<a id=\"more\"></a>\n<h3 id=\"树的分类：\"><a href=\"#树的分类：\" class=\"headerlink\" title=\"树的分类：\"></a>树的分类：</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim\" alt=\"树的分类\"></p>\n<h3 id=\"概念1-有根树rooted-tree\"><a href=\"#概念1-有根树rooted-tree\" class=\"headerlink\" title=\"概念1. 有根树rooted tree\"></a>概念1. 有根树rooted tree</h3><p>指定任一结点为根<br>可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim\" alt=\"子树\"></p>\n<p>ri 为r的孩子( child )， ri之间互为兄弟( sibling )<br>r为父亲( parent ),<br>d=degree(r)为r的度=一结点拥有的孩子的数目<br>任何一棵树中边数e和结点数目n同阶</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim\" alt=\"边数和结点数同阶\"></p>\n<h3 id=\"概念2-有序树\"><a href=\"#概念2-有序树\" class=\"headerlink\" title=\"概念2. 有序树\"></a>概念2. 有序树</h3><p>指定Ti为T的第i棵子树，ri为r的第i个孩子</p>\n<p>即是：兄弟之间有明显<strong>次序</strong></p>\n<h3 id=\"概念3-连通性和无环性：\"><a href=\"#概念3-连通性和无环性：\" class=\"headerlink\" title=\"概念3. 连通性和无环性：\"></a>概念3. 连通性和无环性：</h3><p>任何两结点之间都有路径，则称为<strong>连通图</strong>（connected）<br>不含环路则称为<strong>无环图</strong>（acyclic）</p>\n<p>树的特点：</p>\n<blockquote>\n<p>1 .无环连通图：在无环性和连通性之间平衡<br>2 .极小连通图：在连通的情况下边数尽可能少<br>3 .极大无环图：在无环的情况下边数尽可能多</p>\n</blockquote>\n<p>结论： 任何结点和根之间存在<strong>唯一一条</strong>路径<br>即 $path(v,r)=path(v)$<br>我们用一个指标 <strong>深度( depth )</strong> 记录下每个结点到根的距离<br>path(v)上的结点均为v的<strong>祖先</strong>( ancestor )<br>v是它们的<strong>后代</strong> ( descendent )<br>对于v而言，若<strong>祖先存在，则必定唯一</strong>。若<strong>后代存在，却未必唯一</strong>，因此是半线性结构。<br>而对于图而言，祖先和后代都未必唯一，因此图为非线性结构<br><strong>叶子结点</strong>（leaf）：没有后代的结点</p>\n<p>叶子深度最大的称为<strong>树的高度</strong><br><strong>深度</strong>是<strong>结点v到总树根结点r</strong>的距离<br>即height（v）=max( height (v_son) ) +1<br>结点v的<strong>高度</strong>为<strong>以结点v为根结点</strong>的子树的高度<br>即 height（v）=height（subtree（v））<br>约定俗成：空树的高度取作<strong>-1</strong>，一个结点的树高度取作<strong>0</strong><br>对于任一结点：depth（v）+height（v）&lt;=height(T)<br>（高度向下看，深度向上看）<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim\" alt=\"树的深度和高度\"></p>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a><strong>表示</strong></h2><h3 id=\"1-接口\"><a href=\"#1-接口\" class=\"headerlink\" title=\"1. 接口\"></a>1. 接口</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>结点</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>node*</td>\n<td>root()</td>\n<td>根结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>parent()</td>\n<td>父结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>firstchild()</td>\n<td>长子</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>nextSibling()</td>\n<td>兄弟</td>\n</tr>\n<tr>\n<td>void</td>\n<td>insert( i,e )</td>\n<td>将e作为第i个孩子插入</td>\n</tr>\n<tr>\n<td>int</td>\n<td>remove(i)</td>\n<td>删除第i个孩子(及其后代)</td>\n</tr>\n<tr>\n<td>void</td>\n<td>traverse</td>\n<td>遍历</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-构造方法\"><a href=\"#2-构造方法\" class=\"headerlink\" title=\"2. 构造方法\"></a>2. 构造方法</h3><p>不妨用数组进行模拟</p>\n<p><strong>长子兄弟法</strong>：</p>\n<p>每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint father, child, nextSibling;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node  *tree;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a><strong>二叉树</strong></h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>结点度数<strong>不超过2</strong>（孩子数目&lt;=2）的树</p>\n<p>同一结点的孩子和子树以<strong>左右</strong>区分</p>\n<p>二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。</p>\n<p>基于二叉树的概念，我们可以得到下列关系：<br>1.深度为k的结点最多有$2^k$个<br>2.高度为h的二叉树的结点数n满足$h’&lt;’n’&lt;’2^(h+1)$<br>1.当n=h+1时，二叉树退化为一条单链<br>2.当$n=2^(h+1)-1$时，二叉树为满二叉树</p>\n<p>二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点</p>\n<p>而高度h涨得很慢，与结点n的关系为$h=logn$</p>\n<h2 id=\"真二叉树-Proper-binary-tree\"><a href=\"#真二叉树-Proper-binary-tree\" class=\"headerlink\" title=\"真二叉树(Proper binary tree)\"></a><strong>真二叉树(Proper binary tree)</strong></h2><p>定义：所有结点的度数均为偶数的二叉树。</p>\n<p>很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点<strong>虚拟地</strong>补上孩子。</p>\n<h2 id=\"完全二叉树-complete-binary-tree\"><a href=\"#完全二叉树-complete-binary-tree\" class=\"headerlink\" title=\"完全二叉树(complete binary tree)\"></a><strong>完全二叉树(complete binary tree)</strong></h2><p>定义：叶结点只出现在<strong>最后两层</strong>，并且最底层的叶结点均在次底层叶结点的<strong>左侧</strong>。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG\" alt=\"完全二叉树\"></p>\n<h2 id=\"满二叉树-full-binary-tree\"><a href=\"#满二叉树-full-binary-tree\" class=\"headerlink\" title=\"满二叉树(full binary tree)\"></a><strong>满二叉树(full binary tree)</strong></h2><p>定义：所有叶结点都在<strong>最后一层</strong>，每层结点都达到饱和。</p>\n<p>特性：<br>1.结点数目n和高度h的关系：$n=2^(h+1)-1$<br>2.叶子结点数=内部结点数+1<br>3.满二叉树是<strong>特殊</strong>的<strong>完全二叉树</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG\" alt=\"满二叉树\"></p>\n<h2 id=\"用二叉树描述多叉树\"><a href=\"#用二叉树描述多叉树\" class=\"headerlink\" title=\"用二叉树描述多叉树\"></a><strong>用二叉树描述多叉树</strong></h2><p>先上结论：<strong>凡是有根且有序的树，均可以用二叉树实现</strong></p>\n<p>为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG\" alt=\"树到二叉树\"></p>\n<p>可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG\" alt=\"树到二叉树\"></p>\n<p>这就将一棵树变成了二叉树！</p>\n<p>这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。</p>\n<h2 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a><strong>基本定义</strong></h2><p><strong>结点类的基本定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* lChild,*rChild,*parent;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBinNode() &#123; lChild=rChild=parent= NULL ; height=0; &#125;</span><br><span class=\"line\">\tBinNode( T e , BinNode&lt;T&gt;* pa=NULL , BinNode&lt;T&gt;* lc=NULL, BinNode&lt;T&gt;* rc=NULL)</span><br><span class=\"line\">\t\t:data(e),parent(pa),lChild(lc),rChild(rc) &#123;&#125;</span><br><span class=\"line\">\tint size() const ;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC( T const &amp; e ) //作为左孩子插入</span><br><span class=\"line\">\t&#123; return lChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC( T const &amp; e ) //作为右孩子插入</span><br><span class=\"line\">\t&#123; return rChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBinNode&lt;T&gt; * succ();   // 中序遍历时的直接后继</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit );  // 子树层级遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit );   // 子树先序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit );    // 子树中序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit );   // 子树后序遍历</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int BinNode&lt;T&gt;::size()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint s=1;</span><br><span class=\"line\">\tif(lChild)</span><br><span class=\"line\">\t\ts+=lChild-&gt;size();</span><br><span class=\"line\">\tif(rChild)</span><br><span class=\"line\">\t\ts+=rChild-&gt;size();</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。</p>\n<p>size函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。</p>\n<p><strong>树的基础定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint _size;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* _root;</span><br><span class=\"line\">\tvirtual int updateHeight( BinNode&lt;T&gt;* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）</span><br><span class=\"line\">\tvoid updateHeightAbove( BinNode&lt;T&gt;* x);  // 更新x及x的祖先的高度</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBinTree() &#123;_size=0; _root=NULL;&#125;</span><br><span class=\"line\">\t~BinTree() &#123; remove(_root); &#125;</span><br><span class=\"line\">\tBinTree( T const&amp; e) &#123;_size=1; _root=new BinNode&lt;T&gt; (e);&#125;</span><br><span class=\"line\">\tint size() const &#123;return _size;&#125;</span><br><span class=\"line\">\tbool empty() const &#123;return !_root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * root() const &#123;return _root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造右孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsLC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsRC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为右孩子</span><br><span class=\"line\">\tint remove( BinNode&lt;T&gt;* x );   // 删除某个结点（及其子树）</span><br><span class=\"line\">\tvoid removeAt( BinNode&lt;T&gt;* x );</span><br><span class=\"line\">\tBinTree&lt;T&gt; * secede( BinNode&lt;T&gt;* x );    // 分离子树，返回子树头</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit )  // 层级遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travLevel(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit )  // 先序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPre(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit )  // 中序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travIn(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit )   // 后序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPost(visit); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a><strong>遍历</strong></h2><p>定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次</p>\n<p><strong>遍历方式：</strong></p>\n<blockquote>\n<ol>\n<li>先序遍历( preorder )：中-&gt;左-&gt;右</li>\n<li>中序遍历( inorder )：左-&gt;中-&gt;右</li>\n<li>后序遍历( postorder )：左-&gt;右-&gt;中</li>\n<li>层次遍历：自上而下，自左而右</li>\n</ol>\n<p>先序中序后序原则：必定先左后右，根结点访问次序如名字所示</p>\n</blockquote>\n<h3 id=\"1-先序遍历-中-左-右\"><a href=\"#1-先序遍历-中-左-右\" class=\"headerlink\" title=\"1. 先序遍历( 中 左 右 )\"></a><strong>1. 先序遍历( 中 左 右 )</strong></h3><h4 id=\"1-递归版本\"><a href=\"#1-递归版本\" class=\"headerlink\" title=\"1. 递归版本\"></a><strong>1. 递归版本</strong></h4><p>根据先序遍历的定义，我们很容易写出递归版本的遍历函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V为函数模板类  visit是相应的函数对象</span><br><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_R( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisit(data);</span><br><span class=\"line\">\tif(lChild) lChild-&gt;travPre_R(visit);</span><br><span class=\"line\">\tif(rChild) rChild-&gt;travPre_R(visit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。</p>\n<p>因此如果能够将<strong>递归版</strong>改成<strong>迭代版</strong>，就能够提高很多效率。</p>\n<h4 id=\"2-迭代版本1\"><a href=\"#2-迭代版本1\" class=\"headerlink\" title=\"2. 迭代版本1\"></a><strong>2. 迭代版本1</strong></h4><p>因为在递归版本中，向左右子树的递归出现在最后，即是<strong>尾递归</strong>，那么我们只需要引入一个<strong>栈</strong>，把左右子树的递归改成将左右子树入栈即可。</p>\n<p>值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要<strong>先让右子树入栈，再让左子树入栈</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_V1( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack &lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tif(x) </span><br><span class=\"line\">\t\ts.push(x);</span><br><span class=\"line\">\twhile(!s.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tif(x-&gt;rChild) s.push(x-&gt;rChild); // 先入后出</span><br><span class=\"line\">\t\tif(x-&gt;lChild) s.push(x-&gt;lChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-迭代版本2\"><a href=\"#3-迭代版本2\" class=\"headerlink\" title=\"3. 迭代版本2\"></a><strong>3. 迭代版本2</strong></h4><p>看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。</p>\n<p>通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子-&gt;它父亲的右孩子-&gt;父亲的父亲的右孩子…-&gt;根结点的右孩子。</p>\n<p>于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG\" alt=\"左侧链示意图\"></p>\n<p>这样，我们就有了如下算法流程：</p>\n<p>1.访问该结点<br>2.将右孩子入栈<br>3.目光转向它的左孩子<br>若左孩子存在，回到步骤1<br>4.若栈不为空，取出栈顶元素，回到步骤1</p>\n<p>代码实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\t\tif(x-&gt;rChild) </span><br><span class=\"line\">\t\t\t\ts.push(x-&gt;rChild);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序遍历-左-中-右\"><a href=\"#2-中序遍历-左-中-右\" class=\"headerlink\" title=\"2. 中序遍历( 左 中 右 )\"></a><strong>2. 中序遍历( 左 中 右 )</strong></h3><h4 id=\"1-迭代版本1\"><a href=\"#1-迭代版本1\" class=\"headerlink\" title=\"1. 迭代版本1\"></a><strong>1. 迭代版本1</strong></h4><p>先来观察一下中序遍历的流程：</p>\n<p>每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。</p>\n<p>中序和先序不同在于：<strong>父结点不是立即被访问</strong>，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。</p>\n<p>那右结点怎么办呢？</p>\n<p>右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG\" alt=\"中序遍历\"></p>\n<p>算法的流程如下：</p>\n<p>1.将该结点入栈<br>2.转向该结点的左孩子<br>若左孩子存在，返回步骤1<br>3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子<br>若右孩子存在，返回步骤1<br>若右孩子不存在，重新开始步骤3</p>\n<p>现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ts.push(x);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(s.empty()) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;rChild;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本</p>\n<h4 id=\"2-迭代版本2\"><a href=\"#2-迭代版本2\" class=\"headerlink\" title=\"2. 迭代版本2\"></a><strong>2. 迭代版本2</strong></h4><p>当把二叉树横向伸展地足够开后，如下图所示<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim\" alt=\"中序遍历\"><br>从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序<br>左右规则如下:</p>\n<p>左子树左孩子&gt;左子树根结点&gt;左子树右孩子&gt;根结点&gt;右子树左孩子&gt;右子树根结点&gt;右子树右孩子</p>\n<p>根据这个规则，我们就可以得到每个结点在中序遍历时的<strong>直接后继</strong>，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)</p>\n<p>那么要怎么得到这个直接后继呢？<br>显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。<br>而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个<strong>结点是它父结点左孩子</strong>的结点，直接后继就是这个结点的父结点。<br>简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。</p>\n<p>将上述流程翻译成代码就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; *BinNode&lt;T&gt;::succ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* s=this;</span><br><span class=\"line\">\tif(rChild)   // 若有右孩子</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=rChild;</span><br><span class=\"line\">\t\twhile(s-&gt;lChild)   // 在右子树的左侧链一路到底</span><br><span class=\"line\">\t\t\ts=s-&gt;lChild;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile( s-&gt;parent &amp;&amp; s==s-&gt;parent-&gt;rChild )</span><br><span class=\"line\">\t\t\ts=s-&gt;parent;    // 此时是左子树的根结点</span><br><span class=\"line\">\t\ts=s-&gt;parent;   // 再向上到左子树的父亲结点(也可能是NULL)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_S(  V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\twhile(x-&gt;lChild)</span><br><span class=\"line\">\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;succ();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-后序遍历-左-右-中\"><a href=\"#3-后序遍历-左-右-中\" class=\"headerlink\" title=\"3. 后序遍历( 左 右 中 )\"></a><strong>3. 后序遍历( 左 右 中 )</strong></h3><p>基于后序遍历的定义，我们可以导出如下流程：<br>1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。<br>2.访问结点<br>3.若右兄弟存在，转向右兄弟，返回步骤1<br>4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程</p>\n<p>可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPost_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\tBinNode&lt;T&gt; * c=s.top();</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s.empty()) break;</span><br><span class=\"line\">\t\tif(s.top()!=x-&gt;parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tc=s.top();</span><br><span class=\"line\">\t\t\twhile(1)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(c-&gt;rChild) </span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;rChild);</span><br><span class=\"line\">\t\t\t\tif(c-&gt;lChild) </span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;lChild);</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;lChild;   // 尽可能向左走</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse if(c-&gt;rChild)  // 如果实在只有右孩子，那就向右</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;rChild;</span><br><span class=\"line\">\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-层次遍历\"><a href=\"#4-层次遍历\" class=\"headerlink\" title=\"4. 层次遍历\"></a><strong>4. 层次遍历</strong></h3><p>层次遍历的规则很简单：自上而下，自左而右</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim\" alt=\"层次遍历\"></p>\n<p>对此，我们可以引入<strong>队列</strong>来解决它。</p>\n<p>每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travLevel( V &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueue&lt;BinNode&lt;T&gt;*&gt; q;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tq.enqueue(x);</span><br><span class=\"line\">\twhile( !q.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=q.dequeue();</span><br><span class=\"line\">\t\tif(x-&gt;lChild)  q.enqueue(x-&gt;lChild);</span><br><span class=\"line\">\t\tif(x-&gt;rChild)  q.enqueue(x-&gt;rChild);</span><br><span class=\"line\">\t\te(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a><strong>重构</strong></h2><p>如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？</p>\n<h3 id=\"一-中序-先序-后序\"><a href=\"#一-中序-先序-后序\" class=\"headerlink\" title=\"一. 中序+(先序|后序)\"></a><strong>一. 中序+(先序|后序)</strong></h3><p>结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。</p>\n<p>现在我们来用数学归纳法证明一下：<br>假设结论在结点数n’&lt;’N的情况下都成立<br>在n==N时<br>先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。<br>那么在先序遍历和中序遍历中分别如下图所示：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG\" alt=\"重构二叉树\"></p>\n<p>可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。<br>这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’&lt;’N的左右子树中结论均成立，由此n==N时结论也成立。</p>\n<p>而有后续和中序遍历的序列的证明也同理可得了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先序+中序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PI( T* pre, T* ins, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_PI(pre,ins,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PI( T* pre, T* ins, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(pre); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PI( pre+1, ins, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 中序+后序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_IP( T* ins, T* post, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_IP(ins,post,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_IP( T* ins, T* post, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(* (post+len-1) );</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+len-1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*(post+len-1));</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_IP( ins, post, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-先序-后序-真二叉树\"><a href=\"#二-先序-后序-真二叉树\" class=\"headerlink\" title=\"二. (先序+后序)*真二叉树\"></a><strong>二. (先序+后序)*真二叉树</strong></h3><p>结论二：在只有先序和后序序列时，若是该二叉树是一棵<strong>真二叉树</strong>(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。</p>\n<p>那么要怎么做呢？</p>\n<p>在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。<br>在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。<br>这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG\" alt=\"重构二叉树\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PP( T *pre,T *post,int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=new BinNode&lt;T&gt; (pre[0]);</span><br><span class=\"line\">\trebuildSub_PP( _root,pre,post,len );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PP( T *pre , T *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif( len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PP(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的完整实现 ( 附带遍历和重构 )</a></p>\n<h1 id=\"二叉搜索树BST-Binary-Search-Tree\"><a href=\"#二叉搜索树BST-Binary-Search-Tree\" class=\"headerlink\" title=\"二叉搜索树BST ( Binary Search Tree )\"></a>二叉搜索树BST ( Binary Search Tree )</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"循关键码访问-call-by-key\"><a href=\"#循关键码访问-call-by-key\" class=\"headerlink\" title=\"循关键码访问 call-by-key\"></a>循关键码访问 call-by-key</h3><p>数据项之间，依照各自的关键码(key)彼此区分</p>\n<p>条件：关键码之间支持<strong>大小比较</strong>和<strong>相等比对</strong></p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 非空左子树所有键值小于根结点的键值</span><br><span class=\"line\">2. 非空右子树所有键值大于根结点的键值</span><br><span class=\"line\">3. 左右子树都是二叉搜索树</span><br></pre></td></tr></table></figure>\n<p>基本框架：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct TreeNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * left;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. BinTree Find( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找元素x,返回所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. BinTree FindMin(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最小元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. BinTree FindMax(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最大元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. BinTree Insert( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将元素x插入BST中，返回插入后的BST</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. BinTree Delete( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中删除元素x</p>\n</blockquote>\n<h3 id=\"查找操作：-Find\"><a href=\"#查找操作：-Find\" class=\"headerlink\" title=\"查找操作： Find\"></a>查找操作： Find</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 查找从根结点开始，若树为空则返回NULL</span><br><span class=\"line\">- 若树非空，则将根结点键值和x比较：</span><br><span class=\"line\">    - 若 x &lt; root.data ，在左子树中搜索</span><br><span class=\"line\">    - 若 x &gt; root.data ，在右子树中搜索</span><br><span class=\"line\">    - 若两者相等，则返回指向该结点的指针</span><br><span class=\"line\">- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式</span><br><span class=\"line\">- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**</span><br></pre></td></tr></table></figure>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Find(T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\treturn BST;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找最大和最小元素\"><a href=\"#查找最大和最小元素\" class=\"headerlink\" title=\"查找最大和最小元素\"></a>查找最大和最小元素</h3><p>根据二叉搜索树的性质：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 最大元素一定在树的最右分支的端结点上</span><br><span class=\"line\">- 最小元素一定在树的最左分支的端结点上</span><br></pre></td></tr></table></figure>\n<p>同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMax( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;right)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMin( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;left)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h3><p>关键：要找到元素应该插入的位置，可以采用和Find类似的方法</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Insert( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tBST = new TreeNode&lt;T&gt;();</span><br><span class=\"line\">\t\tBST-&gt;data=x;</span><br><span class=\"line\">\t\tBST-&gt;left=BST-&gt;right=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;left=Insert(x,BST-&gt;left);</span><br><span class=\"line\">\t\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;right=Insert(x,BST-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h3><p>考虑情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL</span><br><span class=\"line\">2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子</span><br><span class=\"line\">3. 要删除的结点有左右两棵子树</span><br><span class=\"line\">    用另一结点代替被删除结点：左子树最大元素或右子树最小元素</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Delete( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; *tmp;</span><br><span class=\"line\">\tif(!BST) return NULL;</span><br><span class=\"line\">\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;left=Delete(x,BST-&gt;left);</span><br><span class=\"line\">\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;right=Delete(x,BST-&gt;right);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(BST-&gt;left &amp;&amp; BST-&gt;right)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=FindMin(BST-&gt;right);</span><br><span class=\"line\">\t\t\tBST-&gt;data=tmp-&gt;data;</span><br><span class=\"line\">\t\t\tBST-&gt;right=delete(BST-&gt;data,BST-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=BST;</span><br><span class=\"line\">\t\t\tif(!BST-&gt;left)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\t\telse if(!BST-&gt;right)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\t\tdelete tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"平衡二叉树-AVL树-Balanced-Binary-Tree\"><a href=\"#平衡二叉树-AVL树-Balanced-Binary-Tree\" class=\"headerlink\" title=\"平衡二叉树 AVL树 (Balanced Binary Tree)\"></a>平衡二叉树 AVL树 (Balanced Binary Tree)</h1><p>定义：<br>空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|&lt;=1</p>\n<p><strong>平衡因子（BF:Balance Factor）</strong>: BF(T)=Hl - Hr<br>Hl和Hr分别为T的左右子树的高度</p>\n<p>推算高度为h的平衡二叉树最少结点数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高度为1时 h(1)=1;</span><br><span class=\"line\">高度为2时 h(2)=2;</span><br><span class=\"line\">高度为3时 h(3)=h(1)+h(2)+1=4;</span><br><span class=\"line\">...</span><br><span class=\"line\">高度为n时 h(n)=h(n-1)+h(n-2)+1;</span><br><span class=\"line\">原因：</span><br><span class=\"line\">    &gt; 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值&lt;=1</span><br><span class=\"line\">    &gt; 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )</span><br><span class=\"line\">由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$</span><br></pre></td></tr></table></figure>\n<p>结点数为n的平衡二叉树的最大高度为O(logn)</p>\n<h2 id=\"平衡二叉树的调整\"><a href=\"#平衡二叉树的调整\" class=\"headerlink\" title=\"平衡二叉树的调整\"></a>平衡二叉树的调整</h2><p><strong>核心思想：选择中间值作为根结点</strong></p>\n<p><strong>RR插入</strong>：插入结点在右子树的右边，需要RR旋转（右单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树根结点 &lt; 右子树的右边</p>\n<p>因此选取右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LL插入</strong>：插入结点在左子树的左边，需要LL旋转（左单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的左边 &lt; 左子树根结点 &lt; 根结点</p>\n<p>因此选取左子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LR插入</strong>：插入结点在左子树的右边，需要LR旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的根结点 &lt; 左子树的右边 &lt; 根结点</p>\n<p>因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>RL插入</strong>：插入结点在右子树的左边，需要RL旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树的左边 &lt; 右子树的根结点</p>\n<p>因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点</p>\n<h1 id=\"堆-heap\"><a href=\"#堆-heap\" class=\"headerlink\" title=\"堆 heap\"></a>堆 heap</h1><h2 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><strong>优先队列( Priority Queue )</strong><br>特殊的队列，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>的大小，而不是元素进入队列的先后顺序</p>\n<p>堆的特性：<br><strong>结构性</strong>：用数组表示的完全二叉树<br><strong>有序性</strong>：任一结点的关键字是其子树所有结点的最大值（或最小值）<br>从根结点到任意结点路径上结点序列的有序性<br>最大堆（MaxHeap）：根结点为最大值<br>最小堆（MinHeap）：根结点为最小值</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>数据对象集：完全二叉树</p>\n<p>接口：<br>MaxHeap Create( int Maxsize );<br>创建一个空的最大堆<br>Boolean IsFull( MaxHeap H );<br>判断最大堆H是否满<br>void Insert( MaxHeap H , T data );<br>将data插入最大堆H<br>Boolean IsEmpty( MaxHeap H );<br>判断最大堆H是否为空<br>T DeleteMax( MaxHeap H );<br>返回H中最大元素（高优先级）</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>思路：</p>\n<blockquote>\n<p>将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Insert( Heap&lt;T&gt;* h, T item)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tif( IsFull(h) ) // 若堆已满，则不做插入操作</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\ti = ++h-&gt;size;</span><br><span class=\"line\">\tfor( ; h-&gt;data[i/2]&lt;item ; i/=2 )</span><br><span class=\"line\">\t\th-&gt;data[i] = h-&gt;data[i/2];</span><br><span class=\"line\">\th-&gt;data[i] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>思路：</p>\n<blockquote>\n<p>取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Delete( Heap&lt;T&gt;* h , T item )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint parent , child;</span><br><span class=\"line\">\tT maxn,tem;</span><br><span class=\"line\">\tif( IsEmpty(h) ) </span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tmaxn = h-&gt;data[1];</span><br><span class=\"line\">\ttem = h-&gt;data[h-&gt;size--];</span><br><span class=\"line\">\tfor( parent=1 ; parent*2&lt;= h-&gt;size ; parent = child )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tchild = parent *2;</span><br><span class=\"line\">\t\tif( child != h-&gt;size  &amp;&amp; h-&gt;data[child]&lt;h.data[child+1])</span><br><span class=\"line\">\t\t\tchild++;   // 寻找左右孩子中较大的那个</span><br><span class=\"line\">\t\tif( tem&gt;= h-&gt;data[child] ) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\th-&gt;data[parent] = h-&gt;data[child];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\th-&gt;data[parent]=tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建立最大堆\"><a href=\"#建立最大堆\" class=\"headerlink\" title=\"建立最大堆\"></a>建立最大堆</h3><p>将已经存在的N个元素按最大堆的要求存放在一个一维数组</p>\n<p>方法1：<br>通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)</p>\n<p>方法2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. n个元素按输入顺序存入，先满足完全二叉树</span><br><span class=\"line\">2. 调整各结点位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><p>自底向上调整</p>\n<p>从倒数第二行的结点开始自右向左调整</p>\n<p>而后再到倒数第三行、倒数第四行…直到根结点</p>\n<p>这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可</p>\n<p>这样就只需要O(n)的时间即可完成建堆</p>\n<h1 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h1><p>带权路径长度（WPL）<br>设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk</p>\n<p>哈夫曼树（最优二叉树）：WPL值最小的二叉树</p>\n<h2 id=\"哈夫曼树的构造\"><a href=\"#哈夫曼树的构造\" class=\"headerlink\" title=\"哈夫曼树的构造\"></a>哈夫曼树的构造</h2><p>每次把<strong>权值最小</strong>的两棵二叉树合并</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 没有度为1的结点</span><br><span class=\"line\">2. n个叶子结点的哈夫曼树有2n-1个结点</span><br><span class=\"line\">    设 n0: 叶子结点总数</span><br><span class=\"line\">    设 n1: 只有一个儿子的结点总数</span><br><span class=\"line\">    设 n2: 有2个儿子的结点总数</span><br><span class=\"line\">    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1</span><br><span class=\"line\">3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树</span><br><span class=\"line\">4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）</span><br></pre></td></tr></table></figure>\n<h2 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少</span><br><span class=\"line\"></span><br><span class=\"line\">避免二义性：</span><br><span class=\"line\">    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</span><br><span class=\"line\"></span><br><span class=\"line\">利用二叉树进行编码：</span><br><span class=\"line\">    1. 左右分支：0、1</span><br><span class=\"line\">    2. 字符只在叶结点上</span><br><span class=\"line\"></span><br><span class=\"line\">构造方法：根据字符的权值构造哈夫曼树</span><br></pre></td></tr></table></figure>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">集合运算：交、并、补、差、判定一个元素是否属于某个集合</span><br><span class=\"line\">并查集：集合并、查某元素属于什么集合</span><br><span class=\"line\">并查集实现：</span><br><span class=\"line\">    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）</span><br><span class=\"line\">    2. 利用数组存储，两个一维数组分别存储数据和父亲下标</span><br></pre></td></tr></table></figure>\n<p>利用数组存储的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint parent;</span><br><span class=\"line\">\tNode( T d , int parent = -1 ):data(d)&#123;&#125;</span><br><span class=\"line\">\tNode()&#123;parent=-1;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标</p>\n<h2 id=\"查找当前结点所属集合\"><a href=\"#查找当前结点所属集合\" class=\"headerlink\" title=\"查找当前结点所属集合\"></a>查找当前结点所属集合</h2><p>思路：<br>首先在数组中找到目标结点<br>而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );   // 在数组中寻找值为x的结点</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;    // 没找到，返回-1</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );  // 顺着父结点指针一路向上找</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>通过<strong>路径压缩</strong>，每次查找时把沿途所有节点的parent都设为根节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;</span><br><span class=\"line\">\tint tem=i,tem1=s[tem].parent;</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );</span><br><span class=\"line\">\twhile( tem1!=-1 &amp;&amp; tem1!=i )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts[tem].parent = i;</span><br><span class=\"line\">\t\ttem=tem1;</span><br><span class=\"line\">\t\ttem1=s[tem].parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合的并运算\"><a href=\"#集合的并运算\" class=\"headerlink\" title=\"集合的并运算\"></a>集合的并运算</h2><p>思路：<br>首先分别找到两个元素所在的集合树的根结点<br>若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t\ts[root2].parent = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>为了改善合并后的查找效率，把小的集合并入大的集合<br>方法1：每个结点额外维护一个值：以该结点为根的结点总数<br>缺点：只有根节点才需要用到该值，造成大量空间浪费<br>方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union1( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s[root1].parent&lt;s[root2].parent )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root1].parent += s[root2].parent;</span><br><span class=\"line\">\t\t\ts[root2].parent = root1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root2].parent += s[root1].parent;</span><br><span class=\"line\">\t\t\ts[root1].parent = root2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a><strong>树</strong></h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h2><h3 id=\"出现原因：\"><a href=\"#出现原因：\" class=\"headerlink\" title=\"出现原因：\"></a>出现原因：</h3><p>向量在静态操作速度快O(1)，在动态操作速度慢O(n)<br>列表在静态操作速度慢O(n)，在动态操作速度快O(1)<br>树结合了两者的优点，可看作是一种<strong>半线性的结构</strong><br>应用：组织层次关系，如文件系统、学院层级关系等</p>","more":"<h3 id=\"树的分类：\"><a href=\"#树的分类：\" class=\"headerlink\" title=\"树的分类：\"></a>树的分类：</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim\" alt=\"树的分类\"></p>\n<h3 id=\"概念1-有根树rooted-tree\"><a href=\"#概念1-有根树rooted-tree\" class=\"headerlink\" title=\"概念1. 有根树rooted tree\"></a>概念1. 有根树rooted tree</h3><p>指定任一结点为根<br>可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim\" alt=\"子树\"></p>\n<p>ri 为r的孩子( child )， ri之间互为兄弟( sibling )<br>r为父亲( parent ),<br>d=degree(r)为r的度=一结点拥有的孩子的数目<br>任何一棵树中边数e和结点数目n同阶</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim\" alt=\"边数和结点数同阶\"></p>\n<h3 id=\"概念2-有序树\"><a href=\"#概念2-有序树\" class=\"headerlink\" title=\"概念2. 有序树\"></a>概念2. 有序树</h3><p>指定Ti为T的第i棵子树，ri为r的第i个孩子</p>\n<p>即是：兄弟之间有明显<strong>次序</strong></p>\n<h3 id=\"概念3-连通性和无环性：\"><a href=\"#概念3-连通性和无环性：\" class=\"headerlink\" title=\"概念3. 连通性和无环性：\"></a>概念3. 连通性和无环性：</h3><p>任何两结点之间都有路径，则称为<strong>连通图</strong>（connected）<br>不含环路则称为<strong>无环图</strong>（acyclic）</p>\n<p>树的特点：</p>\n<blockquote>\n<p>1 .无环连通图：在无环性和连通性之间平衡<br>2 .极小连通图：在连通的情况下边数尽可能少<br>3 .极大无环图：在无环的情况下边数尽可能多</p>\n</blockquote>\n<p>结论： 任何结点和根之间存在<strong>唯一一条</strong>路径<br>即 $path(v,r)=path(v)$<br>我们用一个指标 <strong>深度( depth )</strong> 记录下每个结点到根的距离<br>path(v)上的结点均为v的<strong>祖先</strong>( ancestor )<br>v是它们的<strong>后代</strong> ( descendent )<br>对于v而言，若<strong>祖先存在，则必定唯一</strong>。若<strong>后代存在，却未必唯一</strong>，因此是半线性结构。<br>而对于图而言，祖先和后代都未必唯一，因此图为非线性结构<br><strong>叶子结点</strong>（leaf）：没有后代的结点</p>\n<p>叶子深度最大的称为<strong>树的高度</strong><br><strong>深度</strong>是<strong>结点v到总树根结点r</strong>的距离<br>即height（v）=max( height (v_son) ) +1<br>结点v的<strong>高度</strong>为<strong>以结点v为根结点</strong>的子树的高度<br>即 height（v）=height（subtree（v））<br>约定俗成：空树的高度取作<strong>-1</strong>，一个结点的树高度取作<strong>0</strong><br>对于任一结点：depth（v）+height（v）&lt;=height(T)<br>（高度向下看，深度向上看）<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim\" alt=\"树的深度和高度\"></p>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a><strong>表示</strong></h2><h3 id=\"1-接口\"><a href=\"#1-接口\" class=\"headerlink\" title=\"1. 接口\"></a>1. 接口</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>结点</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>node*</td>\n<td>root()</td>\n<td>根结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>parent()</td>\n<td>父结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>firstchild()</td>\n<td>长子</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>nextSibling()</td>\n<td>兄弟</td>\n</tr>\n<tr>\n<td>void</td>\n<td>insert( i,e )</td>\n<td>将e作为第i个孩子插入</td>\n</tr>\n<tr>\n<td>int</td>\n<td>remove(i)</td>\n<td>删除第i个孩子(及其后代)</td>\n</tr>\n<tr>\n<td>void</td>\n<td>traverse</td>\n<td>遍历</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-构造方法\"><a href=\"#2-构造方法\" class=\"headerlink\" title=\"2. 构造方法\"></a>2. 构造方法</h3><p>不妨用数组进行模拟</p>\n<p><strong>长子兄弟法</strong>：</p>\n<p>每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint father, child, nextSibling;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node  *tree;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a><strong>二叉树</strong></h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>结点度数<strong>不超过2</strong>（孩子数目&lt;=2）的树</p>\n<p>同一结点的孩子和子树以<strong>左右</strong>区分</p>\n<p>二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。</p>\n<p>基于二叉树的概念，我们可以得到下列关系：<br>1.深度为k的结点最多有$2^k$个<br>2.高度为h的二叉树的结点数n满足$h’&lt;’n’&lt;’2^(h+1)$<br>1.当n=h+1时，二叉树退化为一条单链<br>2.当$n=2^(h+1)-1$时，二叉树为满二叉树</p>\n<p>二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点</p>\n<p>而高度h涨得很慢，与结点n的关系为$h=logn$</p>\n<h2 id=\"真二叉树-Proper-binary-tree\"><a href=\"#真二叉树-Proper-binary-tree\" class=\"headerlink\" title=\"真二叉树(Proper binary tree)\"></a><strong>真二叉树(Proper binary tree)</strong></h2><p>定义：所有结点的度数均为偶数的二叉树。</p>\n<p>很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点<strong>虚拟地</strong>补上孩子。</p>\n<h2 id=\"完全二叉树-complete-binary-tree\"><a href=\"#完全二叉树-complete-binary-tree\" class=\"headerlink\" title=\"完全二叉树(complete binary tree)\"></a><strong>完全二叉树(complete binary tree)</strong></h2><p>定义：叶结点只出现在<strong>最后两层</strong>，并且最底层的叶结点均在次底层叶结点的<strong>左侧</strong>。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG\" alt=\"完全二叉树\"></p>\n<h2 id=\"满二叉树-full-binary-tree\"><a href=\"#满二叉树-full-binary-tree\" class=\"headerlink\" title=\"满二叉树(full binary tree)\"></a><strong>满二叉树(full binary tree)</strong></h2><p>定义：所有叶结点都在<strong>最后一层</strong>，每层结点都达到饱和。</p>\n<p>特性：<br>1.结点数目n和高度h的关系：$n=2^(h+1)-1$<br>2.叶子结点数=内部结点数+1<br>3.满二叉树是<strong>特殊</strong>的<strong>完全二叉树</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG\" alt=\"满二叉树\"></p>\n<h2 id=\"用二叉树描述多叉树\"><a href=\"#用二叉树描述多叉树\" class=\"headerlink\" title=\"用二叉树描述多叉树\"></a><strong>用二叉树描述多叉树</strong></h2><p>先上结论：<strong>凡是有根且有序的树，均可以用二叉树实现</strong></p>\n<p>为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG\" alt=\"树到二叉树\"></p>\n<p>可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG\" alt=\"树到二叉树\"></p>\n<p>这就将一棵树变成了二叉树！</p>\n<p>这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。</p>\n<h2 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a><strong>基本定义</strong></h2><p><strong>结点类的基本定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* lChild,*rChild,*parent;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBinNode() &#123; lChild=rChild=parent= NULL ; height=0; &#125;</span><br><span class=\"line\">\tBinNode( T e , BinNode&lt;T&gt;* pa=NULL , BinNode&lt;T&gt;* lc=NULL, BinNode&lt;T&gt;* rc=NULL)</span><br><span class=\"line\">\t\t:data(e),parent(pa),lChild(lc),rChild(rc) &#123;&#125;</span><br><span class=\"line\">\tint size() const ;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC( T const &amp; e ) //作为左孩子插入</span><br><span class=\"line\">\t&#123; return lChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC( T const &amp; e ) //作为右孩子插入</span><br><span class=\"line\">\t&#123; return rChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBinNode&lt;T&gt; * succ();   // 中序遍历时的直接后继</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit );  // 子树层级遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit );   // 子树先序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit );    // 子树中序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit );   // 子树后序遍历</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int BinNode&lt;T&gt;::size()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint s=1;</span><br><span class=\"line\">\tif(lChild)</span><br><span class=\"line\">\t\ts+=lChild-&gt;size();</span><br><span class=\"line\">\tif(rChild)</span><br><span class=\"line\">\t\ts+=rChild-&gt;size();</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。</p>\n<p>size函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。</p>\n<p><strong>树的基础定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint _size;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* _root;</span><br><span class=\"line\">\tvirtual int updateHeight( BinNode&lt;T&gt;* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）</span><br><span class=\"line\">\tvoid updateHeightAbove( BinNode&lt;T&gt;* x);  // 更新x及x的祖先的高度</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBinTree() &#123;_size=0; _root=NULL;&#125;</span><br><span class=\"line\">\t~BinTree() &#123; remove(_root); &#125;</span><br><span class=\"line\">\tBinTree( T const&amp; e) &#123;_size=1; _root=new BinNode&lt;T&gt; (e);&#125;</span><br><span class=\"line\">\tint size() const &#123;return _size;&#125;</span><br><span class=\"line\">\tbool empty() const &#123;return !_root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * root() const &#123;return _root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造右孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsLC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsRC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为右孩子</span><br><span class=\"line\">\tint remove( BinNode&lt;T&gt;* x );   // 删除某个结点（及其子树）</span><br><span class=\"line\">\tvoid removeAt( BinNode&lt;T&gt;* x );</span><br><span class=\"line\">\tBinTree&lt;T&gt; * secede( BinNode&lt;T&gt;* x );    // 分离子树，返回子树头</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit )  // 层级遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travLevel(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit )  // 先序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPre(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit )  // 中序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travIn(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit )   // 后序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPost(visit); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a><strong>遍历</strong></h2><p>定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次</p>\n<p><strong>遍历方式：</strong></p>\n<blockquote>\n<ol>\n<li>先序遍历( preorder )：中-&gt;左-&gt;右</li>\n<li>中序遍历( inorder )：左-&gt;中-&gt;右</li>\n<li>后序遍历( postorder )：左-&gt;右-&gt;中</li>\n<li>层次遍历：自上而下，自左而右</li>\n</ol>\n<p>先序中序后序原则：必定先左后右，根结点访问次序如名字所示</p>\n</blockquote>\n<h3 id=\"1-先序遍历-中-左-右\"><a href=\"#1-先序遍历-中-左-右\" class=\"headerlink\" title=\"1. 先序遍历( 中 左 右 )\"></a><strong>1. 先序遍历( 中 左 右 )</strong></h3><h4 id=\"1-递归版本\"><a href=\"#1-递归版本\" class=\"headerlink\" title=\"1. 递归版本\"></a><strong>1. 递归版本</strong></h4><p>根据先序遍历的定义，我们很容易写出递归版本的遍历函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V为函数模板类  visit是相应的函数对象</span><br><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_R( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisit(data);</span><br><span class=\"line\">\tif(lChild) lChild-&gt;travPre_R(visit);</span><br><span class=\"line\">\tif(rChild) rChild-&gt;travPre_R(visit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。</p>\n<p>因此如果能够将<strong>递归版</strong>改成<strong>迭代版</strong>，就能够提高很多效率。</p>\n<h4 id=\"2-迭代版本1\"><a href=\"#2-迭代版本1\" class=\"headerlink\" title=\"2. 迭代版本1\"></a><strong>2. 迭代版本1</strong></h4><p>因为在递归版本中，向左右子树的递归出现在最后，即是<strong>尾递归</strong>，那么我们只需要引入一个<strong>栈</strong>，把左右子树的递归改成将左右子树入栈即可。</p>\n<p>值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要<strong>先让右子树入栈，再让左子树入栈</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_V1( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack &lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tif(x) </span><br><span class=\"line\">\t\ts.push(x);</span><br><span class=\"line\">\twhile(!s.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tif(x-&gt;rChild) s.push(x-&gt;rChild); // 先入后出</span><br><span class=\"line\">\t\tif(x-&gt;lChild) s.push(x-&gt;lChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-迭代版本2\"><a href=\"#3-迭代版本2\" class=\"headerlink\" title=\"3. 迭代版本2\"></a><strong>3. 迭代版本2</strong></h4><p>看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。</p>\n<p>通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子-&gt;它父亲的右孩子-&gt;父亲的父亲的右孩子…-&gt;根结点的右孩子。</p>\n<p>于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG\" alt=\"左侧链示意图\"></p>\n<p>这样，我们就有了如下算法流程：</p>\n<p>1.访问该结点<br>2.将右孩子入栈<br>3.目光转向它的左孩子<br>若左孩子存在，回到步骤1<br>4.若栈不为空，取出栈顶元素，回到步骤1</p>\n<p>代码实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\t\tif(x-&gt;rChild) </span><br><span class=\"line\">\t\t\t\ts.push(x-&gt;rChild);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序遍历-左-中-右\"><a href=\"#2-中序遍历-左-中-右\" class=\"headerlink\" title=\"2. 中序遍历( 左 中 右 )\"></a><strong>2. 中序遍历( 左 中 右 )</strong></h3><h4 id=\"1-迭代版本1\"><a href=\"#1-迭代版本1\" class=\"headerlink\" title=\"1. 迭代版本1\"></a><strong>1. 迭代版本1</strong></h4><p>先来观察一下中序遍历的流程：</p>\n<p>每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。</p>\n<p>中序和先序不同在于：<strong>父结点不是立即被访问</strong>，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。</p>\n<p>那右结点怎么办呢？</p>\n<p>右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG\" alt=\"中序遍历\"></p>\n<p>算法的流程如下：</p>\n<p>1.将该结点入栈<br>2.转向该结点的左孩子<br>若左孩子存在，返回步骤1<br>3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子<br>若右孩子存在，返回步骤1<br>若右孩子不存在，重新开始步骤3</p>\n<p>现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ts.push(x);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(s.empty()) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;rChild;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本</p>\n<h4 id=\"2-迭代版本2\"><a href=\"#2-迭代版本2\" class=\"headerlink\" title=\"2. 迭代版本2\"></a><strong>2. 迭代版本2</strong></h4><p>当把二叉树横向伸展地足够开后，如下图所示<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim\" alt=\"中序遍历\"><br>从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序<br>左右规则如下:</p>\n<p>左子树左孩子&gt;左子树根结点&gt;左子树右孩子&gt;根结点&gt;右子树左孩子&gt;右子树根结点&gt;右子树右孩子</p>\n<p>根据这个规则，我们就可以得到每个结点在中序遍历时的<strong>直接后继</strong>，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)</p>\n<p>那么要怎么得到这个直接后继呢？<br>显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。<br>而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个<strong>结点是它父结点左孩子</strong>的结点，直接后继就是这个结点的父结点。<br>简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。</p>\n<p>将上述流程翻译成代码就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; *BinNode&lt;T&gt;::succ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* s=this;</span><br><span class=\"line\">\tif(rChild)   // 若有右孩子</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=rChild;</span><br><span class=\"line\">\t\twhile(s-&gt;lChild)   // 在右子树的左侧链一路到底</span><br><span class=\"line\">\t\t\ts=s-&gt;lChild;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile( s-&gt;parent &amp;&amp; s==s-&gt;parent-&gt;rChild )</span><br><span class=\"line\">\t\t\ts=s-&gt;parent;    // 此时是左子树的根结点</span><br><span class=\"line\">\t\ts=s-&gt;parent;   // 再向上到左子树的父亲结点(也可能是NULL)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_S(  V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\twhile(x-&gt;lChild)</span><br><span class=\"line\">\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;succ();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-后序遍历-左-右-中\"><a href=\"#3-后序遍历-左-右-中\" class=\"headerlink\" title=\"3. 后序遍历( 左 右 中 )\"></a><strong>3. 后序遍历( 左 右 中 )</strong></h3><p>基于后序遍历的定义，我们可以导出如下流程：<br>1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。<br>2.访问结点<br>3.若右兄弟存在，转向右兄弟，返回步骤1<br>4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程</p>\n<p>可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPost_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\tBinNode&lt;T&gt; * c=s.top();</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s.empty()) break;</span><br><span class=\"line\">\t\tif(s.top()!=x-&gt;parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tc=s.top();</span><br><span class=\"line\">\t\t\twhile(1)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(c-&gt;rChild) </span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;rChild);</span><br><span class=\"line\">\t\t\t\tif(c-&gt;lChild) </span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;lChild);</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;lChild;   // 尽可能向左走</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse if(c-&gt;rChild)  // 如果实在只有右孩子，那就向右</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;rChild;</span><br><span class=\"line\">\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-层次遍历\"><a href=\"#4-层次遍历\" class=\"headerlink\" title=\"4. 层次遍历\"></a><strong>4. 层次遍历</strong></h3><p>层次遍历的规则很简单：自上而下，自左而右</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim\" alt=\"层次遍历\"></p>\n<p>对此，我们可以引入<strong>队列</strong>来解决它。</p>\n<p>每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travLevel( V &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueue&lt;BinNode&lt;T&gt;*&gt; q;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tq.enqueue(x);</span><br><span class=\"line\">\twhile( !q.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=q.dequeue();</span><br><span class=\"line\">\t\tif(x-&gt;lChild)  q.enqueue(x-&gt;lChild);</span><br><span class=\"line\">\t\tif(x-&gt;rChild)  q.enqueue(x-&gt;rChild);</span><br><span class=\"line\">\t\te(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a><strong>重构</strong></h2><p>如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？</p>\n<h3 id=\"一-中序-先序-后序\"><a href=\"#一-中序-先序-后序\" class=\"headerlink\" title=\"一. 中序+(先序|后序)\"></a><strong>一. 中序+(先序|后序)</strong></h3><p>结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。</p>\n<p>现在我们来用数学归纳法证明一下：<br>假设结论在结点数n’&lt;’N的情况下都成立<br>在n==N时<br>先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。<br>那么在先序遍历和中序遍历中分别如下图所示：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG\" alt=\"重构二叉树\"></p>\n<p>可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。<br>这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’&lt;’N的左右子树中结论均成立，由此n==N时结论也成立。</p>\n<p>而有后续和中序遍历的序列的证明也同理可得了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先序+中序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PI( T* pre, T* ins, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_PI(pre,ins,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PI( T* pre, T* ins, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(pre); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PI( pre+1, ins, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 中序+后序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_IP( T* ins, T* post, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_IP(ins,post,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_IP( T* ins, T* post, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(* (post+len-1) );</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+len-1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*(post+len-1));</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_IP( ins, post, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-先序-后序-真二叉树\"><a href=\"#二-先序-后序-真二叉树\" class=\"headerlink\" title=\"二. (先序+后序)*真二叉树\"></a><strong>二. (先序+后序)*真二叉树</strong></h3><p>结论二：在只有先序和后序序列时，若是该二叉树是一棵<strong>真二叉树</strong>(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。</p>\n<p>那么要怎么做呢？</p>\n<p>在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。<br>在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。<br>这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG\" alt=\"重构二叉树\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PP( T *pre,T *post,int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=new BinNode&lt;T&gt; (pre[0]);</span><br><span class=\"line\">\trebuildSub_PP( _root,pre,post,len );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PP( T *pre , T *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif( len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PP(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的完整实现 ( 附带遍历和重构 )</a></p>\n<h1 id=\"二叉搜索树BST-Binary-Search-Tree\"><a href=\"#二叉搜索树BST-Binary-Search-Tree\" class=\"headerlink\" title=\"二叉搜索树BST ( Binary Search Tree )\"></a>二叉搜索树BST ( Binary Search Tree )</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"循关键码访问-call-by-key\"><a href=\"#循关键码访问-call-by-key\" class=\"headerlink\" title=\"循关键码访问 call-by-key\"></a>循关键码访问 call-by-key</h3><p>数据项之间，依照各自的关键码(key)彼此区分</p>\n<p>条件：关键码之间支持<strong>大小比较</strong>和<strong>相等比对</strong></p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 非空左子树所有键值小于根结点的键值</span><br><span class=\"line\">2. 非空右子树所有键值大于根结点的键值</span><br><span class=\"line\">3. 左右子树都是二叉搜索树</span><br></pre></td></tr></table></figure>\n<p>基本框架：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct TreeNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * left;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. BinTree Find( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找元素x,返回所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. BinTree FindMin(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最小元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. BinTree FindMax(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最大元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. BinTree Insert( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将元素x插入BST中，返回插入后的BST</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. BinTree Delete( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中删除元素x</p>\n</blockquote>\n<h3 id=\"查找操作：-Find\"><a href=\"#查找操作：-Find\" class=\"headerlink\" title=\"查找操作： Find\"></a>查找操作： Find</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 查找从根结点开始，若树为空则返回NULL</span><br><span class=\"line\">- 若树非空，则将根结点键值和x比较：</span><br><span class=\"line\">    - 若 x &lt; root.data ，在左子树中搜索</span><br><span class=\"line\">    - 若 x &gt; root.data ，在右子树中搜索</span><br><span class=\"line\">    - 若两者相等，则返回指向该结点的指针</span><br><span class=\"line\">- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式</span><br><span class=\"line\">- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**</span><br></pre></td></tr></table></figure>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Find(T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\treturn BST;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找最大和最小元素\"><a href=\"#查找最大和最小元素\" class=\"headerlink\" title=\"查找最大和最小元素\"></a>查找最大和最小元素</h3><p>根据二叉搜索树的性质：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 最大元素一定在树的最右分支的端结点上</span><br><span class=\"line\">- 最小元素一定在树的最左分支的端结点上</span><br></pre></td></tr></table></figure>\n<p>同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMax( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;right)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMin( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;left)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h3><p>关键：要找到元素应该插入的位置，可以采用和Find类似的方法</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Insert( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tBST = new TreeNode&lt;T&gt;();</span><br><span class=\"line\">\t\tBST-&gt;data=x;</span><br><span class=\"line\">\t\tBST-&gt;left=BST-&gt;right=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;left=Insert(x,BST-&gt;left);</span><br><span class=\"line\">\t\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;right=Insert(x,BST-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h3><p>考虑情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL</span><br><span class=\"line\">2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子</span><br><span class=\"line\">3. 要删除的结点有左右两棵子树</span><br><span class=\"line\">    用另一结点代替被删除结点：左子树最大元素或右子树最小元素</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Delete( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; *tmp;</span><br><span class=\"line\">\tif(!BST) return NULL;</span><br><span class=\"line\">\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;left=Delete(x,BST-&gt;left);</span><br><span class=\"line\">\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;right=Delete(x,BST-&gt;right);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(BST-&gt;left &amp;&amp; BST-&gt;right)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=FindMin(BST-&gt;right);</span><br><span class=\"line\">\t\t\tBST-&gt;data=tmp-&gt;data;</span><br><span class=\"line\">\t\t\tBST-&gt;right=delete(BST-&gt;data,BST-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=BST;</span><br><span class=\"line\">\t\t\tif(!BST-&gt;left)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\t\telse if(!BST-&gt;right)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\t\tdelete tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"平衡二叉树-AVL树-Balanced-Binary-Tree\"><a href=\"#平衡二叉树-AVL树-Balanced-Binary-Tree\" class=\"headerlink\" title=\"平衡二叉树 AVL树 (Balanced Binary Tree)\"></a>平衡二叉树 AVL树 (Balanced Binary Tree)</h1><p>定义：<br>空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|&lt;=1</p>\n<p><strong>平衡因子（BF:Balance Factor）</strong>: BF(T)=Hl - Hr<br>Hl和Hr分别为T的左右子树的高度</p>\n<p>推算高度为h的平衡二叉树最少结点数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高度为1时 h(1)=1;</span><br><span class=\"line\">高度为2时 h(2)=2;</span><br><span class=\"line\">高度为3时 h(3)=h(1)+h(2)+1=4;</span><br><span class=\"line\">...</span><br><span class=\"line\">高度为n时 h(n)=h(n-1)+h(n-2)+1;</span><br><span class=\"line\">原因：</span><br><span class=\"line\">    &gt; 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值&lt;=1</span><br><span class=\"line\">    &gt; 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )</span><br><span class=\"line\">由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$</span><br></pre></td></tr></table></figure>\n<p>结点数为n的平衡二叉树的最大高度为O(logn)</p>\n<h2 id=\"平衡二叉树的调整\"><a href=\"#平衡二叉树的调整\" class=\"headerlink\" title=\"平衡二叉树的调整\"></a>平衡二叉树的调整</h2><p><strong>核心思想：选择中间值作为根结点</strong></p>\n<p><strong>RR插入</strong>：插入结点在右子树的右边，需要RR旋转（右单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树根结点 &lt; 右子树的右边</p>\n<p>因此选取右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LL插入</strong>：插入结点在左子树的左边，需要LL旋转（左单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的左边 &lt; 左子树根结点 &lt; 根结点</p>\n<p>因此选取左子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LR插入</strong>：插入结点在左子树的右边，需要LR旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的根结点 &lt; 左子树的右边 &lt; 根结点</p>\n<p>因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>RL插入</strong>：插入结点在右子树的左边，需要RL旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树的左边 &lt; 右子树的根结点</p>\n<p>因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点</p>\n<h1 id=\"堆-heap\"><a href=\"#堆-heap\" class=\"headerlink\" title=\"堆 heap\"></a>堆 heap</h1><h2 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><strong>优先队列( Priority Queue )</strong><br>特殊的队列，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>的大小，而不是元素进入队列的先后顺序</p>\n<p>堆的特性：<br><strong>结构性</strong>：用数组表示的完全二叉树<br><strong>有序性</strong>：任一结点的关键字是其子树所有结点的最大值（或最小值）<br>从根结点到任意结点路径上结点序列的有序性<br>最大堆（MaxHeap）：根结点为最大值<br>最小堆（MinHeap）：根结点为最小值</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>数据对象集：完全二叉树</p>\n<p>接口：<br>MaxHeap Create( int Maxsize );<br>创建一个空的最大堆<br>Boolean IsFull( MaxHeap H );<br>判断最大堆H是否满<br>void Insert( MaxHeap H , T data );<br>将data插入最大堆H<br>Boolean IsEmpty( MaxHeap H );<br>判断最大堆H是否为空<br>T DeleteMax( MaxHeap H );<br>返回H中最大元素（高优先级）</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>思路：</p>\n<blockquote>\n<p>将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Insert( Heap&lt;T&gt;* h, T item)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tif( IsFull(h) ) // 若堆已满，则不做插入操作</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\ti = ++h-&gt;size;</span><br><span class=\"line\">\tfor( ; h-&gt;data[i/2]&lt;item ; i/=2 )</span><br><span class=\"line\">\t\th-&gt;data[i] = h-&gt;data[i/2];</span><br><span class=\"line\">\th-&gt;data[i] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>思路：</p>\n<blockquote>\n<p>取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Delete( Heap&lt;T&gt;* h , T item )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint parent , child;</span><br><span class=\"line\">\tT maxn,tem;</span><br><span class=\"line\">\tif( IsEmpty(h) ) </span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tmaxn = h-&gt;data[1];</span><br><span class=\"line\">\ttem = h-&gt;data[h-&gt;size--];</span><br><span class=\"line\">\tfor( parent=1 ; parent*2&lt;= h-&gt;size ; parent = child )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tchild = parent *2;</span><br><span class=\"line\">\t\tif( child != h-&gt;size  &amp;&amp; h-&gt;data[child]&lt;h.data[child+1])</span><br><span class=\"line\">\t\t\tchild++;   // 寻找左右孩子中较大的那个</span><br><span class=\"line\">\t\tif( tem&gt;= h-&gt;data[child] ) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\th-&gt;data[parent] = h-&gt;data[child];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\th-&gt;data[parent]=tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建立最大堆\"><a href=\"#建立最大堆\" class=\"headerlink\" title=\"建立最大堆\"></a>建立最大堆</h3><p>将已经存在的N个元素按最大堆的要求存放在一个一维数组</p>\n<p>方法1：<br>通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)</p>\n<p>方法2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. n个元素按输入顺序存入，先满足完全二叉树</span><br><span class=\"line\">2. 调整各结点位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><p>自底向上调整</p>\n<p>从倒数第二行的结点开始自右向左调整</p>\n<p>而后再到倒数第三行、倒数第四行…直到根结点</p>\n<p>这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可</p>\n<p>这样就只需要O(n)的时间即可完成建堆</p>\n<h1 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h1><p>带权路径长度（WPL）<br>设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk</p>\n<p>哈夫曼树（最优二叉树）：WPL值最小的二叉树</p>\n<h2 id=\"哈夫曼树的构造\"><a href=\"#哈夫曼树的构造\" class=\"headerlink\" title=\"哈夫曼树的构造\"></a>哈夫曼树的构造</h2><p>每次把<strong>权值最小</strong>的两棵二叉树合并</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 没有度为1的结点</span><br><span class=\"line\">2. n个叶子结点的哈夫曼树有2n-1个结点</span><br><span class=\"line\">    设 n0: 叶子结点总数</span><br><span class=\"line\">    设 n1: 只有一个儿子的结点总数</span><br><span class=\"line\">    设 n2: 有2个儿子的结点总数</span><br><span class=\"line\">    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1</span><br><span class=\"line\">3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树</span><br><span class=\"line\">4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）</span><br></pre></td></tr></table></figure>\n<h2 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少</span><br><span class=\"line\"></span><br><span class=\"line\">避免二义性：</span><br><span class=\"line\">    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</span><br><span class=\"line\"></span><br><span class=\"line\">利用二叉树进行编码：</span><br><span class=\"line\">    1. 左右分支：0、1</span><br><span class=\"line\">    2. 字符只在叶结点上</span><br><span class=\"line\"></span><br><span class=\"line\">构造方法：根据字符的权值构造哈夫曼树</span><br></pre></td></tr></table></figure>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">集合运算：交、并、补、差、判定一个元素是否属于某个集合</span><br><span class=\"line\">并查集：集合并、查某元素属于什么集合</span><br><span class=\"line\">并查集实现：</span><br><span class=\"line\">    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）</span><br><span class=\"line\">    2. 利用数组存储，两个一维数组分别存储数据和父亲下标</span><br></pre></td></tr></table></figure>\n<p>利用数组存储的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint parent;</span><br><span class=\"line\">\tNode( T d , int parent = -1 ):data(d)&#123;&#125;</span><br><span class=\"line\">\tNode()&#123;parent=-1;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标</p>\n<h2 id=\"查找当前结点所属集合\"><a href=\"#查找当前结点所属集合\" class=\"headerlink\" title=\"查找当前结点所属集合\"></a>查找当前结点所属集合</h2><p>思路：<br>首先在数组中找到目标结点<br>而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );   // 在数组中寻找值为x的结点</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;    // 没找到，返回-1</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );  // 顺着父结点指针一路向上找</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>通过<strong>路径压缩</strong>，每次查找时把沿途所有节点的parent都设为根节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;</span><br><span class=\"line\">\tint tem=i,tem1=s[tem].parent;</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );</span><br><span class=\"line\">\twhile( tem1!=-1 &amp;&amp; tem1!=i )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts[tem].parent = i;</span><br><span class=\"line\">\t\ttem=tem1;</span><br><span class=\"line\">\t\ttem1=s[tem].parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合的并运算\"><a href=\"#集合的并运算\" class=\"headerlink\" title=\"集合的并运算\"></a>集合的并运算</h2><p>思路：<br>首先分别找到两个元素所在的集合树的根结点<br>若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t\ts[root2].parent = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>为了改善合并后的查找效率，把小的集合并入大的集合<br>方法1：每个结点额外维护一个值：以该结点为根的结点总数<br>缺点：只有根节点才需要用到该值，造成大量空间浪费<br>方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union1( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s[root1].parent&lt;s[root2].parent )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root1].parent += s[root2].parent;</span><br><span class=\"line\">\t\t\ts[root2].parent = root1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root2].parent += s[root1].parent;</span><br><span class=\"line\">\t\t\ts[root1].parent = root2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"刷题选集（一）","date":"2017-08-17T16:00:00.000Z","comments":1,"_content":"\n## 目录\n\n第一个选集，选的比较基础比较水，主要是思维+细节\n\n\n### 贪心\n\nSDUT 2072 删数问题\nSDUT 2072 活动选择\n\n### 栈\n\nSDUT 3334 出栈序列判定\nSDUT 2132 后缀表达式转换\n\n### 动态规划\n\n最大子列和\n最大子列和及区间\n\n<!-- more -->\n\n## 贪心\n\n### 删数问题\n\n[SDUT 2072 删数问题](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072)\n\n题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小\n\n思维+细节题\n\n思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符\n\n细节：\n1.可能有前导0， 比如 9023 删掉1个数字后 -> 023 -> 23\n解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true\n2.可能剩下全是0，比如 9002 删掉2个数字后 -> 00 -> 0\n解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行\n3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n// 解题代码丑了些，见谅\nint main()\n{\n\tchar s[110];\n\tint n;\n\twhile(cin>>s>>n)\n\t{\n\t\tint l=strlen(s);\n\t\ts[l]=0;\n\t\tif(n>=l)\n\t\t{\t\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint c;\n\t\t\tfor(int j=0; j<l; j++)\n\t\t\t{\t\n\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);\n\t\t\t\tif(s[j]>c)\n\t\t\t\t{\t\n\t\t\t\t\ts[j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint firstzero=0;\n\t\tfor(int i=0; i<l; i++)\n\t\t{\t\n\t\t\tif(s[i]=='0'&&firstzero==0)\n\t\t\t\ts[i]=0;\n\t\t\tif(s[i])\n\t\t\t{\t\n\t\t\t\tfirstzero=1;\n\t\t\t\tprintf(\"%c\",s[i]);\n\t\t\t}\n\t\t}\n\t\tif(firstzero)\n\t\t\tprintf(\"\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n}\n```\n\n### 活动选择\n\n[SDUT 2072 活动选择](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html)\n\n题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。\n\n贪心题\n\n思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动\n若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。\n若后一个活动的开始时间早于当前活动，则无视，扫下一个。\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct aaa\n{\n\tint l,r;\n}a[110];\n\nbool com(aaa a1, aaa a2)\n{\n\tif(a1.r==a2.r)\n\t\treturn a1.l>a2.l;\n\treturn a1.r<a2.r;\n}\n\nint main()\n{\n\tint n;\nwhile(~scanf(\"%d\",&n))\n{\n\tmemset(a,0,sizeof(a));\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d%d\",&a[i].l,&a[i].r);\n\tsort(a,a+n,com);\n\tint nowend=a[0].r,ans=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tif(a[i].l<nowend)\n\t\t\tcontinue;\n\t\tnowend=a[i].r;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\treturn 0;\n}\n```\n\n## 栈\n\n### 栈混洗\n\n[SDUT 3334 出栈序列判定](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html)\n\n题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。\n\n栈混洗 ( 贪心 )\n\n思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint a[10010];\nint stack[10010];\nint tem[10010];\nint m=0;\nint n;\nint t;\n\nbool check ()\n{\n\tint j=0,i=0;\n\twhile(i<n&&m<n)\n\t{\n\t\tstack[m++]=a[j++];\n\t\twhile( m-1>=0 && stack[m-1]==tem[i])\n\t\t{\n\t\t\tm--;\n\t\t\ti++;\n\t\t}\n\t}\n\tif(m>0)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tm=0;\n\t\tfor(int i=0; i<n; i++)\n\t\t\tscanf(\"%d\",&tem[i]);\n\t\tif(check()==true)\n\t\t\tprintf(\"yes\\n\");\n\t\telse\n\t\t\tprintf(\"no\\n\");\n\t}\n\t\treturn 0;\n\t}\n```\n\n### 后缀表达式转换\n\n[SDUT 2132 一般算术表达式转换成后缀式](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html)\n\n题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。\n\n和[数据结构笔记（二）：栈和队列](https://zedom1.github.io/2017/08/14/stack/) 中的逆波兰表达式转换方法类似但要简单的多。\n\n1.运算符基于二元 ( “ +-*/ ()# “ )\n2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换\n3.表达式以#号结尾\n\n鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。\n\n思想是一样的，用两个栈分别保存答案和运算符。\n遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。\n\n优先级设置：\n左括号最大，但不碰到右括号不出栈\n右括号和#最小并且不入栈\n同级运算符如+和-比较时栈顶的大\n\n细节：\n左右括号和#出运算符栈后不进入答案栈\n两个#号看作一对括号，在开始人为加入一个#号和最后的配对\n\n最后答案栈保存的是要输出答案的**逆序**，但若用数组模拟的话就可以直接从头输出到尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tchar s[1000];  // 输入表达式\n\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶\n\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶\n\tint l=0;   // 记录输入表达式的长度\n\top[m++]='#';   // 栈底加入一个#用来和最后的#配对\n\twhile(scanf(\"%c\",&s[l])&&s[l++]!='#');\n\tfor(int i=0; i<l; i++)\n\t{\n\t\tif(s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!='/'&&s[i]!='('&&s[i]!=')'&&s[i]!='#')    // 该字符为变量\n\t\t{\t\n\t\t\tans[ansm++]=s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(s[i])\n\t\t{\n\t\tcase '+': \n\t\tcase '-':\n\t\t\t{\n\t\t\t\tif(op[m-1]=='('||op[m-1]=='#')\n\t\t\t\t{\t\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tcase '*': case '/': case '(':\n\t\t\t{\n\t\t\t\top[m++]=s[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase ')':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='(')  // 把左右括号之间的都依次入答案栈\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;  // 左括号出栈\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '#':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='#')\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<ansm; i++)\n\t\tprintf(\"%c\",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n## 动态规划\n\n### 最大子列和\n\n题意：给定n个数的序列，求其中和最大的连续子列\n\n网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法\n\n思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now,maxn;\n\tint tem;\n\tscanf(\"%d\",&tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况\n\tnow=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tnow=max(0,now);\n\t\tscanf(\"%d\",&tem);\n\t\tnow+=tem;\n\t\tmaxn=max(maxn,now);\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n```\n\n### 最大子列和及区间\n\n我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？\n\n在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last\n\n思路：\n\n```\n每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。\n\n一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last\n\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now=0,maxn=0;\n\tint tem;\n\tint first,last,ansfirst;\n\tscanf(\"%d\",&tem);\n\tfirst=last=ansfirst=now=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&tem);\n\t\tif(now<0)\n\t\t{ \n\t\t\tnow=0;\n\t\t\tfirst=tem;\n\t\t}\n\t\tnow+=tem;\n\t\tif(now>maxn)\n\t\t{\n\t\t\tlast=tem;\n\t\t\tmaxn=now;\n\t\t\tansfirst=first;\n\t\t}\n\t}\n\tprintf(\"%d %d %d\\n\",maxn,ansfirst,last);\n\treturn 0;\n}\n```","source":"_posts/ProblemSet1.md","raw":"---\nlayout: post\ntitle: \"刷题选集（一）\"\ndate: 2017-08-18\ncomments: true\ntags: \n\t- c++\n\t- 刷题\n---\n\n## 目录\n\n第一个选集，选的比较基础比较水，主要是思维+细节\n\n\n### 贪心\n\nSDUT 2072 删数问题\nSDUT 2072 活动选择\n\n### 栈\n\nSDUT 3334 出栈序列判定\nSDUT 2132 后缀表达式转换\n\n### 动态规划\n\n最大子列和\n最大子列和及区间\n\n<!-- more -->\n\n## 贪心\n\n### 删数问题\n\n[SDUT 2072 删数问题](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072)\n\n题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小\n\n思维+细节题\n\n思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符\n\n细节：\n1.可能有前导0， 比如 9023 删掉1个数字后 -> 023 -> 23\n解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true\n2.可能剩下全是0，比如 9002 删掉2个数字后 -> 00 -> 0\n解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行\n3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n// 解题代码丑了些，见谅\nint main()\n{\n\tchar s[110];\n\tint n;\n\twhile(cin>>s>>n)\n\t{\n\t\tint l=strlen(s);\n\t\ts[l]=0;\n\t\tif(n>=l)\n\t\t{\t\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint c;\n\t\t\tfor(int j=0; j<l; j++)\n\t\t\t{\t\n\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);\n\t\t\t\tif(s[j]>c)\n\t\t\t\t{\t\n\t\t\t\t\ts[j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint firstzero=0;\n\t\tfor(int i=0; i<l; i++)\n\t\t{\t\n\t\t\tif(s[i]=='0'&&firstzero==0)\n\t\t\t\ts[i]=0;\n\t\t\tif(s[i])\n\t\t\t{\t\n\t\t\t\tfirstzero=1;\n\t\t\t\tprintf(\"%c\",s[i]);\n\t\t\t}\n\t\t}\n\t\tif(firstzero)\n\t\t\tprintf(\"\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n}\n```\n\n### 活动选择\n\n[SDUT 2072 活动选择](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html)\n\n题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。\n\n贪心题\n\n思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动\n若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。\n若后一个活动的开始时间早于当前活动，则无视，扫下一个。\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct aaa\n{\n\tint l,r;\n}a[110];\n\nbool com(aaa a1, aaa a2)\n{\n\tif(a1.r==a2.r)\n\t\treturn a1.l>a2.l;\n\treturn a1.r<a2.r;\n}\n\nint main()\n{\n\tint n;\nwhile(~scanf(\"%d\",&n))\n{\n\tmemset(a,0,sizeof(a));\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d%d\",&a[i].l,&a[i].r);\n\tsort(a,a+n,com);\n\tint nowend=a[0].r,ans=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tif(a[i].l<nowend)\n\t\t\tcontinue;\n\t\tnowend=a[i].r;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\treturn 0;\n}\n```\n\n## 栈\n\n### 栈混洗\n\n[SDUT 3334 出栈序列判定](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html)\n\n题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。\n\n栈混洗 ( 贪心 )\n\n思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint a[10010];\nint stack[10010];\nint tem[10010];\nint m=0;\nint n;\nint t;\n\nbool check ()\n{\n\tint j=0,i=0;\n\twhile(i<n&&m<n)\n\t{\n\t\tstack[m++]=a[j++];\n\t\twhile( m-1>=0 && stack[m-1]==tem[i])\n\t\t{\n\t\t\tm--;\n\t\t\ti++;\n\t\t}\n\t}\n\tif(m>0)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tm=0;\n\t\tfor(int i=0; i<n; i++)\n\t\t\tscanf(\"%d\",&tem[i]);\n\t\tif(check()==true)\n\t\t\tprintf(\"yes\\n\");\n\t\telse\n\t\t\tprintf(\"no\\n\");\n\t}\n\t\treturn 0;\n\t}\n```\n\n### 后缀表达式转换\n\n[SDUT 2132 一般算术表达式转换成后缀式](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html)\n\n题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。\n\n和[数据结构笔记（二）：栈和队列](https://zedom1.github.io/2017/08/14/stack/) 中的逆波兰表达式转换方法类似但要简单的多。\n\n1.运算符基于二元 ( “ +-*/ ()# “ )\n2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换\n3.表达式以#号结尾\n\n鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。\n\n思想是一样的，用两个栈分别保存答案和运算符。\n遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。\n\n优先级设置：\n左括号最大，但不碰到右括号不出栈\n右括号和#最小并且不入栈\n同级运算符如+和-比较时栈顶的大\n\n细节：\n左右括号和#出运算符栈后不进入答案栈\n两个#号看作一对括号，在开始人为加入一个#号和最后的配对\n\n最后答案栈保存的是要输出答案的**逆序**，但若用数组模拟的话就可以直接从头输出到尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tchar s[1000];  // 输入表达式\n\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶\n\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶\n\tint l=0;   // 记录输入表达式的长度\n\top[m++]='#';   // 栈底加入一个#用来和最后的#配对\n\twhile(scanf(\"%c\",&s[l])&&s[l++]!='#');\n\tfor(int i=0; i<l; i++)\n\t{\n\t\tif(s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!='/'&&s[i]!='('&&s[i]!=')'&&s[i]!='#')    // 该字符为变量\n\t\t{\t\n\t\t\tans[ansm++]=s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(s[i])\n\t\t{\n\t\tcase '+': \n\t\tcase '-':\n\t\t\t{\n\t\t\t\tif(op[m-1]=='('||op[m-1]=='#')\n\t\t\t\t{\t\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tcase '*': case '/': case '(':\n\t\t\t{\n\t\t\t\top[m++]=s[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase ')':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='(')  // 把左右括号之间的都依次入答案栈\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;  // 左括号出栈\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '#':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='#')\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<ansm; i++)\n\t\tprintf(\"%c\",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n## 动态规划\n\n### 最大子列和\n\n题意：给定n个数的序列，求其中和最大的连续子列\n\n网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法\n\n思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now,maxn;\n\tint tem;\n\tscanf(\"%d\",&tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况\n\tnow=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tnow=max(0,now);\n\t\tscanf(\"%d\",&tem);\n\t\tnow+=tem;\n\t\tmaxn=max(maxn,now);\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n```\n\n### 最大子列和及区间\n\n我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？\n\n在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last\n\n思路：\n\n```\n每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。\n\n一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last\n\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now=0,maxn=0;\n\tint tem;\n\tint first,last,ansfirst;\n\tscanf(\"%d\",&tem);\n\tfirst=last=ansfirst=now=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&tem);\n\t\tif(now<0)\n\t\t{ \n\t\t\tnow=0;\n\t\t\tfirst=tem;\n\t\t}\n\t\tnow+=tem;\n\t\tif(now>maxn)\n\t\t{\n\t\t\tlast=tem;\n\t\t\tmaxn=now;\n\t\t\tansfirst=first;\n\t\t}\n\t}\n\tprintf(\"%d %d %d\\n\",maxn,ansfirst,last);\n\treturn 0;\n}\n```","slug":"ProblemSet1","published":1,"updated":"2018-05-25T12:41:12.572Z","photos":[],"link":"","_id":"cjleshqjf000fryfcohsjg34z","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>第一个选集，选的比较基础比较水，主要是思维+细节</p>\n<h3 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h3><p>SDUT 2072 删数问题<br>SDUT 2072 活动选择</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>SDUT 3334 出栈序列判定<br>SDUT 2132 后缀表达式转换</p>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>最大子列和<br>最大子列和及区间</p>\n<a id=\"more\"></a>\n<h2 id=\"贪心-1\"><a href=\"#贪心-1\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><h3 id=\"删数问题\"><a href=\"#删数问题\" class=\"headerlink\" title=\"删数问题\"></a>删数问题</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072\" target=\"_blank\" rel=\"noopener\">SDUT 2072 删数问题</a></p>\n<p>题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小</p>\n<p>思维+细节题</p>\n<p>思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符</p>\n<p>细节：<br>1.可能有前导0， 比如 9023 删掉1个数字后 -&gt; 023 -&gt; 23<br>解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true<br>2.可能剩下全是0，比如 9002 删掉2个数字后 -&gt; 00 -&gt; 0<br>解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行<br>3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">// 解题代码丑了些，见谅</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[110];</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\twhile(cin&gt;&gt;s&gt;&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint l=strlen(s);</span><br><span class=\"line\">\t\ts[l]=0;</span><br><span class=\"line\">\t\tif(n&gt;=l)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tint c;</span><br><span class=\"line\">\t\t\tfor(int j=0; j&lt;l; j++)</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);</span><br><span class=\"line\">\t\t\t\tif(s[j]&gt;c)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\ts[j]=0;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint firstzero=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif(s[i]==&apos;0&apos;&amp;&amp;firstzero==0)</span><br><span class=\"line\">\t\t\t\ts[i]=0;</span><br><span class=\"line\">\t\t\tif(s[i])</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfirstzero=1;</span><br><span class=\"line\">\t\t\t\tprintf(&quot;%c&quot;,s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(firstzero)</span><br><span class=\"line\">\t\t\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"活动选择\"><a href=\"#活动选择\" class=\"headerlink\" title=\"活动选择\"></a>活动选择</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html\" target=\"_blank\" rel=\"noopener\">SDUT 2072 活动选择</a></p>\n<p>题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。</p>\n<p>贪心题</p>\n<p>思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动<br>若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。<br>若后一个活动的开始时间早于当前活动，则无视，扫下一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">struct aaa</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint l,r;</span><br><span class=\"line\">&#125;a[110];</span><br><span class=\"line\"></span><br><span class=\"line\">bool com(aaa a1, aaa a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(a1.r==a2.r)</span><br><span class=\"line\">\t\treturn a1.l&gt;a2.l;</span><br><span class=\"line\">\treturn a1.r&lt;a2.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(a,0,sizeof(a));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class=\"line\">\tsort(a,a+n,com);</span><br><span class=\"line\">\tint nowend=a[0].r,ans=1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(a[i].l&lt;nowend)</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tnowend=a[i].r;</span><br><span class=\"line\">\t\tans++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"栈混洗\"><a href=\"#栈混洗\" class=\"headerlink\" title=\"栈混洗\"></a>栈混洗</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html\" target=\"_blank\" rel=\"noopener\">SDUT 3334 出栈序列判定</a></p>\n<p>题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。</p>\n<p>栈混洗 ( 贪心 )</p>\n<p>思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int a[10010];</span><br><span class=\"line\">int stack[10010];</span><br><span class=\"line\">int tem[10010];</span><br><span class=\"line\">int m=0;</span><br><span class=\"line\">int n;</span><br><span class=\"line\">int t;</span><br><span class=\"line\"></span><br><span class=\"line\">bool check ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j=0,i=0;</span><br><span class=\"line\">\twhile(i&lt;n&amp;&amp;m&lt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack[m++]=a[j++];</span><br><span class=\"line\">\t\twhile( m-1&gt;=0 &amp;&amp; stack[m-1]==tem[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tm--;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(m&gt;0)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;t);</span><br><span class=\"line\">\twhile(t--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tm=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;tem[i]);</span><br><span class=\"line\">\t\tif(check()==true)</span><br><span class=\"line\">\t\t\tprintf(&quot;yes\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;no\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀表达式转换\"><a href=\"#后缀表达式转换\" class=\"headerlink\" title=\"后缀表达式转换\"></a>后缀表达式转换</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html\" target=\"_blank\" rel=\"noopener\">SDUT 2132 一般算术表达式转换成后缀式</a></p>\n<p>题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。</p>\n<p>和<a href=\"https://zedom1.github.io/2017/08/14/stack/\">数据结构笔记（二）：栈和队列</a> 中的逆波兰表达式转换方法类似但要简单的多。</p>\n<p>1.运算符基于二元 ( “ +-*/ ()# “ )<br>2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换<br>3.表达式以#号结尾</p>\n<p>鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。</p>\n<p>思想是一样的，用两个栈分别保存答案和运算符。<br>遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。</p>\n<p>优先级设置：<br>左括号最大，但不碰到右括号不出栈<br>右括号和#最小并且不入栈<br>同级运算符如+和-比较时栈顶的大</p>\n<p>细节：<br>左右括号和#出运算符栈后不进入答案栈<br>两个#号看作一对括号，在开始人为加入一个#号和最后的配对</p>\n<p>最后答案栈保存的是要输出答案的<strong>逆序</strong>，但若用数组模拟的话就可以直接从头输出到尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[1000];  // 输入表达式</span><br><span class=\"line\">\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶</span><br><span class=\"line\">\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶</span><br><span class=\"line\">\tint l=0;   // 记录输入表达式的长度</span><br><span class=\"line\">\top[m++]=&apos;#&apos;;   // 栈底加入一个#用来和最后的#配对</span><br><span class=\"line\">\twhile(scanf(&quot;%c&quot;,&amp;s[l])&amp;&amp;s[l++]!=&apos;#&apos;);</span><br><span class=\"line\">\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s[i]!=&apos;+&apos;&amp;&amp;s[i]!=&apos;-&apos;&amp;&amp;s[i]!=&apos;*&apos;&amp;&amp;s[i]!=&apos;/&apos;&amp;&amp;s[i]!=&apos;(&apos;&amp;&amp;s[i]!=&apos;)&apos;&amp;&amp;s[i]!=&apos;#&apos;)    // 该字符为变量</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tans[ansm++]=s[i];</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tswitch(s[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\tcase &apos;+&apos;: </span><br><span class=\"line\">\t\tcase &apos;-&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(op[m-1]==&apos;(&apos;||op[m-1]==&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;*&apos;: case &apos;/&apos;: case &apos;(&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;)&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;(&apos;)  // 把左右括号之间的都依次入答案栈</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;  // 左括号出栈</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;#&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i=0; i&lt;ansm; i++)</span><br><span class=\"line\">\t\tprintf(&quot;%c&quot;,ans[i]);</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"最大子列和\"><a href=\"#最大子列和\" class=\"headerlink\" title=\"最大子列和\"></a>最大子列和</h3><p>题意：给定n个数的序列，求其中和最大的连续子列</p>\n<p>网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法</p>\n<p>思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now,maxn;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况</span><br><span class=\"line\">\tnow=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnow=max(0,now);</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tmaxn=max(maxn,now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,maxn);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大子列和及区间\"><a href=\"#最大子列和及区间\" class=\"headerlink\" title=\"最大子列和及区间\"></a>最大子列和及区间</h3><p>我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？</p>\n<p>在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。</span><br><span class=\"line\"></span><br><span class=\"line\">一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now=0,maxn=0;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tint first,last,ansfirst;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\tfirst=last=ansfirst=now=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tif(now&lt;0)</span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tnow=0;</span><br><span class=\"line\">\t\t\tfirst=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tif(now&gt;maxn)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlast=tem;</span><br><span class=\"line\">\t\t\tmaxn=now;</span><br><span class=\"line\">\t\t\tansfirst=first;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d %d %d\\n&quot;,maxn,ansfirst,last);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>第一个选集，选的比较基础比较水，主要是思维+细节</p>\n<h3 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h3><p>SDUT 2072 删数问题<br>SDUT 2072 活动选择</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>SDUT 3334 出栈序列判定<br>SDUT 2132 后缀表达式转换</p>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>最大子列和<br>最大子列和及区间</p>","more":"<h2 id=\"贪心-1\"><a href=\"#贪心-1\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><h3 id=\"删数问题\"><a href=\"#删数问题\" class=\"headerlink\" title=\"删数问题\"></a>删数问题</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072\" target=\"_blank\" rel=\"noopener\">SDUT 2072 删数问题</a></p>\n<p>题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小</p>\n<p>思维+细节题</p>\n<p>思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符</p>\n<p>细节：<br>1.可能有前导0， 比如 9023 删掉1个数字后 -&gt; 023 -&gt; 23<br>解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true<br>2.可能剩下全是0，比如 9002 删掉2个数字后 -&gt; 00 -&gt; 0<br>解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行<br>3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">// 解题代码丑了些，见谅</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[110];</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\twhile(cin&gt;&gt;s&gt;&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint l=strlen(s);</span><br><span class=\"line\">\t\ts[l]=0;</span><br><span class=\"line\">\t\tif(n&gt;=l)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tint c;</span><br><span class=\"line\">\t\t\tfor(int j=0; j&lt;l; j++)</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);</span><br><span class=\"line\">\t\t\t\tif(s[j]&gt;c)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\ts[j]=0;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint firstzero=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif(s[i]==&apos;0&apos;&amp;&amp;firstzero==0)</span><br><span class=\"line\">\t\t\t\ts[i]=0;</span><br><span class=\"line\">\t\t\tif(s[i])</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfirstzero=1;</span><br><span class=\"line\">\t\t\t\tprintf(&quot;%c&quot;,s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(firstzero)</span><br><span class=\"line\">\t\t\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"活动选择\"><a href=\"#活动选择\" class=\"headerlink\" title=\"活动选择\"></a>活动选择</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html\" target=\"_blank\" rel=\"noopener\">SDUT 2072 活动选择</a></p>\n<p>题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。</p>\n<p>贪心题</p>\n<p>思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动<br>若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。<br>若后一个活动的开始时间早于当前活动，则无视，扫下一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">struct aaa</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint l,r;</span><br><span class=\"line\">&#125;a[110];</span><br><span class=\"line\"></span><br><span class=\"line\">bool com(aaa a1, aaa a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(a1.r==a2.r)</span><br><span class=\"line\">\t\treturn a1.l&gt;a2.l;</span><br><span class=\"line\">\treturn a1.r&lt;a2.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(a,0,sizeof(a));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class=\"line\">\tsort(a,a+n,com);</span><br><span class=\"line\">\tint nowend=a[0].r,ans=1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(a[i].l&lt;nowend)</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tnowend=a[i].r;</span><br><span class=\"line\">\t\tans++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"栈混洗\"><a href=\"#栈混洗\" class=\"headerlink\" title=\"栈混洗\"></a>栈混洗</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html\" target=\"_blank\" rel=\"noopener\">SDUT 3334 出栈序列判定</a></p>\n<p>题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。</p>\n<p>栈混洗 ( 贪心 )</p>\n<p>思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int a[10010];</span><br><span class=\"line\">int stack[10010];</span><br><span class=\"line\">int tem[10010];</span><br><span class=\"line\">int m=0;</span><br><span class=\"line\">int n;</span><br><span class=\"line\">int t;</span><br><span class=\"line\"></span><br><span class=\"line\">bool check ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j=0,i=0;</span><br><span class=\"line\">\twhile(i&lt;n&amp;&amp;m&lt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack[m++]=a[j++];</span><br><span class=\"line\">\t\twhile( m-1&gt;=0 &amp;&amp; stack[m-1]==tem[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tm--;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(m&gt;0)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;t);</span><br><span class=\"line\">\twhile(t--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tm=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;tem[i]);</span><br><span class=\"line\">\t\tif(check()==true)</span><br><span class=\"line\">\t\t\tprintf(&quot;yes\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;no\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀表达式转换\"><a href=\"#后缀表达式转换\" class=\"headerlink\" title=\"后缀表达式转换\"></a>后缀表达式转换</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html\" target=\"_blank\" rel=\"noopener\">SDUT 2132 一般算术表达式转换成后缀式</a></p>\n<p>题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。</p>\n<p>和<a href=\"https://zedom1.github.io/2017/08/14/stack/\">数据结构笔记（二）：栈和队列</a> 中的逆波兰表达式转换方法类似但要简单的多。</p>\n<p>1.运算符基于二元 ( “ +-*/ ()# “ )<br>2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换<br>3.表达式以#号结尾</p>\n<p>鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。</p>\n<p>思想是一样的，用两个栈分别保存答案和运算符。<br>遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。</p>\n<p>优先级设置：<br>左括号最大，但不碰到右括号不出栈<br>右括号和#最小并且不入栈<br>同级运算符如+和-比较时栈顶的大</p>\n<p>细节：<br>左右括号和#出运算符栈后不进入答案栈<br>两个#号看作一对括号，在开始人为加入一个#号和最后的配对</p>\n<p>最后答案栈保存的是要输出答案的<strong>逆序</strong>，但若用数组模拟的话就可以直接从头输出到尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[1000];  // 输入表达式</span><br><span class=\"line\">\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶</span><br><span class=\"line\">\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶</span><br><span class=\"line\">\tint l=0;   // 记录输入表达式的长度</span><br><span class=\"line\">\top[m++]=&apos;#&apos;;   // 栈底加入一个#用来和最后的#配对</span><br><span class=\"line\">\twhile(scanf(&quot;%c&quot;,&amp;s[l])&amp;&amp;s[l++]!=&apos;#&apos;);</span><br><span class=\"line\">\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s[i]!=&apos;+&apos;&amp;&amp;s[i]!=&apos;-&apos;&amp;&amp;s[i]!=&apos;*&apos;&amp;&amp;s[i]!=&apos;/&apos;&amp;&amp;s[i]!=&apos;(&apos;&amp;&amp;s[i]!=&apos;)&apos;&amp;&amp;s[i]!=&apos;#&apos;)    // 该字符为变量</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tans[ansm++]=s[i];</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tswitch(s[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\tcase &apos;+&apos;: </span><br><span class=\"line\">\t\tcase &apos;-&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(op[m-1]==&apos;(&apos;||op[m-1]==&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;*&apos;: case &apos;/&apos;: case &apos;(&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;)&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;(&apos;)  // 把左右括号之间的都依次入答案栈</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;  // 左括号出栈</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;#&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i=0; i&lt;ansm; i++)</span><br><span class=\"line\">\t\tprintf(&quot;%c&quot;,ans[i]);</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"最大子列和\"><a href=\"#最大子列和\" class=\"headerlink\" title=\"最大子列和\"></a>最大子列和</h3><p>题意：给定n个数的序列，求其中和最大的连续子列</p>\n<p>网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法</p>\n<p>思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now,maxn;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况</span><br><span class=\"line\">\tnow=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnow=max(0,now);</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tmaxn=max(maxn,now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,maxn);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大子列和及区间\"><a href=\"#最大子列和及区间\" class=\"headerlink\" title=\"最大子列和及区间\"></a>最大子列和及区间</h3><p>我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？</p>\n<p>在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。</span><br><span class=\"line\"></span><br><span class=\"line\">一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now=0,maxn=0;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tint first,last,ansfirst;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\tfirst=last=ansfirst=now=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tif(now&lt;0)</span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tnow=0;</span><br><span class=\"line\">\t\t\tfirst=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tif(now&gt;maxn)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlast=tem;</span><br><span class=\"line\">\t\t\tmaxn=now;</span><br><span class=\"line\">\t\t\tansfirst=first;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d %d %d\\n&quot;,maxn,ansfirst,last);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"JAVA笔记：基础篇","date":"2017-09-10T16:00:00.000Z","comments":1,"_content":"\n\n## 概述\n\nJAVA学习过程中的简要笔记\n\n从已有C++基础的前提下开始学习java\n\n内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等\n\n<!-- more -->\n\n### 各版本和体系架构\n\n- J2EE\n  - JAVA 2(to) Enterprise Edition:\n  - 定位在服务器端的应用\n- J2SE\n  - JAVA 2(to) Standard Edition:\n  - 定位在个人计算机的应用\n- J2EE\n  - JAVA 2(to) Micro Edition:\n  - 定位在消费性电子产品的应用\n\n### 概念\n\n```\n- JDK\n    - Java Development Kit Java开发工具包\n- JRE\n    - Java Runtime Environment java运行环境\n- JVM\n    - Java Virtual Machine java虚拟机\n\n```\n\n### 数据类型\n\n![数据类型](http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG)\n\n### 整型变量\n\n```\n- 表示形式\n    - 十进制\n    - 八进制：以0开头\n    - 十六进制：以0x或0X开头\n\n```\n\n整型默认为int型，long型常量后加”l”或”L”\n\n| 类型    | 占用空间 | 表示范围             |\n| ----- | ---- | ---------------- |\n| byte  | 1字节  | -128~127         |\n| short | 2字节  | -$2^15$~$2^15-1$ |\n| int   | 4字节  | -$2^31$~$2^31-1$ |\n| long  | 8字节  | -$2^63$~$2^63-1$ |\n\n- 超过long的数字使用**BigInteger**类\n\n### 浮点型\n\n| 类型     | 占用空间 | 表示范围                 |\n| ------ | ---- | -------------------- |\n| float  | 4字节  | -3.403E38~3.403E38   |\n| double | 8字节  | -1.798E308~1.798E308 |\n\n- 默认为double\n- 若需要不产生舍入误差的精确计算，需要用**BigDecimal**类\n- double变float：在数字后加”f”或”F”\n\n### 字符型\n\n- char采用Unicode编码表，，占用2个字节\n- 同c++,可以和整数相互转型，可以使用转义字符\n\n### boolean\n\n- 占1位(非字节)\n- java中boolean无法和整数之间转换\n\n### 变量\n\n```\n- 变量使用前需要声明\n\n```\n\n#### final\n\n类似c++的const\n\n```\n- final修饰变量，则该变量无法修改\n- final修饰类，则说明该类不能被继承，不能有子类\n    - 如 Math、String\n- final修饰方法，则该方法不能被子类重写，但是可以被重载\n\n```\n\n**命名规范**：\n\n- 变量、方法名：\n  - 首字母小写+驼峰原则\n- 常量：\n  - 大写字母+下划线\n- 类名：\n  - 首字母大写+驼峰原则\n\n### 运算符\n\n```\n- 算术运算符： +,-,*,/,%,++,--\n    - 不同于c++, java中浮点数可以使用\"%\"运算符！\n    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串\n- 赋值运算符： =\n- 关系运算符： <,>,<=,>=,==,!=, instanceof\n    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）\n        - 返回值：boolean  true代表属于\n        - 使用： boolean ret= a instanceof A;\n- 逻辑运算符： &&,||,!\n    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算\n- 位运算符： &,|,^,~,>>,<<,>>>\n    - >> 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃\n        - 01110>>1 右移一位： 00111\n        - 10010>>1 右移一位： 11001\n    - >>> 表示无符号右移：左边以0补充，移出的部分将抛弃\n        - 01110>>>1 右移一位：00111   (正数时和\">>\"相同)\n        - 10010>>>1 右移一位：01001\n    - << 没有 \"<<<\"\n- 条件运算符：  ?:\n- 扩展赋值运算符： +=,-=,*=,/=,%=\n\n```\n\n### switch语句\n\n- 在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型\n- JDK7之后，switch表达式结果还可以是字符串\n- 使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句\n\n```\nswitch(a)\n{\n\tcase 1: break;\n\tcase 2: System.out.println(1);\n\tdefault: break;\n}\n```\n\n### 语句\n\n- if,while语句同c++\n- while中可以使用break,continue关键字\n- goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break\n- 可以使用带标签的continue和break\n  - 带标签的continue：跳转继续执行标签指向的循环\n  - 带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）\n\n### 方法 method，function\n\n[修饰符1 修饰符2..] 返回值 方法名(形参列表){\n语句\n}\n\n```\n- **Java中只有值传递！**\n- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身\n    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值\n\n```\n\n### 内存分析\n\n```\n- 栈\n    - 存放：局部变量\n    - 自动分配连续的空间\n- 堆\n    - 存放new出来的对象\n    - 空间不连续\n- 方法区\n    - 包含于堆区\n    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等\n\n```\n\n```\nclass Teacher{\n\tString name;\n\tint age;\n\tvoid teach() {}\n}\n\npublic class Student {\n\tString name;\n\tint age;\n\t\n\tvoid study() {}\n\t\n\tpublic static void main(String[] args){\n\t\tStudent st1=new Student();\n\t\tStudent st2=new Student();\n\t\tst1.age=18;\n\t\tst1.name=\"张三\";\n\t\tst2.age=30;\n\t\tst2.name=\"李四\";\n\t\t\n\t\tTeacher t1=new Teacher();\n\t\tt1.age=30;\n\t\tt1.name=\"李四\";\n\t}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG)\n\n## 包 package\n\n定义：Java的类库管理机制，借助文件系统的目录\n\n- 为什么需要使用Package\n\n  - 为了解决类的重名问题\n  - 为了便于管理类：合适的类位于合适的包\n\n- 怎么使用package\n\n  - 通常是类的第一句非注释性语句\n\n    - 规则：通常域名倒过来写，加上模块名\n\n      > com.qq.test\n\n一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字\n\n包名称内可以带有”.”，每个”.”代表文件系统的下一级目录\n\n如\n\n```\npackage p1;\npackage p1.s1;\n```\n\n则在文件系统中，p1文件夹下有个名为s1的文件夹包\n\n### 使用其它包里的类:\n\n1 . 使用**import**预先声明\n\n```\nimport package1.T;  // 引入package1包里的T\nimport package2.*   // 引入package2包里的所有类\npublic class T2\n{\n\tprivate T t1;\n}\n```\n\n2 . 每次使用时附带说明包的名\n\n```\npublic class T2\n{\n\tprivate package1.T t1;\n}\n```\n\n## API文档\n\n使用**JAVADOC**生成API文档\n\n```\n- 解决代码文档分离的问题\n\n```\n\n- 特殊的注释\n  - 文档注释： “/**”\n- 常用的java注释标签\n  - @Author 作者\n  - @version 版本\n  - @param 参数\n  - @return 返回值含义\n  - @throws 抛出异常描述\n  - @deprecated 废弃，建议用户不再使用该方法\n\n```\n/**\n * 类的描述、功能\n * @author aa\n * @version 1.0\n */\n```\n\n### 垃圾回收机制 (Garbage Collection)\n\n```\n- 对象空间的分配\n    - 使用\"new\"关键字创建对象\n- 对象空间的释放：\n    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间\n- 要点：\n    - 程序员无权调用垃圾回收器\n    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行\n    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用\n\n```\n\n## 数组\n\n### 定义数组变量\n\n1 - <类型>[]<数组名>=new <类型>[元素个数];\n\n> 例如：\n>\n> int [] grade = new int [100];\n>\n> 这样创建的数组会是默认的0值\n\n2 - <类型>[]<数组名>={元素1，元素2…};\n\n> 例如： int []a={1,2,3};\n\n3 - <类型>[]b = a; (a为同类型的数组)\n\n> 与c++中数组名的含义类似，数组名变量管理数组空间\n>\n> b和a管理同一个数组\n\n### 特点：\n\n1 - 所有元素的数据类型相同\n2 - 一旦创建则不能改变大小\n\n### 要求：\n\n- 元素个数必须是整数\n- 元素个数必须给出\n- 元素个数可以是变量\n\n### 内部成员：\n\nlength : 返回元素个数\n\n> for(int i=0; i<grade.length ; ++i)\n\n### 数组和数组变量：\n\n- 数组变量为数组的管理者，而非其本身\n- 数组创建出来后交给数组变量管理\n- 数组变量之间的赋值为管理权限的赋予\n- 数组变量的比较是判断是否管理同一个数组\n\n### 常用操作：\n\n1. 数组复制\n   System的arraycopy函数\n\n   ```\n   public static void arraycopy(Object src,\n                                int srcPos,\n                                Object dest,\n                                int destPos,\n                                int length)\n   // src 源数组\n   // srcPos 源数组开始复制的位置\n   // dest 目标数组\n   // destPos 目标数组开始复制的位置\n   // length 复制长度\n   // [srcPos,srcPos+length-1)\n   ```\n\n2. 二分查找\n   Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口\n   Arrays.binarySearch(Object obj, Object goal);\n\n3. 填充\n   Arrays.fill(Object obj, int start, int end, Object goal)\n   将目标数组[start,end)填充为goal\n\n### for-each循环：\n\n例如：for( int k: data )\n\n对于data数组的每一个元素，循环每一轮取一个元素作为k\n\n第一轮 k=data[0] , 第二轮 k=data[1]\n\n**for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值**\n\n## 包裹类型\n\n- 每种基础类型都有对应的包裹类型\n- 出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象\n\n| 基础类型    | 包裹类型      |\n| ------- | --------- |\n| boolean | Boolean   |\n| char    | Character |\n| int     | Integer   |\n| double  | Double    |\n\n### 用处：\n\n- 声明变量时包裹类型同基础类型\n\n> int a=1; <=> Integer a=1;\n\n- 可以获取该类型的信息，如最大值最小值\n\n> 如 System.out.println(Integer.MAX_VALUE);\n>\n> ( Integer.MAX_VALUE=2147483647 )\n\n- Character\n\n| 函数声明                           | 参数      | 用途            |\n| ------------------------------ | ------- | ------------- |\n| static boolean isDigit         | char ch | 判断该字符是否是数字    |\n| static boolean isLetter        | char ch | 判断该字符是否是字母    |\n| static boolean isLetterOrDigit | char ch | 判断该字符是否是数字或字母 |\n| static boolean isLowerCase     | char ch | 判断该字符是否是小写字母  |\n| static boolean isUpperCase     | char ch | 判断该字符是否是大写字母  |\n| static boolean isWhitespace    | char ch | 判断该字符是否是一种空格  |\n| static char toLowerCase        | char ch | 把该字符转换成小写     |\n| static char toUpperCase        | char ch | 把该字符转换成大写     |\n\n**转换仅体现在返回值，原变量的值没有改变**\n\n#### 自动装箱和自动拆箱 auto-boxing & unboxing\n\n- 自动装箱\n  - 基本类型自动封装到和它相同类型的包装里\n  - 本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);\n- 自动拆箱\n  - 包装类对象自动转换成基本数据类型\n  - 本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();\n\n#### **缓存处理**\n\n```\n-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）\n\n```\n\n```\nInteger d1=1234;\nInteger d2=1234;\n\nSystem.out.println(d1==d2);\nSystem.out.println(d1.equals(d2));\n\nInteger d3=123;\nInteger d4=123;\n\nSystem.out.println(d3==d4);\nSystem.out.println(d3.equals(d4));\n```\n\n结果：\n\n> false (d1==d2)\n> true (d1.equals(d2))\n> true (d3==d4)\n> true (d3.equals(d4))\n\n## 字符串 String\n\n- String是一个类，String变量是对象的管理者而非所有者\n\n### 创建：\n\n1 - String s = new String(“hello world”);\n\n2 - String s = “hello”;\n\n### 字符串连接\n\n- 用 “+” 连接两个字符串\n\n> “hello “+”world” -> “hello world”\n\n- 若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接\n\n> “I am “+18 -> “I am 18”\n>\n> 1+2+”age” -> “3age”\n>\n> “age”+1+2 -> “age12”\n\n### 字符串输入\n\n- in.next();\n  读入一个单词，以空格结束\n- in.nextLine();\n  读入一整行\n\n### 字符串比较\n\n- 用 “==” ：比较两个对象是同一个字符串\n\n> if(input == “hello”)\n\n- 用 “.equals” ：比较两个字符串的内容是否相同\n\n> if(input.equals(“hello”))\n\n### 字符串操作\n\n- 字符串是**对象**，所有操作是通过“.”进行的\n- 表示对“.”左边的字符串做右边的操作\n- 字符串可以是**变量**也可以是**常量**\n\n### 常用操作\n\n**所有操作都不会对字符串本身进行修改**\n\n- s1.compareTo(String s2)\n\n> 比较两个字符串大小\n>\n> s1>s2 返回正数\n>\n> s1<s2 返回负数\n>\n> s1和s2内容相同，返回0\n>\n> 字符串长者大\n>\n> 字符串长度相同时，从第一位开始以字典序比较\n\n- s1.length()\n\n> 获得String的长度\n\n- s1.charAt(int index)\n\n> 访问String里的字符\n>\n> 返回index上的单个字符\n>\n> 0<=index<=s1.length()-1\n>\n> **不能用for-each循环遍历字符串**\n\n- s1.substring(int begin ,int end)\n\n> 获得 s1 下标于[begin,end)的子串\n>\n> end可省略，默认为s1.length()\n\n- s1.indexOf( (char)|(String) c, int n)\n\n> 寻找c字符或字符串第一个所在位置，-1为不存在\n>\n> 从n开始找(包括n)，n可以省略，默认为0\n>\n> s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()\n>\n> 寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);\n\n- s1.startsWith( String s2)\n\n> 判断s1的前缀是否为s2\n\n- s1.endsWith( String s2)\n\n> 判断s1的后缀是否为s2\n\n- s1.trim()\n\n> 清除s1左右两端的空格\n>\n> 要保留清除可以 s1=s1.trim();\n\n- s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)\n\n> 将s1中所有字符或字符串c1替换成c2\n\n- s1.toLowerCase() s1.toUpperCase()\n\n> s1大小写切换\n\n- s1.split(char a)\n\n> 以a作为分隔符分割字符串s1，将结果作为字符串数组返回\n>\n> String [] s= s1.split(“ “);\n>\n> 多种分隔符用”|”分割，(“a”|”b”)\n>\n> 以”.””|”作为分隔符时要加”\\\\“，即(\\\\.)(\\\\|)\n\n### StringBuilder 和 StringBuffer\n\nStringBuilder：线程不安全，效率高\nStringBuffer：线程安全，效率低\n两者基本相同\n\nString无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。\n\n用StringBuffer/StringBuilder能够很好解决string的扩展问题\n\n- StringBuilder sb= new StringBuilder();\n\n- sb.append(“1”);\n\n  > 扩展字符串\n  > 其返回值为StringBuilder,因此可以连续调用\n  >\n  > ```\n  > // JDK源码\n  > @Override\n  > public StringBuilder append(String str) {\n  >     super.append(str);\n  >     return this;\n  > }\n  >\n  > // 因此可以使用\n  > sb.append(\"1\").append(\"2\");\n  > ```\n\n- sb.toString();\n\n  > 将StringBuilder形成字符串，可作为函数的String返回值\n\n- sb.delete(int start , int end);\n\n  > 删除下标为[start,end)的字符\n\n- sb.reverse();\n\n  > 反转sb\n\n#### 容量机制\n\n```\n- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）\n- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度\n- 扩容为当前容量*2+2\n\n```\n\n## 类\n\n### 创建对象\n\n对象变量是对象的**管理者**\n\n- T tem = new T();\n\n### 成员变量\n\n- 定义：类内部的变量\n- 特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数\n- 若没有初始化，则会自动被赋值(0)\n- 初始化\n  - 定义时就可以给出初始值\n  - 对象变量的0值表示没有管理任何对象，也可以主动给null值\n  - 定义初始化可以调用函数，可以使用已经定义的成员变量\n\n```\npublic class T\n{\n\tint a=1;\n\tint b=f();\n\tint f() {return 1;}\n}\n```\n\n### 构造函数\n\n- 名字和类名字完全相同，创建对象时会自动调用\n- 没有返回值\n- 调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句\n\n### 函数重载\n\n- 定义：同名但参数列表不同的函数\n- 可以有多个构造函数，但参数列表要不同\n- 构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次\n\n```\npublic class T\n{\n\tint a=1;\n\tT() {a=2;}\n\tT(int a)\n\t{\n\t\tthis();\n\t\tthis.a=a;\n\t}\n}\n```\n\n若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1->2->3，调用过程为：T(int a)->T()->int a=1;->执行T()->执行T(int a)\n\n### 访问属性\n\n- public (同c++)\n- private (同c++)\n- protected (同c++)\n- friendly\n\n#### public\n\n- 任何人都可以直接使用\n  - 任何函数或定义初始化中可以使用\n  - 使用是指调用、访问、定义变量\n- public类必须定义在自己的文件里\n- 一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)\n\n#### private\n\n- 只有类的内部能够访问\n  - 类的成员函数\n  - 定义初始化\n- 限制是针对类而非对象\n  - 对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)\n\n#### friendly\n\n- 未加private或public声明的成员 (即**默认值**)\n- 属于同一个包内的所有类都可以访问\n\n### System.out.println\n\n正常情况下，调用System.out.println直接输出类的对象，则会输出其地址\n\n若是在类中包含 public String toString 函数，则在println时自动调用该函数\n\n```\npublic class T{\n\tint c;\n\tpublic String toString () {return \"\"+c;}\n}\n```\n\n## 常用类\n\n### 时间处理：\n\n#### java.util.Date\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG)\n\n- 对象表示一个特定的瞬间，精确到毫秒\n- 时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long\n\n#### DateFormat, SimpleDateFormat\n\njava.text.*\n\n- 用来将字符串和时间相互转换\n- DateFormat 是抽象类，无法实例化对象\n- SimpleDateFormat非抽象类\n\n使用方法（详见API文档）\n\n1. 已知毫秒转相应时间和字符串\n\n   ```\n   DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日hh时mm分ss秒\");\n   DateFormat df1 = new SimpleDateFormat(\"yy-MM-dd hh:mm:ss\");\n   Date d = new Date(1321454564);\n   String str=df1.format(d);\n   System.out.println(str);\n   ```\n\n2. 已知字符串及输入格式转毫秒数\n\n   ```\n   String str2 = \"1977-07-07\";\n   DateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\n   try {\n   \tDate d2 = df2.parse(str2);\n   \tSystem.out.println(d2);\n   } catch (ParseException e) {\n   \t// TODO Auto-generated catch block\n   \te.printStackTrace();\n   }\n   ```\n\n#### Calendar，GregorianCalendar 日历类\n\njava.util.*\n\n- Calendar是抽象类，无法实例化对象\n- GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统\n- Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期\n- 注意\n  - 月份：1月是0，2月是1，…12月是11\n    - 星期：周日是1，周一是2…周六是7\n    - 可以使用 Calendar.FEBRUARY 表示数字\n\n使用方法：（详见API文档）\n\n1. 整体设置\n\n   ```\n   Calendar c = new GregorianCalendar();\n   c.set(2001, Calendar.FEBRUARY ,15);\n   Date date = c.getTime();\n   ```\n\n2. 单独设置\n\n   ```\n   c.set(Calendar.YEAR , 2001);\n   c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);\n   // 未设置参数则自动采用当前时间 (日期、时分秒等)\n   System.out.println(c.get(Calendar.YEAR));\n   ```\n\n3. 用Date赋值\n\n   ```\n   c.setTime(new Date());\n   ```\n\n4. 日期计算\n\n   ```\n   c.add(Calendar.YEAR, 30);\n   ```\n\n### File 类\n\njava.io.File:文件和目录路径名的抽象表现形式\n\n```\n- 通过File对象可以访问、修改文件属性\n- 可以创建空文件或目录\n\n```\n\n```\nFile f = new File(\"d:/aaa/bbb/ccc\");\nf.mkdir();  // 若父目录存在则创建\nf.mkdirs(); // 若父目录不存在则自动创建父目录\n```\n\n## 容器\n\n- 容器类的两个类型：\n\n  1 . 容器的类型\n\n  2 . 元素的类型\n\n### ArrayList\n\n- import java.util.ArrayList;\n\n- 特点：元素可以相同，元素以与进入的顺序排序\n\n- 基础类型：存放值\n\n- 非基础类型：作为管理者，存放地址\n\n- 定义：\n\n  ArrayList notes = new ArrayList();\n\n#### 常用操作\n\n- notes.add(int location, String s);\n\n> 向下标为location的位置中插入元素\n>\n> location可省略，默认为末尾\n\n- notes.size();\n\n> 返回容器中存放元素数目\n\n- notes.get(int index);\n\n> 返回下标为Index的元素\n\n- nodes.remove(int index);\n\n> 移除下标为Index的元素\n\n- notes.toArray(String []a);\n\n> 将notes里所有元素依次填入a中\n\n#### for-each循环\n\n若ArrayList存放的非基础类型，则for-each中可以修改值\n\n### Set\n\n- import java.util.HashSet\n- 特点：元素均不相同，不排序，与进入的顺序无关\n\n### Hash表(散列表)\n\n- import java.util.HashMap;\n- HashMap < Key, Value > a=new HashMap < Key,Value > ();\n  数据以一对值放进去，一个为键(KEY),一个为值(value)\n  值对应键\n- 键不能重复，只留相同的最后一个，元素不以先后排序\n\n#### 常用操作\n\n- a.put(Key k1, Value v1);\n\n> 向HashMap里添加元素，键k1对应值为v1\n\n- a.get(Key k);\n\n> 返回键k对应的值，若为空，则返回null\n\n- a.containsKey(Key k);\n\n> 查询是否存在键为k的数据\n\n- a.keySet();\n\n> 返回key的集合\n>\n> 可以通过 a.keySet().size()获取存放的键的数目\n>\n> 通过keySet使用for-each循环\n\n## 继承\n\n- extends\n\n  ```\n  public class son extends parent\n  ```\n\n- **java只允许单继承，一个类只能有一个父类**\n\n| 父类成员访问属性  | 在父类中的含义           | 在子类中的含义                   |                    |\n| --------- | ----------------- | ------------------------- | ------------------ |\n| public    | 对所有人开放            | 对所有人开放                    |                    |\n| protected | 只有包内其它类、自己和子类可以访问 | 只有包内其它类、自己和子类可以访问         |                    |\n| 缺省        | 只有包内其它类可以访问       | 如果子类与父类在同一个包内：只有包内其它类可以访问 | 否则：相当于private，不能访问 |\n| private   | 只有自己可以访问          | 不能访问                      |                    |\n\n子类同样继承了父类的private成员，只是子类无法访问！\n但子类可以通过调用父类的非private函数来间接修改父类的private成员变量\n\n### 继承VS组合\n\n- “is-a”关系使用继承\n  - 如：Bird类继承自Animal类\n- “has-a”关系使用组合\n  - 如：Computer类包含CPU类，每个Computer对象都有一个CPU对象\n\n### super\n\n本质：一个**关键字**，类似this(this的本质为指针),是直接父类的引用\n\n用法\n1 . 直接引用\n\n相当于指向当前对象的父类，用”.”访问父类的成员\n\n2 . 子类成员变量或方法与父类同名时，用super加以区分\n\n```\nclass son extends parent{\n\tvoid a();\n\tvoid b(){\n\t\ta();   // son的a函数\n\t\tsuper.a();  // parent的a函数\n\t}\n}\n```\n\n3 . 调用父类的构造函数\n\n规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数\n\n子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译\n\n```\nclass son extends parent{\n\tint a;\n\tson(int a1){\n\t\tsuper(a1);\n\t}\n}\n```\n\n### 同名变量\n\n若没有明确指明，则在谁的成员函数中就使用谁的成员变量\n\n### 子类和子类型\n\n- 类定义了类型\n- 子类定义了子类型 (son是parent的一个子类型)\n- 子类对象可以被当做父类的对象使用\n  - 赋值给父类变量\n  - 传递给需要父类对象的函数\n  - 放进存放分类对象的容器里\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG)\n\n```\nVehicle v1 = new Vehicle();\nVehicle v2 = new Car();\nVehicle v3 = new Bicycle();\n```\n\n## 多态\n\n主要用来实现**动态联编**\n\n即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了\n\n以此提高系统的灵活性和扩展性\n\n### 如何实现多态\n\n```\n- 引用变量的两种类型\n\n    - 编译时类型（一般是父类）\n        - 由声明时的类型决定\n\n    - 运行时类型（运行时具体的子类）\n        - 由实际对应的对象类型决定\n\n- 三个必要条件\n    - 要有继承\n    - 要有方法重写\n    - 父类引用指向子类对象\n\n```\n\n### 多态变量\n\n- 对象变量能够保存不止一种的对象\n- 可以保存声明类型的对象或是声明类型的子类的对象\n- 子类对象赋给父类变量，发生**向上造型**\n\n### 造型 cast\n\n造型(cast)：把一个类型的对象赋值给另一个类型的变量\n\n- 子类对象可以复制给父类变量\n  - 与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象\n- 父类对象不能赋值给子类变量\n- 可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行\n- 类型转换 ！= 造型\n  - 类型转换中对象发生改变，如 int i=(int)10.2;\n  - 造型中对象本身没有改变，只是改变了看待它的方式\n\n```\nVehicle v;\nCar car = new Car();\nv=car;  //可以\nc=v;   //编译错误\nc=(Car)v // 编译通过\n\n若\nVehicle v=new Vehicle();\nCar car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常\n```\n\n#### 向上造型\n\n- 子类对象当做父类对象使用\n- 向上造型是默认的，不需要运算符\n- 向上造型是安全的\n\n### 绑定\n\n同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数\n\n- 静态绑定：根据变量声明类型决定\n- 动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )\n- 默认使用动态绑定\n- 成员函数中调用其它成员函数通过this变量调用\n\n### 覆盖 override\n\n- 覆盖关系：子类和父类中存在名称和参数表完全相同的函数\n- 通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数\n\n### Object类\n\n- 所有的类都继承自Object类\n- 几乎所有OOP都有Object类（除c++）\n\n#### Object类的函数(部分)\n\n- toString()\n- equals()\n\n### 多态的内存分析\n\n1 . 基本的继承关系和方法调用\n\n```\n- 父类：Animal  有voice方法\n- 子类：Cat 重写voice方法，自己有catchMouse方法\n- 测试：分别声明父类和子类变量并指向子类对象\n\n```\n\n```\npublic class Test{\n\t\n\tpublic static void showVoice(Animal c) {\n\t\tc.voice();\n\t\tif(c instanceof Cat)\n\t\t\t((Cat) c).catchMouse();\n\t}\n\tpublic static void main(String[] args) {\n\t\tAnimal a=new Cat();\n\t\tCat cat=(Cat)a;\n\t\tTest.showVoice(cat);\n\t\tTest.showVoice(a);\n\t}\n}\n\nclass Animal{\n\tString name;\n\tint age;\n\tvoid voice() {}\n}\n\nclass Cat extends Animal{\n\tvoid voice() {\n\t\tSystem.out.println(\"miao\");\n\t};\n\tvoid catchMouse() {}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG)\n\n2 . 深化多态\n\n```\n- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法\n- 子类：MyServlet 重写了doGet方法\n- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本\n\n```\n\n```\npublic class HttpServlet {\n\tpublic void service() {\n\t\tSystem.out.println(\"HttpServlet.service()\");\n\t\tdoGet();\n\t}\n\tpublic void doGet() {\n\t\tSystem.out.println(\"HttpServlet.doGet()\");\n\t}\n}\n\n\npublic class MyServlet extends HttpServlet {\n\tpublic void doGet() {\n\t\tSystem.out.println(\"MyServlet.doGet()\");\n\t}\n}\n\npublic class Test{\n\t\n\tpublic static void main(String[] args) {\n\t\tHttpServlet s = new MyServlet();\n\t\ts.service();\n\t}\n}\n// 输出结果：\n// HttpServlet.service()\n// MyServlet.doGet()\n```\n\n原因分析：\n函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG)\n\n## 设计原则\n\n### 消除代码复制\n\n- 代码复制是不良设计的一种表现\n\n  解决方法：使用函数封装重复的代码\n\n### 增加可扩展性\n\n- 后期的可维护性\n\n  解决方法：用封装降低耦合，用接口实现聚合，借助类继承\n\n  耦合：类和类之间的关系\n\n  耦合越低越好\n\n## 抽象和接口\n\n关键词：**abstract** (抽象)\n\n> public abstract class a\n\n- 抽象函数：表达概念而**无法实现具体代码**的函数\n- 抽象类：表达概念而**无法构造出实体**的类\n- 为什么需要抽象类\n  - **模板模式**，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展\n  - **通过抽象类，可以避免子类设计的随意性**，严格限制子类的设计，使得子类之间更加通用。\n- 抽象方法的意义：**使方法的设计和实现分离！**\n- 要点：\n  - 有抽象函数的类一定是抽象类\n    - 抽象类**不能制造对象**，但可以定义变量\n  - 任何继承了抽象类的非抽象类对象可以赋值给抽象类变量\n  - 抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用\n  - 继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类\n\n### 接口\n\n关键词：**interface**\n\n> public interface a{}\n\n- 接口是纯抽象类(接口中只有常量、抽象方法)\n- 所有成员变量都是public abstract static final （默认的，可以不写）\n- 接口意义：设计和实现分离，利于大项目制作\n- 接口变量的含义为任何实现了接口的对象\n\n关键词：**implements**\n\n> public class b implements a{}\n\n- 类可以实现很多接口\n- 接口可以继承接口，不能继承类\n- 接口不能实现接口\n- 接口和抽象类\n  - 接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了**规范和具体实现的分离**\n  - **接口就是规范，定义了一组规则**\n  - **接口的本质是契约**，制定好后大家都遵守\n  - 项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要**面向接口编程**\n\n#### 面向接口的编程方式\n\n- 设计程序时先定义接口，再实现类\n- 任何需要在函数间传入传出的一定是接口而不是具体的类\n- Java成功的关键之一，极适合多人同时写一个大程序\n- Java被批评的要点之一，代码量膨胀地很快\n\n## 控制反转与MVC模式\n\n### Swing\n\n容器、部件\n\n- 容器继承自部件，因此可以作为部件被放入其它容器中\n\n- 容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整\n\n- JFrame使用BorderLayout管理部件，并且将界面划分为五个区域\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG)\n\n- 容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件\n\n### 控制反转\n\n- 按钮公布一个listener接口和一对注册、注销函数\n- 实现接口后将把listener对象注册在按钮上\n- 一旦按钮被按下，就会反过来调用listener对象的函数\n\n### 内部类 innerclasses\n\n定义在别的类内部、函数内部的类\n\n#### 作用：\n\n```\n- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问\n- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性\n\n```\n\n#### 使用场合\n\n在内部类只为所在外部类提供服务的情况优先使用\n\n#### 分类：\n\n##### 成员内部类\n\n（可以使用private,public,protected修饰）\n\n###### 非静态内部类\n\n`- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();`\n\n```\npublic class Outer {\n\tpublic static void main(String[] args) {\n\t\tFace f=new Face();\n\t\tFace.Nose n= f.new Nose();\n\t}\n}\n\nclass Face {\n\tint type;\n\t\n\tclass Nose{\n\t\tString type;\n\t\t\n\t\tvoid breath() {\n\t\t\tFace.this.type=1;\n\t\t}\n\t\t\n\t}\n}\n```\n\n###### 静态内部类\n\n```\n- 要点：\n    - 静态内部类对象存在时，不一定存在对应的外部类对象\n    - 静态内部类无法直接访问外部类实例方法\n    - 静态内部类看作**外部类的一个静态成员**\n\n```\n\n```\nFace f= new Face();\n// Nose为非静态内部类\nFace.Nose n=f.new Nose();\n// Ear为静态内部类\nFace.Ear e=new Face.Ear();\n```\n\n###### 局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\n\n```\n- 访问函数的本地变量时只能访问函数的final变量\n\n```\n\n##### 匿名内部类\n\n适用于只需要使用一次的类，例如：键盘监听操作等\n\n```\nnew 父类构造器(实参) 实现接口(){\n\t匿名内部类类体\n}\n```\n\n- 匿名类可以继承某类，也可以实现接口\n- Swing的消息机制广泛使用匿名类\n\n### MVC设计模式\n\n- 数据、表现和控制\n\n  三者分离\n\n  - M = Model 模型\n  - V = View 表现\n  - C = Control 控制\n\n- 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新\n\n- 表现：从模型获取数据，根据数据画出表现\n\n- 控制：从用户得到输入，根据输入调整数据\n\n### 异常机制 Exception\n\n#### 常见的异常\n\n```\n用户输入错误\n设备错误\n硬件问题：如打印机关掉、服务器问题\n磁盘满了\n\n```\n\n#### 异常Exception\n\n```\nJava提供的用来处理程序中错误的一种机制\n\nJava采用**面向对象** 方式来处理异常。处理过程：\n    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE\n    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置\n\n```\n\n#### 常见异常\n\n```\n1. ArithmeticException\n    例如试图除以0\n2. NullPointerException\n    对象为null但调用了对象的方法或属性\n3. ClassCastException\n    转型错误，解决：使用istanceof判断\n4. ArrayIndexOutOfBoundsException\n    访问元素超出数组长度\n5. NumberFormatException\n    数字格式异常，如把String转换成int\n\n```\n\n#### 异常的处理方法：\n\n`捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常`\n\n#### 方法重写中声明异常原则：\n\n```\n**子类声明的异常范围不能超出父类的范围**\n    - 父类没有声明异常，子类也不能\n    - 不能抛出 原有方法抛出的父类或上层类\n    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）\n\n```\n\n#### 自定义异常\n\n```\n- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类\n- 从Exception类或它的子类派生一个子类\n- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器\n\n建议：\n    - 避免使用异常机制代替错误处理\n    - 处理异常不能代替简单测试\n    - 不要进行**小力度**的异常处理（如一行一个try catch）\n    - 异常往往在**高层**处理\n\n```","source":"_posts/Java_note1.md","raw":"---\nlayout: post\ntitle: \"JAVA笔记：基础篇\"\ndate: 2017-09-11\ncomments: true\ntags: \n  - 学习笔记\n  - JAVA\n---\n\n\n## 概述\n\nJAVA学习过程中的简要笔记\n\n从已有C++基础的前提下开始学习java\n\n内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等\n\n<!-- more -->\n\n### 各版本和体系架构\n\n- J2EE\n  - JAVA 2(to) Enterprise Edition:\n  - 定位在服务器端的应用\n- J2SE\n  - JAVA 2(to) Standard Edition:\n  - 定位在个人计算机的应用\n- J2EE\n  - JAVA 2(to) Micro Edition:\n  - 定位在消费性电子产品的应用\n\n### 概念\n\n```\n- JDK\n    - Java Development Kit Java开发工具包\n- JRE\n    - Java Runtime Environment java运行环境\n- JVM\n    - Java Virtual Machine java虚拟机\n\n```\n\n### 数据类型\n\n![数据类型](http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG)\n\n### 整型变量\n\n```\n- 表示形式\n    - 十进制\n    - 八进制：以0开头\n    - 十六进制：以0x或0X开头\n\n```\n\n整型默认为int型，long型常量后加”l”或”L”\n\n| 类型    | 占用空间 | 表示范围             |\n| ----- | ---- | ---------------- |\n| byte  | 1字节  | -128~127         |\n| short | 2字节  | -$2^15$~$2^15-1$ |\n| int   | 4字节  | -$2^31$~$2^31-1$ |\n| long  | 8字节  | -$2^63$~$2^63-1$ |\n\n- 超过long的数字使用**BigInteger**类\n\n### 浮点型\n\n| 类型     | 占用空间 | 表示范围                 |\n| ------ | ---- | -------------------- |\n| float  | 4字节  | -3.403E38~3.403E38   |\n| double | 8字节  | -1.798E308~1.798E308 |\n\n- 默认为double\n- 若需要不产生舍入误差的精确计算，需要用**BigDecimal**类\n- double变float：在数字后加”f”或”F”\n\n### 字符型\n\n- char采用Unicode编码表，，占用2个字节\n- 同c++,可以和整数相互转型，可以使用转义字符\n\n### boolean\n\n- 占1位(非字节)\n- java中boolean无法和整数之间转换\n\n### 变量\n\n```\n- 变量使用前需要声明\n\n```\n\n#### final\n\n类似c++的const\n\n```\n- final修饰变量，则该变量无法修改\n- final修饰类，则说明该类不能被继承，不能有子类\n    - 如 Math、String\n- final修饰方法，则该方法不能被子类重写，但是可以被重载\n\n```\n\n**命名规范**：\n\n- 变量、方法名：\n  - 首字母小写+驼峰原则\n- 常量：\n  - 大写字母+下划线\n- 类名：\n  - 首字母大写+驼峰原则\n\n### 运算符\n\n```\n- 算术运算符： +,-,*,/,%,++,--\n    - 不同于c++, java中浮点数可以使用\"%\"运算符！\n    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串\n- 赋值运算符： =\n- 关系运算符： <,>,<=,>=,==,!=, instanceof\n    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）\n        - 返回值：boolean  true代表属于\n        - 使用： boolean ret= a instanceof A;\n- 逻辑运算符： &&,||,!\n    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算\n- 位运算符： &,|,^,~,>>,<<,>>>\n    - >> 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃\n        - 01110>>1 右移一位： 00111\n        - 10010>>1 右移一位： 11001\n    - >>> 表示无符号右移：左边以0补充，移出的部分将抛弃\n        - 01110>>>1 右移一位：00111   (正数时和\">>\"相同)\n        - 10010>>>1 右移一位：01001\n    - << 没有 \"<<<\"\n- 条件运算符：  ?:\n- 扩展赋值运算符： +=,-=,*=,/=,%=\n\n```\n\n### switch语句\n\n- 在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型\n- JDK7之后，switch表达式结果还可以是字符串\n- 使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句\n\n```\nswitch(a)\n{\n\tcase 1: break;\n\tcase 2: System.out.println(1);\n\tdefault: break;\n}\n```\n\n### 语句\n\n- if,while语句同c++\n- while中可以使用break,continue关键字\n- goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break\n- 可以使用带标签的continue和break\n  - 带标签的continue：跳转继续执行标签指向的循环\n  - 带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）\n\n### 方法 method，function\n\n[修饰符1 修饰符2..] 返回值 方法名(形参列表){\n语句\n}\n\n```\n- **Java中只有值传递！**\n- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身\n    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值\n\n```\n\n### 内存分析\n\n```\n- 栈\n    - 存放：局部变量\n    - 自动分配连续的空间\n- 堆\n    - 存放new出来的对象\n    - 空间不连续\n- 方法区\n    - 包含于堆区\n    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等\n\n```\n\n```\nclass Teacher{\n\tString name;\n\tint age;\n\tvoid teach() {}\n}\n\npublic class Student {\n\tString name;\n\tint age;\n\t\n\tvoid study() {}\n\t\n\tpublic static void main(String[] args){\n\t\tStudent st1=new Student();\n\t\tStudent st2=new Student();\n\t\tst1.age=18;\n\t\tst1.name=\"张三\";\n\t\tst2.age=30;\n\t\tst2.name=\"李四\";\n\t\t\n\t\tTeacher t1=new Teacher();\n\t\tt1.age=30;\n\t\tt1.name=\"李四\";\n\t}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG)\n\n## 包 package\n\n定义：Java的类库管理机制，借助文件系统的目录\n\n- 为什么需要使用Package\n\n  - 为了解决类的重名问题\n  - 为了便于管理类：合适的类位于合适的包\n\n- 怎么使用package\n\n  - 通常是类的第一句非注释性语句\n\n    - 规则：通常域名倒过来写，加上模块名\n\n      > com.qq.test\n\n一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字\n\n包名称内可以带有”.”，每个”.”代表文件系统的下一级目录\n\n如\n\n```\npackage p1;\npackage p1.s1;\n```\n\n则在文件系统中，p1文件夹下有个名为s1的文件夹包\n\n### 使用其它包里的类:\n\n1 . 使用**import**预先声明\n\n```\nimport package1.T;  // 引入package1包里的T\nimport package2.*   // 引入package2包里的所有类\npublic class T2\n{\n\tprivate T t1;\n}\n```\n\n2 . 每次使用时附带说明包的名\n\n```\npublic class T2\n{\n\tprivate package1.T t1;\n}\n```\n\n## API文档\n\n使用**JAVADOC**生成API文档\n\n```\n- 解决代码文档分离的问题\n\n```\n\n- 特殊的注释\n  - 文档注释： “/**”\n- 常用的java注释标签\n  - @Author 作者\n  - @version 版本\n  - @param 参数\n  - @return 返回值含义\n  - @throws 抛出异常描述\n  - @deprecated 废弃，建议用户不再使用该方法\n\n```\n/**\n * 类的描述、功能\n * @author aa\n * @version 1.0\n */\n```\n\n### 垃圾回收机制 (Garbage Collection)\n\n```\n- 对象空间的分配\n    - 使用\"new\"关键字创建对象\n- 对象空间的释放：\n    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间\n- 要点：\n    - 程序员无权调用垃圾回收器\n    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行\n    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用\n\n```\n\n## 数组\n\n### 定义数组变量\n\n1 - <类型>[]<数组名>=new <类型>[元素个数];\n\n> 例如：\n>\n> int [] grade = new int [100];\n>\n> 这样创建的数组会是默认的0值\n\n2 - <类型>[]<数组名>={元素1，元素2…};\n\n> 例如： int []a={1,2,3};\n\n3 - <类型>[]b = a; (a为同类型的数组)\n\n> 与c++中数组名的含义类似，数组名变量管理数组空间\n>\n> b和a管理同一个数组\n\n### 特点：\n\n1 - 所有元素的数据类型相同\n2 - 一旦创建则不能改变大小\n\n### 要求：\n\n- 元素个数必须是整数\n- 元素个数必须给出\n- 元素个数可以是变量\n\n### 内部成员：\n\nlength : 返回元素个数\n\n> for(int i=0; i<grade.length ; ++i)\n\n### 数组和数组变量：\n\n- 数组变量为数组的管理者，而非其本身\n- 数组创建出来后交给数组变量管理\n- 数组变量之间的赋值为管理权限的赋予\n- 数组变量的比较是判断是否管理同一个数组\n\n### 常用操作：\n\n1. 数组复制\n   System的arraycopy函数\n\n   ```\n   public static void arraycopy(Object src,\n                                int srcPos,\n                                Object dest,\n                                int destPos,\n                                int length)\n   // src 源数组\n   // srcPos 源数组开始复制的位置\n   // dest 目标数组\n   // destPos 目标数组开始复制的位置\n   // length 复制长度\n   // [srcPos,srcPos+length-1)\n   ```\n\n2. 二分查找\n   Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口\n   Arrays.binarySearch(Object obj, Object goal);\n\n3. 填充\n   Arrays.fill(Object obj, int start, int end, Object goal)\n   将目标数组[start,end)填充为goal\n\n### for-each循环：\n\n例如：for( int k: data )\n\n对于data数组的每一个元素，循环每一轮取一个元素作为k\n\n第一轮 k=data[0] , 第二轮 k=data[1]\n\n**for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值**\n\n## 包裹类型\n\n- 每种基础类型都有对应的包裹类型\n- 出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象\n\n| 基础类型    | 包裹类型      |\n| ------- | --------- |\n| boolean | Boolean   |\n| char    | Character |\n| int     | Integer   |\n| double  | Double    |\n\n### 用处：\n\n- 声明变量时包裹类型同基础类型\n\n> int a=1; <=> Integer a=1;\n\n- 可以获取该类型的信息，如最大值最小值\n\n> 如 System.out.println(Integer.MAX_VALUE);\n>\n> ( Integer.MAX_VALUE=2147483647 )\n\n- Character\n\n| 函数声明                           | 参数      | 用途            |\n| ------------------------------ | ------- | ------------- |\n| static boolean isDigit         | char ch | 判断该字符是否是数字    |\n| static boolean isLetter        | char ch | 判断该字符是否是字母    |\n| static boolean isLetterOrDigit | char ch | 判断该字符是否是数字或字母 |\n| static boolean isLowerCase     | char ch | 判断该字符是否是小写字母  |\n| static boolean isUpperCase     | char ch | 判断该字符是否是大写字母  |\n| static boolean isWhitespace    | char ch | 判断该字符是否是一种空格  |\n| static char toLowerCase        | char ch | 把该字符转换成小写     |\n| static char toUpperCase        | char ch | 把该字符转换成大写     |\n\n**转换仅体现在返回值，原变量的值没有改变**\n\n#### 自动装箱和自动拆箱 auto-boxing & unboxing\n\n- 自动装箱\n  - 基本类型自动封装到和它相同类型的包装里\n  - 本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);\n- 自动拆箱\n  - 包装类对象自动转换成基本数据类型\n  - 本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();\n\n#### **缓存处理**\n\n```\n-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）\n\n```\n\n```\nInteger d1=1234;\nInteger d2=1234;\n\nSystem.out.println(d1==d2);\nSystem.out.println(d1.equals(d2));\n\nInteger d3=123;\nInteger d4=123;\n\nSystem.out.println(d3==d4);\nSystem.out.println(d3.equals(d4));\n```\n\n结果：\n\n> false (d1==d2)\n> true (d1.equals(d2))\n> true (d3==d4)\n> true (d3.equals(d4))\n\n## 字符串 String\n\n- String是一个类，String变量是对象的管理者而非所有者\n\n### 创建：\n\n1 - String s = new String(“hello world”);\n\n2 - String s = “hello”;\n\n### 字符串连接\n\n- 用 “+” 连接两个字符串\n\n> “hello “+”world” -> “hello world”\n\n- 若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接\n\n> “I am “+18 -> “I am 18”\n>\n> 1+2+”age” -> “3age”\n>\n> “age”+1+2 -> “age12”\n\n### 字符串输入\n\n- in.next();\n  读入一个单词，以空格结束\n- in.nextLine();\n  读入一整行\n\n### 字符串比较\n\n- 用 “==” ：比较两个对象是同一个字符串\n\n> if(input == “hello”)\n\n- 用 “.equals” ：比较两个字符串的内容是否相同\n\n> if(input.equals(“hello”))\n\n### 字符串操作\n\n- 字符串是**对象**，所有操作是通过“.”进行的\n- 表示对“.”左边的字符串做右边的操作\n- 字符串可以是**变量**也可以是**常量**\n\n### 常用操作\n\n**所有操作都不会对字符串本身进行修改**\n\n- s1.compareTo(String s2)\n\n> 比较两个字符串大小\n>\n> s1>s2 返回正数\n>\n> s1<s2 返回负数\n>\n> s1和s2内容相同，返回0\n>\n> 字符串长者大\n>\n> 字符串长度相同时，从第一位开始以字典序比较\n\n- s1.length()\n\n> 获得String的长度\n\n- s1.charAt(int index)\n\n> 访问String里的字符\n>\n> 返回index上的单个字符\n>\n> 0<=index<=s1.length()-1\n>\n> **不能用for-each循环遍历字符串**\n\n- s1.substring(int begin ,int end)\n\n> 获得 s1 下标于[begin,end)的子串\n>\n> end可省略，默认为s1.length()\n\n- s1.indexOf( (char)|(String) c, int n)\n\n> 寻找c字符或字符串第一个所在位置，-1为不存在\n>\n> 从n开始找(包括n)，n可以省略，默认为0\n>\n> s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()\n>\n> 寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);\n\n- s1.startsWith( String s2)\n\n> 判断s1的前缀是否为s2\n\n- s1.endsWith( String s2)\n\n> 判断s1的后缀是否为s2\n\n- s1.trim()\n\n> 清除s1左右两端的空格\n>\n> 要保留清除可以 s1=s1.trim();\n\n- s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)\n\n> 将s1中所有字符或字符串c1替换成c2\n\n- s1.toLowerCase() s1.toUpperCase()\n\n> s1大小写切换\n\n- s1.split(char a)\n\n> 以a作为分隔符分割字符串s1，将结果作为字符串数组返回\n>\n> String [] s= s1.split(“ “);\n>\n> 多种分隔符用”|”分割，(“a”|”b”)\n>\n> 以”.””|”作为分隔符时要加”\\\\“，即(\\\\.)(\\\\|)\n\n### StringBuilder 和 StringBuffer\n\nStringBuilder：线程不安全，效率高\nStringBuffer：线程安全，效率低\n两者基本相同\n\nString无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。\n\n用StringBuffer/StringBuilder能够很好解决string的扩展问题\n\n- StringBuilder sb= new StringBuilder();\n\n- sb.append(“1”);\n\n  > 扩展字符串\n  > 其返回值为StringBuilder,因此可以连续调用\n  >\n  > ```\n  > // JDK源码\n  > @Override\n  > public StringBuilder append(String str) {\n  >     super.append(str);\n  >     return this;\n  > }\n  >\n  > // 因此可以使用\n  > sb.append(\"1\").append(\"2\");\n  > ```\n\n- sb.toString();\n\n  > 将StringBuilder形成字符串，可作为函数的String返回值\n\n- sb.delete(int start , int end);\n\n  > 删除下标为[start,end)的字符\n\n- sb.reverse();\n\n  > 反转sb\n\n#### 容量机制\n\n```\n- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）\n- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度\n- 扩容为当前容量*2+2\n\n```\n\n## 类\n\n### 创建对象\n\n对象变量是对象的**管理者**\n\n- T tem = new T();\n\n### 成员变量\n\n- 定义：类内部的变量\n- 特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数\n- 若没有初始化，则会自动被赋值(0)\n- 初始化\n  - 定义时就可以给出初始值\n  - 对象变量的0值表示没有管理任何对象，也可以主动给null值\n  - 定义初始化可以调用函数，可以使用已经定义的成员变量\n\n```\npublic class T\n{\n\tint a=1;\n\tint b=f();\n\tint f() {return 1;}\n}\n```\n\n### 构造函数\n\n- 名字和类名字完全相同，创建对象时会自动调用\n- 没有返回值\n- 调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句\n\n### 函数重载\n\n- 定义：同名但参数列表不同的函数\n- 可以有多个构造函数，但参数列表要不同\n- 构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次\n\n```\npublic class T\n{\n\tint a=1;\n\tT() {a=2;}\n\tT(int a)\n\t{\n\t\tthis();\n\t\tthis.a=a;\n\t}\n}\n```\n\n若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1->2->3，调用过程为：T(int a)->T()->int a=1;->执行T()->执行T(int a)\n\n### 访问属性\n\n- public (同c++)\n- private (同c++)\n- protected (同c++)\n- friendly\n\n#### public\n\n- 任何人都可以直接使用\n  - 任何函数或定义初始化中可以使用\n  - 使用是指调用、访问、定义变量\n- public类必须定义在自己的文件里\n- 一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)\n\n#### private\n\n- 只有类的内部能够访问\n  - 类的成员函数\n  - 定义初始化\n- 限制是针对类而非对象\n  - 对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)\n\n#### friendly\n\n- 未加private或public声明的成员 (即**默认值**)\n- 属于同一个包内的所有类都可以访问\n\n### System.out.println\n\n正常情况下，调用System.out.println直接输出类的对象，则会输出其地址\n\n若是在类中包含 public String toString 函数，则在println时自动调用该函数\n\n```\npublic class T{\n\tint c;\n\tpublic String toString () {return \"\"+c;}\n}\n```\n\n## 常用类\n\n### 时间处理：\n\n#### java.util.Date\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG)\n\n- 对象表示一个特定的瞬间，精确到毫秒\n- 时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long\n\n#### DateFormat, SimpleDateFormat\n\njava.text.*\n\n- 用来将字符串和时间相互转换\n- DateFormat 是抽象类，无法实例化对象\n- SimpleDateFormat非抽象类\n\n使用方法（详见API文档）\n\n1. 已知毫秒转相应时间和字符串\n\n   ```\n   DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日hh时mm分ss秒\");\n   DateFormat df1 = new SimpleDateFormat(\"yy-MM-dd hh:mm:ss\");\n   Date d = new Date(1321454564);\n   String str=df1.format(d);\n   System.out.println(str);\n   ```\n\n2. 已知字符串及输入格式转毫秒数\n\n   ```\n   String str2 = \"1977-07-07\";\n   DateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\n   try {\n   \tDate d2 = df2.parse(str2);\n   \tSystem.out.println(d2);\n   } catch (ParseException e) {\n   \t// TODO Auto-generated catch block\n   \te.printStackTrace();\n   }\n   ```\n\n#### Calendar，GregorianCalendar 日历类\n\njava.util.*\n\n- Calendar是抽象类，无法实例化对象\n- GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统\n- Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期\n- 注意\n  - 月份：1月是0，2月是1，…12月是11\n    - 星期：周日是1，周一是2…周六是7\n    - 可以使用 Calendar.FEBRUARY 表示数字\n\n使用方法：（详见API文档）\n\n1. 整体设置\n\n   ```\n   Calendar c = new GregorianCalendar();\n   c.set(2001, Calendar.FEBRUARY ,15);\n   Date date = c.getTime();\n   ```\n\n2. 单独设置\n\n   ```\n   c.set(Calendar.YEAR , 2001);\n   c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);\n   // 未设置参数则自动采用当前时间 (日期、时分秒等)\n   System.out.println(c.get(Calendar.YEAR));\n   ```\n\n3. 用Date赋值\n\n   ```\n   c.setTime(new Date());\n   ```\n\n4. 日期计算\n\n   ```\n   c.add(Calendar.YEAR, 30);\n   ```\n\n### File 类\n\njava.io.File:文件和目录路径名的抽象表现形式\n\n```\n- 通过File对象可以访问、修改文件属性\n- 可以创建空文件或目录\n\n```\n\n```\nFile f = new File(\"d:/aaa/bbb/ccc\");\nf.mkdir();  // 若父目录存在则创建\nf.mkdirs(); // 若父目录不存在则自动创建父目录\n```\n\n## 容器\n\n- 容器类的两个类型：\n\n  1 . 容器的类型\n\n  2 . 元素的类型\n\n### ArrayList\n\n- import java.util.ArrayList;\n\n- 特点：元素可以相同，元素以与进入的顺序排序\n\n- 基础类型：存放值\n\n- 非基础类型：作为管理者，存放地址\n\n- 定义：\n\n  ArrayList notes = new ArrayList();\n\n#### 常用操作\n\n- notes.add(int location, String s);\n\n> 向下标为location的位置中插入元素\n>\n> location可省略，默认为末尾\n\n- notes.size();\n\n> 返回容器中存放元素数目\n\n- notes.get(int index);\n\n> 返回下标为Index的元素\n\n- nodes.remove(int index);\n\n> 移除下标为Index的元素\n\n- notes.toArray(String []a);\n\n> 将notes里所有元素依次填入a中\n\n#### for-each循环\n\n若ArrayList存放的非基础类型，则for-each中可以修改值\n\n### Set\n\n- import java.util.HashSet\n- 特点：元素均不相同，不排序，与进入的顺序无关\n\n### Hash表(散列表)\n\n- import java.util.HashMap;\n- HashMap < Key, Value > a=new HashMap < Key,Value > ();\n  数据以一对值放进去，一个为键(KEY),一个为值(value)\n  值对应键\n- 键不能重复，只留相同的最后一个，元素不以先后排序\n\n#### 常用操作\n\n- a.put(Key k1, Value v1);\n\n> 向HashMap里添加元素，键k1对应值为v1\n\n- a.get(Key k);\n\n> 返回键k对应的值，若为空，则返回null\n\n- a.containsKey(Key k);\n\n> 查询是否存在键为k的数据\n\n- a.keySet();\n\n> 返回key的集合\n>\n> 可以通过 a.keySet().size()获取存放的键的数目\n>\n> 通过keySet使用for-each循环\n\n## 继承\n\n- extends\n\n  ```\n  public class son extends parent\n  ```\n\n- **java只允许单继承，一个类只能有一个父类**\n\n| 父类成员访问属性  | 在父类中的含义           | 在子类中的含义                   |                    |\n| --------- | ----------------- | ------------------------- | ------------------ |\n| public    | 对所有人开放            | 对所有人开放                    |                    |\n| protected | 只有包内其它类、自己和子类可以访问 | 只有包内其它类、自己和子类可以访问         |                    |\n| 缺省        | 只有包内其它类可以访问       | 如果子类与父类在同一个包内：只有包内其它类可以访问 | 否则：相当于private，不能访问 |\n| private   | 只有自己可以访问          | 不能访问                      |                    |\n\n子类同样继承了父类的private成员，只是子类无法访问！\n但子类可以通过调用父类的非private函数来间接修改父类的private成员变量\n\n### 继承VS组合\n\n- “is-a”关系使用继承\n  - 如：Bird类继承自Animal类\n- “has-a”关系使用组合\n  - 如：Computer类包含CPU类，每个Computer对象都有一个CPU对象\n\n### super\n\n本质：一个**关键字**，类似this(this的本质为指针),是直接父类的引用\n\n用法\n1 . 直接引用\n\n相当于指向当前对象的父类，用”.”访问父类的成员\n\n2 . 子类成员变量或方法与父类同名时，用super加以区分\n\n```\nclass son extends parent{\n\tvoid a();\n\tvoid b(){\n\t\ta();   // son的a函数\n\t\tsuper.a();  // parent的a函数\n\t}\n}\n```\n\n3 . 调用父类的构造函数\n\n规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数\n\n子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译\n\n```\nclass son extends parent{\n\tint a;\n\tson(int a1){\n\t\tsuper(a1);\n\t}\n}\n```\n\n### 同名变量\n\n若没有明确指明，则在谁的成员函数中就使用谁的成员变量\n\n### 子类和子类型\n\n- 类定义了类型\n- 子类定义了子类型 (son是parent的一个子类型)\n- 子类对象可以被当做父类的对象使用\n  - 赋值给父类变量\n  - 传递给需要父类对象的函数\n  - 放进存放分类对象的容器里\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG)\n\n```\nVehicle v1 = new Vehicle();\nVehicle v2 = new Car();\nVehicle v3 = new Bicycle();\n```\n\n## 多态\n\n主要用来实现**动态联编**\n\n即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了\n\n以此提高系统的灵活性和扩展性\n\n### 如何实现多态\n\n```\n- 引用变量的两种类型\n\n    - 编译时类型（一般是父类）\n        - 由声明时的类型决定\n\n    - 运行时类型（运行时具体的子类）\n        - 由实际对应的对象类型决定\n\n- 三个必要条件\n    - 要有继承\n    - 要有方法重写\n    - 父类引用指向子类对象\n\n```\n\n### 多态变量\n\n- 对象变量能够保存不止一种的对象\n- 可以保存声明类型的对象或是声明类型的子类的对象\n- 子类对象赋给父类变量，发生**向上造型**\n\n### 造型 cast\n\n造型(cast)：把一个类型的对象赋值给另一个类型的变量\n\n- 子类对象可以复制给父类变量\n  - 与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象\n- 父类对象不能赋值给子类变量\n- 可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行\n- 类型转换 ！= 造型\n  - 类型转换中对象发生改变，如 int i=(int)10.2;\n  - 造型中对象本身没有改变，只是改变了看待它的方式\n\n```\nVehicle v;\nCar car = new Car();\nv=car;  //可以\nc=v;   //编译错误\nc=(Car)v // 编译通过\n\n若\nVehicle v=new Vehicle();\nCar car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常\n```\n\n#### 向上造型\n\n- 子类对象当做父类对象使用\n- 向上造型是默认的，不需要运算符\n- 向上造型是安全的\n\n### 绑定\n\n同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数\n\n- 静态绑定：根据变量声明类型决定\n- 动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )\n- 默认使用动态绑定\n- 成员函数中调用其它成员函数通过this变量调用\n\n### 覆盖 override\n\n- 覆盖关系：子类和父类中存在名称和参数表完全相同的函数\n- 通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数\n\n### Object类\n\n- 所有的类都继承自Object类\n- 几乎所有OOP都有Object类（除c++）\n\n#### Object类的函数(部分)\n\n- toString()\n- equals()\n\n### 多态的内存分析\n\n1 . 基本的继承关系和方法调用\n\n```\n- 父类：Animal  有voice方法\n- 子类：Cat 重写voice方法，自己有catchMouse方法\n- 测试：分别声明父类和子类变量并指向子类对象\n\n```\n\n```\npublic class Test{\n\t\n\tpublic static void showVoice(Animal c) {\n\t\tc.voice();\n\t\tif(c instanceof Cat)\n\t\t\t((Cat) c).catchMouse();\n\t}\n\tpublic static void main(String[] args) {\n\t\tAnimal a=new Cat();\n\t\tCat cat=(Cat)a;\n\t\tTest.showVoice(cat);\n\t\tTest.showVoice(a);\n\t}\n}\n\nclass Animal{\n\tString name;\n\tint age;\n\tvoid voice() {}\n}\n\nclass Cat extends Animal{\n\tvoid voice() {\n\t\tSystem.out.println(\"miao\");\n\t};\n\tvoid catchMouse() {}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG)\n\n2 . 深化多态\n\n```\n- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法\n- 子类：MyServlet 重写了doGet方法\n- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本\n\n```\n\n```\npublic class HttpServlet {\n\tpublic void service() {\n\t\tSystem.out.println(\"HttpServlet.service()\");\n\t\tdoGet();\n\t}\n\tpublic void doGet() {\n\t\tSystem.out.println(\"HttpServlet.doGet()\");\n\t}\n}\n\n\npublic class MyServlet extends HttpServlet {\n\tpublic void doGet() {\n\t\tSystem.out.println(\"MyServlet.doGet()\");\n\t}\n}\n\npublic class Test{\n\t\n\tpublic static void main(String[] args) {\n\t\tHttpServlet s = new MyServlet();\n\t\ts.service();\n\t}\n}\n// 输出结果：\n// HttpServlet.service()\n// MyServlet.doGet()\n```\n\n原因分析：\n函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG)\n\n## 设计原则\n\n### 消除代码复制\n\n- 代码复制是不良设计的一种表现\n\n  解决方法：使用函数封装重复的代码\n\n### 增加可扩展性\n\n- 后期的可维护性\n\n  解决方法：用封装降低耦合，用接口实现聚合，借助类继承\n\n  耦合：类和类之间的关系\n\n  耦合越低越好\n\n## 抽象和接口\n\n关键词：**abstract** (抽象)\n\n> public abstract class a\n\n- 抽象函数：表达概念而**无法实现具体代码**的函数\n- 抽象类：表达概念而**无法构造出实体**的类\n- 为什么需要抽象类\n  - **模板模式**，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展\n  - **通过抽象类，可以避免子类设计的随意性**，严格限制子类的设计，使得子类之间更加通用。\n- 抽象方法的意义：**使方法的设计和实现分离！**\n- 要点：\n  - 有抽象函数的类一定是抽象类\n    - 抽象类**不能制造对象**，但可以定义变量\n  - 任何继承了抽象类的非抽象类对象可以赋值给抽象类变量\n  - 抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用\n  - 继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类\n\n### 接口\n\n关键词：**interface**\n\n> public interface a{}\n\n- 接口是纯抽象类(接口中只有常量、抽象方法)\n- 所有成员变量都是public abstract static final （默认的，可以不写）\n- 接口意义：设计和实现分离，利于大项目制作\n- 接口变量的含义为任何实现了接口的对象\n\n关键词：**implements**\n\n> public class b implements a{}\n\n- 类可以实现很多接口\n- 接口可以继承接口，不能继承类\n- 接口不能实现接口\n- 接口和抽象类\n  - 接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了**规范和具体实现的分离**\n  - **接口就是规范，定义了一组规则**\n  - **接口的本质是契约**，制定好后大家都遵守\n  - 项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要**面向接口编程**\n\n#### 面向接口的编程方式\n\n- 设计程序时先定义接口，再实现类\n- 任何需要在函数间传入传出的一定是接口而不是具体的类\n- Java成功的关键之一，极适合多人同时写一个大程序\n- Java被批评的要点之一，代码量膨胀地很快\n\n## 控制反转与MVC模式\n\n### Swing\n\n容器、部件\n\n- 容器继承自部件，因此可以作为部件被放入其它容器中\n\n- 容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整\n\n- JFrame使用BorderLayout管理部件，并且将界面划分为五个区域\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG)\n\n- 容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件\n\n### 控制反转\n\n- 按钮公布一个listener接口和一对注册、注销函数\n- 实现接口后将把listener对象注册在按钮上\n- 一旦按钮被按下，就会反过来调用listener对象的函数\n\n### 内部类 innerclasses\n\n定义在别的类内部、函数内部的类\n\n#### 作用：\n\n```\n- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问\n- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性\n\n```\n\n#### 使用场合\n\n在内部类只为所在外部类提供服务的情况优先使用\n\n#### 分类：\n\n##### 成员内部类\n\n（可以使用private,public,protected修饰）\n\n###### 非静态内部类\n\n`- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();`\n\n```\npublic class Outer {\n\tpublic static void main(String[] args) {\n\t\tFace f=new Face();\n\t\tFace.Nose n= f.new Nose();\n\t}\n}\n\nclass Face {\n\tint type;\n\t\n\tclass Nose{\n\t\tString type;\n\t\t\n\t\tvoid breath() {\n\t\t\tFace.this.type=1;\n\t\t}\n\t\t\n\t}\n}\n```\n\n###### 静态内部类\n\n```\n- 要点：\n    - 静态内部类对象存在时，不一定存在对应的外部类对象\n    - 静态内部类无法直接访问外部类实例方法\n    - 静态内部类看作**外部类的一个静态成员**\n\n```\n\n```\nFace f= new Face();\n// Nose为非静态内部类\nFace.Nose n=f.new Nose();\n// Ear为静态内部类\nFace.Ear e=new Face.Ear();\n```\n\n###### 局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\n\n```\n- 访问函数的本地变量时只能访问函数的final变量\n\n```\n\n##### 匿名内部类\n\n适用于只需要使用一次的类，例如：键盘监听操作等\n\n```\nnew 父类构造器(实参) 实现接口(){\n\t匿名内部类类体\n}\n```\n\n- 匿名类可以继承某类，也可以实现接口\n- Swing的消息机制广泛使用匿名类\n\n### MVC设计模式\n\n- 数据、表现和控制\n\n  三者分离\n\n  - M = Model 模型\n  - V = View 表现\n  - C = Control 控制\n\n- 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新\n\n- 表现：从模型获取数据，根据数据画出表现\n\n- 控制：从用户得到输入，根据输入调整数据\n\n### 异常机制 Exception\n\n#### 常见的异常\n\n```\n用户输入错误\n设备错误\n硬件问题：如打印机关掉、服务器问题\n磁盘满了\n\n```\n\n#### 异常Exception\n\n```\nJava提供的用来处理程序中错误的一种机制\n\nJava采用**面向对象** 方式来处理异常。处理过程：\n    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE\n    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置\n\n```\n\n#### 常见异常\n\n```\n1. ArithmeticException\n    例如试图除以0\n2. NullPointerException\n    对象为null但调用了对象的方法或属性\n3. ClassCastException\n    转型错误，解决：使用istanceof判断\n4. ArrayIndexOutOfBoundsException\n    访问元素超出数组长度\n5. NumberFormatException\n    数字格式异常，如把String转换成int\n\n```\n\n#### 异常的处理方法：\n\n`捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常`\n\n#### 方法重写中声明异常原则：\n\n```\n**子类声明的异常范围不能超出父类的范围**\n    - 父类没有声明异常，子类也不能\n    - 不能抛出 原有方法抛出的父类或上层类\n    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）\n\n```\n\n#### 自定义异常\n\n```\n- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类\n- 从Exception类或它的子类派生一个子类\n- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器\n\n建议：\n    - 避免使用异常机制代替错误处理\n    - 处理异常不能代替简单测试\n    - 不要进行**小力度**的异常处理（如一行一个try catch）\n    - 异常往往在**高层**处理\n\n```","slug":"Java_note1","published":1,"updated":"2018-06-02T13:10:32.326Z","photos":[],"link":"","_id":"cjleshqjh000gryfcd6zta3nr","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>JAVA学习过程中的简要笔记</p>\n<p>从已有C++基础的前提下开始学习java</p>\n<p>内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等</p>\n<a id=\"more\"></a>\n<h3 id=\"各版本和体系架构\"><a href=\"#各版本和体系架构\" class=\"headerlink\" title=\"各版本和体系架构\"></a>各版本和体系架构</h3><ul>\n<li>J2EE<ul>\n<li>JAVA 2(to) Enterprise Edition:</li>\n<li>定位在服务器端的应用</li>\n</ul>\n</li>\n<li>J2SE<ul>\n<li>JAVA 2(to) Standard Edition:</li>\n<li>定位在个人计算机的应用</li>\n</ul>\n</li>\n<li>J2EE<ul>\n<li>JAVA 2(to) Micro Edition:</li>\n<li>定位在消费性电子产品的应用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- JDK</span><br><span class=\"line\">    - Java Development Kit Java开发工具包</span><br><span class=\"line\">- JRE</span><br><span class=\"line\">    - Java Runtime Environment java运行环境</span><br><span class=\"line\">- JVM</span><br><span class=\"line\">    - Java Virtual Machine java虚拟机</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG\" alt=\"数据类型\"></p>\n<h3 id=\"整型变量\"><a href=\"#整型变量\" class=\"headerlink\" title=\"整型变量\"></a>整型变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表示形式</span><br><span class=\"line\">    - 十进制</span><br><span class=\"line\">    - 八进制：以0开头</span><br><span class=\"line\">    - 十六进制：以0x或0X开头</span><br></pre></td></tr></table></figure>\n<p>整型默认为int型，long型常量后加”l”或”L”</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>1字节</td>\n<td>-128~127</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2字节</td>\n<td>-$2^15$~$2^15-1$</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4字节</td>\n<td>-$2^31$~$2^31-1$</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8字节</td>\n<td>-$2^63$~$2^63-1$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>超过long的数字使用<strong>BigInteger</strong>类</li>\n</ul>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>4字节</td>\n<td>-3.403E38~3.403E38</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>-1.798E308~1.798E308</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>默认为double</li>\n<li>若需要不产生舍入误差的精确计算，需要用<strong>BigDecimal</strong>类</li>\n<li>double变float：在数字后加”f”或”F”</li>\n</ul>\n<h3 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h3><ul>\n<li>char采用Unicode编码表，，占用2个字节</li>\n<li>同c++,可以和整数相互转型，可以使用转义字符</li>\n</ul>\n<h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><ul>\n<li>占1位(非字节)</li>\n<li>java中boolean无法和整数之间转换</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 变量使用前需要声明</span><br></pre></td></tr></table></figure>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>类似c++的const</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- final修饰变量，则该变量无法修改</span><br><span class=\"line\">- final修饰类，则说明该类不能被继承，不能有子类</span><br><span class=\"line\">    - 如 Math、String</span><br><span class=\"line\">- final修饰方法，则该方法不能被子类重写，但是可以被重载</span><br></pre></td></tr></table></figure>\n<p><strong>命名规范</strong>：</p>\n<ul>\n<li>变量、方法名：<ul>\n<li>首字母小写+驼峰原则</li>\n</ul>\n</li>\n<li>常量：<ul>\n<li>大写字母+下划线</li>\n</ul>\n</li>\n<li>类名：<ul>\n<li>首字母大写+驼峰原则</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 算术运算符： +,-,*,/,%,++,--</span><br><span class=\"line\">    - 不同于c++, java中浮点数可以使用&quot;%&quot;运算符！</span><br><span class=\"line\">    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串</span><br><span class=\"line\">- 赋值运算符： =</span><br><span class=\"line\">- 关系运算符： &lt;,&gt;,&lt;=,&gt;=,==,!=, instanceof</span><br><span class=\"line\">    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）</span><br><span class=\"line\">        - 返回值：boolean  true代表属于</span><br><span class=\"line\">        - 使用： boolean ret= a instanceof A;</span><br><span class=\"line\">- 逻辑运算符： &amp;&amp;,||,!</span><br><span class=\"line\">    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算</span><br><span class=\"line\">- 位运算符： &amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</span><br><span class=\"line\">    - &gt;&gt; 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;1 右移一位： 00111</span><br><span class=\"line\">        - 10010&gt;&gt;1 右移一位： 11001</span><br><span class=\"line\">    - &gt;&gt;&gt; 表示无符号右移：左边以0补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;&gt;1 右移一位：00111   (正数时和&quot;&gt;&gt;&quot;相同)</span><br><span class=\"line\">        - 10010&gt;&gt;&gt;1 右移一位：01001</span><br><span class=\"line\">    - &lt;&lt; 没有 &quot;&lt;&lt;&lt;&quot;</span><br><span class=\"line\">- 条件运算符：  ?:</span><br><span class=\"line\">- 扩展赋值运算符： +=,-=,*=,/=,%=</span><br></pre></td></tr></table></figure>\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><ul>\n<li>在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型</li>\n<li>JDK7之后，switch表达式结果还可以是字符串</li>\n<li>使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcase 1: break;</span><br><span class=\"line\">\tcase 2: System.out.println(1);</span><br><span class=\"line\">\tdefault: break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h3><ul>\n<li>if,while语句同c++</li>\n<li>while中可以使用break,continue关键字</li>\n<li>goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break</li>\n<li>可以使用带标签的continue和break<ul>\n<li>带标签的continue：跳转继续执行标签指向的循环</li>\n<li>带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"方法-method，function\"><a href=\"#方法-method，function\" class=\"headerlink\" title=\"方法 method，function\"></a>方法 method，function</h3><p>[修饰符1 修饰符2..] 返回值 方法名(形参列表){<br>语句<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- **Java中只有值传递！**</span><br><span class=\"line\">- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身</span><br><span class=\"line\">    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存分析\"><a href=\"#内存分析\" class=\"headerlink\" title=\"内存分析\"></a>内存分析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 栈</span><br><span class=\"line\">    - 存放：局部变量</span><br><span class=\"line\">    - 自动分配连续的空间</span><br><span class=\"line\">- 堆</span><br><span class=\"line\">    - 存放new出来的对象</span><br><span class=\"line\">    - 空间不连续</span><br><span class=\"line\">- 方法区</span><br><span class=\"line\">    - 包含于堆区</span><br><span class=\"line\">    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid teach() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid study() &#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tStudent st1=new Student();</span><br><span class=\"line\">\t\tStudent st2=new Student();</span><br><span class=\"line\">\t\tst1.age=18;</span><br><span class=\"line\">\t\tst1.name=&quot;张三&quot;;</span><br><span class=\"line\">\t\tst2.age=30;</span><br><span class=\"line\">\t\tst2.name=&quot;李四&quot;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTeacher t1=new Teacher();</span><br><span class=\"line\">\t\tt1.age=30;</span><br><span class=\"line\">\t\tt1.name=&quot;李四&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG\" alt=\"mark\"></p>\n<h2 id=\"包-package\"><a href=\"#包-package\" class=\"headerlink\" title=\"包 package\"></a>包 package</h2><p>定义：Java的类库管理机制，借助文件系统的目录</p>\n<ul>\n<li><p>为什么需要使用Package</p>\n<ul>\n<li>为了解决类的重名问题</li>\n<li>为了便于管理类：合适的类位于合适的包</li>\n</ul>\n</li>\n<li><p>怎么使用package</p>\n<ul>\n<li><p>通常是类的第一句非注释性语句</p>\n<ul>\n<li><p>规则：通常域名倒过来写，加上模块名</p>\n<blockquote>\n<p>com.qq.test</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字</p>\n<p>包名称内可以带有”.”，每个”.”代表文件系统的下一级目录</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package p1;</span><br><span class=\"line\">package p1.s1;</span><br></pre></td></tr></table></figure>\n<p>则在文件系统中，p1文件夹下有个名为s1的文件夹包</p>\n<h3 id=\"使用其它包里的类\"><a href=\"#使用其它包里的类\" class=\"headerlink\" title=\"使用其它包里的类:\"></a>使用其它包里的类:</h3><p>1 . 使用<strong>import</strong>预先声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import package1.T;  // 引入package1包里的T</span><br><span class=\"line\">import package2.*   // 引入package2包里的所有类</span><br><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2 . 每次使用时附带说明包的名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate package1.T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"API文档\"><a href=\"#API文档\" class=\"headerlink\" title=\"API文档\"></a>API文档</h2><p>使用<strong>JAVADOC</strong>生成API文档</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 解决代码文档分离的问题</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特殊的注释<ul>\n<li>文档注释： “/**”</li>\n</ul>\n</li>\n<li>常用的java注释标签<ul>\n<li>@Author 作者</li>\n<li>@version 版本</li>\n<li>@param 参数</li>\n<li>@return 返回值含义</li>\n<li>@throws 抛出异常描述</li>\n<li>@deprecated 废弃，建议用户不再使用该方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 类的描述、功能</span><br><span class=\"line\"> * @author aa</span><br><span class=\"line\"> * @version 1.0</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾回收机制-Garbage-Collection\"><a href=\"#垃圾回收机制-Garbage-Collection\" class=\"headerlink\" title=\"垃圾回收机制 (Garbage Collection)\"></a>垃圾回收机制 (Garbage Collection)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 对象空间的分配</span><br><span class=\"line\">    - 使用&quot;new&quot;关键字创建对象</span><br><span class=\"line\">- 对象空间的释放：</span><br><span class=\"line\">    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间</span><br><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 程序员无权调用垃圾回收器</span><br><span class=\"line\">    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行</span><br><span class=\"line\">    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"定义数组变量\"><a href=\"#定义数组变量\" class=\"headerlink\" title=\"定义数组变量\"></a>定义数组变量</h3><p>1 - &lt;类型&gt;[]&lt;数组名&gt;=new &lt;类型&gt;[元素个数];</p>\n<blockquote>\n<p>例如：</p>\n<p>int [] grade = new int [100];</p>\n<p>这样创建的数组会是默认的0值</p>\n</blockquote>\n<p>2 - &lt;类型&gt;[]&lt;数组名&gt;={元素1，元素2…};</p>\n<blockquote>\n<p>例如： int []a={1,2,3};</p>\n</blockquote>\n<p>3 - &lt;类型&gt;[]b = a; (a为同类型的数组)</p>\n<blockquote>\n<p>与c++中数组名的含义类似，数组名变量管理数组空间</p>\n<p>b和a管理同一个数组</p>\n</blockquote>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><p>1 - 所有元素的数据类型相同<br>2 - 一旦创建则不能改变大小</p>\n<h3 id=\"要求：\"><a href=\"#要求：\" class=\"headerlink\" title=\"要求：\"></a>要求：</h3><ul>\n<li>元素个数必须是整数</li>\n<li>元素个数必须给出</li>\n<li>元素个数可以是变量</li>\n</ul>\n<h3 id=\"内部成员：\"><a href=\"#内部成员：\" class=\"headerlink\" title=\"内部成员：\"></a>内部成员：</h3><p>length : 返回元素个数</p>\n<blockquote>\n<p>for(int i=0; i&lt;grade.length ; ++i)</p>\n</blockquote>\n<h3 id=\"数组和数组变量：\"><a href=\"#数组和数组变量：\" class=\"headerlink\" title=\"数组和数组变量：\"></a>数组和数组变量：</h3><ul>\n<li>数组变量为数组的管理者，而非其本身</li>\n<li>数组创建出来后交给数组变量管理</li>\n<li>数组变量之间的赋值为管理权限的赋予</li>\n<li>数组变量的比较是判断是否管理同一个数组</li>\n</ul>\n<h3 id=\"常用操作：\"><a href=\"#常用操作：\" class=\"headerlink\" title=\"常用操作：\"></a>常用操作：</h3><ol>\n<li><p>数组复制<br>System的arraycopy函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void arraycopy(Object src,</span><br><span class=\"line\">                             int srcPos,</span><br><span class=\"line\">                             Object dest,</span><br><span class=\"line\">                             int destPos,</span><br><span class=\"line\">                             int length)</span><br><span class=\"line\">// src 源数组</span><br><span class=\"line\">// srcPos 源数组开始复制的位置</span><br><span class=\"line\">// dest 目标数组</span><br><span class=\"line\">// destPos 目标数组开始复制的位置</span><br><span class=\"line\">// length 复制长度</span><br><span class=\"line\">// [srcPos,srcPos+length-1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>二分查找<br>Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口<br>Arrays.binarySearch(Object obj, Object goal);</p>\n</li>\n<li><p>填充<br>Arrays.fill(Object obj, int start, int end, Object goal)<br>将目标数组[start,end)填充为goal</p>\n</li>\n</ol>\n<h3 id=\"for-each循环：\"><a href=\"#for-each循环：\" class=\"headerlink\" title=\"for-each循环：\"></a>for-each循环：</h3><p>例如：for( int k: data )</p>\n<p>对于data数组的每一个元素，循环每一轮取一个元素作为k</p>\n<p>第一轮 k=data[0] , 第二轮 k=data[1]</p>\n<p><strong>for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值</strong></p>\n<h2 id=\"包裹类型\"><a href=\"#包裹类型\" class=\"headerlink\" title=\"包裹类型\"></a>包裹类型</h2><ul>\n<li>每种基础类型都有对应的包裹类型</li>\n<li>出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>基础类型</th>\n<th>包裹类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用处：\"><a href=\"#用处：\" class=\"headerlink\" title=\"用处：\"></a>用处：</h3><ul>\n<li>声明变量时包裹类型同基础类型</li>\n</ul>\n<blockquote>\n<p>int a=1; &lt;=&gt; Integer a=1;</p>\n</blockquote>\n<ul>\n<li>可以获取该类型的信息，如最大值最小值</li>\n</ul>\n<blockquote>\n<p>如 System.out.println(Integer.MAX_VALUE);</p>\n<p>( Integer.MAX_VALUE=2147483647 )</p>\n</blockquote>\n<ul>\n<li>Character</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数声明</th>\n<th>参数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static boolean isDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字</td>\n</tr>\n<tr>\n<td>static boolean isLetter</td>\n<td>char ch</td>\n<td>判断该字符是否是字母</td>\n</tr>\n<tr>\n<td>static boolean isLetterOrDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字或字母</td>\n</tr>\n<tr>\n<td>static boolean isLowerCase</td>\n<td>char ch</td>\n<td>判断该字符是否是小写字母</td>\n</tr>\n<tr>\n<td>static boolean isUpperCase</td>\n<td>char ch</td>\n<td>判断该字符是否是大写字母</td>\n</tr>\n<tr>\n<td>static boolean isWhitespace</td>\n<td>char ch</td>\n<td>判断该字符是否是一种空格</td>\n</tr>\n<tr>\n<td>static char toLowerCase</td>\n<td>char ch</td>\n<td>把该字符转换成小写</td>\n</tr>\n<tr>\n<td>static char toUpperCase</td>\n<td>char ch</td>\n<td>把该字符转换成大写</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>转换仅体现在返回值，原变量的值没有改变</strong></p>\n<h4 id=\"自动装箱和自动拆箱-auto-boxing-amp-unboxing\"><a href=\"#自动装箱和自动拆箱-auto-boxing-amp-unboxing\" class=\"headerlink\" title=\"自动装箱和自动拆箱 auto-boxing &amp; unboxing\"></a>自动装箱和自动拆箱 auto-boxing &amp; unboxing</h4><ul>\n<li>自动装箱<ul>\n<li>基本类型自动封装到和它相同类型的包装里</li>\n<li>本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);</li>\n</ul>\n</li>\n<li>自动拆箱<ul>\n<li>包装类对象自动转换成基本数据类型</li>\n<li>本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"缓存处理\"><a href=\"#缓存处理\" class=\"headerlink\" title=\"缓存处理\"></a><strong>缓存处理</strong></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer d1=1234;</span><br><span class=\"line\">Integer d2=1234;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d1==d2);</span><br><span class=\"line\">System.out.println(d1.equals(d2));</span><br><span class=\"line\"></span><br><span class=\"line\">Integer d3=123;</span><br><span class=\"line\">Integer d4=123;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d3==d4);</span><br><span class=\"line\">System.out.println(d3.equals(d4));</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<blockquote>\n<p>false (d1==d2)<br>true (d1.equals(d2))<br>true (d3==d4)<br>true (d3.equals(d4))</p>\n</blockquote>\n<h2 id=\"字符串-String\"><a href=\"#字符串-String\" class=\"headerlink\" title=\"字符串 String\"></a>字符串 String</h2><ul>\n<li>String是一个类，String变量是对象的管理者而非所有者</li>\n</ul>\n<h3 id=\"创建：\"><a href=\"#创建：\" class=\"headerlink\" title=\"创建：\"></a>创建：</h3><p>1 - String s = new String(“hello world”);</p>\n<p>2 - String s = “hello”;</p>\n<h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><ul>\n<li>用 “+” 连接两个字符串</li>\n</ul>\n<blockquote>\n<p>“hello “+”world” -&gt; “hello world”</p>\n</blockquote>\n<ul>\n<li>若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接</li>\n</ul>\n<blockquote>\n<p>“I am “+18 -&gt; “I am 18”</p>\n<p>1+2+”age” -&gt; “3age”</p>\n<p>“age”+1+2 -&gt; “age12”</p>\n</blockquote>\n<h3 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h3><ul>\n<li>in.next();<br>读入一个单词，以空格结束</li>\n<li>in.nextLine();<br>读入一整行</li>\n</ul>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><ul>\n<li>用 “==” ：比较两个对象是同一个字符串</li>\n</ul>\n<blockquote>\n<p>if(input == “hello”)</p>\n</blockquote>\n<ul>\n<li>用 “.equals” ：比较两个字符串的内容是否相同</li>\n</ul>\n<blockquote>\n<p>if(input.equals(“hello”))</p>\n</blockquote>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><ul>\n<li>字符串是<strong>对象</strong>，所有操作是通过“.”进行的</li>\n<li>表示对“.”左边的字符串做右边的操作</li>\n<li>字符串可以是<strong>变量</strong>也可以是<strong>常量</strong></li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p><strong>所有操作都不会对字符串本身进行修改</strong></p>\n<ul>\n<li>s1.compareTo(String s2)</li>\n</ul>\n<blockquote>\n<p>比较两个字符串大小</p>\n<p>s1&gt;s2 返回正数</p>\n<p>s1&lt;s2 返回负数</p>\n<p>s1和s2内容相同，返回0</p>\n<p>字符串长者大</p>\n<p>字符串长度相同时，从第一位开始以字典序比较</p>\n</blockquote>\n<ul>\n<li>s1.length()</li>\n</ul>\n<blockquote>\n<p>获得String的长度</p>\n</blockquote>\n<ul>\n<li>s1.charAt(int index)</li>\n</ul>\n<blockquote>\n<p>访问String里的字符</p>\n<p>返回index上的单个字符</p>\n<p>0&lt;=index&lt;=s1.length()-1</p>\n<p><strong>不能用for-each循环遍历字符串</strong></p>\n</blockquote>\n<ul>\n<li>s1.substring(int begin ,int end)</li>\n</ul>\n<blockquote>\n<p>获得 s1 下标于[begin,end)的子串</p>\n<p>end可省略，默认为s1.length()</p>\n</blockquote>\n<ul>\n<li>s1.indexOf( (char)|(String) c, int n)</li>\n</ul>\n<blockquote>\n<p>寻找c字符或字符串第一个所在位置，-1为不存在</p>\n<p>从n开始找(包括n)，n可以省略，默认为0</p>\n<p>s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()</p>\n<p>寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);</p>\n</blockquote>\n<ul>\n<li>s1.startsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的前缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.endsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的后缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.trim()</li>\n</ul>\n<blockquote>\n<p>清除s1左右两端的空格</p>\n<p>要保留清除可以 s1=s1.trim();</p>\n</blockquote>\n<ul>\n<li>s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)</li>\n</ul>\n<blockquote>\n<p>将s1中所有字符或字符串c1替换成c2</p>\n</blockquote>\n<ul>\n<li>s1.toLowerCase() s1.toUpperCase()</li>\n</ul>\n<blockquote>\n<p>s1大小写切换</p>\n</blockquote>\n<ul>\n<li>s1.split(char a)</li>\n</ul>\n<blockquote>\n<p>以a作为分隔符分割字符串s1，将结果作为字符串数组返回</p>\n<p>String [] s= s1.split(“ “);</p>\n<p>多种分隔符用”|”分割，(“a”|”b”)</p>\n<p>以”.””|”作为分隔符时要加”\\“，即(\\.)(\\|)</p>\n</blockquote>\n<h3 id=\"StringBuilder-和-StringBuffer\"><a href=\"#StringBuilder-和-StringBuffer\" class=\"headerlink\" title=\"StringBuilder 和 StringBuffer\"></a>StringBuilder 和 StringBuffer</h3><p>StringBuilder：线程不安全，效率高<br>StringBuffer：线程安全，效率低<br>两者基本相同</p>\n<p>String无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。</p>\n<p>用StringBuffer/StringBuilder能够很好解决string的扩展问题</p>\n<ul>\n<li><p>StringBuilder sb= new StringBuilder();</p>\n</li>\n<li><p>sb.append(“1”);</p>\n<blockquote>\n<p>扩展字符串<br>其返回值为StringBuilder,因此可以连续调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; // JDK源码</span><br><span class=\"line\">&gt; @Override</span><br><span class=\"line\">&gt; public StringBuilder append(String str) &#123;</span><br><span class=\"line\">&gt;     super.append(str);</span><br><span class=\"line\">&gt;     return this;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; // 因此可以使用</span><br><span class=\"line\">&gt; sb.append(&quot;1&quot;).append(&quot;2&quot;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>sb.toString();</p>\n<blockquote>\n<p>将StringBuilder形成字符串，可作为函数的String返回值</p>\n</blockquote>\n</li>\n<li><p>sb.delete(int start , int end);</p>\n<blockquote>\n<p>删除下标为[start,end)的字符</p>\n</blockquote>\n</li>\n<li><p>sb.reverse();</p>\n<blockquote>\n<p>反转sb</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"容量机制\"><a href=\"#容量机制\" class=\"headerlink\" title=\"容量机制\"></a>容量机制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）</span><br><span class=\"line\">- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度</span><br><span class=\"line\">- 扩容为当前容量*2+2</span><br></pre></td></tr></table></figure>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>对象变量是对象的<strong>管理者</strong></p>\n<ul>\n<li>T tem = new T();</li>\n</ul>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><ul>\n<li>定义：类内部的变量</li>\n<li>特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数</li>\n<li>若没有初始化，则会自动被赋值(0)</li>\n<li>初始化<ul>\n<li>定义时就可以给出初始值</li>\n<li>对象变量的0值表示没有管理任何对象，也可以主动给null值</li>\n<li>定义初始化可以调用函数，可以使用已经定义的成员变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tint b=f();</span><br><span class=\"line\">\tint f() &#123;return 1;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li>名字和类名字完全相同，创建对象时会自动调用</li>\n<li>没有返回值</li>\n<li>调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句</li>\n</ul>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><ul>\n<li>定义：同名但参数列表不同的函数</li>\n<li>可以有多个构造函数，但参数列表要不同</li>\n<li>构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tT() &#123;a=2;&#125;</span><br><span class=\"line\">\tT(int a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis();</span><br><span class=\"line\">\t\tthis.a=a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1-&gt;2-&gt;3，调用过程为：T(int a)-&gt;T()-&gt;int a=1;-&gt;执行T()-&gt;执行T(int a)</p>\n<h3 id=\"访问属性\"><a href=\"#访问属性\" class=\"headerlink\" title=\"访问属性\"></a>访问属性</h3><ul>\n<li>public (同c++)</li>\n<li>private (同c++)</li>\n<li>protected (同c++)</li>\n<li>friendly</li>\n</ul>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h4><ul>\n<li>任何人都可以直接使用<ul>\n<li>任何函数或定义初始化中可以使用</li>\n<li>使用是指调用、访问、定义变量</li>\n</ul>\n</li>\n<li>public类必须定义在自己的文件里</li>\n<li>一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)</li>\n</ul>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><ul>\n<li>只有类的内部能够访问<ul>\n<li>类的成员函数</li>\n<li>定义初始化</li>\n</ul>\n</li>\n<li>限制是针对类而非对象<ul>\n<li>对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"friendly\"><a href=\"#friendly\" class=\"headerlink\" title=\"friendly\"></a>friendly</h4><ul>\n<li>未加private或public声明的成员 (即<strong>默认值</strong>)</li>\n<li>属于同一个包内的所有类都可以访问</li>\n</ul>\n<h3 id=\"System-out-println\"><a href=\"#System-out-println\" class=\"headerlink\" title=\"System.out.println\"></a>System.out.println</h3><p>正常情况下，调用System.out.println直接输出类的对象，则会输出其地址</p>\n<p>若是在类中包含 public String toString 函数，则在println时自动调用该函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T&#123;</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">\tpublic String toString () &#123;return &quot;&quot;+c;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h2><h3 id=\"时间处理：\"><a href=\"#时间处理：\" class=\"headerlink\" title=\"时间处理：\"></a>时间处理：</h3><h4 id=\"java-util-Date\"><a href=\"#java-util-Date\" class=\"headerlink\" title=\"java.util.Date\"></a>java.util.Date</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG\" alt=\"mark\"></p>\n<ul>\n<li>对象表示一个特定的瞬间，精确到毫秒</li>\n<li>时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long</li>\n</ul>\n<h4 id=\"DateFormat-SimpleDateFormat\"><a href=\"#DateFormat-SimpleDateFormat\" class=\"headerlink\" title=\"DateFormat, SimpleDateFormat\"></a>DateFormat, SimpleDateFormat</h4><p>java.text.*</p>\n<ul>\n<li>用来将字符串和时间相互转换</li>\n<li>DateFormat 是抽象类，无法实例化对象</li>\n<li>SimpleDateFormat非抽象类</li>\n</ul>\n<p>使用方法（详见API文档）</p>\n<ol>\n<li><p>已知毫秒转相应时间和字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);</span><br><span class=\"line\">DateFormat df1 = new SimpleDateFormat(&quot;yy-MM-dd hh:mm:ss&quot;);</span><br><span class=\"line\">Date d = new Date(1321454564);</span><br><span class=\"line\">String str=df1.format(d);</span><br><span class=\"line\">System.out.println(str);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知字符串及输入格式转毫秒数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str2 = &quot;1977-07-07&quot;;</span><br><span class=\"line\">DateFormat df2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tDate d2 = df2.parse(str2);</span><br><span class=\"line\">\tSystem.out.println(d2);</span><br><span class=\"line\">&#125; catch (ParseException e) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated catch block</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Calendar，GregorianCalendar-日历类\"><a href=\"#Calendar，GregorianCalendar-日历类\" class=\"headerlink\" title=\"Calendar，GregorianCalendar 日历类\"></a>Calendar，GregorianCalendar 日历类</h4><p>java.util.*</p>\n<ul>\n<li>Calendar是抽象类，无法实例化对象</li>\n<li>GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统</li>\n<li>Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期</li>\n<li>注意<ul>\n<li>月份：1月是0，2月是1，…12月是11<ul>\n<li>星期：周日是1，周一是2…周六是7</li>\n<li>可以使用 Calendar.FEBRUARY 表示数字</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>使用方法：（详见API文档）</p>\n<ol>\n<li><p>整体设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c = new GregorianCalendar();</span><br><span class=\"line\">c.set(2001, Calendar.FEBRUARY ,15);</span><br><span class=\"line\">Date date = c.getTime();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单独设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.set(Calendar.YEAR , 2001);</span><br><span class=\"line\">c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);</span><br><span class=\"line\">// 未设置参数则自动采用当前时间 (日期、时分秒等)</span><br><span class=\"line\">System.out.println(c.get(Calendar.YEAR));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用Date赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.setTime(new Date());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.add(Calendar.YEAR, 30);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"File-类\"><a href=\"#File-类\" class=\"headerlink\" title=\"File 类\"></a>File 类</h3><p>java.io.File:文件和目录路径名的抽象表现形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 通过File对象可以访问、修改文件属性</span><br><span class=\"line\">- 可以创建空文件或目录</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = new File(&quot;d:/aaa/bbb/ccc&quot;);</span><br><span class=\"line\">f.mkdir();  // 若父目录存在则创建</span><br><span class=\"line\">f.mkdirs(); // 若父目录不存在则自动创建父目录</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><ul>\n<li><p>容器类的两个类型：</p>\n<p>1 . 容器的类型</p>\n<p>2 . 元素的类型</p>\n</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li><p>import java.util.ArrayList;</p>\n</li>\n<li><p>特点：元素可以相同，元素以与进入的顺序排序</p>\n</li>\n<li><p>基础类型：存放值</p>\n</li>\n<li><p>非基础类型：作为管理者，存放地址</p>\n</li>\n<li><p>定义：</p>\n<p>ArrayList notes = new ArrayList();</p>\n</li>\n</ul>\n<h4 id=\"常用操作-1\"><a href=\"#常用操作-1\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>notes.add(int location, String s);</li>\n</ul>\n<blockquote>\n<p>向下标为location的位置中插入元素</p>\n<p>location可省略，默认为末尾</p>\n</blockquote>\n<ul>\n<li>notes.size();</li>\n</ul>\n<blockquote>\n<p>返回容器中存放元素数目</p>\n</blockquote>\n<ul>\n<li>notes.get(int index);</li>\n</ul>\n<blockquote>\n<p>返回下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>nodes.remove(int index);</li>\n</ul>\n<blockquote>\n<p>移除下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>notes.toArray(String []a);</li>\n</ul>\n<blockquote>\n<p>将notes里所有元素依次填入a中</p>\n</blockquote>\n<h4 id=\"for-each循环\"><a href=\"#for-each循环\" class=\"headerlink\" title=\"for-each循环\"></a>for-each循环</h4><p>若ArrayList存放的非基础类型，则for-each中可以修改值</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><ul>\n<li>import java.util.HashSet</li>\n<li>特点：元素均不相同，不排序，与进入的顺序无关</li>\n</ul>\n<h3 id=\"Hash表-散列表\"><a href=\"#Hash表-散列表\" class=\"headerlink\" title=\"Hash表(散列表)\"></a>Hash表(散列表)</h3><ul>\n<li>import java.util.HashMap;</li>\n<li>HashMap &lt; Key, Value &gt; a=new HashMap &lt; Key,Value &gt; ();<br>数据以一对值放进去，一个为键(KEY),一个为值(value)<br>值对应键</li>\n<li>键不能重复，只留相同的最后一个，元素不以先后排序</li>\n</ul>\n<h4 id=\"常用操作-2\"><a href=\"#常用操作-2\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>a.put(Key k1, Value v1);</li>\n</ul>\n<blockquote>\n<p>向HashMap里添加元素，键k1对应值为v1</p>\n</blockquote>\n<ul>\n<li>a.get(Key k);</li>\n</ul>\n<blockquote>\n<p>返回键k对应的值，若为空，则返回null</p>\n</blockquote>\n<ul>\n<li>a.containsKey(Key k);</li>\n</ul>\n<blockquote>\n<p>查询是否存在键为k的数据</p>\n</blockquote>\n<ul>\n<li>a.keySet();</li>\n</ul>\n<blockquote>\n<p>返回key的集合</p>\n<p>可以通过 a.keySet().size()获取存放的键的数目</p>\n<p>通过keySet使用for-each循环</p>\n</blockquote>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li><p>extends</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class son extends parent</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>java只允许单继承，一个类只能有一个父类</strong></p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>父类成员访问属性</th>\n<th>在父类中的含义</th>\n<th>在子类中的含义</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>对所有人开放</td>\n<td>对所有人开放</td>\n<td></td>\n</tr>\n<tr>\n<td>protected</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td></td>\n</tr>\n<tr>\n<td>缺省</td>\n<td>只有包内其它类可以访问</td>\n<td>如果子类与父类在同一个包内：只有包内其它类可以访问</td>\n<td>否则：相当于private，不能访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>只有自己可以访问</td>\n<td>不能访问</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>子类同样继承了父类的private成员，只是子类无法访问！<br>但子类可以通过调用父类的非private函数来间接修改父类的private成员变量</p>\n<h3 id=\"继承VS组合\"><a href=\"#继承VS组合\" class=\"headerlink\" title=\"继承VS组合\"></a>继承VS组合</h3><ul>\n<li>“is-a”关系使用继承<ul>\n<li>如：Bird类继承自Animal类</li>\n</ul>\n</li>\n<li>“has-a”关系使用组合<ul>\n<li>如：Computer类包含CPU类，每个Computer对象都有一个CPU对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><p>本质：一个<strong>关键字</strong>，类似this(this的本质为指针),是直接父类的引用</p>\n<p>用法<br>1 . 直接引用</p>\n<p>相当于指向当前对象的父类，用”.”访问父类的成员</p>\n<p>2 . 子类成员变量或方法与父类同名时，用super加以区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tvoid a();</span><br><span class=\"line\">\tvoid b()&#123;</span><br><span class=\"line\">\t\ta();   // son的a函数</span><br><span class=\"line\">\t\tsuper.a();  // parent的a函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3 . 调用父类的构造函数</p>\n<p>规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数</p>\n<p>子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tson(int a1)&#123;</span><br><span class=\"line\">\t\tsuper(a1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同名变量\"><a href=\"#同名变量\" class=\"headerlink\" title=\"同名变量\"></a>同名变量</h3><p>若没有明确指明，则在谁的成员函数中就使用谁的成员变量</p>\n<h3 id=\"子类和子类型\"><a href=\"#子类和子类型\" class=\"headerlink\" title=\"子类和子类型\"></a>子类和子类型</h3><ul>\n<li>类定义了类型</li>\n<li>子类定义了子类型 (son是parent的一个子类型)</li>\n<li>子类对象可以被当做父类的对象使用<ul>\n<li>赋值给父类变量</li>\n<li>传递给需要父类对象的函数</li>\n<li>放进存放分类对象的容器里</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG\" alt=\"mark\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v1 = new Vehicle();</span><br><span class=\"line\">Vehicle v2 = new Car();</span><br><span class=\"line\">Vehicle v3 = new Bicycle();</span><br></pre></td></tr></table></figure>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>主要用来实现<strong>动态联编</strong></p>\n<p>即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了</p>\n<p>以此提高系统的灵活性和扩展性</p>\n<h3 id=\"如何实现多态\"><a href=\"#如何实现多态\" class=\"headerlink\" title=\"如何实现多态\"></a>如何实现多态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 引用变量的两种类型</span><br><span class=\"line\"></span><br><span class=\"line\">    - 编译时类型（一般是父类）</span><br><span class=\"line\">        - 由声明时的类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">    - 运行时类型（运行时具体的子类）</span><br><span class=\"line\">        - 由实际对应的对象类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">- 三个必要条件</span><br><span class=\"line\">    - 要有继承</span><br><span class=\"line\">    - 要有方法重写</span><br><span class=\"line\">    - 父类引用指向子类对象</span><br></pre></td></tr></table></figure>\n<h3 id=\"多态变量\"><a href=\"#多态变量\" class=\"headerlink\" title=\"多态变量\"></a>多态变量</h3><ul>\n<li>对象变量能够保存不止一种的对象</li>\n<li>可以保存声明类型的对象或是声明类型的子类的对象</li>\n<li>子类对象赋给父类变量，发生<strong>向上造型</strong></li>\n</ul>\n<h3 id=\"造型-cast\"><a href=\"#造型-cast\" class=\"headerlink\" title=\"造型 cast\"></a>造型 cast</h3><p>造型(cast)：把一个类型的对象赋值给另一个类型的变量</p>\n<ul>\n<li>子类对象可以复制给父类变量<ul>\n<li>与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象</li>\n</ul>\n</li>\n<li>父类对象不能赋值给子类变量</li>\n<li>可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行</li>\n<li>类型转换 ！= 造型<ul>\n<li>类型转换中对象发生改变，如 int i=(int)10.2;</li>\n<li>造型中对象本身没有改变，只是改变了看待它的方式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v;</span><br><span class=\"line\">Car car = new Car();</span><br><span class=\"line\">v=car;  //可以</span><br><span class=\"line\">c=v;   //编译错误</span><br><span class=\"line\">c=(Car)v // 编译通过</span><br><span class=\"line\"></span><br><span class=\"line\">若</span><br><span class=\"line\">Vehicle v=new Vehicle();</span><br><span class=\"line\">Car car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常</span><br></pre></td></tr></table></figure>\n<h4 id=\"向上造型\"><a href=\"#向上造型\" class=\"headerlink\" title=\"向上造型\"></a>向上造型</h4><ul>\n<li>子类对象当做父类对象使用</li>\n<li>向上造型是默认的，不需要运算符</li>\n<li>向上造型是安全的</li>\n</ul>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数</p>\n<ul>\n<li>静态绑定：根据变量声明类型决定</li>\n<li>动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )</li>\n<li>默认使用动态绑定</li>\n<li>成员函数中调用其它成员函数通过this变量调用</li>\n</ul>\n<h3 id=\"覆盖-override\"><a href=\"#覆盖-override\" class=\"headerlink\" title=\"覆盖 override\"></a>覆盖 override</h3><ul>\n<li>覆盖关系：子类和父类中存在名称和参数表完全相同的函数</li>\n<li>通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数</li>\n</ul>\n<h3 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h3><ul>\n<li>所有的类都继承自Object类</li>\n<li>几乎所有OOP都有Object类（除c++）</li>\n</ul>\n<h4 id=\"Object类的函数-部分\"><a href=\"#Object类的函数-部分\" class=\"headerlink\" title=\"Object类的函数(部分)\"></a>Object类的函数(部分)</h4><ul>\n<li>toString()</li>\n<li>equals()</li>\n</ul>\n<h3 id=\"多态的内存分析\"><a href=\"#多态的内存分析\" class=\"headerlink\" title=\"多态的内存分析\"></a>多态的内存分析</h3><p>1 . 基本的继承关系和方法调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：Animal  有voice方法</span><br><span class=\"line\">- 子类：Cat 重写voice方法，自己有catchMouse方法</span><br><span class=\"line\">- 测试：分别声明父类和子类变量并指向子类对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void showVoice(Animal c) &#123;</span><br><span class=\"line\">\t\tc.voice();</span><br><span class=\"line\">\t\tif(c instanceof Cat)</span><br><span class=\"line\">\t\t\t((Cat) c).catchMouse();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tAnimal a=new Cat();</span><br><span class=\"line\">\t\tCat cat=(Cat)a;</span><br><span class=\"line\">\t\tTest.showVoice(cat);</span><br><span class=\"line\">\t\tTest.showVoice(a);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid voice() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Cat extends Animal&#123;</span><br><span class=\"line\">\tvoid voice() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;miao&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tvoid catchMouse() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG\" alt=\"mark\"></p>\n<p>2 . 深化多态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法</span><br><span class=\"line\">- 子类：MyServlet 重写了doGet方法</span><br><span class=\"line\">- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HttpServlet &#123;</span><br><span class=\"line\">\tpublic void service() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.service()&quot;);</span><br><span class=\"line\">\t\tdoGet();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class MyServlet extends HttpServlet &#123;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;MyServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tHttpServlet s = new MyServlet();</span><br><span class=\"line\">\t\ts.service();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出结果：</span><br><span class=\"line\">// HttpServlet.service()</span><br><span class=\"line\">// MyServlet.doGet()</span><br></pre></td></tr></table></figure>\n<p>原因分析：<br>函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG\" alt=\"mark\"></p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><h3 id=\"消除代码复制\"><a href=\"#消除代码复制\" class=\"headerlink\" title=\"消除代码复制\"></a>消除代码复制</h3><ul>\n<li><p>代码复制是不良设计的一种表现</p>\n<p>解决方法：使用函数封装重复的代码</p>\n</li>\n</ul>\n<h3 id=\"增加可扩展性\"><a href=\"#增加可扩展性\" class=\"headerlink\" title=\"增加可扩展性\"></a>增加可扩展性</h3><ul>\n<li><p>后期的可维护性</p>\n<p>解决方法：用封装降低耦合，用接口实现聚合，借助类继承</p>\n<p>耦合：类和类之间的关系</p>\n<p>耦合越低越好</p>\n</li>\n</ul>\n<h2 id=\"抽象和接口\"><a href=\"#抽象和接口\" class=\"headerlink\" title=\"抽象和接口\"></a>抽象和接口</h2><p>关键词：<strong>abstract</strong> (抽象)</p>\n<blockquote>\n<p>public abstract class a</p>\n</blockquote>\n<ul>\n<li>抽象函数：表达概念而<strong>无法实现具体代码</strong>的函数</li>\n<li>抽象类：表达概念而<strong>无法构造出实体</strong>的类</li>\n<li>为什么需要抽象类<ul>\n<li><strong>模板模式</strong>，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展</li>\n<li><strong>通过抽象类，可以避免子类设计的随意性</strong>，严格限制子类的设计，使得子类之间更加通用。</li>\n</ul>\n</li>\n<li>抽象方法的意义：<strong>使方法的设计和实现分离！</strong></li>\n<li>要点：<ul>\n<li>有抽象函数的类一定是抽象类<ul>\n<li>抽象类<strong>不能制造对象</strong>，但可以定义变量</li>\n</ul>\n</li>\n<li>任何继承了抽象类的非抽象类对象可以赋值给抽象类变量</li>\n<li>抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用</li>\n<li>继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>关键词：<strong>interface</strong></p>\n<blockquote>\n<p>public interface a{}</p>\n</blockquote>\n<ul>\n<li>接口是纯抽象类(接口中只有常量、抽象方法)</li>\n<li>所有成员变量都是public abstract static final （默认的，可以不写）</li>\n<li>接口意义：设计和实现分离，利于大项目制作</li>\n<li>接口变量的含义为任何实现了接口的对象</li>\n</ul>\n<p>关键词：<strong>implements</strong></p>\n<blockquote>\n<p>public class b implements a{}</p>\n</blockquote>\n<ul>\n<li>类可以实现很多接口</li>\n<li>接口可以继承接口，不能继承类</li>\n<li>接口不能实现接口</li>\n<li>接口和抽象类<ul>\n<li>接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了<strong>规范和具体实现的分离</strong></li>\n<li><strong>接口就是规范，定义了一组规则</strong></li>\n<li><strong>接口的本质是契约</strong>，制定好后大家都遵守</li>\n<li>项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要<strong>面向接口编程</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向接口的编程方式\"><a href=\"#面向接口的编程方式\" class=\"headerlink\" title=\"面向接口的编程方式\"></a>面向接口的编程方式</h4><ul>\n<li>设计程序时先定义接口，再实现类</li>\n<li>任何需要在函数间传入传出的一定是接口而不是具体的类</li>\n<li>Java成功的关键之一，极适合多人同时写一个大程序</li>\n<li>Java被批评的要点之一，代码量膨胀地很快</li>\n</ul>\n<h2 id=\"控制反转与MVC模式\"><a href=\"#控制反转与MVC模式\" class=\"headerlink\" title=\"控制反转与MVC模式\"></a>控制反转与MVC模式</h2><h3 id=\"Swing\"><a href=\"#Swing\" class=\"headerlink\" title=\"Swing\"></a>Swing</h3><p>容器、部件</p>\n<ul>\n<li><p>容器继承自部件，因此可以作为部件被放入其它容器中</p>\n</li>\n<li><p>容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整</p>\n</li>\n<li><p>JFrame使用BorderLayout管理部件，并且将界面划分为五个区域</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG\" alt=\"mark\"></p>\n</li>\n<li><p>容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件</p>\n</li>\n</ul>\n<h3 id=\"控制反转\"><a href=\"#控制反转\" class=\"headerlink\" title=\"控制反转\"></a>控制反转</h3><ul>\n<li>按钮公布一个listener接口和一对注册、注销函数</li>\n<li>实现接口后将把listener对象注册在按钮上</li>\n<li>一旦按钮被按下，就会反过来调用listener对象的函数</li>\n</ul>\n<h3 id=\"内部类-innerclasses\"><a href=\"#内部类-innerclasses\" class=\"headerlink\" title=\"内部类 innerclasses\"></a>内部类 innerclasses</h3><p>定义在别的类内部、函数内部的类</p>\n<h4 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问</span><br><span class=\"line\">- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场合\"><a href=\"#使用场合\" class=\"headerlink\" title=\"使用场合\"></a>使用场合</h4><p>在内部类只为所在外部类提供服务的情况优先使用</p>\n<h4 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h4><h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>（可以使用private,public,protected修饰）</p>\n<h6 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h6><p><code>- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Outer &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tFace f=new Face();</span><br><span class=\"line\">\t\tFace.Nose n= f.new Nose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Face &#123;</span><br><span class=\"line\">\tint type;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass Nose&#123;</span><br><span class=\"line\">\t\tString type;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvoid breath() &#123;</span><br><span class=\"line\">\t\t\tFace.this.type=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 静态内部类对象存在时，不一定存在对应的外部类对象</span><br><span class=\"line\">    - 静态内部类无法直接访问外部类实例方法</span><br><span class=\"line\">    - 静态内部类看作**外部类的一个静态成员**</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Face f= new Face();</span><br><span class=\"line\">// Nose为非静态内部类</span><br><span class=\"line\">Face.Nose n=f.new Nose();</span><br><span class=\"line\">// Ear为静态内部类</span><br><span class=\"line\">Face.Ear e=new Face.Ear();</span><br></pre></td></tr></table></figure>\n<h6 id=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"><a href=\"#局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\" class=\"headerlink\" title=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"></a>局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 访问函数的本地变量时只能访问函数的final变量</span><br></pre></td></tr></table></figure>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>适用于只需要使用一次的类，例如：键盘监听操作等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new 父类构造器(实参) 实现接口()&#123;</span><br><span class=\"line\">\t匿名内部类类体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名类可以继承某类，也可以实现接口</li>\n<li>Swing的消息机制广泛使用匿名类</li>\n</ul>\n<h3 id=\"MVC设计模式\"><a href=\"#MVC设计模式\" class=\"headerlink\" title=\"MVC设计模式\"></a>MVC设计模式</h3><ul>\n<li><p>数据、表现和控制</p>\n<p>三者分离</p>\n<ul>\n<li>M = Model 模型</li>\n<li>V = View 表现</li>\n<li>C = Control 控制</li>\n</ul>\n</li>\n<li><p>模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新</p>\n</li>\n<li><p>表现：从模型获取数据，根据数据画出表现</p>\n</li>\n<li><p>控制：从用户得到输入，根据输入调整数据</p>\n</li>\n</ul>\n<h3 id=\"异常机制-Exception\"><a href=\"#异常机制-Exception\" class=\"headerlink\" title=\"异常机制 Exception\"></a>异常机制 Exception</h3><h4 id=\"常见的异常\"><a href=\"#常见的异常\" class=\"headerlink\" title=\"常见的异常\"></a>常见的异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户输入错误</span><br><span class=\"line\">设备错误</span><br><span class=\"line\">硬件问题：如打印机关掉、服务器问题</span><br><span class=\"line\">磁盘满了</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常Exception\"><a href=\"#异常Exception\" class=\"headerlink\" title=\"异常Exception\"></a>异常Exception</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java提供的用来处理程序中错误的一种机制</span><br><span class=\"line\"></span><br><span class=\"line\">Java采用**面向对象** 方式来处理异常。处理过程：</span><br><span class=\"line\">    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE</span><br><span class=\"line\">    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"常见异常\"><a href=\"#常见异常\" class=\"headerlink\" title=\"常见异常\"></a>常见异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. ArithmeticException</span><br><span class=\"line\">    例如试图除以0</span><br><span class=\"line\">2. NullPointerException</span><br><span class=\"line\">    对象为null但调用了对象的方法或属性</span><br><span class=\"line\">3. ClassCastException</span><br><span class=\"line\">    转型错误，解决：使用istanceof判断</span><br><span class=\"line\">4. ArrayIndexOutOfBoundsException</span><br><span class=\"line\">    访问元素超出数组长度</span><br><span class=\"line\">5. NumberFormatException</span><br><span class=\"line\">    数字格式异常，如把String转换成int</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常的处理方法：\"><a href=\"#异常的处理方法：\" class=\"headerlink\" title=\"异常的处理方法：\"></a>异常的处理方法：</h4><p><code>捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常</code></p>\n<h4 id=\"方法重写中声明异常原则：\"><a href=\"#方法重写中声明异常原则：\" class=\"headerlink\" title=\"方法重写中声明异常原则：\"></a>方法重写中声明异常原则：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**子类声明的异常范围不能超出父类的范围**</span><br><span class=\"line\">    - 父类没有声明异常，子类也不能</span><br><span class=\"line\">    - 不能抛出 原有方法抛出的父类或上层类</span><br><span class=\"line\">    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类</span><br><span class=\"line\">- 从Exception类或它的子类派生一个子类</span><br><span class=\"line\">- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">建议：</span><br><span class=\"line\">    - 避免使用异常机制代替错误处理</span><br><span class=\"line\">    - 处理异常不能代替简单测试</span><br><span class=\"line\">    - 不要进行**小力度**的异常处理（如一行一个try catch）</span><br><span class=\"line\">    - 异常往往在**高层**处理</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>JAVA学习过程中的简要笔记</p>\n<p>从已有C++基础的前提下开始学习java</p>\n<p>内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等</p>","more":"<h3 id=\"各版本和体系架构\"><a href=\"#各版本和体系架构\" class=\"headerlink\" title=\"各版本和体系架构\"></a>各版本和体系架构</h3><ul>\n<li>J2EE<ul>\n<li>JAVA 2(to) Enterprise Edition:</li>\n<li>定位在服务器端的应用</li>\n</ul>\n</li>\n<li>J2SE<ul>\n<li>JAVA 2(to) Standard Edition:</li>\n<li>定位在个人计算机的应用</li>\n</ul>\n</li>\n<li>J2EE<ul>\n<li>JAVA 2(to) Micro Edition:</li>\n<li>定位在消费性电子产品的应用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- JDK</span><br><span class=\"line\">    - Java Development Kit Java开发工具包</span><br><span class=\"line\">- JRE</span><br><span class=\"line\">    - Java Runtime Environment java运行环境</span><br><span class=\"line\">- JVM</span><br><span class=\"line\">    - Java Virtual Machine java虚拟机</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG\" alt=\"数据类型\"></p>\n<h3 id=\"整型变量\"><a href=\"#整型变量\" class=\"headerlink\" title=\"整型变量\"></a>整型变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表示形式</span><br><span class=\"line\">    - 十进制</span><br><span class=\"line\">    - 八进制：以0开头</span><br><span class=\"line\">    - 十六进制：以0x或0X开头</span><br></pre></td></tr></table></figure>\n<p>整型默认为int型，long型常量后加”l”或”L”</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>1字节</td>\n<td>-128~127</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2字节</td>\n<td>-$2^15$~$2^15-1$</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4字节</td>\n<td>-$2^31$~$2^31-1$</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8字节</td>\n<td>-$2^63$~$2^63-1$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>超过long的数字使用<strong>BigInteger</strong>类</li>\n</ul>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>4字节</td>\n<td>-3.403E38~3.403E38</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>-1.798E308~1.798E308</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>默认为double</li>\n<li>若需要不产生舍入误差的精确计算，需要用<strong>BigDecimal</strong>类</li>\n<li>double变float：在数字后加”f”或”F”</li>\n</ul>\n<h3 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h3><ul>\n<li>char采用Unicode编码表，，占用2个字节</li>\n<li>同c++,可以和整数相互转型，可以使用转义字符</li>\n</ul>\n<h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><ul>\n<li>占1位(非字节)</li>\n<li>java中boolean无法和整数之间转换</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 变量使用前需要声明</span><br></pre></td></tr></table></figure>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>类似c++的const</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- final修饰变量，则该变量无法修改</span><br><span class=\"line\">- final修饰类，则说明该类不能被继承，不能有子类</span><br><span class=\"line\">    - 如 Math、String</span><br><span class=\"line\">- final修饰方法，则该方法不能被子类重写，但是可以被重载</span><br></pre></td></tr></table></figure>\n<p><strong>命名规范</strong>：</p>\n<ul>\n<li>变量、方法名：<ul>\n<li>首字母小写+驼峰原则</li>\n</ul>\n</li>\n<li>常量：<ul>\n<li>大写字母+下划线</li>\n</ul>\n</li>\n<li>类名：<ul>\n<li>首字母大写+驼峰原则</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 算术运算符： +,-,*,/,%,++,--</span><br><span class=\"line\">    - 不同于c++, java中浮点数可以使用&quot;%&quot;运算符！</span><br><span class=\"line\">    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串</span><br><span class=\"line\">- 赋值运算符： =</span><br><span class=\"line\">- 关系运算符： &lt;,&gt;,&lt;=,&gt;=,==,!=, instanceof</span><br><span class=\"line\">    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）</span><br><span class=\"line\">        - 返回值：boolean  true代表属于</span><br><span class=\"line\">        - 使用： boolean ret= a instanceof A;</span><br><span class=\"line\">- 逻辑运算符： &amp;&amp;,||,!</span><br><span class=\"line\">    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算</span><br><span class=\"line\">- 位运算符： &amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</span><br><span class=\"line\">    - &gt;&gt; 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;1 右移一位： 00111</span><br><span class=\"line\">        - 10010&gt;&gt;1 右移一位： 11001</span><br><span class=\"line\">    - &gt;&gt;&gt; 表示无符号右移：左边以0补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;&gt;1 右移一位：00111   (正数时和&quot;&gt;&gt;&quot;相同)</span><br><span class=\"line\">        - 10010&gt;&gt;&gt;1 右移一位：01001</span><br><span class=\"line\">    - &lt;&lt; 没有 &quot;&lt;&lt;&lt;&quot;</span><br><span class=\"line\">- 条件运算符：  ?:</span><br><span class=\"line\">- 扩展赋值运算符： +=,-=,*=,/=,%=</span><br></pre></td></tr></table></figure>\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><ul>\n<li>在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型</li>\n<li>JDK7之后，switch表达式结果还可以是字符串</li>\n<li>使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcase 1: break;</span><br><span class=\"line\">\tcase 2: System.out.println(1);</span><br><span class=\"line\">\tdefault: break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h3><ul>\n<li>if,while语句同c++</li>\n<li>while中可以使用break,continue关键字</li>\n<li>goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break</li>\n<li>可以使用带标签的continue和break<ul>\n<li>带标签的continue：跳转继续执行标签指向的循环</li>\n<li>带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"方法-method，function\"><a href=\"#方法-method，function\" class=\"headerlink\" title=\"方法 method，function\"></a>方法 method，function</h3><p>[修饰符1 修饰符2..] 返回值 方法名(形参列表){<br>语句<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- **Java中只有值传递！**</span><br><span class=\"line\">- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身</span><br><span class=\"line\">    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存分析\"><a href=\"#内存分析\" class=\"headerlink\" title=\"内存分析\"></a>内存分析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 栈</span><br><span class=\"line\">    - 存放：局部变量</span><br><span class=\"line\">    - 自动分配连续的空间</span><br><span class=\"line\">- 堆</span><br><span class=\"line\">    - 存放new出来的对象</span><br><span class=\"line\">    - 空间不连续</span><br><span class=\"line\">- 方法区</span><br><span class=\"line\">    - 包含于堆区</span><br><span class=\"line\">    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid teach() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid study() &#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tStudent st1=new Student();</span><br><span class=\"line\">\t\tStudent st2=new Student();</span><br><span class=\"line\">\t\tst1.age=18;</span><br><span class=\"line\">\t\tst1.name=&quot;张三&quot;;</span><br><span class=\"line\">\t\tst2.age=30;</span><br><span class=\"line\">\t\tst2.name=&quot;李四&quot;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTeacher t1=new Teacher();</span><br><span class=\"line\">\t\tt1.age=30;</span><br><span class=\"line\">\t\tt1.name=&quot;李四&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG\" alt=\"mark\"></p>\n<h2 id=\"包-package\"><a href=\"#包-package\" class=\"headerlink\" title=\"包 package\"></a>包 package</h2><p>定义：Java的类库管理机制，借助文件系统的目录</p>\n<ul>\n<li><p>为什么需要使用Package</p>\n<ul>\n<li>为了解决类的重名问题</li>\n<li>为了便于管理类：合适的类位于合适的包</li>\n</ul>\n</li>\n<li><p>怎么使用package</p>\n<ul>\n<li><p>通常是类的第一句非注释性语句</p>\n<ul>\n<li><p>规则：通常域名倒过来写，加上模块名</p>\n<blockquote>\n<p>com.qq.test</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字</p>\n<p>包名称内可以带有”.”，每个”.”代表文件系统的下一级目录</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package p1;</span><br><span class=\"line\">package p1.s1;</span><br></pre></td></tr></table></figure>\n<p>则在文件系统中，p1文件夹下有个名为s1的文件夹包</p>\n<h3 id=\"使用其它包里的类\"><a href=\"#使用其它包里的类\" class=\"headerlink\" title=\"使用其它包里的类:\"></a>使用其它包里的类:</h3><p>1 . 使用<strong>import</strong>预先声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import package1.T;  // 引入package1包里的T</span><br><span class=\"line\">import package2.*   // 引入package2包里的所有类</span><br><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2 . 每次使用时附带说明包的名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate package1.T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"API文档\"><a href=\"#API文档\" class=\"headerlink\" title=\"API文档\"></a>API文档</h2><p>使用<strong>JAVADOC</strong>生成API文档</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 解决代码文档分离的问题</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特殊的注释<ul>\n<li>文档注释： “/**”</li>\n</ul>\n</li>\n<li>常用的java注释标签<ul>\n<li>@Author 作者</li>\n<li>@version 版本</li>\n<li>@param 参数</li>\n<li>@return 返回值含义</li>\n<li>@throws 抛出异常描述</li>\n<li>@deprecated 废弃，建议用户不再使用该方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 类的描述、功能</span><br><span class=\"line\"> * @author aa</span><br><span class=\"line\"> * @version 1.0</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾回收机制-Garbage-Collection\"><a href=\"#垃圾回收机制-Garbage-Collection\" class=\"headerlink\" title=\"垃圾回收机制 (Garbage Collection)\"></a>垃圾回收机制 (Garbage Collection)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 对象空间的分配</span><br><span class=\"line\">    - 使用&quot;new&quot;关键字创建对象</span><br><span class=\"line\">- 对象空间的释放：</span><br><span class=\"line\">    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间</span><br><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 程序员无权调用垃圾回收器</span><br><span class=\"line\">    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行</span><br><span class=\"line\">    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"定义数组变量\"><a href=\"#定义数组变量\" class=\"headerlink\" title=\"定义数组变量\"></a>定义数组变量</h3><p>1 - &lt;类型&gt;[]&lt;数组名&gt;=new &lt;类型&gt;[元素个数];</p>\n<blockquote>\n<p>例如：</p>\n<p>int [] grade = new int [100];</p>\n<p>这样创建的数组会是默认的0值</p>\n</blockquote>\n<p>2 - &lt;类型&gt;[]&lt;数组名&gt;={元素1，元素2…};</p>\n<blockquote>\n<p>例如： int []a={1,2,3};</p>\n</blockquote>\n<p>3 - &lt;类型&gt;[]b = a; (a为同类型的数组)</p>\n<blockquote>\n<p>与c++中数组名的含义类似，数组名变量管理数组空间</p>\n<p>b和a管理同一个数组</p>\n</blockquote>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><p>1 - 所有元素的数据类型相同<br>2 - 一旦创建则不能改变大小</p>\n<h3 id=\"要求：\"><a href=\"#要求：\" class=\"headerlink\" title=\"要求：\"></a>要求：</h3><ul>\n<li>元素个数必须是整数</li>\n<li>元素个数必须给出</li>\n<li>元素个数可以是变量</li>\n</ul>\n<h3 id=\"内部成员：\"><a href=\"#内部成员：\" class=\"headerlink\" title=\"内部成员：\"></a>内部成员：</h3><p>length : 返回元素个数</p>\n<blockquote>\n<p>for(int i=0; i&lt;grade.length ; ++i)</p>\n</blockquote>\n<h3 id=\"数组和数组变量：\"><a href=\"#数组和数组变量：\" class=\"headerlink\" title=\"数组和数组变量：\"></a>数组和数组变量：</h3><ul>\n<li>数组变量为数组的管理者，而非其本身</li>\n<li>数组创建出来后交给数组变量管理</li>\n<li>数组变量之间的赋值为管理权限的赋予</li>\n<li>数组变量的比较是判断是否管理同一个数组</li>\n</ul>\n<h3 id=\"常用操作：\"><a href=\"#常用操作：\" class=\"headerlink\" title=\"常用操作：\"></a>常用操作：</h3><ol>\n<li><p>数组复制<br>System的arraycopy函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void arraycopy(Object src,</span><br><span class=\"line\">                             int srcPos,</span><br><span class=\"line\">                             Object dest,</span><br><span class=\"line\">                             int destPos,</span><br><span class=\"line\">                             int length)</span><br><span class=\"line\">// src 源数组</span><br><span class=\"line\">// srcPos 源数组开始复制的位置</span><br><span class=\"line\">// dest 目标数组</span><br><span class=\"line\">// destPos 目标数组开始复制的位置</span><br><span class=\"line\">// length 复制长度</span><br><span class=\"line\">// [srcPos,srcPos+length-1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>二分查找<br>Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口<br>Arrays.binarySearch(Object obj, Object goal);</p>\n</li>\n<li><p>填充<br>Arrays.fill(Object obj, int start, int end, Object goal)<br>将目标数组[start,end)填充为goal</p>\n</li>\n</ol>\n<h3 id=\"for-each循环：\"><a href=\"#for-each循环：\" class=\"headerlink\" title=\"for-each循环：\"></a>for-each循环：</h3><p>例如：for( int k: data )</p>\n<p>对于data数组的每一个元素，循环每一轮取一个元素作为k</p>\n<p>第一轮 k=data[0] , 第二轮 k=data[1]</p>\n<p><strong>for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值</strong></p>\n<h2 id=\"包裹类型\"><a href=\"#包裹类型\" class=\"headerlink\" title=\"包裹类型\"></a>包裹类型</h2><ul>\n<li>每种基础类型都有对应的包裹类型</li>\n<li>出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>基础类型</th>\n<th>包裹类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用处：\"><a href=\"#用处：\" class=\"headerlink\" title=\"用处：\"></a>用处：</h3><ul>\n<li>声明变量时包裹类型同基础类型</li>\n</ul>\n<blockquote>\n<p>int a=1; &lt;=&gt; Integer a=1;</p>\n</blockquote>\n<ul>\n<li>可以获取该类型的信息，如最大值最小值</li>\n</ul>\n<blockquote>\n<p>如 System.out.println(Integer.MAX_VALUE);</p>\n<p>( Integer.MAX_VALUE=2147483647 )</p>\n</blockquote>\n<ul>\n<li>Character</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数声明</th>\n<th>参数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static boolean isDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字</td>\n</tr>\n<tr>\n<td>static boolean isLetter</td>\n<td>char ch</td>\n<td>判断该字符是否是字母</td>\n</tr>\n<tr>\n<td>static boolean isLetterOrDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字或字母</td>\n</tr>\n<tr>\n<td>static boolean isLowerCase</td>\n<td>char ch</td>\n<td>判断该字符是否是小写字母</td>\n</tr>\n<tr>\n<td>static boolean isUpperCase</td>\n<td>char ch</td>\n<td>判断该字符是否是大写字母</td>\n</tr>\n<tr>\n<td>static boolean isWhitespace</td>\n<td>char ch</td>\n<td>判断该字符是否是一种空格</td>\n</tr>\n<tr>\n<td>static char toLowerCase</td>\n<td>char ch</td>\n<td>把该字符转换成小写</td>\n</tr>\n<tr>\n<td>static char toUpperCase</td>\n<td>char ch</td>\n<td>把该字符转换成大写</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>转换仅体现在返回值，原变量的值没有改变</strong></p>\n<h4 id=\"自动装箱和自动拆箱-auto-boxing-amp-unboxing\"><a href=\"#自动装箱和自动拆箱-auto-boxing-amp-unboxing\" class=\"headerlink\" title=\"自动装箱和自动拆箱 auto-boxing &amp; unboxing\"></a>自动装箱和自动拆箱 auto-boxing &amp; unboxing</h4><ul>\n<li>自动装箱<ul>\n<li>基本类型自动封装到和它相同类型的包装里</li>\n<li>本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);</li>\n</ul>\n</li>\n<li>自动拆箱<ul>\n<li>包装类对象自动转换成基本数据类型</li>\n<li>本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"缓存处理\"><a href=\"#缓存处理\" class=\"headerlink\" title=\"缓存处理\"></a><strong>缓存处理</strong></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer d1=1234;</span><br><span class=\"line\">Integer d2=1234;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d1==d2);</span><br><span class=\"line\">System.out.println(d1.equals(d2));</span><br><span class=\"line\"></span><br><span class=\"line\">Integer d3=123;</span><br><span class=\"line\">Integer d4=123;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d3==d4);</span><br><span class=\"line\">System.out.println(d3.equals(d4));</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<blockquote>\n<p>false (d1==d2)<br>true (d1.equals(d2))<br>true (d3==d4)<br>true (d3.equals(d4))</p>\n</blockquote>\n<h2 id=\"字符串-String\"><a href=\"#字符串-String\" class=\"headerlink\" title=\"字符串 String\"></a>字符串 String</h2><ul>\n<li>String是一个类，String变量是对象的管理者而非所有者</li>\n</ul>\n<h3 id=\"创建：\"><a href=\"#创建：\" class=\"headerlink\" title=\"创建：\"></a>创建：</h3><p>1 - String s = new String(“hello world”);</p>\n<p>2 - String s = “hello”;</p>\n<h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><ul>\n<li>用 “+” 连接两个字符串</li>\n</ul>\n<blockquote>\n<p>“hello “+”world” -&gt; “hello world”</p>\n</blockquote>\n<ul>\n<li>若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接</li>\n</ul>\n<blockquote>\n<p>“I am “+18 -&gt; “I am 18”</p>\n<p>1+2+”age” -&gt; “3age”</p>\n<p>“age”+1+2 -&gt; “age12”</p>\n</blockquote>\n<h3 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h3><ul>\n<li>in.next();<br>读入一个单词，以空格结束</li>\n<li>in.nextLine();<br>读入一整行</li>\n</ul>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><ul>\n<li>用 “==” ：比较两个对象是同一个字符串</li>\n</ul>\n<blockquote>\n<p>if(input == “hello”)</p>\n</blockquote>\n<ul>\n<li>用 “.equals” ：比较两个字符串的内容是否相同</li>\n</ul>\n<blockquote>\n<p>if(input.equals(“hello”))</p>\n</blockquote>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><ul>\n<li>字符串是<strong>对象</strong>，所有操作是通过“.”进行的</li>\n<li>表示对“.”左边的字符串做右边的操作</li>\n<li>字符串可以是<strong>变量</strong>也可以是<strong>常量</strong></li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p><strong>所有操作都不会对字符串本身进行修改</strong></p>\n<ul>\n<li>s1.compareTo(String s2)</li>\n</ul>\n<blockquote>\n<p>比较两个字符串大小</p>\n<p>s1&gt;s2 返回正数</p>\n<p>s1&lt;s2 返回负数</p>\n<p>s1和s2内容相同，返回0</p>\n<p>字符串长者大</p>\n<p>字符串长度相同时，从第一位开始以字典序比较</p>\n</blockquote>\n<ul>\n<li>s1.length()</li>\n</ul>\n<blockquote>\n<p>获得String的长度</p>\n</blockquote>\n<ul>\n<li>s1.charAt(int index)</li>\n</ul>\n<blockquote>\n<p>访问String里的字符</p>\n<p>返回index上的单个字符</p>\n<p>0&lt;=index&lt;=s1.length()-1</p>\n<p><strong>不能用for-each循环遍历字符串</strong></p>\n</blockquote>\n<ul>\n<li>s1.substring(int begin ,int end)</li>\n</ul>\n<blockquote>\n<p>获得 s1 下标于[begin,end)的子串</p>\n<p>end可省略，默认为s1.length()</p>\n</blockquote>\n<ul>\n<li>s1.indexOf( (char)|(String) c, int n)</li>\n</ul>\n<blockquote>\n<p>寻找c字符或字符串第一个所在位置，-1为不存在</p>\n<p>从n开始找(包括n)，n可以省略，默认为0</p>\n<p>s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()</p>\n<p>寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);</p>\n</blockquote>\n<ul>\n<li>s1.startsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的前缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.endsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的后缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.trim()</li>\n</ul>\n<blockquote>\n<p>清除s1左右两端的空格</p>\n<p>要保留清除可以 s1=s1.trim();</p>\n</blockquote>\n<ul>\n<li>s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)</li>\n</ul>\n<blockquote>\n<p>将s1中所有字符或字符串c1替换成c2</p>\n</blockquote>\n<ul>\n<li>s1.toLowerCase() s1.toUpperCase()</li>\n</ul>\n<blockquote>\n<p>s1大小写切换</p>\n</blockquote>\n<ul>\n<li>s1.split(char a)</li>\n</ul>\n<blockquote>\n<p>以a作为分隔符分割字符串s1，将结果作为字符串数组返回</p>\n<p>String [] s= s1.split(“ “);</p>\n<p>多种分隔符用”|”分割，(“a”|”b”)</p>\n<p>以”.””|”作为分隔符时要加”\\“，即(\\.)(\\|)</p>\n</blockquote>\n<h3 id=\"StringBuilder-和-StringBuffer\"><a href=\"#StringBuilder-和-StringBuffer\" class=\"headerlink\" title=\"StringBuilder 和 StringBuffer\"></a>StringBuilder 和 StringBuffer</h3><p>StringBuilder：线程不安全，效率高<br>StringBuffer：线程安全，效率低<br>两者基本相同</p>\n<p>String无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。</p>\n<p>用StringBuffer/StringBuilder能够很好解决string的扩展问题</p>\n<ul>\n<li><p>StringBuilder sb= new StringBuilder();</p>\n</li>\n<li><p>sb.append(“1”);</p>\n<blockquote>\n<p>扩展字符串<br>其返回值为StringBuilder,因此可以连续调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; // JDK源码</span><br><span class=\"line\">&gt; @Override</span><br><span class=\"line\">&gt; public StringBuilder append(String str) &#123;</span><br><span class=\"line\">&gt;     super.append(str);</span><br><span class=\"line\">&gt;     return this;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; // 因此可以使用</span><br><span class=\"line\">&gt; sb.append(&quot;1&quot;).append(&quot;2&quot;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>sb.toString();</p>\n<blockquote>\n<p>将StringBuilder形成字符串，可作为函数的String返回值</p>\n</blockquote>\n</li>\n<li><p>sb.delete(int start , int end);</p>\n<blockquote>\n<p>删除下标为[start,end)的字符</p>\n</blockquote>\n</li>\n<li><p>sb.reverse();</p>\n<blockquote>\n<p>反转sb</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"容量机制\"><a href=\"#容量机制\" class=\"headerlink\" title=\"容量机制\"></a>容量机制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）</span><br><span class=\"line\">- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度</span><br><span class=\"line\">- 扩容为当前容量*2+2</span><br></pre></td></tr></table></figure>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>对象变量是对象的<strong>管理者</strong></p>\n<ul>\n<li>T tem = new T();</li>\n</ul>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><ul>\n<li>定义：类内部的变量</li>\n<li>特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数</li>\n<li>若没有初始化，则会自动被赋值(0)</li>\n<li>初始化<ul>\n<li>定义时就可以给出初始值</li>\n<li>对象变量的0值表示没有管理任何对象，也可以主动给null值</li>\n<li>定义初始化可以调用函数，可以使用已经定义的成员变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tint b=f();</span><br><span class=\"line\">\tint f() &#123;return 1;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li>名字和类名字完全相同，创建对象时会自动调用</li>\n<li>没有返回值</li>\n<li>调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句</li>\n</ul>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><ul>\n<li>定义：同名但参数列表不同的函数</li>\n<li>可以有多个构造函数，但参数列表要不同</li>\n<li>构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tT() &#123;a=2;&#125;</span><br><span class=\"line\">\tT(int a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis();</span><br><span class=\"line\">\t\tthis.a=a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1-&gt;2-&gt;3，调用过程为：T(int a)-&gt;T()-&gt;int a=1;-&gt;执行T()-&gt;执行T(int a)</p>\n<h3 id=\"访问属性\"><a href=\"#访问属性\" class=\"headerlink\" title=\"访问属性\"></a>访问属性</h3><ul>\n<li>public (同c++)</li>\n<li>private (同c++)</li>\n<li>protected (同c++)</li>\n<li>friendly</li>\n</ul>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h4><ul>\n<li>任何人都可以直接使用<ul>\n<li>任何函数或定义初始化中可以使用</li>\n<li>使用是指调用、访问、定义变量</li>\n</ul>\n</li>\n<li>public类必须定义在自己的文件里</li>\n<li>一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)</li>\n</ul>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><ul>\n<li>只有类的内部能够访问<ul>\n<li>类的成员函数</li>\n<li>定义初始化</li>\n</ul>\n</li>\n<li>限制是针对类而非对象<ul>\n<li>对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"friendly\"><a href=\"#friendly\" class=\"headerlink\" title=\"friendly\"></a>friendly</h4><ul>\n<li>未加private或public声明的成员 (即<strong>默认值</strong>)</li>\n<li>属于同一个包内的所有类都可以访问</li>\n</ul>\n<h3 id=\"System-out-println\"><a href=\"#System-out-println\" class=\"headerlink\" title=\"System.out.println\"></a>System.out.println</h3><p>正常情况下，调用System.out.println直接输出类的对象，则会输出其地址</p>\n<p>若是在类中包含 public String toString 函数，则在println时自动调用该函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T&#123;</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">\tpublic String toString () &#123;return &quot;&quot;+c;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h2><h3 id=\"时间处理：\"><a href=\"#时间处理：\" class=\"headerlink\" title=\"时间处理：\"></a>时间处理：</h3><h4 id=\"java-util-Date\"><a href=\"#java-util-Date\" class=\"headerlink\" title=\"java.util.Date\"></a>java.util.Date</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG\" alt=\"mark\"></p>\n<ul>\n<li>对象表示一个特定的瞬间，精确到毫秒</li>\n<li>时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long</li>\n</ul>\n<h4 id=\"DateFormat-SimpleDateFormat\"><a href=\"#DateFormat-SimpleDateFormat\" class=\"headerlink\" title=\"DateFormat, SimpleDateFormat\"></a>DateFormat, SimpleDateFormat</h4><p>java.text.*</p>\n<ul>\n<li>用来将字符串和时间相互转换</li>\n<li>DateFormat 是抽象类，无法实例化对象</li>\n<li>SimpleDateFormat非抽象类</li>\n</ul>\n<p>使用方法（详见API文档）</p>\n<ol>\n<li><p>已知毫秒转相应时间和字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);</span><br><span class=\"line\">DateFormat df1 = new SimpleDateFormat(&quot;yy-MM-dd hh:mm:ss&quot;);</span><br><span class=\"line\">Date d = new Date(1321454564);</span><br><span class=\"line\">String str=df1.format(d);</span><br><span class=\"line\">System.out.println(str);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知字符串及输入格式转毫秒数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str2 = &quot;1977-07-07&quot;;</span><br><span class=\"line\">DateFormat df2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tDate d2 = df2.parse(str2);</span><br><span class=\"line\">\tSystem.out.println(d2);</span><br><span class=\"line\">&#125; catch (ParseException e) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated catch block</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Calendar，GregorianCalendar-日历类\"><a href=\"#Calendar，GregorianCalendar-日历类\" class=\"headerlink\" title=\"Calendar，GregorianCalendar 日历类\"></a>Calendar，GregorianCalendar 日历类</h4><p>java.util.*</p>\n<ul>\n<li>Calendar是抽象类，无法实例化对象</li>\n<li>GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统</li>\n<li>Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期</li>\n<li>注意<ul>\n<li>月份：1月是0，2月是1，…12月是11<ul>\n<li>星期：周日是1，周一是2…周六是7</li>\n<li>可以使用 Calendar.FEBRUARY 表示数字</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>使用方法：（详见API文档）</p>\n<ol>\n<li><p>整体设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c = new GregorianCalendar();</span><br><span class=\"line\">c.set(2001, Calendar.FEBRUARY ,15);</span><br><span class=\"line\">Date date = c.getTime();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单独设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.set(Calendar.YEAR , 2001);</span><br><span class=\"line\">c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);</span><br><span class=\"line\">// 未设置参数则自动采用当前时间 (日期、时分秒等)</span><br><span class=\"line\">System.out.println(c.get(Calendar.YEAR));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用Date赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.setTime(new Date());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.add(Calendar.YEAR, 30);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"File-类\"><a href=\"#File-类\" class=\"headerlink\" title=\"File 类\"></a>File 类</h3><p>java.io.File:文件和目录路径名的抽象表现形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 通过File对象可以访问、修改文件属性</span><br><span class=\"line\">- 可以创建空文件或目录</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = new File(&quot;d:/aaa/bbb/ccc&quot;);</span><br><span class=\"line\">f.mkdir();  // 若父目录存在则创建</span><br><span class=\"line\">f.mkdirs(); // 若父目录不存在则自动创建父目录</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><ul>\n<li><p>容器类的两个类型：</p>\n<p>1 . 容器的类型</p>\n<p>2 . 元素的类型</p>\n</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li><p>import java.util.ArrayList;</p>\n</li>\n<li><p>特点：元素可以相同，元素以与进入的顺序排序</p>\n</li>\n<li><p>基础类型：存放值</p>\n</li>\n<li><p>非基础类型：作为管理者，存放地址</p>\n</li>\n<li><p>定义：</p>\n<p>ArrayList notes = new ArrayList();</p>\n</li>\n</ul>\n<h4 id=\"常用操作-1\"><a href=\"#常用操作-1\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>notes.add(int location, String s);</li>\n</ul>\n<blockquote>\n<p>向下标为location的位置中插入元素</p>\n<p>location可省略，默认为末尾</p>\n</blockquote>\n<ul>\n<li>notes.size();</li>\n</ul>\n<blockquote>\n<p>返回容器中存放元素数目</p>\n</blockquote>\n<ul>\n<li>notes.get(int index);</li>\n</ul>\n<blockquote>\n<p>返回下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>nodes.remove(int index);</li>\n</ul>\n<blockquote>\n<p>移除下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>notes.toArray(String []a);</li>\n</ul>\n<blockquote>\n<p>将notes里所有元素依次填入a中</p>\n</blockquote>\n<h4 id=\"for-each循环\"><a href=\"#for-each循环\" class=\"headerlink\" title=\"for-each循环\"></a>for-each循环</h4><p>若ArrayList存放的非基础类型，则for-each中可以修改值</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><ul>\n<li>import java.util.HashSet</li>\n<li>特点：元素均不相同，不排序，与进入的顺序无关</li>\n</ul>\n<h3 id=\"Hash表-散列表\"><a href=\"#Hash表-散列表\" class=\"headerlink\" title=\"Hash表(散列表)\"></a>Hash表(散列表)</h3><ul>\n<li>import java.util.HashMap;</li>\n<li>HashMap &lt; Key, Value &gt; a=new HashMap &lt; Key,Value &gt; ();<br>数据以一对值放进去，一个为键(KEY),一个为值(value)<br>值对应键</li>\n<li>键不能重复，只留相同的最后一个，元素不以先后排序</li>\n</ul>\n<h4 id=\"常用操作-2\"><a href=\"#常用操作-2\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>a.put(Key k1, Value v1);</li>\n</ul>\n<blockquote>\n<p>向HashMap里添加元素，键k1对应值为v1</p>\n</blockquote>\n<ul>\n<li>a.get(Key k);</li>\n</ul>\n<blockquote>\n<p>返回键k对应的值，若为空，则返回null</p>\n</blockquote>\n<ul>\n<li>a.containsKey(Key k);</li>\n</ul>\n<blockquote>\n<p>查询是否存在键为k的数据</p>\n</blockquote>\n<ul>\n<li>a.keySet();</li>\n</ul>\n<blockquote>\n<p>返回key的集合</p>\n<p>可以通过 a.keySet().size()获取存放的键的数目</p>\n<p>通过keySet使用for-each循环</p>\n</blockquote>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li><p>extends</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class son extends parent</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>java只允许单继承，一个类只能有一个父类</strong></p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>父类成员访问属性</th>\n<th>在父类中的含义</th>\n<th>在子类中的含义</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>对所有人开放</td>\n<td>对所有人开放</td>\n<td></td>\n</tr>\n<tr>\n<td>protected</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td></td>\n</tr>\n<tr>\n<td>缺省</td>\n<td>只有包内其它类可以访问</td>\n<td>如果子类与父类在同一个包内：只有包内其它类可以访问</td>\n<td>否则：相当于private，不能访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>只有自己可以访问</td>\n<td>不能访问</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>子类同样继承了父类的private成员，只是子类无法访问！<br>但子类可以通过调用父类的非private函数来间接修改父类的private成员变量</p>\n<h3 id=\"继承VS组合\"><a href=\"#继承VS组合\" class=\"headerlink\" title=\"继承VS组合\"></a>继承VS组合</h3><ul>\n<li>“is-a”关系使用继承<ul>\n<li>如：Bird类继承自Animal类</li>\n</ul>\n</li>\n<li>“has-a”关系使用组合<ul>\n<li>如：Computer类包含CPU类，每个Computer对象都有一个CPU对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><p>本质：一个<strong>关键字</strong>，类似this(this的本质为指针),是直接父类的引用</p>\n<p>用法<br>1 . 直接引用</p>\n<p>相当于指向当前对象的父类，用”.”访问父类的成员</p>\n<p>2 . 子类成员变量或方法与父类同名时，用super加以区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tvoid a();</span><br><span class=\"line\">\tvoid b()&#123;</span><br><span class=\"line\">\t\ta();   // son的a函数</span><br><span class=\"line\">\t\tsuper.a();  // parent的a函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3 . 调用父类的构造函数</p>\n<p>规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数</p>\n<p>子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tson(int a1)&#123;</span><br><span class=\"line\">\t\tsuper(a1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同名变量\"><a href=\"#同名变量\" class=\"headerlink\" title=\"同名变量\"></a>同名变量</h3><p>若没有明确指明，则在谁的成员函数中就使用谁的成员变量</p>\n<h3 id=\"子类和子类型\"><a href=\"#子类和子类型\" class=\"headerlink\" title=\"子类和子类型\"></a>子类和子类型</h3><ul>\n<li>类定义了类型</li>\n<li>子类定义了子类型 (son是parent的一个子类型)</li>\n<li>子类对象可以被当做父类的对象使用<ul>\n<li>赋值给父类变量</li>\n<li>传递给需要父类对象的函数</li>\n<li>放进存放分类对象的容器里</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG\" alt=\"mark\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v1 = new Vehicle();</span><br><span class=\"line\">Vehicle v2 = new Car();</span><br><span class=\"line\">Vehicle v3 = new Bicycle();</span><br></pre></td></tr></table></figure>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>主要用来实现<strong>动态联编</strong></p>\n<p>即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了</p>\n<p>以此提高系统的灵活性和扩展性</p>\n<h3 id=\"如何实现多态\"><a href=\"#如何实现多态\" class=\"headerlink\" title=\"如何实现多态\"></a>如何实现多态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 引用变量的两种类型</span><br><span class=\"line\"></span><br><span class=\"line\">    - 编译时类型（一般是父类）</span><br><span class=\"line\">        - 由声明时的类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">    - 运行时类型（运行时具体的子类）</span><br><span class=\"line\">        - 由实际对应的对象类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">- 三个必要条件</span><br><span class=\"line\">    - 要有继承</span><br><span class=\"line\">    - 要有方法重写</span><br><span class=\"line\">    - 父类引用指向子类对象</span><br></pre></td></tr></table></figure>\n<h3 id=\"多态变量\"><a href=\"#多态变量\" class=\"headerlink\" title=\"多态变量\"></a>多态变量</h3><ul>\n<li>对象变量能够保存不止一种的对象</li>\n<li>可以保存声明类型的对象或是声明类型的子类的对象</li>\n<li>子类对象赋给父类变量，发生<strong>向上造型</strong></li>\n</ul>\n<h3 id=\"造型-cast\"><a href=\"#造型-cast\" class=\"headerlink\" title=\"造型 cast\"></a>造型 cast</h3><p>造型(cast)：把一个类型的对象赋值给另一个类型的变量</p>\n<ul>\n<li>子类对象可以复制给父类变量<ul>\n<li>与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象</li>\n</ul>\n</li>\n<li>父类对象不能赋值给子类变量</li>\n<li>可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行</li>\n<li>类型转换 ！= 造型<ul>\n<li>类型转换中对象发生改变，如 int i=(int)10.2;</li>\n<li>造型中对象本身没有改变，只是改变了看待它的方式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v;</span><br><span class=\"line\">Car car = new Car();</span><br><span class=\"line\">v=car;  //可以</span><br><span class=\"line\">c=v;   //编译错误</span><br><span class=\"line\">c=(Car)v // 编译通过</span><br><span class=\"line\"></span><br><span class=\"line\">若</span><br><span class=\"line\">Vehicle v=new Vehicle();</span><br><span class=\"line\">Car car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常</span><br></pre></td></tr></table></figure>\n<h4 id=\"向上造型\"><a href=\"#向上造型\" class=\"headerlink\" title=\"向上造型\"></a>向上造型</h4><ul>\n<li>子类对象当做父类对象使用</li>\n<li>向上造型是默认的，不需要运算符</li>\n<li>向上造型是安全的</li>\n</ul>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数</p>\n<ul>\n<li>静态绑定：根据变量声明类型决定</li>\n<li>动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )</li>\n<li>默认使用动态绑定</li>\n<li>成员函数中调用其它成员函数通过this变量调用</li>\n</ul>\n<h3 id=\"覆盖-override\"><a href=\"#覆盖-override\" class=\"headerlink\" title=\"覆盖 override\"></a>覆盖 override</h3><ul>\n<li>覆盖关系：子类和父类中存在名称和参数表完全相同的函数</li>\n<li>通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数</li>\n</ul>\n<h3 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h3><ul>\n<li>所有的类都继承自Object类</li>\n<li>几乎所有OOP都有Object类（除c++）</li>\n</ul>\n<h4 id=\"Object类的函数-部分\"><a href=\"#Object类的函数-部分\" class=\"headerlink\" title=\"Object类的函数(部分)\"></a>Object类的函数(部分)</h4><ul>\n<li>toString()</li>\n<li>equals()</li>\n</ul>\n<h3 id=\"多态的内存分析\"><a href=\"#多态的内存分析\" class=\"headerlink\" title=\"多态的内存分析\"></a>多态的内存分析</h3><p>1 . 基本的继承关系和方法调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：Animal  有voice方法</span><br><span class=\"line\">- 子类：Cat 重写voice方法，自己有catchMouse方法</span><br><span class=\"line\">- 测试：分别声明父类和子类变量并指向子类对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void showVoice(Animal c) &#123;</span><br><span class=\"line\">\t\tc.voice();</span><br><span class=\"line\">\t\tif(c instanceof Cat)</span><br><span class=\"line\">\t\t\t((Cat) c).catchMouse();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tAnimal a=new Cat();</span><br><span class=\"line\">\t\tCat cat=(Cat)a;</span><br><span class=\"line\">\t\tTest.showVoice(cat);</span><br><span class=\"line\">\t\tTest.showVoice(a);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid voice() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Cat extends Animal&#123;</span><br><span class=\"line\">\tvoid voice() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;miao&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tvoid catchMouse() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG\" alt=\"mark\"></p>\n<p>2 . 深化多态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法</span><br><span class=\"line\">- 子类：MyServlet 重写了doGet方法</span><br><span class=\"line\">- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HttpServlet &#123;</span><br><span class=\"line\">\tpublic void service() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.service()&quot;);</span><br><span class=\"line\">\t\tdoGet();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class MyServlet extends HttpServlet &#123;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;MyServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tHttpServlet s = new MyServlet();</span><br><span class=\"line\">\t\ts.service();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出结果：</span><br><span class=\"line\">// HttpServlet.service()</span><br><span class=\"line\">// MyServlet.doGet()</span><br></pre></td></tr></table></figure>\n<p>原因分析：<br>函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG\" alt=\"mark\"></p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><h3 id=\"消除代码复制\"><a href=\"#消除代码复制\" class=\"headerlink\" title=\"消除代码复制\"></a>消除代码复制</h3><ul>\n<li><p>代码复制是不良设计的一种表现</p>\n<p>解决方法：使用函数封装重复的代码</p>\n</li>\n</ul>\n<h3 id=\"增加可扩展性\"><a href=\"#增加可扩展性\" class=\"headerlink\" title=\"增加可扩展性\"></a>增加可扩展性</h3><ul>\n<li><p>后期的可维护性</p>\n<p>解决方法：用封装降低耦合，用接口实现聚合，借助类继承</p>\n<p>耦合：类和类之间的关系</p>\n<p>耦合越低越好</p>\n</li>\n</ul>\n<h2 id=\"抽象和接口\"><a href=\"#抽象和接口\" class=\"headerlink\" title=\"抽象和接口\"></a>抽象和接口</h2><p>关键词：<strong>abstract</strong> (抽象)</p>\n<blockquote>\n<p>public abstract class a</p>\n</blockquote>\n<ul>\n<li>抽象函数：表达概念而<strong>无法实现具体代码</strong>的函数</li>\n<li>抽象类：表达概念而<strong>无法构造出实体</strong>的类</li>\n<li>为什么需要抽象类<ul>\n<li><strong>模板模式</strong>，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展</li>\n<li><strong>通过抽象类，可以避免子类设计的随意性</strong>，严格限制子类的设计，使得子类之间更加通用。</li>\n</ul>\n</li>\n<li>抽象方法的意义：<strong>使方法的设计和实现分离！</strong></li>\n<li>要点：<ul>\n<li>有抽象函数的类一定是抽象类<ul>\n<li>抽象类<strong>不能制造对象</strong>，但可以定义变量</li>\n</ul>\n</li>\n<li>任何继承了抽象类的非抽象类对象可以赋值给抽象类变量</li>\n<li>抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用</li>\n<li>继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>关键词：<strong>interface</strong></p>\n<blockquote>\n<p>public interface a{}</p>\n</blockquote>\n<ul>\n<li>接口是纯抽象类(接口中只有常量、抽象方法)</li>\n<li>所有成员变量都是public abstract static final （默认的，可以不写）</li>\n<li>接口意义：设计和实现分离，利于大项目制作</li>\n<li>接口变量的含义为任何实现了接口的对象</li>\n</ul>\n<p>关键词：<strong>implements</strong></p>\n<blockquote>\n<p>public class b implements a{}</p>\n</blockquote>\n<ul>\n<li>类可以实现很多接口</li>\n<li>接口可以继承接口，不能继承类</li>\n<li>接口不能实现接口</li>\n<li>接口和抽象类<ul>\n<li>接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了<strong>规范和具体实现的分离</strong></li>\n<li><strong>接口就是规范，定义了一组规则</strong></li>\n<li><strong>接口的本质是契约</strong>，制定好后大家都遵守</li>\n<li>项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要<strong>面向接口编程</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向接口的编程方式\"><a href=\"#面向接口的编程方式\" class=\"headerlink\" title=\"面向接口的编程方式\"></a>面向接口的编程方式</h4><ul>\n<li>设计程序时先定义接口，再实现类</li>\n<li>任何需要在函数间传入传出的一定是接口而不是具体的类</li>\n<li>Java成功的关键之一，极适合多人同时写一个大程序</li>\n<li>Java被批评的要点之一，代码量膨胀地很快</li>\n</ul>\n<h2 id=\"控制反转与MVC模式\"><a href=\"#控制反转与MVC模式\" class=\"headerlink\" title=\"控制反转与MVC模式\"></a>控制反转与MVC模式</h2><h3 id=\"Swing\"><a href=\"#Swing\" class=\"headerlink\" title=\"Swing\"></a>Swing</h3><p>容器、部件</p>\n<ul>\n<li><p>容器继承自部件，因此可以作为部件被放入其它容器中</p>\n</li>\n<li><p>容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整</p>\n</li>\n<li><p>JFrame使用BorderLayout管理部件，并且将界面划分为五个区域</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG\" alt=\"mark\"></p>\n</li>\n<li><p>容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件</p>\n</li>\n</ul>\n<h3 id=\"控制反转\"><a href=\"#控制反转\" class=\"headerlink\" title=\"控制反转\"></a>控制反转</h3><ul>\n<li>按钮公布一个listener接口和一对注册、注销函数</li>\n<li>实现接口后将把listener对象注册在按钮上</li>\n<li>一旦按钮被按下，就会反过来调用listener对象的函数</li>\n</ul>\n<h3 id=\"内部类-innerclasses\"><a href=\"#内部类-innerclasses\" class=\"headerlink\" title=\"内部类 innerclasses\"></a>内部类 innerclasses</h3><p>定义在别的类内部、函数内部的类</p>\n<h4 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问</span><br><span class=\"line\">- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场合\"><a href=\"#使用场合\" class=\"headerlink\" title=\"使用场合\"></a>使用场合</h4><p>在内部类只为所在外部类提供服务的情况优先使用</p>\n<h4 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h4><h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>（可以使用private,public,protected修饰）</p>\n<h6 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h6><p><code>- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Outer &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tFace f=new Face();</span><br><span class=\"line\">\t\tFace.Nose n= f.new Nose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Face &#123;</span><br><span class=\"line\">\tint type;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass Nose&#123;</span><br><span class=\"line\">\t\tString type;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvoid breath() &#123;</span><br><span class=\"line\">\t\t\tFace.this.type=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 静态内部类对象存在时，不一定存在对应的外部类对象</span><br><span class=\"line\">    - 静态内部类无法直接访问外部类实例方法</span><br><span class=\"line\">    - 静态内部类看作**外部类的一个静态成员**</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Face f= new Face();</span><br><span class=\"line\">// Nose为非静态内部类</span><br><span class=\"line\">Face.Nose n=f.new Nose();</span><br><span class=\"line\">// Ear为静态内部类</span><br><span class=\"line\">Face.Ear e=new Face.Ear();</span><br></pre></td></tr></table></figure>\n<h6 id=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"><a href=\"#局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\" class=\"headerlink\" title=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"></a>局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 访问函数的本地变量时只能访问函数的final变量</span><br></pre></td></tr></table></figure>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>适用于只需要使用一次的类，例如：键盘监听操作等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new 父类构造器(实参) 实现接口()&#123;</span><br><span class=\"line\">\t匿名内部类类体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名类可以继承某类，也可以实现接口</li>\n<li>Swing的消息机制广泛使用匿名类</li>\n</ul>\n<h3 id=\"MVC设计模式\"><a href=\"#MVC设计模式\" class=\"headerlink\" title=\"MVC设计模式\"></a>MVC设计模式</h3><ul>\n<li><p>数据、表现和控制</p>\n<p>三者分离</p>\n<ul>\n<li>M = Model 模型</li>\n<li>V = View 表现</li>\n<li>C = Control 控制</li>\n</ul>\n</li>\n<li><p>模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新</p>\n</li>\n<li><p>表现：从模型获取数据，根据数据画出表现</p>\n</li>\n<li><p>控制：从用户得到输入，根据输入调整数据</p>\n</li>\n</ul>\n<h3 id=\"异常机制-Exception\"><a href=\"#异常机制-Exception\" class=\"headerlink\" title=\"异常机制 Exception\"></a>异常机制 Exception</h3><h4 id=\"常见的异常\"><a href=\"#常见的异常\" class=\"headerlink\" title=\"常见的异常\"></a>常见的异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户输入错误</span><br><span class=\"line\">设备错误</span><br><span class=\"line\">硬件问题：如打印机关掉、服务器问题</span><br><span class=\"line\">磁盘满了</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常Exception\"><a href=\"#异常Exception\" class=\"headerlink\" title=\"异常Exception\"></a>异常Exception</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java提供的用来处理程序中错误的一种机制</span><br><span class=\"line\"></span><br><span class=\"line\">Java采用**面向对象** 方式来处理异常。处理过程：</span><br><span class=\"line\">    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE</span><br><span class=\"line\">    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"常见异常\"><a href=\"#常见异常\" class=\"headerlink\" title=\"常见异常\"></a>常见异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. ArithmeticException</span><br><span class=\"line\">    例如试图除以0</span><br><span class=\"line\">2. NullPointerException</span><br><span class=\"line\">    对象为null但调用了对象的方法或属性</span><br><span class=\"line\">3. ClassCastException</span><br><span class=\"line\">    转型错误，解决：使用istanceof判断</span><br><span class=\"line\">4. ArrayIndexOutOfBoundsException</span><br><span class=\"line\">    访问元素超出数组长度</span><br><span class=\"line\">5. NumberFormatException</span><br><span class=\"line\">    数字格式异常，如把String转换成int</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常的处理方法：\"><a href=\"#异常的处理方法：\" class=\"headerlink\" title=\"异常的处理方法：\"></a>异常的处理方法：</h4><p><code>捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常</code></p>\n<h4 id=\"方法重写中声明异常原则：\"><a href=\"#方法重写中声明异常原则：\" class=\"headerlink\" title=\"方法重写中声明异常原则：\"></a>方法重写中声明异常原则：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**子类声明的异常范围不能超出父类的范围**</span><br><span class=\"line\">    - 父类没有声明异常，子类也不能</span><br><span class=\"line\">    - 不能抛出 原有方法抛出的父类或上层类</span><br><span class=\"line\">    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类</span><br><span class=\"line\">- 从Exception类或它的子类派生一个子类</span><br><span class=\"line\">- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">建议：</span><br><span class=\"line\">    - 避免使用异常机制代替错误处理</span><br><span class=\"line\">    - 处理异常不能代替简单测试</span><br><span class=\"line\">    - 不要进行**小力度**的异常处理（如一行一个try catch）</span><br><span class=\"line\">    - 异常往往在**高层**处理</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"百度机器阅读理解比赛赛后总结","date":"2018-05-21T16:00:00.000Z","comments":1,"_content":"\n\n2018年4-5月间，笔者参加了百度举办的[机器阅读理解竞赛](http://mrc2018.cipsc.org.cn/)，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。\n\n\n\n我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。\n\n比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。\n\n![Ranklist](http://ot1c7ttzm.bkt.clouddn.com/ranklist.png)\n\n<!-- more -->\n\n### Step0：了解比赛，掌握数据形式\n\n题目背景：\n\n官方给出解释：\n\n\t对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n\n个人详细解释：\n\t语料库包含很多问题\n\t对于每个问题，语料库中对应几篇文档和该问题的标准答案。\n\t文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。\n\t问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。\n\t我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。\n\n评分机制： \n\tRough-L：相同最大子串(考虑顺序)\n\tBLEU-4：预测答案和实际答案共同出现的词数(无顺序)\n\t评分以Rough-L为主，Rough-L相同以BLEU-4排名\n在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。\n\n介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。\n\n### Step1: 阅读论文，了解state-of-art models\n\n头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：[BIDAF](https://arxiv.org/abs/1611.01603)和[Match-LSTM](https://arxiv.org/abs/1608.07905)，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软[r-net](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf)。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。\n\n阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：\n\n       \t1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       \t2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       \t3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       \t4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n\n### Step2 模型选择与改进\n\n#### 挑选Baseline System：\n\n\tBIDAF与MLSTM区别：\n\t\tBiDAF在Interaction 层中引入了双向注意力机制\n\t\t首先计算一个原文和问题的 Alignment matrix，\n\t\t基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n\t\t基于注意力计算 query-aware 的原文表示，\n\t\t使用双向 LSTM 进行语义信息的聚合。\n\t\n\t\t另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n\t\t词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\t\n\t通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n\n#### 初期想法：\n\n\t师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n\t\t1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n\t\t2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n\t\t3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\t\n\t但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n#### 模型改造：\n\n##### 架构上：end-to-end 到 非 end-to-end\n\n​\t一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。\n\n​\t对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。\n\n​\t由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。\n\n##### 实现上\n\n在实现方面，我们做了两点变化：\n\n###### 问题编码作为上文流入文章编码\n\n第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：\n\n```\nQ：中国第一个乒乓球大满贯是谁？\nA1：刘国梁。\nA2：中国第一个乒乓球大满贯是刘国梁。\nA3：中国第一个乒乓球大满贯。\n```\n\n​\t人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。\n\n###### 加入self-matching层\n\n如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。\n\n虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。\n\n考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。\n\n随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的\"指针\"，而忽略了这句话就会使得变量对应不上。\n\n虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。\n\n#### 答案抽取1： EM算法\n\n起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。\n\nEM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。\n\n这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。\n\n考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。\n\n在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。\n\n#### 答案抽取2：Xgboost\n\n要使用xgboost训练首先得构造训练数据\n\n答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。\n\n特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。\n\n有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。\n\n以下就是我们的成品模型了：\n\n![最终模型](http://ot1c7ttzm.bkt.clouddn.com/Model.jpg)\n\n### Step3 调参\n\n改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。\n\n此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。\n\n在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的\"悲惨境地\"，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了**gridCV**这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。\n\n### 未来改进点与赛后感想\n\n#### 改进：\n\n\t1. 用预先训练好的词向量代替随机初始化词向量进行训练\n\t2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n\t3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n\t4. 加强数据预处理，清洗噪音消息和html标签\n\t5. 有无疑问代词的优化\n\t6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n\t7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n\t8. 字符级别词嵌入：为模型提供更多特征\n\t9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n\t10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n\n#### 感想\n\n首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。\n\n这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。\n\n非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。\n\n#### 源代码\n\n比赛中使用的神经网络部分和xgboost调参部分的代码可以在[我的github仓库](https://github.com/zedom1/nlp)中看到。","source":"_posts/RC_DuReader.md","raw":"---\nlayout: post\ntitle: \"百度机器阅读理解比赛赛后总结\"\ndate: 2018-05-22\ncomments: true\ntags: \n\t- NLP\n\t- 阅读理解\n\t- 机器学习\n---\n\n\n2018年4-5月间，笔者参加了百度举办的[机器阅读理解竞赛](http://mrc2018.cipsc.org.cn/)，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。\n\n\n\n我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。\n\n比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。\n\n![Ranklist](http://ot1c7ttzm.bkt.clouddn.com/ranklist.png)\n\n<!-- more -->\n\n### Step0：了解比赛，掌握数据形式\n\n题目背景：\n\n官方给出解释：\n\n\t对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n\n个人详细解释：\n\t语料库包含很多问题\n\t对于每个问题，语料库中对应几篇文档和该问题的标准答案。\n\t文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。\n\t问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。\n\t我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。\n\n评分机制： \n\tRough-L：相同最大子串(考虑顺序)\n\tBLEU-4：预测答案和实际答案共同出现的词数(无顺序)\n\t评分以Rough-L为主，Rough-L相同以BLEU-4排名\n在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。\n\n介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。\n\n### Step1: 阅读论文，了解state-of-art models\n\n头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：[BIDAF](https://arxiv.org/abs/1611.01603)和[Match-LSTM](https://arxiv.org/abs/1608.07905)，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软[r-net](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf)。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。\n\n阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：\n\n       \t1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       \t2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       \t3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       \t4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n\n### Step2 模型选择与改进\n\n#### 挑选Baseline System：\n\n\tBIDAF与MLSTM区别：\n\t\tBiDAF在Interaction 层中引入了双向注意力机制\n\t\t首先计算一个原文和问题的 Alignment matrix，\n\t\t基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n\t\t基于注意力计算 query-aware 的原文表示，\n\t\t使用双向 LSTM 进行语义信息的聚合。\n\t\n\t\t另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n\t\t词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\t\n\t通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n\n#### 初期想法：\n\n\t师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n\t\t1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n\t\t2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n\t\t3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\t\n\t但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n#### 模型改造：\n\n##### 架构上：end-to-end 到 非 end-to-end\n\n​\t一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。\n\n​\t对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。\n\n​\t由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。\n\n##### 实现上\n\n在实现方面，我们做了两点变化：\n\n###### 问题编码作为上文流入文章编码\n\n第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：\n\n```\nQ：中国第一个乒乓球大满贯是谁？\nA1：刘国梁。\nA2：中国第一个乒乓球大满贯是刘国梁。\nA3：中国第一个乒乓球大满贯。\n```\n\n​\t人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。\n\n###### 加入self-matching层\n\n如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。\n\n虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。\n\n考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。\n\n随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的\"指针\"，而忽略了这句话就会使得变量对应不上。\n\n虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。\n\n#### 答案抽取1： EM算法\n\n起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。\n\nEM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。\n\n这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。\n\n考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。\n\n在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。\n\n#### 答案抽取2：Xgboost\n\n要使用xgboost训练首先得构造训练数据\n\n答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。\n\n特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。\n\n有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。\n\n以下就是我们的成品模型了：\n\n![最终模型](http://ot1c7ttzm.bkt.clouddn.com/Model.jpg)\n\n### Step3 调参\n\n改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。\n\n此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。\n\n在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的\"悲惨境地\"，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了**gridCV**这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。\n\n### 未来改进点与赛后感想\n\n#### 改进：\n\n\t1. 用预先训练好的词向量代替随机初始化词向量进行训练\n\t2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n\t3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n\t4. 加强数据预处理，清洗噪音消息和html标签\n\t5. 有无疑问代词的优化\n\t6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n\t7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n\t8. 字符级别词嵌入：为模型提供更多特征\n\t9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n\t10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n\n#### 感想\n\n首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。\n\n这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。\n\n非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。\n\n#### 源代码\n\n比赛中使用的神经网络部分和xgboost调参部分的代码可以在[我的github仓库](https://github.com/zedom1/nlp)中看到。","slug":"RC_DuReader","published":1,"updated":"2018-06-02T13:16:36.651Z","photos":[],"link":"","_id":"cjleshqjj000iryfc6m81w0h2","content":"<p>2018年4-5月间，笔者参加了百度举办的<a href=\"http://mrc2018.cipsc.org.cn/\" target=\"_blank\" rel=\"noopener\">机器阅读理解竞赛</a>，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。</p>\n<p>我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。</p>\n<p>比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ranklist.png\" alt=\"Ranklist\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Step0：了解比赛，掌握数据形式\"><a href=\"#Step0：了解比赛，掌握数据形式\" class=\"headerlink\" title=\"Step0：了解比赛，掌握数据形式\"></a>Step0：了解比赛，掌握数据形式</h3><p>题目背景：</p>\n<p>官方给出解释：</p>\n<pre><code>对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n</code></pre><p>个人详细解释：<br>    语料库包含很多问题<br>    对于每个问题，语料库中对应几篇文档和该问题的标准答案。<br>    文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。<br>    问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。<br>    我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。</p>\n<p>评分机制：<br>    Rough-L：相同最大子串(考虑顺序)<br>    BLEU-4：预测答案和实际答案共同出现的词数(无顺序)<br>    评分以Rough-L为主，Rough-L相同以BLEU-4排名<br>在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。</p>\n<p>介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。</p>\n<h3 id=\"Step1-阅读论文，了解state-of-art-models\"><a href=\"#Step1-阅读论文，了解state-of-art-models\" class=\"headerlink\" title=\"Step1: 阅读论文，了解state-of-art models\"></a>Step1: 阅读论文，了解state-of-art models</h3><p>头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：<a href=\"https://arxiv.org/abs/1611.01603\" target=\"_blank\" rel=\"noopener\">BIDAF</a>和<a href=\"https://arxiv.org/abs/1608.07905\" target=\"_blank\" rel=\"noopener\">Match-LSTM</a>，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软<a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf\" target=\"_blank\" rel=\"noopener\">r-net</a>。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。</p>\n<p>阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：</p>\n<pre><code>       1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n</code></pre><h3 id=\"Step2-模型选择与改进\"><a href=\"#Step2-模型选择与改进\" class=\"headerlink\" title=\"Step2 模型选择与改进\"></a>Step2 模型选择与改进</h3><h4 id=\"挑选Baseline-System：\"><a href=\"#挑选Baseline-System：\" class=\"headerlink\" title=\"挑选Baseline System：\"></a>挑选Baseline System：</h4><pre><code>BIDAF与MLSTM区别：\n    BiDAF在Interaction 层中引入了双向注意力机制\n    首先计算一个原文和问题的 Alignment matrix，\n    基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n    基于注意力计算 query-aware 的原文表示，\n    使用双向 LSTM 进行语义信息的聚合。\n\n    另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n    词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\n通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n</code></pre><h4 id=\"初期想法：\"><a href=\"#初期想法：\" class=\"headerlink\" title=\"初期想法：\"></a>初期想法：</h4><pre><code>师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n    1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n    2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n    3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\n但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n</code></pre><h4 id=\"模型改造：\"><a href=\"#模型改造：\" class=\"headerlink\" title=\"模型改造：\"></a>模型改造：</h4><h5 id=\"架构上：end-to-end-到-非-end-to-end\"><a href=\"#架构上：end-to-end-到-非-end-to-end\" class=\"headerlink\" title=\"架构上：end-to-end 到 非 end-to-end\"></a>架构上：end-to-end 到 非 end-to-end</h5><p>​    一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。</p>\n<p>​    对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。</p>\n<p>​    由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。</p>\n<h5 id=\"实现上\"><a href=\"#实现上\" class=\"headerlink\" title=\"实现上\"></a>实现上</h5><p>在实现方面，我们做了两点变化：</p>\n<h6 id=\"问题编码作为上文流入文章编码\"><a href=\"#问题编码作为上文流入文章编码\" class=\"headerlink\" title=\"问题编码作为上文流入文章编码\"></a>问题编码作为上文流入文章编码</h6><p>第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q：中国第一个乒乓球大满贯是谁？</span><br><span class=\"line\">A1：刘国梁。</span><br><span class=\"line\">A2：中国第一个乒乓球大满贯是刘国梁。</span><br><span class=\"line\">A3：中国第一个乒乓球大满贯。</span><br></pre></td></tr></table></figure>\n<p>​    人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。</p>\n<h6 id=\"加入self-matching层\"><a href=\"#加入self-matching层\" class=\"headerlink\" title=\"加入self-matching层\"></a>加入self-matching层</h6><p>如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。</p>\n<p>虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。</p>\n<p>考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。</p>\n<p>随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的”指针”，而忽略了这句话就会使得变量对应不上。</p>\n<p>虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。</p>\n<h4 id=\"答案抽取1：-EM算法\"><a href=\"#答案抽取1：-EM算法\" class=\"headerlink\" title=\"答案抽取1： EM算法\"></a>答案抽取1： EM算法</h4><p>起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。</p>\n<p>EM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。</p>\n<p>这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。</p>\n<p>考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。</p>\n<p>在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。</p>\n<h4 id=\"答案抽取2：Xgboost\"><a href=\"#答案抽取2：Xgboost\" class=\"headerlink\" title=\"答案抽取2：Xgboost\"></a>答案抽取2：Xgboost</h4><p>要使用xgboost训练首先得构造训练数据</p>\n<p>答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。</p>\n<p>特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。</p>\n<p>有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。</p>\n<p>以下就是我们的成品模型了：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Model.jpg\" alt=\"最终模型\"></p>\n<h3 id=\"Step3-调参\"><a href=\"#Step3-调参\" class=\"headerlink\" title=\"Step3 调参\"></a>Step3 调参</h3><p>改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。</p>\n<p>此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。</p>\n<p>在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的”悲惨境地”，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了<strong>gridCV</strong>这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。</p>\n<h3 id=\"未来改进点与赛后感想\"><a href=\"#未来改进点与赛后感想\" class=\"headerlink\" title=\"未来改进点与赛后感想\"></a>未来改进点与赛后感想</h3><h4 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h4><pre><code>1. 用预先训练好的词向量代替随机初始化词向量进行训练\n2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n4. 加强数据预处理，清洗噪音消息和html标签\n5. 有无疑问代词的优化\n6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n8. 字符级别词嵌入：为模型提供更多特征\n9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n</code></pre><h4 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h4><p>首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。</p>\n<p>这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。</p>\n<p>非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p>比赛中使用的神经网络部分和xgboost调参部分的代码可以在<a href=\"https://github.com/zedom1/nlp\" target=\"_blank\" rel=\"noopener\">我的github仓库</a>中看到。</p>\n","site":{"data":{}},"excerpt":"<p>2018年4-5月间，笔者参加了百度举办的<a href=\"http://mrc2018.cipsc.org.cn/\" target=\"_blank\" rel=\"noopener\">机器阅读理解竞赛</a>，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。</p>\n<p>我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。</p>\n<p>比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ranklist.png\" alt=\"Ranklist\"></p>","more":"<h3 id=\"Step0：了解比赛，掌握数据形式\"><a href=\"#Step0：了解比赛，掌握数据形式\" class=\"headerlink\" title=\"Step0：了解比赛，掌握数据形式\"></a>Step0：了解比赛，掌握数据形式</h3><p>题目背景：</p>\n<p>官方给出解释：</p>\n<pre><code>对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n</code></pre><p>个人详细解释：<br>    语料库包含很多问题<br>    对于每个问题，语料库中对应几篇文档和该问题的标准答案。<br>    文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。<br>    问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。<br>    我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。</p>\n<p>评分机制：<br>    Rough-L：相同最大子串(考虑顺序)<br>    BLEU-4：预测答案和实际答案共同出现的词数(无顺序)<br>    评分以Rough-L为主，Rough-L相同以BLEU-4排名<br>在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。</p>\n<p>介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。</p>\n<h3 id=\"Step1-阅读论文，了解state-of-art-models\"><a href=\"#Step1-阅读论文，了解state-of-art-models\" class=\"headerlink\" title=\"Step1: 阅读论文，了解state-of-art models\"></a>Step1: 阅读论文，了解state-of-art models</h3><p>头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：<a href=\"https://arxiv.org/abs/1611.01603\" target=\"_blank\" rel=\"noopener\">BIDAF</a>和<a href=\"https://arxiv.org/abs/1608.07905\" target=\"_blank\" rel=\"noopener\">Match-LSTM</a>，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软<a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf\" target=\"_blank\" rel=\"noopener\">r-net</a>。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。</p>\n<p>阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：</p>\n<pre><code>       1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n</code></pre><h3 id=\"Step2-模型选择与改进\"><a href=\"#Step2-模型选择与改进\" class=\"headerlink\" title=\"Step2 模型选择与改进\"></a>Step2 模型选择与改进</h3><h4 id=\"挑选Baseline-System：\"><a href=\"#挑选Baseline-System：\" class=\"headerlink\" title=\"挑选Baseline System：\"></a>挑选Baseline System：</h4><pre><code>BIDAF与MLSTM区别：\n    BiDAF在Interaction 层中引入了双向注意力机制\n    首先计算一个原文和问题的 Alignment matrix，\n    基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n    基于注意力计算 query-aware 的原文表示，\n    使用双向 LSTM 进行语义信息的聚合。\n\n    另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n    词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\n通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n</code></pre><h4 id=\"初期想法：\"><a href=\"#初期想法：\" class=\"headerlink\" title=\"初期想法：\"></a>初期想法：</h4><pre><code>师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n    1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n    2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n    3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\n但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n</code></pre><h4 id=\"模型改造：\"><a href=\"#模型改造：\" class=\"headerlink\" title=\"模型改造：\"></a>模型改造：</h4><h5 id=\"架构上：end-to-end-到-非-end-to-end\"><a href=\"#架构上：end-to-end-到-非-end-to-end\" class=\"headerlink\" title=\"架构上：end-to-end 到 非 end-to-end\"></a>架构上：end-to-end 到 非 end-to-end</h5><p>​    一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。</p>\n<p>​    对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。</p>\n<p>​    由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。</p>\n<h5 id=\"实现上\"><a href=\"#实现上\" class=\"headerlink\" title=\"实现上\"></a>实现上</h5><p>在实现方面，我们做了两点变化：</p>\n<h6 id=\"问题编码作为上文流入文章编码\"><a href=\"#问题编码作为上文流入文章编码\" class=\"headerlink\" title=\"问题编码作为上文流入文章编码\"></a>问题编码作为上文流入文章编码</h6><p>第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q：中国第一个乒乓球大满贯是谁？</span><br><span class=\"line\">A1：刘国梁。</span><br><span class=\"line\">A2：中国第一个乒乓球大满贯是刘国梁。</span><br><span class=\"line\">A3：中国第一个乒乓球大满贯。</span><br></pre></td></tr></table></figure>\n<p>​    人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。</p>\n<h6 id=\"加入self-matching层\"><a href=\"#加入self-matching层\" class=\"headerlink\" title=\"加入self-matching层\"></a>加入self-matching层</h6><p>如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。</p>\n<p>虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。</p>\n<p>考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。</p>\n<p>随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的”指针”，而忽略了这句话就会使得变量对应不上。</p>\n<p>虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。</p>\n<h4 id=\"答案抽取1：-EM算法\"><a href=\"#答案抽取1：-EM算法\" class=\"headerlink\" title=\"答案抽取1： EM算法\"></a>答案抽取1： EM算法</h4><p>起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。</p>\n<p>EM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。</p>\n<p>这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。</p>\n<p>考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。</p>\n<p>在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。</p>\n<h4 id=\"答案抽取2：Xgboost\"><a href=\"#答案抽取2：Xgboost\" class=\"headerlink\" title=\"答案抽取2：Xgboost\"></a>答案抽取2：Xgboost</h4><p>要使用xgboost训练首先得构造训练数据</p>\n<p>答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。</p>\n<p>特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。</p>\n<p>有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。</p>\n<p>以下就是我们的成品模型了：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Model.jpg\" alt=\"最终模型\"></p>\n<h3 id=\"Step3-调参\"><a href=\"#Step3-调参\" class=\"headerlink\" title=\"Step3 调参\"></a>Step3 调参</h3><p>改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。</p>\n<p>此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。</p>\n<p>在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的”悲惨境地”，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了<strong>gridCV</strong>这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。</p>\n<h3 id=\"未来改进点与赛后感想\"><a href=\"#未来改进点与赛后感想\" class=\"headerlink\" title=\"未来改进点与赛后感想\"></a>未来改进点与赛后感想</h3><h4 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h4><pre><code>1. 用预先训练好的词向量代替随机初始化词向量进行训练\n2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n4. 加强数据预处理，清洗噪音消息和html标签\n5. 有无疑问代词的优化\n6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n8. 字符级别词嵌入：为模型提供更多特征\n9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n</code></pre><h4 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h4><p>首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。</p>\n<p>这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。</p>\n<p>非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p>比赛中使用的神经网络部分和xgboost调参部分的代码可以在<a href=\"https://github.com/zedom1/nlp\" target=\"_blank\" rel=\"noopener\">我的github仓库</a>中看到。</p>"},{"layout":"post","title":"浅析基于分离轴原理的碰撞检测及分离算法","date":"2017-07-14T16:00:00.000Z","comments":1,"_content":"\n\n# **导言**\n\n分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。\n\n想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。\n\n以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。\n\n> 适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离\n>\n> 非凸多边形的改进办法：\n>\n> > 1. 将物体划分成多个凸多边形\n> > 2. 将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。\n\n<!-- more -->\n\n# **原理介绍**\n\n## **什么是碰撞？**\n\n首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。\n\n## **光线检测法**\n\n![光线检测法](http://ot1c7ttzm.bkt.clouddn.com/sat1.png)\n\n假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：\n\n> 1. 一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。\n> 2. 为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 ![非凸多边形](http://ot1c7ttzm.bkt.clouddn.com/sat2.png)\n\n## **投影**\n\n现在介绍一下一个非常关键的概念，也是整个算法的基础：**投影**。 两个物体未发生碰撞 -> 两个物体之间有空隙 -> 可以找到一条穿过它们中间的一条直线。 那么，**两个物体在垂直这条线的投影轴上的投影也必定存在空隙**。 ![投影1](http://ot1c7ttzm.bkt.clouddn.com/sat3.png)\n\n## **进一步优化**\n\n若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：**以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。**\n\n# **实现步骤**\n\n1.取第一个凸多边形相邻的两个点，得到向量a\n\n> $$Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)$$\n\n2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴\n\n> $$Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})$$\n\n3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影$$ 投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b} $$,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。\n\n以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1\n\n![投影2](http://ot1c7ttzm.bkt.clouddn.com/sat4.png)\n\n4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2\n\n5.判断是否碰撞\n\n> - 未发生碰撞\n>\n> > min2 > max1或 min1 > max2 两者中间有空隙，未发生碰撞\n>\n> - 发生碰撞（若不需分离可直接跳至下一步）\n>\n> > - min2 <= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n> >\n> > > 因向量方向任意，因此在计算距离时要记得加上绝对值abs\n> >\n> > - min1 <= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n\n6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。\n\n7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。\n\n8.得出判断\n\n# **分离**\n\n在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 $$ x-=min \\times \\vec{bmin}.x; $$ $$ y-=min \\times \\vec{bmin}.y; $$\n\n(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)\n\n# **圆的碰撞检测及分离**\n\n圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 ![投影3](http://ot1c7ttzm.bkt.clouddn.com/sat5.png)\n\n# **完整实现代码**\n\n[碰撞检测完整实现(两凸多边形版和圆形凸多边形版)](https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6)\n\n- ​","source":"_posts/SAT.md","raw":"---\nlayout: post\ntitle: \"浅析基于分离轴原理的碰撞检测及分离算法\"\ndate: 2017-07-15\ncomments: true\ntags: \n\t- 游戏\n\t- 算法\n---\n\n\n# **导言**\n\n分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。\n\n想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。\n\n以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。\n\n> 适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离\n>\n> 非凸多边形的改进办法：\n>\n> > 1. 将物体划分成多个凸多边形\n> > 2. 将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。\n\n<!-- more -->\n\n# **原理介绍**\n\n## **什么是碰撞？**\n\n首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。\n\n## **光线检测法**\n\n![光线检测法](http://ot1c7ttzm.bkt.clouddn.com/sat1.png)\n\n假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：\n\n> 1. 一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。\n> 2. 为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 ![非凸多边形](http://ot1c7ttzm.bkt.clouddn.com/sat2.png)\n\n## **投影**\n\n现在介绍一下一个非常关键的概念，也是整个算法的基础：**投影**。 两个物体未发生碰撞 -> 两个物体之间有空隙 -> 可以找到一条穿过它们中间的一条直线。 那么，**两个物体在垂直这条线的投影轴上的投影也必定存在空隙**。 ![投影1](http://ot1c7ttzm.bkt.clouddn.com/sat3.png)\n\n## **进一步优化**\n\n若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：**以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。**\n\n# **实现步骤**\n\n1.取第一个凸多边形相邻的两个点，得到向量a\n\n> $$Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)$$\n\n2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴\n\n> $$Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})$$\n\n3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影$$ 投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b} $$,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。\n\n以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1\n\n![投影2](http://ot1c7ttzm.bkt.clouddn.com/sat4.png)\n\n4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2\n\n5.判断是否碰撞\n\n> - 未发生碰撞\n>\n> > min2 > max1或 min1 > max2 两者中间有空隙，未发生碰撞\n>\n> - 发生碰撞（若不需分离可直接跳至下一步）\n>\n> > - min2 <= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n> >\n> > > 因向量方向任意，因此在计算距离时要记得加上绝对值abs\n> >\n> > - min1 <= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n\n6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。\n\n7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。\n\n8.得出判断\n\n# **分离**\n\n在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 $$ x-=min \\times \\vec{bmin}.x; $$ $$ y-=min \\times \\vec{bmin}.y; $$\n\n(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)\n\n# **圆的碰撞检测及分离**\n\n圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 ![投影3](http://ot1c7ttzm.bkt.clouddn.com/sat5.png)\n\n# **完整实现代码**\n\n[碰撞检测完整实现(两凸多边形版和圆形凸多边形版)](https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6)\n\n- ​","slug":"SAT","published":1,"updated":"2018-05-25T12:41:12.646Z","photos":[],"link":"","_id":"cjleshqjk000kryfc1klv356h","content":"<h1 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a><strong>导言</strong></h1><p>分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。</p>\n<p>想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。</p>\n<p>以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。</p>\n<blockquote>\n<p>适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离</p>\n<p>非凸多边形的改进办法：</p>\n<blockquote>\n<ol>\n<li>将物体划分成多个凸多边形</li>\n<li>将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。</li>\n</ol>\n</blockquote>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a><strong>原理介绍</strong></h1><h2 id=\"什么是碰撞？\"><a href=\"#什么是碰撞？\" class=\"headerlink\" title=\"什么是碰撞？\"></a><strong>什么是碰撞？</strong></h2><p>首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。</p>\n<h2 id=\"光线检测法\"><a href=\"#光线检测法\" class=\"headerlink\" title=\"光线检测法\"></a><strong>光线检测法</strong></h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat1.png\" alt=\"光线检测法\"></p>\n<p>假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：</p>\n<blockquote>\n<ol>\n<li>一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。</li>\n<li>为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat2.png\" alt=\"非凸多边形\"></li>\n</ol>\n</blockquote>\n<h2 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a><strong>投影</strong></h2><p>现在介绍一下一个非常关键的概念，也是整个算法的基础：<strong>投影</strong>。 两个物体未发生碰撞 -&gt; 两个物体之间有空隙 -&gt; 可以找到一条穿过它们中间的一条直线。 那么，<strong>两个物体在垂直这条线的投影轴上的投影也必定存在空隙</strong>。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat3.png\" alt=\"投影1\"></p>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a><strong>进一步优化</strong></h2><p>若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：<strong>以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。</strong></p>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a><strong>实现步骤</strong></h1><p>1.取第一个凸多边形相邻的两个点，得到向量a</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)</script></blockquote>\n<p>2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})</script></blockquote>\n<p>3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影<script type=\"math/tex\">投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b}</script>,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。</p>\n<p>以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat4.png\" alt=\"投影2\"></p>\n<p>4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2</p>\n<p>5.判断是否碰撞</p>\n<blockquote>\n<ul>\n<li>未发生碰撞</li>\n</ul>\n<blockquote>\n<p>min2 &gt; max1或 min1 &gt; max2 两者中间有空隙，未发生碰撞</p>\n</blockquote>\n<ul>\n<li>发生碰撞（若不需分离可直接跳至下一步）</li>\n</ul>\n<blockquote>\n<ul>\n<li>min2 &lt;= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n<blockquote>\n<p>因向量方向任意，因此在计算距离时要记得加上绝对值abs</p>\n</blockquote>\n<ul>\n<li>min1 &lt;= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。</p>\n<p>7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。</p>\n<p>8.得出判断</p>\n<h1 id=\"分离\"><a href=\"#分离\" class=\"headerlink\" title=\"分离\"></a><strong>分离</strong></h1><p>在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 <script type=\"math/tex\">x-=min \\times \\vec{bmin}.x;</script> <script type=\"math/tex\">y-=min \\times \\vec{bmin}.y;</script></p>\n<p>(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)</p>\n<h1 id=\"圆的碰撞检测及分离\"><a href=\"#圆的碰撞检测及分离\" class=\"headerlink\" title=\"圆的碰撞检测及分离\"></a><strong>圆的碰撞检测及分离</strong></h1><p>圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat5.png\" alt=\"投影3\"></p>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6\" target=\"_blank\" rel=\"noopener\">碰撞检测完整实现(两凸多边形版和圆形凸多边形版)</a></p>\n<ul>\n<li>​</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a><strong>导言</strong></h1><p>分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。</p>\n<p>想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。</p>\n<p>以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。</p>\n<blockquote>\n<p>适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离</p>\n<p>非凸多边形的改进办法：</p>\n<blockquote>\n<ol>\n<li>将物体划分成多个凸多边形</li>\n<li>将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。</li>\n</ol>\n</blockquote>\n</blockquote>","more":"<h1 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a><strong>原理介绍</strong></h1><h2 id=\"什么是碰撞？\"><a href=\"#什么是碰撞？\" class=\"headerlink\" title=\"什么是碰撞？\"></a><strong>什么是碰撞？</strong></h2><p>首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。</p>\n<h2 id=\"光线检测法\"><a href=\"#光线检测法\" class=\"headerlink\" title=\"光线检测法\"></a><strong>光线检测法</strong></h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat1.png\" alt=\"光线检测法\"></p>\n<p>假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：</p>\n<blockquote>\n<ol>\n<li>一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。</li>\n<li>为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat2.png\" alt=\"非凸多边形\"></li>\n</ol>\n</blockquote>\n<h2 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a><strong>投影</strong></h2><p>现在介绍一下一个非常关键的概念，也是整个算法的基础：<strong>投影</strong>。 两个物体未发生碰撞 -&gt; 两个物体之间有空隙 -&gt; 可以找到一条穿过它们中间的一条直线。 那么，<strong>两个物体在垂直这条线的投影轴上的投影也必定存在空隙</strong>。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat3.png\" alt=\"投影1\"></p>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a><strong>进一步优化</strong></h2><p>若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：<strong>以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。</strong></p>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a><strong>实现步骤</strong></h1><p>1.取第一个凸多边形相邻的两个点，得到向量a</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)</script></blockquote>\n<p>2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})</script></blockquote>\n<p>3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影<script type=\"math/tex\">投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b}</script>,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。</p>\n<p>以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat4.png\" alt=\"投影2\"></p>\n<p>4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2</p>\n<p>5.判断是否碰撞</p>\n<blockquote>\n<ul>\n<li>未发生碰撞</li>\n</ul>\n<blockquote>\n<p>min2 &gt; max1或 min1 &gt; max2 两者中间有空隙，未发生碰撞</p>\n</blockquote>\n<ul>\n<li>发生碰撞（若不需分离可直接跳至下一步）</li>\n</ul>\n<blockquote>\n<ul>\n<li>min2 &lt;= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n<blockquote>\n<p>因向量方向任意，因此在计算距离时要记得加上绝对值abs</p>\n</blockquote>\n<ul>\n<li>min1 &lt;= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。</p>\n<p>7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。</p>\n<p>8.得出判断</p>\n<h1 id=\"分离\"><a href=\"#分离\" class=\"headerlink\" title=\"分离\"></a><strong>分离</strong></h1><p>在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 <script type=\"math/tex\">x-=min \\times \\vec{bmin}.x;</script> <script type=\"math/tex\">y-=min \\times \\vec{bmin}.y;</script></p>\n<p>(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)</p>\n<h1 id=\"圆的碰撞检测及分离\"><a href=\"#圆的碰撞检测及分离\" class=\"headerlink\" title=\"圆的碰撞检测及分离\"></a><strong>圆的碰撞检测及分离</strong></h1><p>圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat5.png\" alt=\"投影3\"></p>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6\" target=\"_blank\" rel=\"noopener\">碰撞检测完整实现(两凸多边形版和圆形凸多边形版)</a></p>\n<ul>\n<li>​</li>\n</ul>"},{"layout":"post","title":"题目小结：二叉树 ( 建树和遍历 )","date":"2017-08-17T16:00:00.000Z","comments":1,"_content":"\n\n# 二叉树练习：\n\n分为：\n树的构建\n树的同构\n子树节点数\n自定义遍历顺序\n子树相同\nTree Travels again\n\n<!-- more -->\n\n## 1. 树的构建\n\n有关二叉树的题目有以下几种输入建树方式：\n1.前序+中序遍历序列\n2.中序+后序遍历序列\n3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数\n4.每个节点子节点数目以及子节点编号\n5.先序序列，空节点以’,’代替\n\n### 1. 前序+中序遍历序列\n\n![前序+中序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG)\n\n从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。\n\n用流程表述如下：\n在前序中确定根节点->在中序中确定根节点->得知左右序列的长度->递归左右序列\n\n你可能会疑惑，那左右节点呢？不是能够确定吗？\n没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。\n\n```\nnode *build( char *pre, char * ins, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*pre ; i++);\n\ts= new node (*pre);\n\ts->lc=build(pre+1,ins,i);\n\ts->rc=build(pre+i+1,ins+i+1,n-i-1);\n\treturn s;\n}\n```\n\n### 2. 中序+后序遍历序列\n\n![中序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG)\n\n和前序+中序一般，这次不过是根节点在最后，流程是类似的。\n\n```\nnode *build(char *ins, char *post, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node (*(post+n-1));\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+n-1); i++);\n\ts=new node (*(post+n-1));\n\ts->lc=build(ins,post,i);\n\ts->rc=build(ins+i+1,post+i,n-i-1);\n\treturn s;\n}\n```\n\n### 3. 前序+后序序列\n\n![前序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG)\n\n那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？\n这时候就靠左孩子了。而根据给出的性质：**所有节点的子节点数均为偶数**可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）\n\n明确思路后修改一下细节就可以得到如下代码\n\n```\nnode * build( char *pre , char *post, int len )\n{ \n\tnode *s=NULL;\n\tif(len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new node (*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new node (*pre);\n\ts->lc=build(pre+1,post,i+1);\n\ts->rc=build(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n### 4. 子节点编号\n\n假设题目的输入如下：\n第一行为节点总数n，节点编号1-n\n紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。\n范例如下：\n\n```\n7 \n1 6 3\n2 0 4\n1 7 0\n3 0 0\n1 2 1\n2 0 0\n2 0 0\n```\n\n显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：**没有给出根节点编号！**，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。\n\n我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组\n3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。\n1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。\n\nbuild函数很简单，若有孩子则递归构建。\n\n```\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n```\n\n那输入要怎么处理？\n\n```\nmemset(isroot,0,sizeof(isroot)); // 数组归零，很重要！\nfor(int i=1; i<=n; i++)\n{\n\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理\n}\nfor(nroot=1; isroot[nroot]==1; nroot++);\ntree=build(nroot);\n```\n\n### 5. 先序序列\n\n还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）\n如\n\n```\nabc,,de,g,,f,,,\n```\n\n很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩\n\n```\nnode *build( int &fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据\n// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir>=n)方便\n{\n\tnode *s=NULL;\n\tif(fir>=n) return s;\n\tif(pre[fir]==',' ) return s;\n\ts=new node(pre[fir]);\n\ts->lc=build(++fir,n);\n\ts->rc=build(++fir,n);\n\treturn s;\n}\n```\n\n## 2. 树的同构\n\n[SDUT 3340: 数据结构实验之二叉树一：树的同构](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html)\n\n题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。\n\n例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。\n\n![图1](http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim)\n\n![图2](http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim)\n\n难点：\n\n1. 树的构建\n2. 同构判断\n\n坑：\n\n1. n和m可能不同\n   在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。\n2. n和m可能为0 (分别或同时)\n\n判等思路：\n1.粗糙版：贪心同构tree1，看看能不能变成tree2。\ntree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样\n\n2.递归巧妙版：判断当前节点数值是否相等\n若两个节点都不存在，返回正确。\n若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&&（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&&（tree1右孩子+tree2左孩子）。\n若不等或者只有其中一个存在，返回错。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n\nchar a[15];\nint llc[15],rrc[15];\nint n,m;\nchar tem1,tem2;\nbool isroot[15];\nint nroot;\n\nstruct node\n{\n\tchar data;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL;}\n\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){}\n};\n\nnode * build(int i)\n{\n\tnode *s=new node (a[i]);\n\tif(llc[i]!=-1)\n\t\ts->lc=build(llc[i]);\n\tif(rrc[i]!=-1)\n\t\ts->rc=build(rrc[i]);\n\treturn s;\n}\n\nnode * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等\n{\n\tnroot=0;\n\tmemset(isroot,0,sizeof(isroot));\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=0; i<n1; i++)\n\t{\t\n\t\tcin>>a[i]>>tem1>>tem2;\n\t\tif(tem1=='-') \n\t\t\tllc[i]=-1;\n\t\telse\n\t\t{\n\t\t\tllc[i]=tem1-'0';\n\t\t\tisroot[llc[i]]=1;\n\t\t}\n\t\tif(tem2=='-') \n\t\t\trrc[i]=-1;\n\t\telse\n\t\t{\n\t\t\trrc[i]=tem2-'0';\n\t\t\tisroot[rrc[i]]=1;\n\t\t}\n\t}\n\tfor( nroot=0; nroot<n1; nroot++)\n\t\tif(isroot[nroot]==0)\n\t\t\tbreak;\n\treturn build(nroot);\n}\n\nbool change(node*r1, node *r2)\n{\n\tif(!r1 && !r2) \n\t\treturn 1;\n\tif(r1&&r2)\n\t{\n\t\tif(r1->data==r2->data)\n\t\t{\n\t\t\tif( (change(r1->rc,r2->rc))&&(change(r1->lc,r2->lc))  || (change(r1->lc,r2->rc))&&(change(r1->rc,r2->lc))   )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\nwhile(cin>>n)\n{\n\tnode* tree1,*tree2;\n\tif(n)\n\t\ttree1=rebuild(n);\n\tcin>>m;\n\tif(m)\n\t\ttree2=rebuild(m);\n\tif(change(tree1,tree2))\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n}\n\treturn 0;\n}\n```\n\n## 3. 子树节点数\n\n[九度OJ 1113：二叉树](http://ac.jobdu.com/problem.php?pid=1113)\n\n题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数\n\n一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。\n\n个人想法（不一定为最简）：\n先求得m和n所在二叉树的高度lenm和lenn，求得’<’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count*po个节点，最后一层的节点数减去count*po后，剩下在po范围里的则是最后一层m可以加上的节点数。\n\n![解法图示](http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim)\n\ncmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n \nint getheight(int num)\n{\n    return (int)(log(num)*1.0/(log(2)*1.0));\n}\n \nint main()\n{   \n    int m,n;\n\twhile(  scanf(\"%d%d\",&m,&n)&& m+n  )\n\t{   \n\t\tint lenm=getheight(m),lenn=getheight(n);\n\t\tint count=0;\n\t\tint po=1;\n\t\tint ans=0;\n\t\tfor(int i=m-1; ; i--)\n\t\t{\n\t\t\tif(getheight(i)!=lenm)\n\t\t\t\tbreak;\n\t\t\tcount++;  // 找出同层中m左边有多少个节点\n\t\t}\n    \n\t\tfor(int i=lenm; i<lenn; i++)\n\t\t{\n\t\t\tans+=po;   // 在lenn层前的子树节点总数\n\t\t\tpo*=2;\n\t\t}\n\t\tcount*=po;\n\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号\n\t\tif(n<=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围\n\t\t\tprintf(\"%d\\n\",ans);\n\t\telse\n\t\t{\n\t\t\tn-= count+fir-1;\n\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围\n\t\t\tans+=n;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n    return 0;\n}\n```\n\n## 4. 自定义遍历顺序\n\n[SDUT 3133: C要–二叉树中的秘密](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html)\n\n题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。\n\n遍历顺序：\n若根节点只有左子树或右子树，则遍历子树。\n若左右子树均没有，则返回父节点\n若左右子树均有\n若左右节点高度不同，优先遍历高度小的\n若左右节点高度相同，优先遍历储存的数据较小的\n\n难点：\n1.建树\n2.按规则实现遍历\n\n思路：\n跟着题意走就行，注意细节。\n每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *pa,*lc,*rc;\n\tnode(){ pa=lc=rc=NULL; size=1;}\n\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc){size=1;}\n};\nint x;\nint llc[3010],rrc[3010];\nint a[3010];\nbool hasfound;\nint ans;\n\nint updateh(node *s)\n{\n\tif(!s) return 0;\n\treturn s->size=updateh(s->lc)+updateh(s->rc)+1;\n}\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[a[n]])\n\t{\t\n\t\ts->lc=build(llc[a[n]]);\n\t\tif(s->lc)\n\t\t\ts->lc->pa=s;\n\t}\n\tif(rrc[a[n]])\n\t{\t\n\t\ts->rc=build(rrc[a[n]]);\n\t\tif(s->rc)\n\t\t\ts->rc->pa=s;\n\t}\n\treturn s;\n}\n\nvoid found(node *s)\n{\n\tif(hasfound==true) return;\n\tans++;\n\tif(s->data==x)\n\t{\n\t\thasfound=true;\n\t\treturn;\n\t}\n\tif( !s->lc&&s->rc )\n\t\tfound(s->rc);\n\telse if( !s->rc && s->lc )\n\t\tfound(s->lc);\n\telse if( !s->rc && !s->lc)\n\t\treturn;\n\telse\n\t{\n\t\tif(s->rc->size < s->lc->size || (s->rc->size==s->lc->size && s->rc->data < s->lc->data) )\n\t\t{\n\t\t\tfound(s->rc);\n\t\t\tfound(s->lc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfound(s->lc);\n\t\t\tfound(s->rc);\n\t\t}\n\t}\n}\n\n\nint main()\n{   \n\tint n;\n\tnode *tree;\n\tint tem1;\nwhile(~scanf(\"%d%d\",&n,&x))\n{\n\thasfound=false;\n\tans=0;\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\ta[i]=i;\n\t\tscanf(\"%d\",&tem1);\n\t\tif(tem1==0) continue;\n\t\telse if(tem1==1) \n\t\t{\t\n\t\t\tscanf(\"%d\",&llc[i]);\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\t}\n\t}\n\ttree=build(1);\n\tupdateh(tree);\n\tfound(tree);\n\tprintf(\"%d\\n\",ans);\n}\n    return 0;\n}\n```\n\n## 5. 子树相同\n\n[SDUT 3926: bLue的二叉树](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html)\n\n题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。\n\n思路：\n显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。\n在判断时，\n若tree1中当前节点的size和tree2的根节点size不等或者data不等\n若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点\n若子树的size小于tree2的size，就不判断了\n若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL; size=1;}\n\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){size=1; }\n};\n\nint llc[100010],rrc[100010];\nint a[100010];\nbool isroot[100010];\nint nroot;\nint ans;\nint pre1[100010],pre2[100010];\nint npre1,npre2;\n\nnode *tree1,*tree2;\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n\nvoid bbb(node *&tree, int n)\n{\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tmemset(isroot,0,sizeof(isroot));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\tisroot[llc[i]]=isroot[rrc[i]]=1;\n\t}\n\tfor(nroot=1; isroot[nroot]==1; nroot++);\n\ttree=build(nroot);\n}\n\nint update(node *tree)\n{\n\tif(!tree) return 0;\n\treturn tree->size=1+update(tree->lc)+update(tree->rc);\n}\n\nint n,m;\n\nbool equal(node *tree1, node *tree2)\n{\n\tif( !tree1 && !tree2 ) return true;\n\tif( (!tree1 && tree2) || ( tree1&&!tree2 ) ) return false; \n\tif(tree1->size!=tree2->size || tree1->data!=tree2->data)\n\t\treturn false;\n\treturn equal(tree1->lc,tree2->lc)&&equal(tree1->rc,tree2->rc);\n}\n\nvoid com(node *tree)\n{\n\tif(tree->size!=tree2->size || tree->data!=tree2->data)\n\t{\n\t\t\n\t\tif( tree->lc && tree->lc->size>=tree2->size)\n\t\t\tcom(tree->lc);\n\t\tif( tree->rc && tree->rc->size>=tree2->size)\n\t\t\tcom(tree->rc);\n\t}\n\telse\n\t\tif(equal(tree,tree2)==true)\n\t\t\tans++;\n\treturn;\n}\n\nvoid release(node *tree)\n{\n\tif(!tree) return;\n\trelease(tree->lc);\n\trelease(tree->rc);\n\tdelete tree;\n}\n\nint main()\n{   \nwhile(~scanf(\"%d%d\",&n,&m))\n{\n\tans=0;\n\tnpre1=npre2=0;\n\tmemset(pre1,0,sizeof(pre1));\n\tmemset(pre2,0,sizeof(pre2));\n\tbbb(tree1,n);\n\tbbb(tree2,m);\n\tif(m>n)\n\t{\n\t\tprintf(\"0\\n\");\n\t\tcontinue;\n\t}\n\tupdate(tree1);\n\tupdate(tree2);\n\tcom(tree1);\n\tprintf(\"%d\\n\",ans);\n\trelease(tree1);\n\trelease(tree2);\n}\n    return 0;\n}\n```\n\n\n## 6. Tree Travels again\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG)\n\n题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列\n\n思路：经过观察可以发现，入栈的顺序其实就是**先序遍历的序列**，出栈顺序就是**中序遍历的序列**，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了\n\n优化：\n在得到序列后，可以不用建树，直接根据序列得到后序序列\n思路：分治\n先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可\n\n代码：\n\n```\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <stdio.h>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n\nstruct Node\n{\n\tint data;\n\tNode * left,* right;\n\tNode() {left=right=NULL;}\n\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r){}\n};\n\nint pre[100],in[100];\nint stack[100];\nint top=0;\nint npre=0,nin=0;\nint ans[100];\n\nvoid solve(int prei , int ini , int posti, int n)\n{\n\tif(n<=0) return ; \n\tif(n==1)\n\t{\n\t\tans[posti]=pre[prei];\n\t\treturn;\n\t}\n\tans[posti+n-1]=pre[prei];\n\tint i;\n\tfor(i=0; in[i+ini]!=pre[prei] ; i++);\n\tsolve( prei+1 , ini , posti , i );\n\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tchar c[10];\n\tint tem;\n\t// 根据出入栈构造序列\n\twhile(cin>>c)\n\t{\n\t\tif(c[1]=='u')\n\t\t{\n\t\t\tcin>>tem;\n\t\t\tstack[top++]=tem;\n\t\t\tpre[npre++]=tem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin[nin++]=stack[--top];\n\t\t}\n\t}\n\tsolve(0,0,0,n);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```","source":"_posts/ProblemSet_Tree.md","raw":"---\nlayout: post\ntitle: \"题目小结：二叉树 ( 建树和遍历 )\"\ndate: 2017-08-18\ncomments: true\ntags: \n\t- c++\n\t- 数据结构\n\t- 刷题\n---\n\n\n# 二叉树练习：\n\n分为：\n树的构建\n树的同构\n子树节点数\n自定义遍历顺序\n子树相同\nTree Travels again\n\n<!-- more -->\n\n## 1. 树的构建\n\n有关二叉树的题目有以下几种输入建树方式：\n1.前序+中序遍历序列\n2.中序+后序遍历序列\n3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数\n4.每个节点子节点数目以及子节点编号\n5.先序序列，空节点以’,’代替\n\n### 1. 前序+中序遍历序列\n\n![前序+中序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG)\n\n从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。\n\n用流程表述如下：\n在前序中确定根节点->在中序中确定根节点->得知左右序列的长度->递归左右序列\n\n你可能会疑惑，那左右节点呢？不是能够确定吗？\n没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。\n\n```\nnode *build( char *pre, char * ins, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*pre ; i++);\n\ts= new node (*pre);\n\ts->lc=build(pre+1,ins,i);\n\ts->rc=build(pre+i+1,ins+i+1,n-i-1);\n\treturn s;\n}\n```\n\n### 2. 中序+后序遍历序列\n\n![中序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG)\n\n和前序+中序一般，这次不过是根节点在最后，流程是类似的。\n\n```\nnode *build(char *ins, char *post, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node (*(post+n-1));\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+n-1); i++);\n\ts=new node (*(post+n-1));\n\ts->lc=build(ins,post,i);\n\ts->rc=build(ins+i+1,post+i,n-i-1);\n\treturn s;\n}\n```\n\n### 3. 前序+后序序列\n\n![前序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG)\n\n那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？\n这时候就靠左孩子了。而根据给出的性质：**所有节点的子节点数均为偶数**可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）\n\n明确思路后修改一下细节就可以得到如下代码\n\n```\nnode * build( char *pre , char *post, int len )\n{ \n\tnode *s=NULL;\n\tif(len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new node (*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new node (*pre);\n\ts->lc=build(pre+1,post,i+1);\n\ts->rc=build(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n### 4. 子节点编号\n\n假设题目的输入如下：\n第一行为节点总数n，节点编号1-n\n紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。\n范例如下：\n\n```\n7 \n1 6 3\n2 0 4\n1 7 0\n3 0 0\n1 2 1\n2 0 0\n2 0 0\n```\n\n显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：**没有给出根节点编号！**，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。\n\n我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组\n3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。\n1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。\n\nbuild函数很简单，若有孩子则递归构建。\n\n```\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n```\n\n那输入要怎么处理？\n\n```\nmemset(isroot,0,sizeof(isroot)); // 数组归零，很重要！\nfor(int i=1; i<=n; i++)\n{\n\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理\n}\nfor(nroot=1; isroot[nroot]==1; nroot++);\ntree=build(nroot);\n```\n\n### 5. 先序序列\n\n还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）\n如\n\n```\nabc,,de,g,,f,,,\n```\n\n很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩\n\n```\nnode *build( int &fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据\n// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir>=n)方便\n{\n\tnode *s=NULL;\n\tif(fir>=n) return s;\n\tif(pre[fir]==',' ) return s;\n\ts=new node(pre[fir]);\n\ts->lc=build(++fir,n);\n\ts->rc=build(++fir,n);\n\treturn s;\n}\n```\n\n## 2. 树的同构\n\n[SDUT 3340: 数据结构实验之二叉树一：树的同构](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html)\n\n题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。\n\n例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。\n\n![图1](http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim)\n\n![图2](http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim)\n\n难点：\n\n1. 树的构建\n2. 同构判断\n\n坑：\n\n1. n和m可能不同\n   在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。\n2. n和m可能为0 (分别或同时)\n\n判等思路：\n1.粗糙版：贪心同构tree1，看看能不能变成tree2。\ntree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样\n\n2.递归巧妙版：判断当前节点数值是否相等\n若两个节点都不存在，返回正确。\n若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&&（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&&（tree1右孩子+tree2左孩子）。\n若不等或者只有其中一个存在，返回错。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n\nchar a[15];\nint llc[15],rrc[15];\nint n,m;\nchar tem1,tem2;\nbool isroot[15];\nint nroot;\n\nstruct node\n{\n\tchar data;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL;}\n\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){}\n};\n\nnode * build(int i)\n{\n\tnode *s=new node (a[i]);\n\tif(llc[i]!=-1)\n\t\ts->lc=build(llc[i]);\n\tif(rrc[i]!=-1)\n\t\ts->rc=build(rrc[i]);\n\treturn s;\n}\n\nnode * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等\n{\n\tnroot=0;\n\tmemset(isroot,0,sizeof(isroot));\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=0; i<n1; i++)\n\t{\t\n\t\tcin>>a[i]>>tem1>>tem2;\n\t\tif(tem1=='-') \n\t\t\tllc[i]=-1;\n\t\telse\n\t\t{\n\t\t\tllc[i]=tem1-'0';\n\t\t\tisroot[llc[i]]=1;\n\t\t}\n\t\tif(tem2=='-') \n\t\t\trrc[i]=-1;\n\t\telse\n\t\t{\n\t\t\trrc[i]=tem2-'0';\n\t\t\tisroot[rrc[i]]=1;\n\t\t}\n\t}\n\tfor( nroot=0; nroot<n1; nroot++)\n\t\tif(isroot[nroot]==0)\n\t\t\tbreak;\n\treturn build(nroot);\n}\n\nbool change(node*r1, node *r2)\n{\n\tif(!r1 && !r2) \n\t\treturn 1;\n\tif(r1&&r2)\n\t{\n\t\tif(r1->data==r2->data)\n\t\t{\n\t\t\tif( (change(r1->rc,r2->rc))&&(change(r1->lc,r2->lc))  || (change(r1->lc,r2->rc))&&(change(r1->rc,r2->lc))   )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\nwhile(cin>>n)\n{\n\tnode* tree1,*tree2;\n\tif(n)\n\t\ttree1=rebuild(n);\n\tcin>>m;\n\tif(m)\n\t\ttree2=rebuild(m);\n\tif(change(tree1,tree2))\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n}\n\treturn 0;\n}\n```\n\n## 3. 子树节点数\n\n[九度OJ 1113：二叉树](http://ac.jobdu.com/problem.php?pid=1113)\n\n题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数\n\n一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。\n\n个人想法（不一定为最简）：\n先求得m和n所在二叉树的高度lenm和lenn，求得’<’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count*po个节点，最后一层的节点数减去count*po后，剩下在po范围里的则是最后一层m可以加上的节点数。\n\n![解法图示](http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim)\n\ncmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n \nint getheight(int num)\n{\n    return (int)(log(num)*1.0/(log(2)*1.0));\n}\n \nint main()\n{   \n    int m,n;\n\twhile(  scanf(\"%d%d\",&m,&n)&& m+n  )\n\t{   \n\t\tint lenm=getheight(m),lenn=getheight(n);\n\t\tint count=0;\n\t\tint po=1;\n\t\tint ans=0;\n\t\tfor(int i=m-1; ; i--)\n\t\t{\n\t\t\tif(getheight(i)!=lenm)\n\t\t\t\tbreak;\n\t\t\tcount++;  // 找出同层中m左边有多少个节点\n\t\t}\n    \n\t\tfor(int i=lenm; i<lenn; i++)\n\t\t{\n\t\t\tans+=po;   // 在lenn层前的子树节点总数\n\t\t\tpo*=2;\n\t\t}\n\t\tcount*=po;\n\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号\n\t\tif(n<=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围\n\t\t\tprintf(\"%d\\n\",ans);\n\t\telse\n\t\t{\n\t\t\tn-= count+fir-1;\n\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围\n\t\t\tans+=n;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n    return 0;\n}\n```\n\n## 4. 自定义遍历顺序\n\n[SDUT 3133: C要–二叉树中的秘密](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html)\n\n题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。\n\n遍历顺序：\n若根节点只有左子树或右子树，则遍历子树。\n若左右子树均没有，则返回父节点\n若左右子树均有\n若左右节点高度不同，优先遍历高度小的\n若左右节点高度相同，优先遍历储存的数据较小的\n\n难点：\n1.建树\n2.按规则实现遍历\n\n思路：\n跟着题意走就行，注意细节。\n每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *pa,*lc,*rc;\n\tnode(){ pa=lc=rc=NULL; size=1;}\n\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc){size=1;}\n};\nint x;\nint llc[3010],rrc[3010];\nint a[3010];\nbool hasfound;\nint ans;\n\nint updateh(node *s)\n{\n\tif(!s) return 0;\n\treturn s->size=updateh(s->lc)+updateh(s->rc)+1;\n}\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[a[n]])\n\t{\t\n\t\ts->lc=build(llc[a[n]]);\n\t\tif(s->lc)\n\t\t\ts->lc->pa=s;\n\t}\n\tif(rrc[a[n]])\n\t{\t\n\t\ts->rc=build(rrc[a[n]]);\n\t\tif(s->rc)\n\t\t\ts->rc->pa=s;\n\t}\n\treturn s;\n}\n\nvoid found(node *s)\n{\n\tif(hasfound==true) return;\n\tans++;\n\tif(s->data==x)\n\t{\n\t\thasfound=true;\n\t\treturn;\n\t}\n\tif( !s->lc&&s->rc )\n\t\tfound(s->rc);\n\telse if( !s->rc && s->lc )\n\t\tfound(s->lc);\n\telse if( !s->rc && !s->lc)\n\t\treturn;\n\telse\n\t{\n\t\tif(s->rc->size < s->lc->size || (s->rc->size==s->lc->size && s->rc->data < s->lc->data) )\n\t\t{\n\t\t\tfound(s->rc);\n\t\t\tfound(s->lc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfound(s->lc);\n\t\t\tfound(s->rc);\n\t\t}\n\t}\n}\n\n\nint main()\n{   \n\tint n;\n\tnode *tree;\n\tint tem1;\nwhile(~scanf(\"%d%d\",&n,&x))\n{\n\thasfound=false;\n\tans=0;\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\ta[i]=i;\n\t\tscanf(\"%d\",&tem1);\n\t\tif(tem1==0) continue;\n\t\telse if(tem1==1) \n\t\t{\t\n\t\t\tscanf(\"%d\",&llc[i]);\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\t}\n\t}\n\ttree=build(1);\n\tupdateh(tree);\n\tfound(tree);\n\tprintf(\"%d\\n\",ans);\n}\n    return 0;\n}\n```\n\n## 5. 子树相同\n\n[SDUT 3926: bLue的二叉树](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html)\n\n题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。\n\n思路：\n显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。\n在判断时，\n若tree1中当前节点的size和tree2的根节点size不等或者data不等\n若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点\n若子树的size小于tree2的size，就不判断了\n若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL; size=1;}\n\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){size=1; }\n};\n\nint llc[100010],rrc[100010];\nint a[100010];\nbool isroot[100010];\nint nroot;\nint ans;\nint pre1[100010],pre2[100010];\nint npre1,npre2;\n\nnode *tree1,*tree2;\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n\nvoid bbb(node *&tree, int n)\n{\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tmemset(isroot,0,sizeof(isroot));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\tisroot[llc[i]]=isroot[rrc[i]]=1;\n\t}\n\tfor(nroot=1; isroot[nroot]==1; nroot++);\n\ttree=build(nroot);\n}\n\nint update(node *tree)\n{\n\tif(!tree) return 0;\n\treturn tree->size=1+update(tree->lc)+update(tree->rc);\n}\n\nint n,m;\n\nbool equal(node *tree1, node *tree2)\n{\n\tif( !tree1 && !tree2 ) return true;\n\tif( (!tree1 && tree2) || ( tree1&&!tree2 ) ) return false; \n\tif(tree1->size!=tree2->size || tree1->data!=tree2->data)\n\t\treturn false;\n\treturn equal(tree1->lc,tree2->lc)&&equal(tree1->rc,tree2->rc);\n}\n\nvoid com(node *tree)\n{\n\tif(tree->size!=tree2->size || tree->data!=tree2->data)\n\t{\n\t\t\n\t\tif( tree->lc && tree->lc->size>=tree2->size)\n\t\t\tcom(tree->lc);\n\t\tif( tree->rc && tree->rc->size>=tree2->size)\n\t\t\tcom(tree->rc);\n\t}\n\telse\n\t\tif(equal(tree,tree2)==true)\n\t\t\tans++;\n\treturn;\n}\n\nvoid release(node *tree)\n{\n\tif(!tree) return;\n\trelease(tree->lc);\n\trelease(tree->rc);\n\tdelete tree;\n}\n\nint main()\n{   \nwhile(~scanf(\"%d%d\",&n,&m))\n{\n\tans=0;\n\tnpre1=npre2=0;\n\tmemset(pre1,0,sizeof(pre1));\n\tmemset(pre2,0,sizeof(pre2));\n\tbbb(tree1,n);\n\tbbb(tree2,m);\n\tif(m>n)\n\t{\n\t\tprintf(\"0\\n\");\n\t\tcontinue;\n\t}\n\tupdate(tree1);\n\tupdate(tree2);\n\tcom(tree1);\n\tprintf(\"%d\\n\",ans);\n\trelease(tree1);\n\trelease(tree2);\n}\n    return 0;\n}\n```\n\n\n## 6. Tree Travels again\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG)\n\n题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列\n\n思路：经过观察可以发现，入栈的顺序其实就是**先序遍历的序列**，出栈顺序就是**中序遍历的序列**，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了\n\n优化：\n在得到序列后，可以不用建树，直接根据序列得到后序序列\n思路：分治\n先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可\n\n代码：\n\n```\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <stdio.h>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n\nstruct Node\n{\n\tint data;\n\tNode * left,* right;\n\tNode() {left=right=NULL;}\n\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r){}\n};\n\nint pre[100],in[100];\nint stack[100];\nint top=0;\nint npre=0,nin=0;\nint ans[100];\n\nvoid solve(int prei , int ini , int posti, int n)\n{\n\tif(n<=0) return ; \n\tif(n==1)\n\t{\n\t\tans[posti]=pre[prei];\n\t\treturn;\n\t}\n\tans[posti+n-1]=pre[prei];\n\tint i;\n\tfor(i=0; in[i+ini]!=pre[prei] ; i++);\n\tsolve( prei+1 , ini , posti , i );\n\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tchar c[10];\n\tint tem;\n\t// 根据出入栈构造序列\n\twhile(cin>>c)\n\t{\n\t\tif(c[1]=='u')\n\t\t{\n\t\t\tcin>>tem;\n\t\t\tstack[top++]=tem;\n\t\t\tpre[npre++]=tem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin[nin++]=stack[--top];\n\t\t}\n\t}\n\tsolve(0,0,0,n);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```","slug":"ProblemSet_Tree","published":1,"updated":"2018-05-25T12:41:12.805Z","photos":[],"link":"","_id":"cjleshqjn000nryfcsixr9bce","content":"<h1 id=\"二叉树练习：\"><a href=\"#二叉树练习：\" class=\"headerlink\" title=\"二叉树练习：\"></a>二叉树练习：</h1><p>分为：<br>树的构建<br>树的同构<br>子树节点数<br>自定义遍历顺序<br>子树相同<br>Tree Travels again</p>\n<a id=\"more\"></a>\n<h2 id=\"1-树的构建\"><a href=\"#1-树的构建\" class=\"headerlink\" title=\"1. 树的构建\"></a>1. 树的构建</h2><p>有关二叉树的题目有以下几种输入建树方式：<br>1.前序+中序遍历序列<br>2.中序+后序遍历序列<br>3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数<br>4.每个节点子节点数目以及子节点编号<br>5.先序序列，空节点以’,’代替</p>\n<h3 id=\"1-前序-中序遍历序列\"><a href=\"#1-前序-中序遍历序列\" class=\"headerlink\" title=\"1. 前序+中序遍历序列\"></a>1. 前序+中序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG\" alt=\"前序+中序\"></p>\n<p>从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。</p>\n<p>用流程表述如下：<br>在前序中确定根节点-&gt;在中序中确定根节点-&gt;得知左右序列的长度-&gt;递归左右序列</p>\n<p>你可能会疑惑，那左右节点呢？不是能够确定吗？<br>没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( char *pre, char * ins, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*pre ; i++);</span><br><span class=\"line\">\ts= new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,ins,i);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+1,ins+i+1,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序-后序遍历序列\"><a href=\"#2-中序-后序遍历序列\" class=\"headerlink\" title=\"2. 中序+后序遍历序列\"></a>2. 中序+后序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG\" alt=\"中序+后序\"></p>\n<p>和前序+中序一般，这次不过是根节点在最后，流程是类似的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build(char *ins, char *post, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*(post+n-1));</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+n-1); i++);</span><br><span class=\"line\">\ts=new node (*(post+n-1));</span><br><span class=\"line\">\ts-&gt;lc=build(ins,post,i);</span><br><span class=\"line\">\ts-&gt;rc=build(ins+i+1,post+i,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-前序-后序序列\"><a href=\"#3-前序-后序序列\" class=\"headerlink\" title=\"3. 前序+后序序列\"></a>3. 前序+后序序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG\" alt=\"前序+后序\"></p>\n<p>那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？<br>这时候就靠左孩子了。而根据给出的性质：<strong>所有节点的子节点数均为偶数</strong>可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）</p>\n<p>明确思路后修改一下细节就可以得到如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build( char *pre , char *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-子节点编号\"><a href=\"#4-子节点编号\" class=\"headerlink\" title=\"4. 子节点编号\"></a>4. 子节点编号</h3><p>假设题目的输入如下：<br>第一行为节点总数n，节点编号1-n<br>紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。<br>范例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 </span><br><span class=\"line\">1 6 3</span><br><span class=\"line\">2 0 4</span><br><span class=\"line\">1 7 0</span><br><span class=\"line\">3 0 0</span><br><span class=\"line\">1 2 1</span><br><span class=\"line\">2 0 0</span><br><span class=\"line\">2 0 0</span><br></pre></td></tr></table></figure>\n<p>显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：<strong>没有给出根节点编号！</strong>，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。</p>\n<p>我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组<br>3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。<br>1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。</p>\n<p>build函数很简单，若有孩子则递归构建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那输入要怎么处理？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memset(isroot,0,sizeof(isroot)); // 数组归零，很重要！</span><br><span class=\"line\">for(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">tree=build(nroot);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-先序序列\"><a href=\"#5-先序序列\" class=\"headerlink\" title=\"5. 先序序列\"></a>5. 先序序列</h3><p>还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）<br>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abc,,de,g,,f,,,</span><br></pre></td></tr></table></figure>\n<p>很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( int &amp;fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据</span><br><span class=\"line\">// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir&gt;=n)方便</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(fir&gt;=n) return s;</span><br><span class=\"line\">\tif(pre[fir]==&apos;,&apos; ) return s;</span><br><span class=\"line\">\ts=new node(pre[fir]);</span><br><span class=\"line\">\ts-&gt;lc=build(++fir,n);</span><br><span class=\"line\">\ts-&gt;rc=build(++fir,n);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-树的同构\"><a href=\"#2-树的同构\" class=\"headerlink\" title=\"2. 树的同构\"></a>2. 树的同构</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html\" target=\"_blank\" rel=\"noopener\">SDUT 3340: 数据结构实验之二叉树一：树的同构</a></p>\n<p>题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p>\n<p>例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim\" alt=\"图1\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim\" alt=\"图2\"></p>\n<p>难点：</p>\n<ol>\n<li>树的构建</li>\n<li>同构判断</li>\n</ol>\n<p>坑：</p>\n<ol>\n<li>n和m可能不同<br>在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。</li>\n<li>n和m可能为0 (分别或同时)</li>\n</ol>\n<p>判等思路：<br>1.粗糙版：贪心同构tree1，看看能不能变成tree2。<br>tree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样</p>\n<p>2.递归巧妙版：判断当前节点数值是否相等<br>若两个节点都不存在，返回正确。<br>若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&amp;&amp;（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&amp;&amp;（tree1右孩子+tree2左孩子）。<br>若不等或者只有其中一个存在，返回错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">char a[15];</span><br><span class=\"line\">int llc[15],rrc[15];</span><br><span class=\"line\">int n,m;</span><br><span class=\"line\">char tem1,tem2;</span><br><span class=\"line\">bool isroot[15];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\"></span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar data;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL;&#125;</span><br><span class=\"line\">\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node (a[i]);</span><br><span class=\"line\">\tif(llc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[i]);</span><br><span class=\"line\">\tif(rrc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[i]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnroot=0;</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n1; i++)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i]&gt;&gt;tem1&gt;&gt;tem2;</span><br><span class=\"line\">\t\tif(tem1==&apos;-&apos;) </span><br><span class=\"line\">\t\t\tllc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tllc[i]=tem1-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[llc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(tem2==&apos;-&apos;) </span><br><span class=\"line\">\t\t\trrc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\trrc[i]=tem2-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[rrc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( nroot=0; nroot&lt;n1; nroot++)</span><br><span class=\"line\">\t\tif(isroot[nroot]==0)</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\treturn build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool change(node*r1, node *r2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!r1 &amp;&amp; !r2) </span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tif(r1&amp;&amp;r2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(r1-&gt;data==r2-&gt;data)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( (change(r1-&gt;rc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;lc,r2-&gt;lc))  || (change(r1-&gt;lc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;rc,r2-&gt;lc))   )</span><br><span class=\"line\">\t\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">while(cin&gt;&gt;n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode* tree1,*tree2;</span><br><span class=\"line\">\tif(n)</span><br><span class=\"line\">\t\ttree1=rebuild(n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\tif(m)</span><br><span class=\"line\">\t\ttree2=rebuild(m);</span><br><span class=\"line\">\tif(change(tree1,tree2))</span><br><span class=\"line\">\t\tprintf(&quot;Yes\\n&quot;);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tprintf(&quot;No\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-子树节点数\"><a href=\"#3-子树节点数\" class=\"headerlink\" title=\"3. 子树节点数\"></a>3. 子树节点数</h2><p><a href=\"http://ac.jobdu.com/problem.php?pid=1113\" target=\"_blank\" rel=\"noopener\">九度OJ 1113：二叉树</a></p>\n<p>题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数</p>\n<p>一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。</p>\n<p>个人想法（不一定为最简）：<br>先求得m和n所在二叉树的高度lenm和lenn，求得’&lt;’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count<em>po个节点，最后一层的节点数减去count</em>po后，剩下在po范围里的则是最后一层m可以加上的节点数。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim\" alt=\"解法图示\"></p>\n<p>cmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">int getheight(int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (int)(log(num)*1.0/(log(2)*1.0));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    int m,n;</span><br><span class=\"line\">\twhile(  scanf(&quot;%d%d&quot;,&amp;m,&amp;n)&amp;&amp; m+n  )</span><br><span class=\"line\">\t&#123;   </span><br><span class=\"line\">\t\tint lenm=getheight(m),lenn=getheight(n);</span><br><span class=\"line\">\t\tint count=0;</span><br><span class=\"line\">\t\tint po=1;</span><br><span class=\"line\">\t\tint ans=0;</span><br><span class=\"line\">\t\tfor(int i=m-1; ; i--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif(getheight(i)!=lenm)</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcount++;  // 找出同层中m左边有多少个节点</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\tfor(int i=lenm; i&lt;lenn; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tans+=po;   // 在lenn层前的子树节点总数</span><br><span class=\"line\">\t\t\tpo*=2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount*=po;</span><br><span class=\"line\">\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号</span><br><span class=\"line\">\t\tif(n&lt;=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tn-= count+fir-1;</span><br><span class=\"line\">\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围</span><br><span class=\"line\">\t\t\tans+=n;</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-自定义遍历顺序\"><a href=\"#4-自定义遍历顺序\" class=\"headerlink\" title=\"4. 自定义遍历顺序\"></a>4. 自定义遍历顺序</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html\" target=\"_blank\" rel=\"noopener\">SDUT 3133: C要–二叉树中的秘密</a></p>\n<p>题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。</p>\n<p>遍历顺序：<br>若根节点只有左子树或右子树，则遍历子树。<br>若左右子树均没有，则返回父节点<br>若左右子树均有<br>若左右节点高度不同，优先遍历高度小的<br>若左右节点高度相同，优先遍历储存的数据较小的</p>\n<p>难点：<br>1.建树<br>2.按规则实现遍历</p>\n<p>思路：<br>跟着题意走就行，注意细节。<br>每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *pa,*lc,*rc;</span><br><span class=\"line\">\tnode()&#123; pa=lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc)&#123;size=1;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int x;</span><br><span class=\"line\">int llc[3010],rrc[3010];</span><br><span class=\"line\">int a[3010];</span><br><span class=\"line\">bool hasfound;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\"></span><br><span class=\"line\">int updateh(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!s) return 0;</span><br><span class=\"line\">\treturn s-&gt;size=updateh(s-&gt;lc)+updateh(s-&gt;rc)+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;lc)</span><br><span class=\"line\">\t\t\ts-&gt;lc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(rrc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;rc)</span><br><span class=\"line\">\t\t\ts-&gt;rc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void found(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(hasfound==true) return;</span><br><span class=\"line\">\tans++;</span><br><span class=\"line\">\tif(s-&gt;data==x)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thasfound=true;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s-&gt;lc&amp;&amp;s-&gt;rc )</span><br><span class=\"line\">\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; s-&gt;lc )</span><br><span class=\"line\">\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; !s-&gt;lc)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s-&gt;rc-&gt;size &lt; s-&gt;lc-&gt;size || (s-&gt;rc-&gt;size==s-&gt;lc-&gt;size &amp;&amp; s-&gt;rc-&gt;data &lt; s-&gt;lc-&gt;data) )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tnode *tree;</span><br><span class=\"line\">\tint tem1;</span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;x))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\thasfound=false;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[i]=i;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem1);</span><br><span class=\"line\">\t\tif(tem1==0) continue;</span><br><span class=\"line\">\t\telse if(tem1==1) </span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;llc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttree=build(1);</span><br><span class=\"line\">\tupdateh(tree);</span><br><span class=\"line\">\tfound(tree);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-子树相同\"><a href=\"#5-子树相同\" class=\"headerlink\" title=\"5. 子树相同\"></a>5. 子树相同</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html\" target=\"_blank\" rel=\"noopener\">SDUT 3926: bLue的二叉树</a></p>\n<p>题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。</p>\n<p>思路：<br>显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。<br>在判断时，<br>若tree1中当前节点的size和tree2的根节点size不等或者data不等<br>若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点<br>若子树的size小于tree2的size，就不判断了<br>若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;size=1; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int llc[100010],rrc[100010];</span><br><span class=\"line\">int a[100010];</span><br><span class=\"line\">bool isroot[100010];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\">int pre1[100010],pre2[100010];</span><br><span class=\"line\">int npre1,npre2;</span><br><span class=\"line\"></span><br><span class=\"line\">node *tree1,*tree2;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void bbb(node *&amp;tree, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\tisroot[llc[i]]=isroot[rrc[i]]=1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">\ttree=build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int update(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return 0;</span><br><span class=\"line\">\treturn tree-&gt;size=1+update(tree-&gt;lc)+update(tree-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int n,m;</span><br><span class=\"line\"></span><br><span class=\"line\">bool equal(node *tree1, node *tree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( !tree1 &amp;&amp; !tree2 ) return true;</span><br><span class=\"line\">\tif( (!tree1 &amp;&amp; tree2) || ( tree1&amp;&amp;!tree2 ) ) return false; </span><br><span class=\"line\">\tif(tree1-&gt;size!=tree2-&gt;size || tree1-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn equal(tree1-&gt;lc,tree2-&gt;lc)&amp;&amp;equal(tree1-&gt;rc,tree2-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void com(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(tree-&gt;size!=tree2-&gt;size || tree-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tif( tree-&gt;lc &amp;&amp; tree-&gt;lc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;lc);</span><br><span class=\"line\">\t\tif( tree-&gt;rc &amp;&amp; tree-&gt;rc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;rc);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif(equal(tree,tree2)==true)</span><br><span class=\"line\">\t\t\tans++;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void release(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return;</span><br><span class=\"line\">\trelease(tree-&gt;lc);</span><br><span class=\"line\">\trelease(tree-&gt;rc);</span><br><span class=\"line\">\tdelete tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tnpre1=npre2=0;</span><br><span class=\"line\">\tmemset(pre1,0,sizeof(pre1));</span><br><span class=\"line\">\tmemset(pre2,0,sizeof(pre2));</span><br><span class=\"line\">\tbbb(tree1,n);</span><br><span class=\"line\">\tbbb(tree2,m);</span><br><span class=\"line\">\tif(m&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tupdate(tree1);</span><br><span class=\"line\">\tupdate(tree2);</span><br><span class=\"line\">\tcom(tree1);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\trelease(tree1);</span><br><span class=\"line\">\trelease(tree2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-Tree-Travels-again\"><a href=\"#6-Tree-Travels-again\" class=\"headerlink\" title=\"6. Tree Travels again\"></a>6. Tree Travels again</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG\" alt=\"mark\"></p>\n<p>题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列</p>\n<p>思路：经过观察可以发现，入栈的顺序其实就是<strong>先序遍历的序列</strong>，出栈顺序就是<strong>中序遍历的序列</strong>，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了</p>\n<p>优化：<br>在得到序列后，可以不用建树，直接根据序列得到后序序列<br>思路：分治<br>先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctime&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tNode * left,* right;</span><br><span class=\"line\">\tNode() &#123;left=right=NULL;&#125;</span><br><span class=\"line\">\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int pre[100],in[100];</span><br><span class=\"line\">int stack[100];</span><br><span class=\"line\">int top=0;</span><br><span class=\"line\">int npre=0,nin=0;</span><br><span class=\"line\">int ans[100];</span><br><span class=\"line\"></span><br><span class=\"line\">void solve(int prei , int ini , int posti, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(n&lt;=0) return ; </span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans[posti]=pre[prei];</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans[posti+n-1]=pre[prei];</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; in[i+ini]!=pre[prei] ; i++);</span><br><span class=\"line\">\tsolve( prei+1 , ini , posti , i );</span><br><span class=\"line\">\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tchar c[10];</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\t// 根据出入栈构造序列</span><br><span class=\"line\">\twhile(cin&gt;&gt;c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(c[1]==&apos;u&apos;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;tem;</span><br><span class=\"line\">\t\t\tstack[top++]=tem;</span><br><span class=\"line\">\t\t\tpre[npre++]=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tin[nin++]=stack[--top];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsolve(0,0,0,n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(i) printf(&quot; &quot;);</span><br><span class=\"line\">\t\tprintf(&quot;%d&quot;,ans[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"二叉树练习：\"><a href=\"#二叉树练习：\" class=\"headerlink\" title=\"二叉树练习：\"></a>二叉树练习：</h1><p>分为：<br>树的构建<br>树的同构<br>子树节点数<br>自定义遍历顺序<br>子树相同<br>Tree Travels again</p>","more":"<h2 id=\"1-树的构建\"><a href=\"#1-树的构建\" class=\"headerlink\" title=\"1. 树的构建\"></a>1. 树的构建</h2><p>有关二叉树的题目有以下几种输入建树方式：<br>1.前序+中序遍历序列<br>2.中序+后序遍历序列<br>3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数<br>4.每个节点子节点数目以及子节点编号<br>5.先序序列，空节点以’,’代替</p>\n<h3 id=\"1-前序-中序遍历序列\"><a href=\"#1-前序-中序遍历序列\" class=\"headerlink\" title=\"1. 前序+中序遍历序列\"></a>1. 前序+中序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG\" alt=\"前序+中序\"></p>\n<p>从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。</p>\n<p>用流程表述如下：<br>在前序中确定根节点-&gt;在中序中确定根节点-&gt;得知左右序列的长度-&gt;递归左右序列</p>\n<p>你可能会疑惑，那左右节点呢？不是能够确定吗？<br>没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( char *pre, char * ins, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*pre ; i++);</span><br><span class=\"line\">\ts= new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,ins,i);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+1,ins+i+1,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序-后序遍历序列\"><a href=\"#2-中序-后序遍历序列\" class=\"headerlink\" title=\"2. 中序+后序遍历序列\"></a>2. 中序+后序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG\" alt=\"中序+后序\"></p>\n<p>和前序+中序一般，这次不过是根节点在最后，流程是类似的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build(char *ins, char *post, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*(post+n-1));</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+n-1); i++);</span><br><span class=\"line\">\ts=new node (*(post+n-1));</span><br><span class=\"line\">\ts-&gt;lc=build(ins,post,i);</span><br><span class=\"line\">\ts-&gt;rc=build(ins+i+1,post+i,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-前序-后序序列\"><a href=\"#3-前序-后序序列\" class=\"headerlink\" title=\"3. 前序+后序序列\"></a>3. 前序+后序序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG\" alt=\"前序+后序\"></p>\n<p>那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？<br>这时候就靠左孩子了。而根据给出的性质：<strong>所有节点的子节点数均为偶数</strong>可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）</p>\n<p>明确思路后修改一下细节就可以得到如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build( char *pre , char *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-子节点编号\"><a href=\"#4-子节点编号\" class=\"headerlink\" title=\"4. 子节点编号\"></a>4. 子节点编号</h3><p>假设题目的输入如下：<br>第一行为节点总数n，节点编号1-n<br>紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。<br>范例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 </span><br><span class=\"line\">1 6 3</span><br><span class=\"line\">2 0 4</span><br><span class=\"line\">1 7 0</span><br><span class=\"line\">3 0 0</span><br><span class=\"line\">1 2 1</span><br><span class=\"line\">2 0 0</span><br><span class=\"line\">2 0 0</span><br></pre></td></tr></table></figure>\n<p>显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：<strong>没有给出根节点编号！</strong>，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。</p>\n<p>我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组<br>3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。<br>1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。</p>\n<p>build函数很简单，若有孩子则递归构建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那输入要怎么处理？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memset(isroot,0,sizeof(isroot)); // 数组归零，很重要！</span><br><span class=\"line\">for(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">tree=build(nroot);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-先序序列\"><a href=\"#5-先序序列\" class=\"headerlink\" title=\"5. 先序序列\"></a>5. 先序序列</h3><p>还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）<br>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abc,,de,g,,f,,,</span><br></pre></td></tr></table></figure>\n<p>很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( int &amp;fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据</span><br><span class=\"line\">// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir&gt;=n)方便</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(fir&gt;=n) return s;</span><br><span class=\"line\">\tif(pre[fir]==&apos;,&apos; ) return s;</span><br><span class=\"line\">\ts=new node(pre[fir]);</span><br><span class=\"line\">\ts-&gt;lc=build(++fir,n);</span><br><span class=\"line\">\ts-&gt;rc=build(++fir,n);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-树的同构\"><a href=\"#2-树的同构\" class=\"headerlink\" title=\"2. 树的同构\"></a>2. 树的同构</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html\" target=\"_blank\" rel=\"noopener\">SDUT 3340: 数据结构实验之二叉树一：树的同构</a></p>\n<p>题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p>\n<p>例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim\" alt=\"图1\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim\" alt=\"图2\"></p>\n<p>难点：</p>\n<ol>\n<li>树的构建</li>\n<li>同构判断</li>\n</ol>\n<p>坑：</p>\n<ol>\n<li>n和m可能不同<br>在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。</li>\n<li>n和m可能为0 (分别或同时)</li>\n</ol>\n<p>判等思路：<br>1.粗糙版：贪心同构tree1，看看能不能变成tree2。<br>tree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样</p>\n<p>2.递归巧妙版：判断当前节点数值是否相等<br>若两个节点都不存在，返回正确。<br>若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&amp;&amp;（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&amp;&amp;（tree1右孩子+tree2左孩子）。<br>若不等或者只有其中一个存在，返回错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">char a[15];</span><br><span class=\"line\">int llc[15],rrc[15];</span><br><span class=\"line\">int n,m;</span><br><span class=\"line\">char tem1,tem2;</span><br><span class=\"line\">bool isroot[15];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\"></span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar data;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL;&#125;</span><br><span class=\"line\">\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node (a[i]);</span><br><span class=\"line\">\tif(llc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[i]);</span><br><span class=\"line\">\tif(rrc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[i]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnroot=0;</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n1; i++)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i]&gt;&gt;tem1&gt;&gt;tem2;</span><br><span class=\"line\">\t\tif(tem1==&apos;-&apos;) </span><br><span class=\"line\">\t\t\tllc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tllc[i]=tem1-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[llc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(tem2==&apos;-&apos;) </span><br><span class=\"line\">\t\t\trrc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\trrc[i]=tem2-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[rrc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( nroot=0; nroot&lt;n1; nroot++)</span><br><span class=\"line\">\t\tif(isroot[nroot]==0)</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\treturn build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool change(node*r1, node *r2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!r1 &amp;&amp; !r2) </span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tif(r1&amp;&amp;r2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(r1-&gt;data==r2-&gt;data)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( (change(r1-&gt;rc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;lc,r2-&gt;lc))  || (change(r1-&gt;lc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;rc,r2-&gt;lc))   )</span><br><span class=\"line\">\t\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">while(cin&gt;&gt;n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode* tree1,*tree2;</span><br><span class=\"line\">\tif(n)</span><br><span class=\"line\">\t\ttree1=rebuild(n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\tif(m)</span><br><span class=\"line\">\t\ttree2=rebuild(m);</span><br><span class=\"line\">\tif(change(tree1,tree2))</span><br><span class=\"line\">\t\tprintf(&quot;Yes\\n&quot;);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tprintf(&quot;No\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-子树节点数\"><a href=\"#3-子树节点数\" class=\"headerlink\" title=\"3. 子树节点数\"></a>3. 子树节点数</h2><p><a href=\"http://ac.jobdu.com/problem.php?pid=1113\" target=\"_blank\" rel=\"noopener\">九度OJ 1113：二叉树</a></p>\n<p>题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数</p>\n<p>一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。</p>\n<p>个人想法（不一定为最简）：<br>先求得m和n所在二叉树的高度lenm和lenn，求得’&lt;’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count<em>po个节点，最后一层的节点数减去count</em>po后，剩下在po范围里的则是最后一层m可以加上的节点数。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim\" alt=\"解法图示\"></p>\n<p>cmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">int getheight(int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (int)(log(num)*1.0/(log(2)*1.0));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    int m,n;</span><br><span class=\"line\">\twhile(  scanf(&quot;%d%d&quot;,&amp;m,&amp;n)&amp;&amp; m+n  )</span><br><span class=\"line\">\t&#123;   </span><br><span class=\"line\">\t\tint lenm=getheight(m),lenn=getheight(n);</span><br><span class=\"line\">\t\tint count=0;</span><br><span class=\"line\">\t\tint po=1;</span><br><span class=\"line\">\t\tint ans=0;</span><br><span class=\"line\">\t\tfor(int i=m-1; ; i--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif(getheight(i)!=lenm)</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcount++;  // 找出同层中m左边有多少个节点</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\tfor(int i=lenm; i&lt;lenn; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tans+=po;   // 在lenn层前的子树节点总数</span><br><span class=\"line\">\t\t\tpo*=2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount*=po;</span><br><span class=\"line\">\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号</span><br><span class=\"line\">\t\tif(n&lt;=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tn-= count+fir-1;</span><br><span class=\"line\">\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围</span><br><span class=\"line\">\t\t\tans+=n;</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-自定义遍历顺序\"><a href=\"#4-自定义遍历顺序\" class=\"headerlink\" title=\"4. 自定义遍历顺序\"></a>4. 自定义遍历顺序</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html\" target=\"_blank\" rel=\"noopener\">SDUT 3133: C要–二叉树中的秘密</a></p>\n<p>题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。</p>\n<p>遍历顺序：<br>若根节点只有左子树或右子树，则遍历子树。<br>若左右子树均没有，则返回父节点<br>若左右子树均有<br>若左右节点高度不同，优先遍历高度小的<br>若左右节点高度相同，优先遍历储存的数据较小的</p>\n<p>难点：<br>1.建树<br>2.按规则实现遍历</p>\n<p>思路：<br>跟着题意走就行，注意细节。<br>每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *pa,*lc,*rc;</span><br><span class=\"line\">\tnode()&#123; pa=lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc)&#123;size=1;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int x;</span><br><span class=\"line\">int llc[3010],rrc[3010];</span><br><span class=\"line\">int a[3010];</span><br><span class=\"line\">bool hasfound;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\"></span><br><span class=\"line\">int updateh(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!s) return 0;</span><br><span class=\"line\">\treturn s-&gt;size=updateh(s-&gt;lc)+updateh(s-&gt;rc)+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;lc)</span><br><span class=\"line\">\t\t\ts-&gt;lc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(rrc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;rc)</span><br><span class=\"line\">\t\t\ts-&gt;rc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void found(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(hasfound==true) return;</span><br><span class=\"line\">\tans++;</span><br><span class=\"line\">\tif(s-&gt;data==x)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thasfound=true;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s-&gt;lc&amp;&amp;s-&gt;rc )</span><br><span class=\"line\">\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; s-&gt;lc )</span><br><span class=\"line\">\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; !s-&gt;lc)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s-&gt;rc-&gt;size &lt; s-&gt;lc-&gt;size || (s-&gt;rc-&gt;size==s-&gt;lc-&gt;size &amp;&amp; s-&gt;rc-&gt;data &lt; s-&gt;lc-&gt;data) )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tnode *tree;</span><br><span class=\"line\">\tint tem1;</span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;x))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\thasfound=false;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[i]=i;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem1);</span><br><span class=\"line\">\t\tif(tem1==0) continue;</span><br><span class=\"line\">\t\telse if(tem1==1) </span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;llc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttree=build(1);</span><br><span class=\"line\">\tupdateh(tree);</span><br><span class=\"line\">\tfound(tree);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-子树相同\"><a href=\"#5-子树相同\" class=\"headerlink\" title=\"5. 子树相同\"></a>5. 子树相同</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html\" target=\"_blank\" rel=\"noopener\">SDUT 3926: bLue的二叉树</a></p>\n<p>题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。</p>\n<p>思路：<br>显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。<br>在判断时，<br>若tree1中当前节点的size和tree2的根节点size不等或者data不等<br>若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点<br>若子树的size小于tree2的size，就不判断了<br>若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;size=1; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int llc[100010],rrc[100010];</span><br><span class=\"line\">int a[100010];</span><br><span class=\"line\">bool isroot[100010];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\">int pre1[100010],pre2[100010];</span><br><span class=\"line\">int npre1,npre2;</span><br><span class=\"line\"></span><br><span class=\"line\">node *tree1,*tree2;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void bbb(node *&amp;tree, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\tisroot[llc[i]]=isroot[rrc[i]]=1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">\ttree=build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int update(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return 0;</span><br><span class=\"line\">\treturn tree-&gt;size=1+update(tree-&gt;lc)+update(tree-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int n,m;</span><br><span class=\"line\"></span><br><span class=\"line\">bool equal(node *tree1, node *tree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( !tree1 &amp;&amp; !tree2 ) return true;</span><br><span class=\"line\">\tif( (!tree1 &amp;&amp; tree2) || ( tree1&amp;&amp;!tree2 ) ) return false; </span><br><span class=\"line\">\tif(tree1-&gt;size!=tree2-&gt;size || tree1-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn equal(tree1-&gt;lc,tree2-&gt;lc)&amp;&amp;equal(tree1-&gt;rc,tree2-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void com(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(tree-&gt;size!=tree2-&gt;size || tree-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tif( tree-&gt;lc &amp;&amp; tree-&gt;lc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;lc);</span><br><span class=\"line\">\t\tif( tree-&gt;rc &amp;&amp; tree-&gt;rc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;rc);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif(equal(tree,tree2)==true)</span><br><span class=\"line\">\t\t\tans++;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void release(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return;</span><br><span class=\"line\">\trelease(tree-&gt;lc);</span><br><span class=\"line\">\trelease(tree-&gt;rc);</span><br><span class=\"line\">\tdelete tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tnpre1=npre2=0;</span><br><span class=\"line\">\tmemset(pre1,0,sizeof(pre1));</span><br><span class=\"line\">\tmemset(pre2,0,sizeof(pre2));</span><br><span class=\"line\">\tbbb(tree1,n);</span><br><span class=\"line\">\tbbb(tree2,m);</span><br><span class=\"line\">\tif(m&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tupdate(tree1);</span><br><span class=\"line\">\tupdate(tree2);</span><br><span class=\"line\">\tcom(tree1);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\trelease(tree1);</span><br><span class=\"line\">\trelease(tree2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-Tree-Travels-again\"><a href=\"#6-Tree-Travels-again\" class=\"headerlink\" title=\"6. Tree Travels again\"></a>6. Tree Travels again</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG\" alt=\"mark\"></p>\n<p>题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列</p>\n<p>思路：经过观察可以发现，入栈的顺序其实就是<strong>先序遍历的序列</strong>，出栈顺序就是<strong>中序遍历的序列</strong>，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了</p>\n<p>优化：<br>在得到序列后，可以不用建树，直接根据序列得到后序序列<br>思路：分治<br>先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctime&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tNode * left,* right;</span><br><span class=\"line\">\tNode() &#123;left=right=NULL;&#125;</span><br><span class=\"line\">\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int pre[100],in[100];</span><br><span class=\"line\">int stack[100];</span><br><span class=\"line\">int top=0;</span><br><span class=\"line\">int npre=0,nin=0;</span><br><span class=\"line\">int ans[100];</span><br><span class=\"line\"></span><br><span class=\"line\">void solve(int prei , int ini , int posti, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(n&lt;=0) return ; </span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans[posti]=pre[prei];</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans[posti+n-1]=pre[prei];</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; in[i+ini]!=pre[prei] ; i++);</span><br><span class=\"line\">\tsolve( prei+1 , ini , posti , i );</span><br><span class=\"line\">\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tchar c[10];</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\t// 根据出入栈构造序列</span><br><span class=\"line\">\twhile(cin&gt;&gt;c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(c[1]==&apos;u&apos;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;tem;</span><br><span class=\"line\">\t\t\tstack[top++]=tem;</span><br><span class=\"line\">\t\t\tpre[npre++]=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tin[nin++]=stack[--top];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsolve(0,0,0,n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(i) printf(&quot; &quot;);</span><br><span class=\"line\">\t\tprintf(&quot;%d&quot;,ans[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"复现Entropy-based Term Weighting Schemes for Text Categorization in VSM小结","date":"2018-05-31T16:00:00.000Z","comments":1,"_content":"\n\n论文 [Entropy-based Term Weighting Schemes for Text Categorization in VSM](https://ieeexplore.ieee.org/document/7372153/) 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。\n\n在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。\n\n复现基于python2.7，KNN使用[sklearn](http://scikit-learn.org/)包，SVM和原论文同样使用[liblinear](https://www.csie.ntu.edu.tw/~cjlin/liblinear/)，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。\n\n<!-- more -->\n\n## 理论介绍\n\n### VSM向量空间模型\n\n在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：\n\n假设词汇表有  ['one', 'apple','a','day','an'], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率\n\n文章a = \"one day\". 那么 它的向量则是 [1,0,0,1,0]\n\n文章b = \"an apple\"， 则代表b的向量是[0,1,0,0,1]\n\none hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出**一个词的辨别能力**。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 \"算法\" 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。\n\n就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。\n\n由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。\n\n### 旧方法\n\n为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：\n\n大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：\n\n1. PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。\n2. NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了\n3. 计算权重得基于标签，但测试文档本身就不具备标签\n\n对于非监督的计算方法，就拿tf-idf来说，其能力在于**将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来**。\n\n文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。\n\n#### tf·idf\n\n作为最流行的权重计算方法，其计算方法分为两个部分\n\n一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n_{i,j}}{\\sum_{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可\n\n另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一\n\n最终的 tf-idf就等于两者相乘。\n\n#### tf·chi\n\n基于统计的卡方检验和下面一些计算方法都基于以下这个表格：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/abcd.png)\n\nA：类别k中出现了词j的文档数目\n\nB：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可\n\nC：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A\n\nD：其它类别不包含词j的数目，用其它类文档总数 - B\n\n卡方检验的原始公式和近似公式：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png)\n\n#### tf·ig\n\nInformation Gain 信息增益：增加了这个信息使得系统的熵降低了多少。\n\n在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ig.png)\n\nP(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 \n\nP(t)：词语T出现的概率，用出现过T的文档数除以总文档数 \n\nP(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 \n\nP(～t)：词语T不出现的概率，用 1 - P(t) 即可\n\nP(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 \n\n#### tf·eccd\n\n论文 [Entropy based feature selection for text categorization](https://hal.archives-ouvertes.fr/hal-00617969/document) 同样提出了一种基于熵的权重计算方法\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd0.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd1.png)\n\n#### tf·rf\n\n由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/rf.png)\n\n#### iqf·qf·icf\n\n这篇论文  [Term weighting schemes for question categorization](https://www.ncbi.nlm.nih.gov/pubmed/20733219) 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf\\*qf\\*icf、qf\\*icf 和 vrf。\n\n和rf相比，iqf\\*qf\\*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf1.png)\n\n### 新的权重计算方法\n\n#### tf·dc\n\n论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。\n\n思想基于两点：\n\n1. 辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高\n2. 集中程度越高的词，具有的熵越小\n\n![](http://ot1c7ttzm.bkt.clouddn.com/dc.png)\n\nH(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目\n\n由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。\n\n#### tf·bdc\n\n考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。\n\n为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/bdc.png)\n\n## 复现过程\n\n### 用特征权重进行文本分类的思路\n\n文本分类的整个过程如下：\n\n1. 通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：\n   1. 词语权重表\n   2. 词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。\n   3. 模型参数\n2. 对于每篇测试文档：\n   1. 根据词汇表删去无关词汇\n   2. 查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示\n   3. 将文档向量作为特征输入分类模型中，得到预测结果\n\n### 数据处理\n\n语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：[Reuters-21578 R8](http://ana.cachopo.org/datasets-for-single-label-text-categorization)，[TrainingSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0)， [TestSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0) .\n\n获得语料之后，一个比较重要的地方在于制作特征向量和标签。\n\n我的特征向量和标签制作方法是：\n\n1. 对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。\n2. 对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。\n\n### 维度压缩\n\n在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。\n\n解决方法就是删去频率过高和过低的词：\n\n1. 统计训练语料中的词语频率得到词频表和词汇表\n2. 使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考\n3. 根据长度、频率分布挑选阈值，根据上下界删减词汇表\n4. 根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。\n\n通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png)\n\n<center>删减前</center>\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png)\n\n<center>删减后</center>\n\n### KNN中的cos近似\n\n下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条[stackoverflow上的回答](https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier)：\n\n回答分为两个方面：\n\n1. 指出为什么cosine相似度没有在sklearn包中：\n\n   cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。\n\n2. 给出了解决方法：\n\n   1. 可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。\n   2. 第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 \n\n![](http://ot1c7ttzm.bkt.clouddn.com/cosine.png)\n\n看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。\n\n### 论文细节\n\n论文中的实验部分有这么一句话：\n\n> To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.\n\n鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。\n\n权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  \n\n```python\ntf[document][word] = frequency[document][word] / doclength[document]\n```\n\n另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。\n\n```python\ntf_idf[document][word] = tf[document][word] * idf[word]\n```\n\n而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：\n\n```python\ntf_chi[document][word] = tf[document][word] * chi[label][word]\n```\n\n那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：\n\n```python\nif weights[labell].has_key(word):\n\ttf_chi[doc][word] *= weights[labell][word]\nelse:\n\ttf_chi[doc][word] *= max([ weights[x][word]  for x in weights if weights[x].has_key(word)])\n```\n\n由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。\n\n### 衡量标准\n\n根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：\n\n1. MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数\n\n2. MacroF1 就是通常的F1的均值：\n\n   1. $ MacroF1 = avg(F1)$ \n\n   2. $ F1(C) = \\frac{2\\*precision\\*recall}{(precision + recall)}$ \n\n   3. $ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数\n      $ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目\n\n   4. TP: true positive  属于C被分到C（预测正确）\n      TN: true nagative  属于C被分到其它类（预测错误）\n      FP: false positive 不属于C被正确分类（预测正确）\n      FN: false nagative 不属于C被分到C（预测错误）\n\n## 复现结果\n\n下面是复现之后的结果：\n\n笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/result.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/Result.png)\n\n论文给出的最终结果：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png)\n\n笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/knn.png)\n\n论文给出的关系图：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png)\n\n可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。\n\n## 小结\n\n通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。\n\n## 源代码\n\n原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：[我的github](https://github.com/zedom1/nlp/tree/master/VSM)","source":"_posts/VSM.md","raw":"---\nlayout: post\ntitle: \"复现Entropy-based Term Weighting Schemes for Text Categorization in VSM小结\"\ndate: 2018-06-01\ncomments: true\ntags: \n   - 机器学习\n   - NLP\n   - VSM\n---\n\n\n论文 [Entropy-based Term Weighting Schemes for Text Categorization in VSM](https://ieeexplore.ieee.org/document/7372153/) 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。\n\n在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。\n\n复现基于python2.7，KNN使用[sklearn](http://scikit-learn.org/)包，SVM和原论文同样使用[liblinear](https://www.csie.ntu.edu.tw/~cjlin/liblinear/)，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。\n\n<!-- more -->\n\n## 理论介绍\n\n### VSM向量空间模型\n\n在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：\n\n假设词汇表有  ['one', 'apple','a','day','an'], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率\n\n文章a = \"one day\". 那么 它的向量则是 [1,0,0,1,0]\n\n文章b = \"an apple\"， 则代表b的向量是[0,1,0,0,1]\n\none hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出**一个词的辨别能力**。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 \"算法\" 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。\n\n就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。\n\n由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。\n\n### 旧方法\n\n为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：\n\n大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：\n\n1. PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。\n2. NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了\n3. 计算权重得基于标签，但测试文档本身就不具备标签\n\n对于非监督的计算方法，就拿tf-idf来说，其能力在于**将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来**。\n\n文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。\n\n#### tf·idf\n\n作为最流行的权重计算方法，其计算方法分为两个部分\n\n一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n_{i,j}}{\\sum_{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可\n\n另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一\n\n最终的 tf-idf就等于两者相乘。\n\n#### tf·chi\n\n基于统计的卡方检验和下面一些计算方法都基于以下这个表格：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/abcd.png)\n\nA：类别k中出现了词j的文档数目\n\nB：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可\n\nC：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A\n\nD：其它类别不包含词j的数目，用其它类文档总数 - B\n\n卡方检验的原始公式和近似公式：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png)\n\n#### tf·ig\n\nInformation Gain 信息增益：增加了这个信息使得系统的熵降低了多少。\n\n在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ig.png)\n\nP(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 \n\nP(t)：词语T出现的概率，用出现过T的文档数除以总文档数 \n\nP(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 \n\nP(～t)：词语T不出现的概率，用 1 - P(t) 即可\n\nP(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 \n\n#### tf·eccd\n\n论文 [Entropy based feature selection for text categorization](https://hal.archives-ouvertes.fr/hal-00617969/document) 同样提出了一种基于熵的权重计算方法\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd0.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd1.png)\n\n#### tf·rf\n\n由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/rf.png)\n\n#### iqf·qf·icf\n\n这篇论文  [Term weighting schemes for question categorization](https://www.ncbi.nlm.nih.gov/pubmed/20733219) 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf\\*qf\\*icf、qf\\*icf 和 vrf。\n\n和rf相比，iqf\\*qf\\*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf1.png)\n\n### 新的权重计算方法\n\n#### tf·dc\n\n论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。\n\n思想基于两点：\n\n1. 辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高\n2. 集中程度越高的词，具有的熵越小\n\n![](http://ot1c7ttzm.bkt.clouddn.com/dc.png)\n\nH(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目\n\n由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。\n\n#### tf·bdc\n\n考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。\n\n为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/bdc.png)\n\n## 复现过程\n\n### 用特征权重进行文本分类的思路\n\n文本分类的整个过程如下：\n\n1. 通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：\n   1. 词语权重表\n   2. 词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。\n   3. 模型参数\n2. 对于每篇测试文档：\n   1. 根据词汇表删去无关词汇\n   2. 查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示\n   3. 将文档向量作为特征输入分类模型中，得到预测结果\n\n### 数据处理\n\n语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：[Reuters-21578 R8](http://ana.cachopo.org/datasets-for-single-label-text-categorization)，[TrainingSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0)， [TestSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0) .\n\n获得语料之后，一个比较重要的地方在于制作特征向量和标签。\n\n我的特征向量和标签制作方法是：\n\n1. 对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。\n2. 对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。\n\n### 维度压缩\n\n在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。\n\n解决方法就是删去频率过高和过低的词：\n\n1. 统计训练语料中的词语频率得到词频表和词汇表\n2. 使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考\n3. 根据长度、频率分布挑选阈值，根据上下界删减词汇表\n4. 根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。\n\n通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png)\n\n<center>删减前</center>\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png)\n\n<center>删减后</center>\n\n### KNN中的cos近似\n\n下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条[stackoverflow上的回答](https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier)：\n\n回答分为两个方面：\n\n1. 指出为什么cosine相似度没有在sklearn包中：\n\n   cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。\n\n2. 给出了解决方法：\n\n   1. 可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。\n   2. 第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 \n\n![](http://ot1c7ttzm.bkt.clouddn.com/cosine.png)\n\n看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。\n\n### 论文细节\n\n论文中的实验部分有这么一句话：\n\n> To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.\n\n鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。\n\n权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  \n\n```python\ntf[document][word] = frequency[document][word] / doclength[document]\n```\n\n另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。\n\n```python\ntf_idf[document][word] = tf[document][word] * idf[word]\n```\n\n而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：\n\n```python\ntf_chi[document][word] = tf[document][word] * chi[label][word]\n```\n\n那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：\n\n```python\nif weights[labell].has_key(word):\n\ttf_chi[doc][word] *= weights[labell][word]\nelse:\n\ttf_chi[doc][word] *= max([ weights[x][word]  for x in weights if weights[x].has_key(word)])\n```\n\n由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。\n\n### 衡量标准\n\n根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：\n\n1. MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数\n\n2. MacroF1 就是通常的F1的均值：\n\n   1. $ MacroF1 = avg(F1)$ \n\n   2. $ F1(C) = \\frac{2\\*precision\\*recall}{(precision + recall)}$ \n\n   3. $ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数\n      $ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目\n\n   4. TP: true positive  属于C被分到C（预测正确）\n      TN: true nagative  属于C被分到其它类（预测错误）\n      FP: false positive 不属于C被正确分类（预测正确）\n      FN: false nagative 不属于C被分到C（预测错误）\n\n## 复现结果\n\n下面是复现之后的结果：\n\n笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/result.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/Result.png)\n\n论文给出的最终结果：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png)\n\n笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/knn.png)\n\n论文给出的关系图：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png)\n\n可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。\n\n## 小结\n\n通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。\n\n## 源代码\n\n原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：[我的github](https://github.com/zedom1/nlp/tree/master/VSM)","slug":"VSM","published":1,"updated":"2018-06-02T02:59:52.474Z","photos":[],"link":"","_id":"cjleshqjo000oryfc1skdypvi","content":"<p>论文 <a href=\"https://ieeexplore.ieee.org/document/7372153/\" target=\"_blank\" rel=\"noopener\">Entropy-based Term Weighting Schemes for Text Categorization in VSM</a> 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。</p>\n<p>在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。</p>\n<p>复现基于python2.7，KNN使用<a href=\"http://scikit-learn.org/\" target=\"_blank\" rel=\"noopener\">sklearn</a>包，SVM和原论文同样使用<a href=\"https://www.csie.ntu.edu.tw/~cjlin/liblinear/\" target=\"_blank\" rel=\"noopener\">liblinear</a>，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。</p>\n<a id=\"more\"></a>\n<h2 id=\"理论介绍\"><a href=\"#理论介绍\" class=\"headerlink\" title=\"理论介绍\"></a>理论介绍</h2><h3 id=\"VSM向量空间模型\"><a href=\"#VSM向量空间模型\" class=\"headerlink\" title=\"VSM向量空间模型\"></a>VSM向量空间模型</h3><p>在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：</p>\n<p>假设词汇表有  [‘one’, ‘apple’,’a’,’day’,’an’], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率</p>\n<p>文章a = “one day”. 那么 它的向量则是 [1,0,0,1,0]</p>\n<p>文章b = “an apple”， 则代表b的向量是[0,1,0,0,1]</p>\n<p>one hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出<strong>一个词的辨别能力</strong>。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 “算法” 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。</p>\n<p>就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。</p>\n<p>由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。</p>\n<h3 id=\"旧方法\"><a href=\"#旧方法\" class=\"headerlink\" title=\"旧方法\"></a>旧方法</h3><p>为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：</p>\n<p>大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：</p>\n<ol>\n<li>PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。</li>\n<li>NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了</li>\n<li>计算权重得基于标签，但测试文档本身就不具备标签</li>\n</ol>\n<p>对于非监督的计算方法，就拿tf-idf来说，其能力在于<strong>将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来</strong>。</p>\n<p>文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。</p>\n<h4 id=\"tf·idf\"><a href=\"#tf·idf\" class=\"headerlink\" title=\"tf·idf\"></a>tf·idf</h4><p>作为最流行的权重计算方法，其计算方法分为两个部分</p>\n<p>一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n<em>{i,j}}{\\sum</em>{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可</p>\n<p>另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一</p>\n<p>最终的 tf-idf就等于两者相乘。</p>\n<h4 id=\"tf·chi\"><a href=\"#tf·chi\" class=\"headerlink\" title=\"tf·chi\"></a>tf·chi</h4><p>基于统计的卡方检验和下面一些计算方法都基于以下这个表格：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/abcd.png\" alt=\"\"></p>\n<p>A：类别k中出现了词j的文档数目</p>\n<p>B：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可</p>\n<p>C：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A</p>\n<p>D：其它类别不包含词j的数目，用其它类文档总数 - B</p>\n<p>卡方检验的原始公式和近似公式：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png\" alt=\"\"></p>\n<h4 id=\"tf·ig\"><a href=\"#tf·ig\" class=\"headerlink\" title=\"tf·ig\"></a>tf·ig</h4><p>Information Gain 信息增益：增加了这个信息使得系统的熵降低了多少。</p>\n<p>在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ig.png\" alt=\"\"></p>\n<p>P(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 </p>\n<p>P(t)：词语T出现的概率，用出现过T的文档数除以总文档数 </p>\n<p>P(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 </p>\n<p>P(～t)：词语T不出现的概率，用 1 - P(t) 即可</p>\n<p>P(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 </p>\n<h4 id=\"tf·eccd\"><a href=\"#tf·eccd\" class=\"headerlink\" title=\"tf·eccd\"></a>tf·eccd</h4><p>论文 <a href=\"https://hal.archives-ouvertes.fr/hal-00617969/document\" target=\"_blank\" rel=\"noopener\">Entropy based feature selection for text categorization</a> 同样提出了一种基于熵的权重计算方法</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd0.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd1.png\" alt=\"\"></p>\n<h4 id=\"tf·rf\"><a href=\"#tf·rf\" class=\"headerlink\" title=\"tf·rf\"></a>tf·rf</h4><p>由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rf.png\" alt=\"\"></p>\n<h4 id=\"iqf·qf·icf\"><a href=\"#iqf·qf·icf\" class=\"headerlink\" title=\"iqf·qf·icf\"></a>iqf·qf·icf</h4><p>这篇论文  <a href=\"https://www.ncbi.nlm.nih.gov/pubmed/20733219\" target=\"_blank\" rel=\"noopener\">Term weighting schemes for question categorization</a> 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf*qf*icf、qf*icf 和 vrf。</p>\n<p>和rf相比，iqf*qf*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf1.png\" alt=\"\"></p>\n<h3 id=\"新的权重计算方法\"><a href=\"#新的权重计算方法\" class=\"headerlink\" title=\"新的权重计算方法\"></a>新的权重计算方法</h3><h4 id=\"tf·dc\"><a href=\"#tf·dc\" class=\"headerlink\" title=\"tf·dc\"></a>tf·dc</h4><p>论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。</p>\n<p>思想基于两点：</p>\n<ol>\n<li>辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高</li>\n<li>集中程度越高的词，具有的熵越小</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/dc.png\" alt=\"\"></p>\n<p>H(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目</p>\n<p>由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。</p>\n<h4 id=\"tf·bdc\"><a href=\"#tf·bdc\" class=\"headerlink\" title=\"tf·bdc\"></a>tf·bdc</h4><p>考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。</p>\n<p>为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/bdc.png\" alt=\"\"></p>\n<h2 id=\"复现过程\"><a href=\"#复现过程\" class=\"headerlink\" title=\"复现过程\"></a>复现过程</h2><h3 id=\"用特征权重进行文本分类的思路\"><a href=\"#用特征权重进行文本分类的思路\" class=\"headerlink\" title=\"用特征权重进行文本分类的思路\"></a>用特征权重进行文本分类的思路</h3><p>文本分类的整个过程如下：</p>\n<ol>\n<li>通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：<ol>\n<li>词语权重表</li>\n<li>词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。</li>\n<li>模型参数</li>\n</ol>\n</li>\n<li>对于每篇测试文档：<ol>\n<li>根据词汇表删去无关词汇</li>\n<li>查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示</li>\n<li>将文档向量作为特征输入分类模型中，得到预测结果</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><p>语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization\" target=\"_blank\" rel=\"noopener\">Reuters-21578 R8</a>，<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TrainingSet</a>， <a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TestSet</a> .</p>\n<p>获得语料之后，一个比较重要的地方在于制作特征向量和标签。</p>\n<p>我的特征向量和标签制作方法是：</p>\n<ol>\n<li>对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。</li>\n<li>对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。</li>\n</ol>\n<h3 id=\"维度压缩\"><a href=\"#维度压缩\" class=\"headerlink\" title=\"维度压缩\"></a>维度压缩</h3><p>在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。</p>\n<p>解决方法就是删去频率过高和过低的词：</p>\n<ol>\n<li>统计训练语料中的词语频率得到词频表和词汇表</li>\n<li>使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考</li>\n<li>根据长度、频率分布挑选阈值，根据上下界删减词汇表</li>\n<li>根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。</li>\n</ol>\n<p>通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png\" alt=\"\"></p>\n<center>删减前</center>\n\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png\" alt=\"\"></p>\n<center>删减后</center>\n\n<h3 id=\"KNN中的cos近似\"><a href=\"#KNN中的cos近似\" class=\"headerlink\" title=\"KNN中的cos近似\"></a>KNN中的cos近似</h3><p>下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条<a href=\"https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier\" target=\"_blank\" rel=\"noopener\">stackoverflow上的回答</a>：</p>\n<p>回答分为两个方面：</p>\n<ol>\n<li><p>指出为什么cosine相似度没有在sklearn包中：</p>\n<p>cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。</p>\n</li>\n<li><p>给出了解决方法：</p>\n<ol>\n<li>可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。</li>\n<li>第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 </li>\n</ol>\n</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/cosine.png\" alt=\"\"></p>\n<p>看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。</p>\n<h3 id=\"论文细节\"><a href=\"#论文细节\" class=\"headerlink\" title=\"论文细节\"></a>论文细节</h3><p>论文中的实验部分有这么一句话：</p>\n<blockquote>\n<p>To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.</p>\n</blockquote>\n<p>鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。</p>\n<p>权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf[document][word] = frequency[document][word] / doclength[document]</span><br></pre></td></tr></table></figure>\n<p>另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_idf[document][word] = tf[document][word] * idf[word]</span><br></pre></td></tr></table></figure>\n<p>而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_chi[document][word] = tf[document][word] * chi[label][word]</span><br></pre></td></tr></table></figure>\n<p>那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> weights[labell].has_key(word):</span><br><span class=\"line\">\ttf_chi[doc][word] *= weights[labell][word]</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\ttf_chi[doc][word] *= max([ weights[x][word]  <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> weights <span class=\"keyword\">if</span> weights[x].has_key(word)])</span><br></pre></td></tr></table></figure>\n<p>由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。</p>\n<h3 id=\"衡量标准\"><a href=\"#衡量标准\" class=\"headerlink\" title=\"衡量标准\"></a>衡量标准</h3><p>根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：</p>\n<ol>\n<li><p>MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数</p>\n</li>\n<li><p>MacroF1 就是通常的F1的均值：</p>\n<ol>\n<li><p>$ MacroF1 = avg(F1)$ </p>\n</li>\n<li><p>$ F1(C) = \\frac{2*precision*recall}{(precision + recall)}$ </p>\n</li>\n<li><p>$ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数<br>$ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目</p>\n</li>\n<li><p>TP: true positive  属于C被分到C（预测正确）<br>TN: true nagative  属于C被分到其它类（预测错误）<br>FP: false positive 不属于C被正确分类（预测正确）<br>FN: false nagative 不属于C被分到C（预测错误）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"复现结果\"><a href=\"#复现结果\" class=\"headerlink\" title=\"复现结果\"></a>复现结果</h2><p>下面是复现之后的结果：</p>\n<p>笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/result.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Result.png\" alt=\"\"></p>\n<p>论文给出的最终结果：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png\" alt=\"\"></p>\n<p>笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/knn.png\" alt=\"\"></p>\n<p>论文给出的关系图：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png\" alt=\"\"></p>\n<p>可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p>原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：<a href=\"https://github.com/zedom1/nlp/tree/master/VSM\" target=\"_blank\" rel=\"noopener\">我的github</a></p>\n","site":{"data":{}},"excerpt":"<p>论文 <a href=\"https://ieeexplore.ieee.org/document/7372153/\" target=\"_blank\" rel=\"noopener\">Entropy-based Term Weighting Schemes for Text Categorization in VSM</a> 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。</p>\n<p>在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。</p>\n<p>复现基于python2.7，KNN使用<a href=\"http://scikit-learn.org/\" target=\"_blank\" rel=\"noopener\">sklearn</a>包，SVM和原论文同样使用<a href=\"https://www.csie.ntu.edu.tw/~cjlin/liblinear/\" target=\"_blank\" rel=\"noopener\">liblinear</a>，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。</p>","more":"<h2 id=\"理论介绍\"><a href=\"#理论介绍\" class=\"headerlink\" title=\"理论介绍\"></a>理论介绍</h2><h3 id=\"VSM向量空间模型\"><a href=\"#VSM向量空间模型\" class=\"headerlink\" title=\"VSM向量空间模型\"></a>VSM向量空间模型</h3><p>在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：</p>\n<p>假设词汇表有  [‘one’, ‘apple’,’a’,’day’,’an’], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率</p>\n<p>文章a = “one day”. 那么 它的向量则是 [1,0,0,1,0]</p>\n<p>文章b = “an apple”， 则代表b的向量是[0,1,0,0,1]</p>\n<p>one hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出<strong>一个词的辨别能力</strong>。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 “算法” 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。</p>\n<p>就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。</p>\n<p>由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。</p>\n<h3 id=\"旧方法\"><a href=\"#旧方法\" class=\"headerlink\" title=\"旧方法\"></a>旧方法</h3><p>为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：</p>\n<p>大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：</p>\n<ol>\n<li>PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。</li>\n<li>NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了</li>\n<li>计算权重得基于标签，但测试文档本身就不具备标签</li>\n</ol>\n<p>对于非监督的计算方法，就拿tf-idf来说，其能力在于<strong>将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来</strong>。</p>\n<p>文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。</p>\n<h4 id=\"tf·idf\"><a href=\"#tf·idf\" class=\"headerlink\" title=\"tf·idf\"></a>tf·idf</h4><p>作为最流行的权重计算方法，其计算方法分为两个部分</p>\n<p>一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n<em>{i,j}}{\\sum</em>{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可</p>\n<p>另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一</p>\n<p>最终的 tf-idf就等于两者相乘。</p>\n<h4 id=\"tf·chi\"><a href=\"#tf·chi\" class=\"headerlink\" title=\"tf·chi\"></a>tf·chi</h4><p>基于统计的卡方检验和下面一些计算方法都基于以下这个表格：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/abcd.png\" alt=\"\"></p>\n<p>A：类别k中出现了词j的文档数目</p>\n<p>B：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可</p>\n<p>C：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A</p>\n<p>D：其它类别不包含词j的数目，用其它类文档总数 - B</p>\n<p>卡方检验的原始公式和近似公式：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png\" alt=\"\"></p>\n<h4 id=\"tf·ig\"><a href=\"#tf·ig\" class=\"headerlink\" title=\"tf·ig\"></a>tf·ig</h4><p>Information Gain 信息增益：增加了这个信息使得系统的熵降低了多少。</p>\n<p>在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ig.png\" alt=\"\"></p>\n<p>P(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 </p>\n<p>P(t)：词语T出现的概率，用出现过T的文档数除以总文档数 </p>\n<p>P(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 </p>\n<p>P(～t)：词语T不出现的概率，用 1 - P(t) 即可</p>\n<p>P(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 </p>\n<h4 id=\"tf·eccd\"><a href=\"#tf·eccd\" class=\"headerlink\" title=\"tf·eccd\"></a>tf·eccd</h4><p>论文 <a href=\"https://hal.archives-ouvertes.fr/hal-00617969/document\" target=\"_blank\" rel=\"noopener\">Entropy based feature selection for text categorization</a> 同样提出了一种基于熵的权重计算方法</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd0.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd1.png\" alt=\"\"></p>\n<h4 id=\"tf·rf\"><a href=\"#tf·rf\" class=\"headerlink\" title=\"tf·rf\"></a>tf·rf</h4><p>由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rf.png\" alt=\"\"></p>\n<h4 id=\"iqf·qf·icf\"><a href=\"#iqf·qf·icf\" class=\"headerlink\" title=\"iqf·qf·icf\"></a>iqf·qf·icf</h4><p>这篇论文  <a href=\"https://www.ncbi.nlm.nih.gov/pubmed/20733219\" target=\"_blank\" rel=\"noopener\">Term weighting schemes for question categorization</a> 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf*qf*icf、qf*icf 和 vrf。</p>\n<p>和rf相比，iqf*qf*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf1.png\" alt=\"\"></p>\n<h3 id=\"新的权重计算方法\"><a href=\"#新的权重计算方法\" class=\"headerlink\" title=\"新的权重计算方法\"></a>新的权重计算方法</h3><h4 id=\"tf·dc\"><a href=\"#tf·dc\" class=\"headerlink\" title=\"tf·dc\"></a>tf·dc</h4><p>论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。</p>\n<p>思想基于两点：</p>\n<ol>\n<li>辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高</li>\n<li>集中程度越高的词，具有的熵越小</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/dc.png\" alt=\"\"></p>\n<p>H(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目</p>\n<p>由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。</p>\n<h4 id=\"tf·bdc\"><a href=\"#tf·bdc\" class=\"headerlink\" title=\"tf·bdc\"></a>tf·bdc</h4><p>考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。</p>\n<p>为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/bdc.png\" alt=\"\"></p>\n<h2 id=\"复现过程\"><a href=\"#复现过程\" class=\"headerlink\" title=\"复现过程\"></a>复现过程</h2><h3 id=\"用特征权重进行文本分类的思路\"><a href=\"#用特征权重进行文本分类的思路\" class=\"headerlink\" title=\"用特征权重进行文本分类的思路\"></a>用特征权重进行文本分类的思路</h3><p>文本分类的整个过程如下：</p>\n<ol>\n<li>通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：<ol>\n<li>词语权重表</li>\n<li>词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。</li>\n<li>模型参数</li>\n</ol>\n</li>\n<li>对于每篇测试文档：<ol>\n<li>根据词汇表删去无关词汇</li>\n<li>查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示</li>\n<li>将文档向量作为特征输入分类模型中，得到预测结果</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><p>语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization\" target=\"_blank\" rel=\"noopener\">Reuters-21578 R8</a>，<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TrainingSet</a>， <a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TestSet</a> .</p>\n<p>获得语料之后，一个比较重要的地方在于制作特征向量和标签。</p>\n<p>我的特征向量和标签制作方法是：</p>\n<ol>\n<li>对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。</li>\n<li>对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。</li>\n</ol>\n<h3 id=\"维度压缩\"><a href=\"#维度压缩\" class=\"headerlink\" title=\"维度压缩\"></a>维度压缩</h3><p>在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。</p>\n<p>解决方法就是删去频率过高和过低的词：</p>\n<ol>\n<li>统计训练语料中的词语频率得到词频表和词汇表</li>\n<li>使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考</li>\n<li>根据长度、频率分布挑选阈值，根据上下界删减词汇表</li>\n<li>根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。</li>\n</ol>\n<p>通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png\" alt=\"\"></p>\n<center>删减前</center>\n\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png\" alt=\"\"></p>\n<center>删减后</center>\n\n<h3 id=\"KNN中的cos近似\"><a href=\"#KNN中的cos近似\" class=\"headerlink\" title=\"KNN中的cos近似\"></a>KNN中的cos近似</h3><p>下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条<a href=\"https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier\" target=\"_blank\" rel=\"noopener\">stackoverflow上的回答</a>：</p>\n<p>回答分为两个方面：</p>\n<ol>\n<li><p>指出为什么cosine相似度没有在sklearn包中：</p>\n<p>cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。</p>\n</li>\n<li><p>给出了解决方法：</p>\n<ol>\n<li>可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。</li>\n<li>第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 </li>\n</ol>\n</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/cosine.png\" alt=\"\"></p>\n<p>看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。</p>\n<h3 id=\"论文细节\"><a href=\"#论文细节\" class=\"headerlink\" title=\"论文细节\"></a>论文细节</h3><p>论文中的实验部分有这么一句话：</p>\n<blockquote>\n<p>To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.</p>\n</blockquote>\n<p>鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。</p>\n<p>权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf[document][word] = frequency[document][word] / doclength[document]</span><br></pre></td></tr></table></figure>\n<p>另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_idf[document][word] = tf[document][word] * idf[word]</span><br></pre></td></tr></table></figure>\n<p>而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_chi[document][word] = tf[document][word] * chi[label][word]</span><br></pre></td></tr></table></figure>\n<p>那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> weights[labell].has_key(word):</span><br><span class=\"line\">\ttf_chi[doc][word] *= weights[labell][word]</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\ttf_chi[doc][word] *= max([ weights[x][word]  <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> weights <span class=\"keyword\">if</span> weights[x].has_key(word)])</span><br></pre></td></tr></table></figure>\n<p>由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。</p>\n<h3 id=\"衡量标准\"><a href=\"#衡量标准\" class=\"headerlink\" title=\"衡量标准\"></a>衡量标准</h3><p>根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：</p>\n<ol>\n<li><p>MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数</p>\n</li>\n<li><p>MacroF1 就是通常的F1的均值：</p>\n<ol>\n<li><p>$ MacroF1 = avg(F1)$ </p>\n</li>\n<li><p>$ F1(C) = \\frac{2*precision*recall}{(precision + recall)}$ </p>\n</li>\n<li><p>$ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数<br>$ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目</p>\n</li>\n<li><p>TP: true positive  属于C被分到C（预测正确）<br>TN: true nagative  属于C被分到其它类（预测错误）<br>FP: false positive 不属于C被正确分类（预测正确）<br>FN: false nagative 不属于C被分到C（预测错误）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"复现结果\"><a href=\"#复现结果\" class=\"headerlink\" title=\"复现结果\"></a>复现结果</h2><p>下面是复现之后的结果：</p>\n<p>笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/result.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Result.png\" alt=\"\"></p>\n<p>论文给出的最终结果：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png\" alt=\"\"></p>\n<p>笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/knn.png\" alt=\"\"></p>\n<p>论文给出的关系图：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png\" alt=\"\"></p>\n<p>可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p>原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：<a href=\"https://github.com/zedom1/nlp/tree/master/VSM\" target=\"_blank\" rel=\"noopener\">我的github</a></p>"},{"layout":"post","title":"中文语音识别后检错纠错（一）：n-gram + 拼音相似度 + 词语搭配","date":"2018-07-21T16:00:00.000Z","comments":1,"_content":"\n有幸参加研究生师兄的创新创业项目，一个和金融企业合作的对话文本分析与挖掘的项目。项目组从公司处获得语音识别后的客服对话文本，我们对文本进行纠错、情感分析与挖掘等并最终给公司反馈，让公司能够从客服对话文本中获得有效信息。我在项目中参与的部分是文本处理的第一步：文本检错纠错。这几个月中，在研究生师兄的带领下，我们基于机器学习构建了数个用于语音识别后文本的检错纠错模型，在此将主要的两个方法：n-gram+拼音相似度+词语搭配， 双向LSTM模型的整个构建过程进行总结。\n\n本文介绍了我们采用的第一个方法：n-gram+拼音相似度+词语搭配。\n\n整体分为四个部分：\n\n1.  错误文本分析，语料获取、处理与利用\n2.  错误检测\n3.  错误纠正\n4.  模型评估\n\n<!-- more -->\n\n### Part  0  :  前置理论简述\n\n#### n-gram\n\nn-gram的思路非常简单易懂，即假设一个字或词出现仅与前n个词相关（n为人为给定），句子整体的概率等于所有词语搭配概率的乘积。常用的有2-gram（bi-gram）和3-gram（Tri-gram），词语概率的计算方法用到了概率论中的条件概率，此外用频数计算计算频率代替概率。人们通常用n-gram来评估一个句子是否合理。在这里，我们通过计算一个词语的n-gram分数来评估这个词语是否合理，以此检测错误词语。\n\n#### 依存句法\n\n依存句法通过分析词语间的依存关系揭示句子的结构，它可以识别出句子中的主谓宾、定状补等语法成分并分析各个成分之间的关系。除了能够解析句子并划分结构之外，它还能够找到句子的核心词并且分析词语之间的语义距离。\n\n#### 编辑距离与最长公共子串（LCS）\n\n编辑距离和LCS通常用于字符串的相似度匹配。\n\nLCS的思想很简单，就是两个字符串共有的子串的最大长度。\n\n编辑距离稍微复杂一点，编辑的方式分为三种：修改一个字符、增加一个字符、删去一个字符，第一个字符串通过应用以上三种编辑方式变成第二个字符串，所需要的最少的编辑次数（不限种类）称为编辑距离。\n\n### Part   1  :  错误文本分析，语料获取、处理与利用\n\n![语料利用](http://ot1c7ttzm.bkt.clouddn.com/ngram1.PNG)\n\n得到待测语料后，我们首先对文本进行观察，并结合这是语音识别后的前提，分析得到一下结果：\n\n#### 错误类型\n\n我们通过对待测语料的观察发现，对话文本中的错误除了包括常用词语的错误外，还包括金融方面的错误。并且由于是语音识别后的文本，错误主要与拼音有关。\n\n错误类型主要包括以下两大方面：\n\n1.  拼音相关：\n   1.  错音\n   2.  缺音\n   3.  多音\n   4.  拼音正确但词识别错误\n2.  说话者相关：\n   1.  反复：因为对话发生在打电话中，而说话者在想要尽力表达自己的意思时常常会将某个词或某个短句重复数次。\n   2.  倒装：与说话人的习惯以及对话情况有关。\n\n#### 错误原因分析\n\n在观察得到有哪些错误之后，我们开始着手对错误背后的原因进行分析并试图给出解决方案。\n\n语音识别方面：\n\n​\t由于语音识别是使用较为通用的工具，而客服对话涉及到很多金融方面的名词尤其是该企业的特定产品，因此在名词方面容易发生拼音正确但词识别错误的情况。这类错误既然集中于名词，那么我们通过构建专有名词库再通过拼音相似度进行识别即可。\n\n说话者方面：\n\n​\t考虑到这是电话咨询中的对话，客服人员方面由于经过专门的筛选和训练，因此普通话较为标准且吐字清晰，说话音量合理且很少有外部噪音。而咨询者没有限定，其口音、音量等方面会对识别造成较大影响。\n\n​\t此外，说话者的知识背景及成长环境会对其陈述的句子的语法结构有影响，可能会更倾向于使用倒装句。\n\n​\t第三，说话过程中咨询者一方可能会有额外噪音或突发事件，这些噪音起码会导致语句无法被识别，还可能导致误识别，在文本中增加一些无用词。\n\n​\t这方面的错误是识别错误的主体部分，我们打算采用的是基于统计的n-gram模型结合拼音的方案，通过n-gram找到说话者可能原本想说的词语，因为这是语音识别后的文本，因此在n-gram识别后再通过拼音相似度来纠正的正确率会很高。\n\n语言方面：\n\n​\t中文本身就极为复杂，多义性的句子比比皆是，拼音类似在不同的应用场景之下词语也不同，这类语义上的错误很难通过统计解决，如本文采用的n-gram模型，若要捕获长距离的句子依赖关系来对句子进行诊断，则需要构建不止2-gram、3-gram，那么模型对时间空间的消耗较大。而另一篇文章采用的双向LSTM则在这个问题的解决上会优于n-gram基于统计的方式。\n\n#### 训练语料获取\n\n1.  从网络上获取的搜狗通用新闻语料（数GB级）\n2.  网络获取的金融新闻语料（数百MB级）\n3.  人工从待测的句子中检测并纠正少部分句子（数MB级）\n\n#### 模型选择\n\n在经过对错误类型和错误原因经过分析之后，我们打算初步使用n-gram模型进行低级错误识别。考虑到错误除了涉及通用领域外还有金融领域，以及该企业特有名词，那构造n-gram模型就得同时考虑到这几个方面，构造一个通用的n-gram以及一个专业领域的n-gram。\n\n对于n的选择，考虑到对话主要是短文本，并且短句之间的联系并不大，因此我们将每个长句子都剪成短句子并以短句子为单位进行错误检测，因此构建2-gram与3-gram模型足够解决需要。\n\n最终我们敲定的n-gram模型如下：\n\n1.  由通用语料训练的模型，分为2-gram和3-gram，用来识别通常对话中的错误。\n2.  由金融新闻以及人工纠正过的待测句子训练的专业模型，同样分为2-gram和3-gram，用于识别金融领域乃至该公司领域的错误。\n\n#### 预处理\n\n在了解了目标和解决方向之后，就要实际开始处理语料了。\n\n数据处理要点：\n\n1.  重新分词（语料和待纠句子）\n2.  数字变星号\n3.  长句剪断（全角转半角），根据逗号、句号、问号、感叹号裁剪句子\n\n首先我要从项目的服务器上获取待纠错的文本数据，师兄先前已经做过一些工作，首先在java利用JDBC访问数据库，得到每份对话的id、分完词的对话。训练的通用语料以及专业语料则直接从服务器上下载。\n\n之后对待测语料和训练语料统一进行处理，由于训练语料未经过分词，而待测语料的分词工具未知，分词又对检测的结果有很大的影响，因此我对待测文本重新用和训练语料一样的工具进行分词。\n\n接下来我们将目光转向文本中的数字。文本中包含各种数字，但我们知道，它们虽然各异，但在不考虑数值差异的情况下基本相近，且前后可以连接的词也差不多。比如年月日，在给定格式的前提下里面只要是合理的数字即可，而在检错中我们并不需要考虑数字的合理性，因此对于待测语料和训练语料，我们统一将数字变成星号以去除不同数字相同模式的影响。去除方式也很简单粗暴，用正则表达式匹配替换即可。\n\n再之后就是句子裁剪了。如上文所提，我们用n-gram捕获低级的句子错误，并且对话中句子关联度并不如文章句子那般大，而对话长距离的语义错误n-gram本身就无法捕获，因此我们直接根据逗号、句号、问号等明显分割句子的标点符号进行句子切分，将长句子划分成数个短句子，而后以短句子为单位检测错误。\n\n#### 模型构建\n\n在对语料处理完之后，接下来进行n-gram模型的构建。在模型构建方面，我们利用berkeley提供的[自然语言处理工具包](http://mvnrepository.com/artifact/edu.berkeley.nlp/berkeleylm/1.1.2) 来生成n-gram模型，平滑(Smoothing)方面选用了工具包内置的较为优秀的平滑方法Kneser-Ney。\n\n工具包会将导入的分好词的txt文件生成成.arpa模型文件保存下来，以后要用到计算好的模型时直接读取arpa模型文件而后将待检测的句子分好词逐几个喂进去检测概率即可。\n\n在得到模型之后我自然要试试产生什么结果以及效果如何，在给出一个样例之后得到如下结果：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ngram4.PNG)\n\n其中-100是给模型的设置参数，当在ngram中找不到类似的匹配对时会输出-100.\n\n看到这结果有些让人疑惑，n-gram出来的不应该是概率吗？虽然在大规模语料中某个特定对的概率很低，但也应该分布在0和1之间呐，这负数又是怎么回事？在经过查阅和总结之后，我知道它采用的是log之后的概率，原因如下：\n\n   1. n-gram的原理：一系列小于1的概率的乘积，当它们相乘之后可能会变得非常小以至于float无法放下，而使用了log之后将乘积放大。\n   2. 便于求导和公式推导，套上log之后将概率的乘法变成了log的加法。\n   3. 不改变大小关系，原本概率越大的句子在使用log之后的数值是负数，但更靠近0，原本的大小顺序没有被破坏。\n\n由此，模型构建完成，接下来就要将文本导入模型进行错误检测了。\n\n### Part   2  :  错误检测\n\n![错误检测](http://ot1c7ttzm.bkt.clouddn.com/ngram0.PNG)\n\n模型的使用很简单，将待检测句子进行分词（在项目中我们的待测句子已经分好了词），而后扫描一遍句子获取词语对列表，对于2-gram则是从第二个词开始每个词语及其前面的词。如“ 系统 提示 查询 密码 不 正确”，那么2-gram的词语对列表就是： [系统，提示]、[提示，查询]、[查询，密码]、[密码，不]、[不，正确]。同理得到3-gram的词语对列表。\n\n将词语对列表分别导入两个n-gram模型，得到两个模型的2-gram和3-gram分数，总共四个分数，若四个分数均低于某个阈值，则认为该词出错。阈值为人工选定的数字，在我们的项目中选定的阈值为-5.5。\n\n在扫描过后，我们得到模型认为出错了的词语，为了在网页上进行标红以及之后的纠正处理，我们要将结果保存为JSON文件，文件以 中括号[] 嵌套的形式 记录每个大句子的id，大句子分割成的小句子的错误词语索引及词语本身，以及词语的2-gram，3-gram分数。\n\n### Part   3  :  错误纠正\n\n![错误纠正](http://ot1c7ttzm.bkt.clouddn.com/ngram2.PNG)\n\n在获得错误词语之后，接下来就要根据词语搭配和拼音相似度来纠正词语了。\n\n首先要获取词语搭配，师兄已经通过依存句法在语料中提取了词语搭配，然而提取之后的顺序是乱序。这时候之前训练的2-gram就派上用场了，将词语搭配的两个顺序导入两个2-gram中，最后选择分数较高的作为词语顺序保存下来。\n\n将词语搭配文件导入哈希表中，每个前驱词都对应一个备选词集，词集中的词是通常接在前驱词后面的词。\n\n获得词语搭配之后，接下来就要获取拼音并计算相似度了。纠正步骤如下：\n\n1.   首先，通过hanlp获取待纠正词语以及词语搭配表的拼音\n2.   根据待检测语料以及错误词语的索引获取错误词语的前一个词，查询搭配表得到备选词集\n3.   将错误词语的拼音和备选词集每个词的拼音求 编辑距离和LCS 的加权分数，取超过阈值的前几个词语进行观察\n4.   将备选词替换疑似错误词并代回n-gram模型中进行分数比较，取分数高者保存。\n\n分数的算法方面，第一想法是直接最长公共子串的匹配，但是在错误识别中有很多错音、多音、少音的例子，因为一个拼音而导致公共子串断裂，由此额外考虑编辑距离，两个算法都是用动态规划自行实现的。\n\n选定算法之后，我们还需要结合两个算法的结果。\n\n​\t对于最长公共子串，最终的结果是两个字符串最长公共子串的长度，越大则两个字符串匹配程度越高。考虑到越长的字符串最后的公共子串更可能越长，这对短字符串不公平，因此我将最终的最长子串长度除以第一个字符串（错误词语的拼音）的长度进行归一化。\n\n​\t对于编辑距离，最终的分数是第一个字符串需要改动多少才能变到第二个字符串，越小说明两个字符串匹配程度越高。我将最终分数取倒数，考虑到分数可能是0（两个字符串完全相同），则先在最终结果上+1而后再取倒数，这样同样对编辑距离进行归一化并且匹配程度越高，分数越高。\n\n​\t两个算法的分数结合方面，虽然两个算法有些相似但仍有不同点，我们更倾向于选择最长公共子串分数更高的，但是同样得考虑编辑距离，在经过观察与实验后选定最终分数为 0.5\\*编辑距离 + 0.8\\*LCS。这样，两个字符串在匹配的时候，既能以公共子串为主，又能考虑到少部分拼音出错的因素。\n\n### Part  4  :  模型简单评估\n\n在构建模型之后，我们还对模型检测错误的效果进行一个简单的评估。评估从待测语料中挑选50条句子，每句扩成几个只有一处错误的句子，句子不涉及语义错误，和完全正确的句子放在一起给模型进行测试，共176个测试样本。\n\n50条完全正确的句子，126个只含一处词语错误的句子，若模型给出的所有分数均低于阈值则模型认为这个句子完全完全正确。\n\n最终结果如图：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ngram5.jpg)\n\nTP ：模型判断正确：模型认为句子中有错误并且正确指出错误词语\n\nTN ：模型判断正确：模型认为句子没错误，句子本身完全正确\n\nFP ：模型判断出错：模型认为句子有错误但其判断出错，分为两种情况：\n\n1.  句子本身完全正确，但模型认为有错\n2.  句子本身有错，但模型认为错误的词语与句子的错误词语不匹配\n\nFN ：模型判断出错：模型认为句子无错误，句子包含错误\n\n### 总结\n\n#### 不足\n\nn-gram模型在检测低级错误上表现良好，准确率颇高，但这个方案仍有不足之处。\n\n##### 1. 训练语料：\n\n我们采用的搜狗通用语料是从新闻网页上爬取的结果，包含很多噪声文本，若要进行处理则需要花费较多额外功夫。\n\n金融新闻方面亦如此，此外还有些问题。虽然语料有金融方面的知识，但和对话相比过于正式，对话通常使用口语化表述，和正式的新闻文本的匹配程度并不是很高。\n\n除了语料本身的问题之外，在语料规模上也有待加强，n-gram这类基于统计的模型训练数据自然越多越好（噪声少的情况下），照目前结果来看，GB级的通用语料表现还不错，若要再加强一下效果还需要更多更好的训练数据，尤其是在金融方面以及对话方面的文本数据。\n\n我们所要识别的是对话过程中的错误，因此若有大量正确的对话文本用于训练那是再好不过，然而受限于对话文本语料库的规模，我们额外加入的人工纠正的对话文本虽然噪声较少，但样本数过少且费时费力。\n\n##### 2. 模型缺陷\n\n除了训练语料上的缺陷外，模型本身也并不完美。基于统计的模型并不能很好地捕获语义关联，长距离依赖以及上下句关联，若是试图将n扩展到4、5乃至更高，则会产生很多空值，平滑之后的分数大多很难低于阈值。因此，对于语义关联上的错误，我们打算采用双向LSTM检测，这就是后话了。\n\n#### 感悟\n\n经过从目标分析、文本数据分析以及原因诊断，再到选择模型、获取语料，之后进行预处理、构建模型，最后实际使用模型以及评估模型，这么个基本完整的流程走下来之后，我对机器学习在项目中的实际应用有了进一步的理解。此外，在任务进行的过程中有多个小任务，如何又快又好地完成小任务也同样需要考虑，这需要多语言之间的协作，JAVA的快速，Python的易用与多功能，都在完成任务的过程中给予我很大帮助。\n\n项目进行过程中同样也遇到了很多小问题，并且由于经验不足以及不像做题那般有答案可以对，时不时还会走下弯路，但最后还是靠着坚持和努力，比较好地完成了任务。","source":"_posts/chineseErrorDectection_n_gram.md","raw":"---\nlayout: post\ntitle: \"中文语音识别后检错纠错（一）：n-gram + 拼音相似度 + 词语搭配\"\ndate: 2018-07-22\ncomments: true\ntags: \n\t- NLP\n\t- 机器学习\n---\n\n有幸参加研究生师兄的创新创业项目，一个和金融企业合作的对话文本分析与挖掘的项目。项目组从公司处获得语音识别后的客服对话文本，我们对文本进行纠错、情感分析与挖掘等并最终给公司反馈，让公司能够从客服对话文本中获得有效信息。我在项目中参与的部分是文本处理的第一步：文本检错纠错。这几个月中，在研究生师兄的带领下，我们基于机器学习构建了数个用于语音识别后文本的检错纠错模型，在此将主要的两个方法：n-gram+拼音相似度+词语搭配， 双向LSTM模型的整个构建过程进行总结。\n\n本文介绍了我们采用的第一个方法：n-gram+拼音相似度+词语搭配。\n\n整体分为四个部分：\n\n1.  错误文本分析，语料获取、处理与利用\n2.  错误检测\n3.  错误纠正\n4.  模型评估\n\n<!-- more -->\n\n### Part  0  :  前置理论简述\n\n#### n-gram\n\nn-gram的思路非常简单易懂，即假设一个字或词出现仅与前n个词相关（n为人为给定），句子整体的概率等于所有词语搭配概率的乘积。常用的有2-gram（bi-gram）和3-gram（Tri-gram），词语概率的计算方法用到了概率论中的条件概率，此外用频数计算计算频率代替概率。人们通常用n-gram来评估一个句子是否合理。在这里，我们通过计算一个词语的n-gram分数来评估这个词语是否合理，以此检测错误词语。\n\n#### 依存句法\n\n依存句法通过分析词语间的依存关系揭示句子的结构，它可以识别出句子中的主谓宾、定状补等语法成分并分析各个成分之间的关系。除了能够解析句子并划分结构之外，它还能够找到句子的核心词并且分析词语之间的语义距离。\n\n#### 编辑距离与最长公共子串（LCS）\n\n编辑距离和LCS通常用于字符串的相似度匹配。\n\nLCS的思想很简单，就是两个字符串共有的子串的最大长度。\n\n编辑距离稍微复杂一点，编辑的方式分为三种：修改一个字符、增加一个字符、删去一个字符，第一个字符串通过应用以上三种编辑方式变成第二个字符串，所需要的最少的编辑次数（不限种类）称为编辑距离。\n\n### Part   1  :  错误文本分析，语料获取、处理与利用\n\n![语料利用](http://ot1c7ttzm.bkt.clouddn.com/ngram1.PNG)\n\n得到待测语料后，我们首先对文本进行观察，并结合这是语音识别后的前提，分析得到一下结果：\n\n#### 错误类型\n\n我们通过对待测语料的观察发现，对话文本中的错误除了包括常用词语的错误外，还包括金融方面的错误。并且由于是语音识别后的文本，错误主要与拼音有关。\n\n错误类型主要包括以下两大方面：\n\n1.  拼音相关：\n   1.  错音\n   2.  缺音\n   3.  多音\n   4.  拼音正确但词识别错误\n2.  说话者相关：\n   1.  反复：因为对话发生在打电话中，而说话者在想要尽力表达自己的意思时常常会将某个词或某个短句重复数次。\n   2.  倒装：与说话人的习惯以及对话情况有关。\n\n#### 错误原因分析\n\n在观察得到有哪些错误之后，我们开始着手对错误背后的原因进行分析并试图给出解决方案。\n\n语音识别方面：\n\n​\t由于语音识别是使用较为通用的工具，而客服对话涉及到很多金融方面的名词尤其是该企业的特定产品，因此在名词方面容易发生拼音正确但词识别错误的情况。这类错误既然集中于名词，那么我们通过构建专有名词库再通过拼音相似度进行识别即可。\n\n说话者方面：\n\n​\t考虑到这是电话咨询中的对话，客服人员方面由于经过专门的筛选和训练，因此普通话较为标准且吐字清晰，说话音量合理且很少有外部噪音。而咨询者没有限定，其口音、音量等方面会对识别造成较大影响。\n\n​\t此外，说话者的知识背景及成长环境会对其陈述的句子的语法结构有影响，可能会更倾向于使用倒装句。\n\n​\t第三，说话过程中咨询者一方可能会有额外噪音或突发事件，这些噪音起码会导致语句无法被识别，还可能导致误识别，在文本中增加一些无用词。\n\n​\t这方面的错误是识别错误的主体部分，我们打算采用的是基于统计的n-gram模型结合拼音的方案，通过n-gram找到说话者可能原本想说的词语，因为这是语音识别后的文本，因此在n-gram识别后再通过拼音相似度来纠正的正确率会很高。\n\n语言方面：\n\n​\t中文本身就极为复杂，多义性的句子比比皆是，拼音类似在不同的应用场景之下词语也不同，这类语义上的错误很难通过统计解决，如本文采用的n-gram模型，若要捕获长距离的句子依赖关系来对句子进行诊断，则需要构建不止2-gram、3-gram，那么模型对时间空间的消耗较大。而另一篇文章采用的双向LSTM则在这个问题的解决上会优于n-gram基于统计的方式。\n\n#### 训练语料获取\n\n1.  从网络上获取的搜狗通用新闻语料（数GB级）\n2.  网络获取的金融新闻语料（数百MB级）\n3.  人工从待测的句子中检测并纠正少部分句子（数MB级）\n\n#### 模型选择\n\n在经过对错误类型和错误原因经过分析之后，我们打算初步使用n-gram模型进行低级错误识别。考虑到错误除了涉及通用领域外还有金融领域，以及该企业特有名词，那构造n-gram模型就得同时考虑到这几个方面，构造一个通用的n-gram以及一个专业领域的n-gram。\n\n对于n的选择，考虑到对话主要是短文本，并且短句之间的联系并不大，因此我们将每个长句子都剪成短句子并以短句子为单位进行错误检测，因此构建2-gram与3-gram模型足够解决需要。\n\n最终我们敲定的n-gram模型如下：\n\n1.  由通用语料训练的模型，分为2-gram和3-gram，用来识别通常对话中的错误。\n2.  由金融新闻以及人工纠正过的待测句子训练的专业模型，同样分为2-gram和3-gram，用于识别金融领域乃至该公司领域的错误。\n\n#### 预处理\n\n在了解了目标和解决方向之后，就要实际开始处理语料了。\n\n数据处理要点：\n\n1.  重新分词（语料和待纠句子）\n2.  数字变星号\n3.  长句剪断（全角转半角），根据逗号、句号、问号、感叹号裁剪句子\n\n首先我要从项目的服务器上获取待纠错的文本数据，师兄先前已经做过一些工作，首先在java利用JDBC访问数据库，得到每份对话的id、分完词的对话。训练的通用语料以及专业语料则直接从服务器上下载。\n\n之后对待测语料和训练语料统一进行处理，由于训练语料未经过分词，而待测语料的分词工具未知，分词又对检测的结果有很大的影响，因此我对待测文本重新用和训练语料一样的工具进行分词。\n\n接下来我们将目光转向文本中的数字。文本中包含各种数字，但我们知道，它们虽然各异，但在不考虑数值差异的情况下基本相近，且前后可以连接的词也差不多。比如年月日，在给定格式的前提下里面只要是合理的数字即可，而在检错中我们并不需要考虑数字的合理性，因此对于待测语料和训练语料，我们统一将数字变成星号以去除不同数字相同模式的影响。去除方式也很简单粗暴，用正则表达式匹配替换即可。\n\n再之后就是句子裁剪了。如上文所提，我们用n-gram捕获低级的句子错误，并且对话中句子关联度并不如文章句子那般大，而对话长距离的语义错误n-gram本身就无法捕获，因此我们直接根据逗号、句号、问号等明显分割句子的标点符号进行句子切分，将长句子划分成数个短句子，而后以短句子为单位检测错误。\n\n#### 模型构建\n\n在对语料处理完之后，接下来进行n-gram模型的构建。在模型构建方面，我们利用berkeley提供的[自然语言处理工具包](http://mvnrepository.com/artifact/edu.berkeley.nlp/berkeleylm/1.1.2) 来生成n-gram模型，平滑(Smoothing)方面选用了工具包内置的较为优秀的平滑方法Kneser-Ney。\n\n工具包会将导入的分好词的txt文件生成成.arpa模型文件保存下来，以后要用到计算好的模型时直接读取arpa模型文件而后将待检测的句子分好词逐几个喂进去检测概率即可。\n\n在得到模型之后我自然要试试产生什么结果以及效果如何，在给出一个样例之后得到如下结果：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ngram4.PNG)\n\n其中-100是给模型的设置参数，当在ngram中找不到类似的匹配对时会输出-100.\n\n看到这结果有些让人疑惑，n-gram出来的不应该是概率吗？虽然在大规模语料中某个特定对的概率很低，但也应该分布在0和1之间呐，这负数又是怎么回事？在经过查阅和总结之后，我知道它采用的是log之后的概率，原因如下：\n\n   1. n-gram的原理：一系列小于1的概率的乘积，当它们相乘之后可能会变得非常小以至于float无法放下，而使用了log之后将乘积放大。\n   2. 便于求导和公式推导，套上log之后将概率的乘法变成了log的加法。\n   3. 不改变大小关系，原本概率越大的句子在使用log之后的数值是负数，但更靠近0，原本的大小顺序没有被破坏。\n\n由此，模型构建完成，接下来就要将文本导入模型进行错误检测了。\n\n### Part   2  :  错误检测\n\n![错误检测](http://ot1c7ttzm.bkt.clouddn.com/ngram0.PNG)\n\n模型的使用很简单，将待检测句子进行分词（在项目中我们的待测句子已经分好了词），而后扫描一遍句子获取词语对列表，对于2-gram则是从第二个词开始每个词语及其前面的词。如“ 系统 提示 查询 密码 不 正确”，那么2-gram的词语对列表就是： [系统，提示]、[提示，查询]、[查询，密码]、[密码，不]、[不，正确]。同理得到3-gram的词语对列表。\n\n将词语对列表分别导入两个n-gram模型，得到两个模型的2-gram和3-gram分数，总共四个分数，若四个分数均低于某个阈值，则认为该词出错。阈值为人工选定的数字，在我们的项目中选定的阈值为-5.5。\n\n在扫描过后，我们得到模型认为出错了的词语，为了在网页上进行标红以及之后的纠正处理，我们要将结果保存为JSON文件，文件以 中括号[] 嵌套的形式 记录每个大句子的id，大句子分割成的小句子的错误词语索引及词语本身，以及词语的2-gram，3-gram分数。\n\n### Part   3  :  错误纠正\n\n![错误纠正](http://ot1c7ttzm.bkt.clouddn.com/ngram2.PNG)\n\n在获得错误词语之后，接下来就要根据词语搭配和拼音相似度来纠正词语了。\n\n首先要获取词语搭配，师兄已经通过依存句法在语料中提取了词语搭配，然而提取之后的顺序是乱序。这时候之前训练的2-gram就派上用场了，将词语搭配的两个顺序导入两个2-gram中，最后选择分数较高的作为词语顺序保存下来。\n\n将词语搭配文件导入哈希表中，每个前驱词都对应一个备选词集，词集中的词是通常接在前驱词后面的词。\n\n获得词语搭配之后，接下来就要获取拼音并计算相似度了。纠正步骤如下：\n\n1.   首先，通过hanlp获取待纠正词语以及词语搭配表的拼音\n2.   根据待检测语料以及错误词语的索引获取错误词语的前一个词，查询搭配表得到备选词集\n3.   将错误词语的拼音和备选词集每个词的拼音求 编辑距离和LCS 的加权分数，取超过阈值的前几个词语进行观察\n4.   将备选词替换疑似错误词并代回n-gram模型中进行分数比较，取分数高者保存。\n\n分数的算法方面，第一想法是直接最长公共子串的匹配，但是在错误识别中有很多错音、多音、少音的例子，因为一个拼音而导致公共子串断裂，由此额外考虑编辑距离，两个算法都是用动态规划自行实现的。\n\n选定算法之后，我们还需要结合两个算法的结果。\n\n​\t对于最长公共子串，最终的结果是两个字符串最长公共子串的长度，越大则两个字符串匹配程度越高。考虑到越长的字符串最后的公共子串更可能越长，这对短字符串不公平，因此我将最终的最长子串长度除以第一个字符串（错误词语的拼音）的长度进行归一化。\n\n​\t对于编辑距离，最终的分数是第一个字符串需要改动多少才能变到第二个字符串，越小说明两个字符串匹配程度越高。我将最终分数取倒数，考虑到分数可能是0（两个字符串完全相同），则先在最终结果上+1而后再取倒数，这样同样对编辑距离进行归一化并且匹配程度越高，分数越高。\n\n​\t两个算法的分数结合方面，虽然两个算法有些相似但仍有不同点，我们更倾向于选择最长公共子串分数更高的，但是同样得考虑编辑距离，在经过观察与实验后选定最终分数为 0.5\\*编辑距离 + 0.8\\*LCS。这样，两个字符串在匹配的时候，既能以公共子串为主，又能考虑到少部分拼音出错的因素。\n\n### Part  4  :  模型简单评估\n\n在构建模型之后，我们还对模型检测错误的效果进行一个简单的评估。评估从待测语料中挑选50条句子，每句扩成几个只有一处错误的句子，句子不涉及语义错误，和完全正确的句子放在一起给模型进行测试，共176个测试样本。\n\n50条完全正确的句子，126个只含一处词语错误的句子，若模型给出的所有分数均低于阈值则模型认为这个句子完全完全正确。\n\n最终结果如图：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ngram5.jpg)\n\nTP ：模型判断正确：模型认为句子中有错误并且正确指出错误词语\n\nTN ：模型判断正确：模型认为句子没错误，句子本身完全正确\n\nFP ：模型判断出错：模型认为句子有错误但其判断出错，分为两种情况：\n\n1.  句子本身完全正确，但模型认为有错\n2.  句子本身有错，但模型认为错误的词语与句子的错误词语不匹配\n\nFN ：模型判断出错：模型认为句子无错误，句子包含错误\n\n### 总结\n\n#### 不足\n\nn-gram模型在检测低级错误上表现良好，准确率颇高，但这个方案仍有不足之处。\n\n##### 1. 训练语料：\n\n我们采用的搜狗通用语料是从新闻网页上爬取的结果，包含很多噪声文本，若要进行处理则需要花费较多额外功夫。\n\n金融新闻方面亦如此，此外还有些问题。虽然语料有金融方面的知识，但和对话相比过于正式，对话通常使用口语化表述，和正式的新闻文本的匹配程度并不是很高。\n\n除了语料本身的问题之外，在语料规模上也有待加强，n-gram这类基于统计的模型训练数据自然越多越好（噪声少的情况下），照目前结果来看，GB级的通用语料表现还不错，若要再加强一下效果还需要更多更好的训练数据，尤其是在金融方面以及对话方面的文本数据。\n\n我们所要识别的是对话过程中的错误，因此若有大量正确的对话文本用于训练那是再好不过，然而受限于对话文本语料库的规模，我们额外加入的人工纠正的对话文本虽然噪声较少，但样本数过少且费时费力。\n\n##### 2. 模型缺陷\n\n除了训练语料上的缺陷外，模型本身也并不完美。基于统计的模型并不能很好地捕获语义关联，长距离依赖以及上下句关联，若是试图将n扩展到4、5乃至更高，则会产生很多空值，平滑之后的分数大多很难低于阈值。因此，对于语义关联上的错误，我们打算采用双向LSTM检测，这就是后话了。\n\n#### 感悟\n\n经过从目标分析、文本数据分析以及原因诊断，再到选择模型、获取语料，之后进行预处理、构建模型，最后实际使用模型以及评估模型，这么个基本完整的流程走下来之后，我对机器学习在项目中的实际应用有了进一步的理解。此外，在任务进行的过程中有多个小任务，如何又快又好地完成小任务也同样需要考虑，这需要多语言之间的协作，JAVA的快速，Python的易用与多功能，都在完成任务的过程中给予我很大帮助。\n\n项目进行过程中同样也遇到了很多小问题，并且由于经验不足以及不像做题那般有答案可以对，时不时还会走下弯路，但最后还是靠着坚持和努力，比较好地完成了任务。","slug":"chineseErrorDectection_n_gram","published":1,"updated":"2018-07-22T12:38:57.548Z","photos":[],"link":"","_id":"cjleshqjp000qryfc6spwjizi","content":"<p>有幸参加研究生师兄的创新创业项目，一个和金融企业合作的对话文本分析与挖掘的项目。项目组从公司处获得语音识别后的客服对话文本，我们对文本进行纠错、情感分析与挖掘等并最终给公司反馈，让公司能够从客服对话文本中获得有效信息。我在项目中参与的部分是文本处理的第一步：文本检错纠错。这几个月中，在研究生师兄的带领下，我们基于机器学习构建了数个用于语音识别后文本的检错纠错模型，在此将主要的两个方法：n-gram+拼音相似度+词语搭配， 双向LSTM模型的整个构建过程进行总结。</p>\n<p>本文介绍了我们采用的第一个方法：n-gram+拼音相似度+词语搭配。</p>\n<p>整体分为四个部分：</p>\n<ol>\n<li>错误文本分析，语料获取、处理与利用</li>\n<li>错误检测</li>\n<li>错误纠正</li>\n<li>模型评估</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"Part-0-前置理论简述\"><a href=\"#Part-0-前置理论简述\" class=\"headerlink\" title=\"Part  0  :  前置理论简述\"></a>Part  0  :  前置理论简述</h3><h4 id=\"n-gram\"><a href=\"#n-gram\" class=\"headerlink\" title=\"n-gram\"></a>n-gram</h4><p>n-gram的思路非常简单易懂，即假设一个字或词出现仅与前n个词相关（n为人为给定），句子整体的概率等于所有词语搭配概率的乘积。常用的有2-gram（bi-gram）和3-gram（Tri-gram），词语概率的计算方法用到了概率论中的条件概率，此外用频数计算计算频率代替概率。人们通常用n-gram来评估一个句子是否合理。在这里，我们通过计算一个词语的n-gram分数来评估这个词语是否合理，以此检测错误词语。</p>\n<h4 id=\"依存句法\"><a href=\"#依存句法\" class=\"headerlink\" title=\"依存句法\"></a>依存句法</h4><p>依存句法通过分析词语间的依存关系揭示句子的结构，它可以识别出句子中的主谓宾、定状补等语法成分并分析各个成分之间的关系。除了能够解析句子并划分结构之外，它还能够找到句子的核心词并且分析词语之间的语义距离。</p>\n<h4 id=\"编辑距离与最长公共子串（LCS）\"><a href=\"#编辑距离与最长公共子串（LCS）\" class=\"headerlink\" title=\"编辑距离与最长公共子串（LCS）\"></a>编辑距离与最长公共子串（LCS）</h4><p>编辑距离和LCS通常用于字符串的相似度匹配。</p>\n<p>LCS的思想很简单，就是两个字符串共有的子串的最大长度。</p>\n<p>编辑距离稍微复杂一点，编辑的方式分为三种：修改一个字符、增加一个字符、删去一个字符，第一个字符串通过应用以上三种编辑方式变成第二个字符串，所需要的最少的编辑次数（不限种类）称为编辑距离。</p>\n<h3 id=\"Part-1-错误文本分析，语料获取、处理与利用\"><a href=\"#Part-1-错误文本分析，语料获取、处理与利用\" class=\"headerlink\" title=\"Part   1  :  错误文本分析，语料获取、处理与利用\"></a>Part   1  :  错误文本分析，语料获取、处理与利用</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram1.PNG\" alt=\"语料利用\"></p>\n<p>得到待测语料后，我们首先对文本进行观察，并结合这是语音识别后的前提，分析得到一下结果：</p>\n<h4 id=\"错误类型\"><a href=\"#错误类型\" class=\"headerlink\" title=\"错误类型\"></a>错误类型</h4><p>我们通过对待测语料的观察发现，对话文本中的错误除了包括常用词语的错误外，还包括金融方面的错误。并且由于是语音识别后的文本，错误主要与拼音有关。</p>\n<p>错误类型主要包括以下两大方面：</p>\n<ol>\n<li>拼音相关：<ol>\n<li>错音</li>\n<li>缺音</li>\n<li>多音</li>\n<li>拼音正确但词识别错误</li>\n</ol>\n</li>\n<li>说话者相关：<ol>\n<li>反复：因为对话发生在打电话中，而说话者在想要尽力表达自己的意思时常常会将某个词或某个短句重复数次。</li>\n<li>倒装：与说话人的习惯以及对话情况有关。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"错误原因分析\"><a href=\"#错误原因分析\" class=\"headerlink\" title=\"错误原因分析\"></a>错误原因分析</h4><p>在观察得到有哪些错误之后，我们开始着手对错误背后的原因进行分析并试图给出解决方案。</p>\n<p>语音识别方面：</p>\n<p>​    由于语音识别是使用较为通用的工具，而客服对话涉及到很多金融方面的名词尤其是该企业的特定产品，因此在名词方面容易发生拼音正确但词识别错误的情况。这类错误既然集中于名词，那么我们通过构建专有名词库再通过拼音相似度进行识别即可。</p>\n<p>说话者方面：</p>\n<p>​    考虑到这是电话咨询中的对话，客服人员方面由于经过专门的筛选和训练，因此普通话较为标准且吐字清晰，说话音量合理且很少有外部噪音。而咨询者没有限定，其口音、音量等方面会对识别造成较大影响。</p>\n<p>​    此外，说话者的知识背景及成长环境会对其陈述的句子的语法结构有影响，可能会更倾向于使用倒装句。</p>\n<p>​    第三，说话过程中咨询者一方可能会有额外噪音或突发事件，这些噪音起码会导致语句无法被识别，还可能导致误识别，在文本中增加一些无用词。</p>\n<p>​    这方面的错误是识别错误的主体部分，我们打算采用的是基于统计的n-gram模型结合拼音的方案，通过n-gram找到说话者可能原本想说的词语，因为这是语音识别后的文本，因此在n-gram识别后再通过拼音相似度来纠正的正确率会很高。</p>\n<p>语言方面：</p>\n<p>​    中文本身就极为复杂，多义性的句子比比皆是，拼音类似在不同的应用场景之下词语也不同，这类语义上的错误很难通过统计解决，如本文采用的n-gram模型，若要捕获长距离的句子依赖关系来对句子进行诊断，则需要构建不止2-gram、3-gram，那么模型对时间空间的消耗较大。而另一篇文章采用的双向LSTM则在这个问题的解决上会优于n-gram基于统计的方式。</p>\n<h4 id=\"训练语料获取\"><a href=\"#训练语料获取\" class=\"headerlink\" title=\"训练语料获取\"></a>训练语料获取</h4><ol>\n<li>从网络上获取的搜狗通用新闻语料（数GB级）</li>\n<li>网络获取的金融新闻语料（数百MB级）</li>\n<li>人工从待测的句子中检测并纠正少部分句子（数MB级）</li>\n</ol>\n<h4 id=\"模型选择\"><a href=\"#模型选择\" class=\"headerlink\" title=\"模型选择\"></a>模型选择</h4><p>在经过对错误类型和错误原因经过分析之后，我们打算初步使用n-gram模型进行低级错误识别。考虑到错误除了涉及通用领域外还有金融领域，以及该企业特有名词，那构造n-gram模型就得同时考虑到这几个方面，构造一个通用的n-gram以及一个专业领域的n-gram。</p>\n<p>对于n的选择，考虑到对话主要是短文本，并且短句之间的联系并不大，因此我们将每个长句子都剪成短句子并以短句子为单位进行错误检测，因此构建2-gram与3-gram模型足够解决需要。</p>\n<p>最终我们敲定的n-gram模型如下：</p>\n<ol>\n<li>由通用语料训练的模型，分为2-gram和3-gram，用来识别通常对话中的错误。</li>\n<li>由金融新闻以及人工纠正过的待测句子训练的专业模型，同样分为2-gram和3-gram，用于识别金融领域乃至该公司领域的错误。</li>\n</ol>\n<h4 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h4><p>在了解了目标和解决方向之后，就要实际开始处理语料了。</p>\n<p>数据处理要点：</p>\n<ol>\n<li>重新分词（语料和待纠句子）</li>\n<li>数字变星号</li>\n<li>长句剪断（全角转半角），根据逗号、句号、问号、感叹号裁剪句子</li>\n</ol>\n<p>首先我要从项目的服务器上获取待纠错的文本数据，师兄先前已经做过一些工作，首先在java利用JDBC访问数据库，得到每份对话的id、分完词的对话。训练的通用语料以及专业语料则直接从服务器上下载。</p>\n<p>之后对待测语料和训练语料统一进行处理，由于训练语料未经过分词，而待测语料的分词工具未知，分词又对检测的结果有很大的影响，因此我对待测文本重新用和训练语料一样的工具进行分词。</p>\n<p>接下来我们将目光转向文本中的数字。文本中包含各种数字，但我们知道，它们虽然各异，但在不考虑数值差异的情况下基本相近，且前后可以连接的词也差不多。比如年月日，在给定格式的前提下里面只要是合理的数字即可，而在检错中我们并不需要考虑数字的合理性，因此对于待测语料和训练语料，我们统一将数字变成星号以去除不同数字相同模式的影响。去除方式也很简单粗暴，用正则表达式匹配替换即可。</p>\n<p>再之后就是句子裁剪了。如上文所提，我们用n-gram捕获低级的句子错误，并且对话中句子关联度并不如文章句子那般大，而对话长距离的语义错误n-gram本身就无法捕获，因此我们直接根据逗号、句号、问号等明显分割句子的标点符号进行句子切分，将长句子划分成数个短句子，而后以短句子为单位检测错误。</p>\n<h4 id=\"模型构建\"><a href=\"#模型构建\" class=\"headerlink\" title=\"模型构建\"></a>模型构建</h4><p>在对语料处理完之后，接下来进行n-gram模型的构建。在模型构建方面，我们利用berkeley提供的<a href=\"http://mvnrepository.com/artifact/edu.berkeley.nlp/berkeleylm/1.1.2\" target=\"_blank\" rel=\"noopener\">自然语言处理工具包</a> 来生成n-gram模型，平滑(Smoothing)方面选用了工具包内置的较为优秀的平滑方法Kneser-Ney。</p>\n<p>工具包会将导入的分好词的txt文件生成成.arpa模型文件保存下来，以后要用到计算好的模型时直接读取arpa模型文件而后将待检测的句子分好词逐几个喂进去检测概率即可。</p>\n<p>在得到模型之后我自然要试试产生什么结果以及效果如何，在给出一个样例之后得到如下结果：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram4.PNG\" alt=\"\"></p>\n<p>其中-100是给模型的设置参数，当在ngram中找不到类似的匹配对时会输出-100.</p>\n<p>看到这结果有些让人疑惑，n-gram出来的不应该是概率吗？虽然在大规模语料中某个特定对的概率很低，但也应该分布在0和1之间呐，这负数又是怎么回事？在经过查阅和总结之后，我知道它采用的是log之后的概率，原因如下：</p>\n<ol>\n<li>n-gram的原理：一系列小于1的概率的乘积，当它们相乘之后可能会变得非常小以至于float无法放下，而使用了log之后将乘积放大。</li>\n<li>便于求导和公式推导，套上log之后将概率的乘法变成了log的加法。</li>\n<li>不改变大小关系，原本概率越大的句子在使用log之后的数值是负数，但更靠近0，原本的大小顺序没有被破坏。</li>\n</ol>\n<p>由此，模型构建完成，接下来就要将文本导入模型进行错误检测了。</p>\n<h3 id=\"Part-2-错误检测\"><a href=\"#Part-2-错误检测\" class=\"headerlink\" title=\"Part   2  :  错误检测\"></a>Part   2  :  错误检测</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram0.PNG\" alt=\"错误检测\"></p>\n<p>模型的使用很简单，将待检测句子进行分词（在项目中我们的待测句子已经分好了词），而后扫描一遍句子获取词语对列表，对于2-gram则是从第二个词开始每个词语及其前面的词。如“ 系统 提示 查询 密码 不 正确”，那么2-gram的词语对列表就是： [系统，提示]、[提示，查询]、[查询，密码]、[密码，不]、[不，正确]。同理得到3-gram的词语对列表。</p>\n<p>将词语对列表分别导入两个n-gram模型，得到两个模型的2-gram和3-gram分数，总共四个分数，若四个分数均低于某个阈值，则认为该词出错。阈值为人工选定的数字，在我们的项目中选定的阈值为-5.5。</p>\n<p>在扫描过后，我们得到模型认为出错了的词语，为了在网页上进行标红以及之后的纠正处理，我们要将结果保存为JSON文件，文件以 中括号[] 嵌套的形式 记录每个大句子的id，大句子分割成的小句子的错误词语索引及词语本身，以及词语的2-gram，3-gram分数。</p>\n<h3 id=\"Part-3-错误纠正\"><a href=\"#Part-3-错误纠正\" class=\"headerlink\" title=\"Part   3  :  错误纠正\"></a>Part   3  :  错误纠正</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram2.PNG\" alt=\"错误纠正\"></p>\n<p>在获得错误词语之后，接下来就要根据词语搭配和拼音相似度来纠正词语了。</p>\n<p>首先要获取词语搭配，师兄已经通过依存句法在语料中提取了词语搭配，然而提取之后的顺序是乱序。这时候之前训练的2-gram就派上用场了，将词语搭配的两个顺序导入两个2-gram中，最后选择分数较高的作为词语顺序保存下来。</p>\n<p>将词语搭配文件导入哈希表中，每个前驱词都对应一个备选词集，词集中的词是通常接在前驱词后面的词。</p>\n<p>获得词语搭配之后，接下来就要获取拼音并计算相似度了。纠正步骤如下：</p>\n<ol>\n<li>首先，通过hanlp获取待纠正词语以及词语搭配表的拼音</li>\n<li>根据待检测语料以及错误词语的索引获取错误词语的前一个词，查询搭配表得到备选词集</li>\n<li>将错误词语的拼音和备选词集每个词的拼音求 编辑距离和LCS 的加权分数，取超过阈值的前几个词语进行观察</li>\n<li>将备选词替换疑似错误词并代回n-gram模型中进行分数比较，取分数高者保存。</li>\n</ol>\n<p>分数的算法方面，第一想法是直接最长公共子串的匹配，但是在错误识别中有很多错音、多音、少音的例子，因为一个拼音而导致公共子串断裂，由此额外考虑编辑距离，两个算法都是用动态规划自行实现的。</p>\n<p>选定算法之后，我们还需要结合两个算法的结果。</p>\n<p>​    对于最长公共子串，最终的结果是两个字符串最长公共子串的长度，越大则两个字符串匹配程度越高。考虑到越长的字符串最后的公共子串更可能越长，这对短字符串不公平，因此我将最终的最长子串长度除以第一个字符串（错误词语的拼音）的长度进行归一化。</p>\n<p>​    对于编辑距离，最终的分数是第一个字符串需要改动多少才能变到第二个字符串，越小说明两个字符串匹配程度越高。我将最终分数取倒数，考虑到分数可能是0（两个字符串完全相同），则先在最终结果上+1而后再取倒数，这样同样对编辑距离进行归一化并且匹配程度越高，分数越高。</p>\n<p>​    两个算法的分数结合方面，虽然两个算法有些相似但仍有不同点，我们更倾向于选择最长公共子串分数更高的，但是同样得考虑编辑距离，在经过观察与实验后选定最终分数为 0.5*编辑距离 + 0.8*LCS。这样，两个字符串在匹配的时候，既能以公共子串为主，又能考虑到少部分拼音出错的因素。</p>\n<h3 id=\"Part-4-模型简单评估\"><a href=\"#Part-4-模型简单评估\" class=\"headerlink\" title=\"Part  4  :  模型简单评估\"></a>Part  4  :  模型简单评估</h3><p>在构建模型之后，我们还对模型检测错误的效果进行一个简单的评估。评估从待测语料中挑选50条句子，每句扩成几个只有一处错误的句子，句子不涉及语义错误，和完全正确的句子放在一起给模型进行测试，共176个测试样本。</p>\n<p>50条完全正确的句子，126个只含一处词语错误的句子，若模型给出的所有分数均低于阈值则模型认为这个句子完全完全正确。</p>\n<p>最终结果如图：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram5.jpg\" alt=\"\"></p>\n<p>TP ：模型判断正确：模型认为句子中有错误并且正确指出错误词语</p>\n<p>TN ：模型判断正确：模型认为句子没错误，句子本身完全正确</p>\n<p>FP ：模型判断出错：模型认为句子有错误但其判断出错，分为两种情况：</p>\n<ol>\n<li>句子本身完全正确，但模型认为有错</li>\n<li>句子本身有错，但模型认为错误的词语与句子的错误词语不匹配</li>\n</ol>\n<p>FN ：模型判断出错：模型认为句子无错误，句子包含错误</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h4><p>n-gram模型在检测低级错误上表现良好，准确率颇高，但这个方案仍有不足之处。</p>\n<h5 id=\"1-训练语料：\"><a href=\"#1-训练语料：\" class=\"headerlink\" title=\"1. 训练语料：\"></a>1. 训练语料：</h5><p>我们采用的搜狗通用语料是从新闻网页上爬取的结果，包含很多噪声文本，若要进行处理则需要花费较多额外功夫。</p>\n<p>金融新闻方面亦如此，此外还有些问题。虽然语料有金融方面的知识，但和对话相比过于正式，对话通常使用口语化表述，和正式的新闻文本的匹配程度并不是很高。</p>\n<p>除了语料本身的问题之外，在语料规模上也有待加强，n-gram这类基于统计的模型训练数据自然越多越好（噪声少的情况下），照目前结果来看，GB级的通用语料表现还不错，若要再加强一下效果还需要更多更好的训练数据，尤其是在金融方面以及对话方面的文本数据。</p>\n<p>我们所要识别的是对话过程中的错误，因此若有大量正确的对话文本用于训练那是再好不过，然而受限于对话文本语料库的规模，我们额外加入的人工纠正的对话文本虽然噪声较少，但样本数过少且费时费力。</p>\n<h5 id=\"2-模型缺陷\"><a href=\"#2-模型缺陷\" class=\"headerlink\" title=\"2. 模型缺陷\"></a>2. 模型缺陷</h5><p>除了训练语料上的缺陷外，模型本身也并不完美。基于统计的模型并不能很好地捕获语义关联，长距离依赖以及上下句关联，若是试图将n扩展到4、5乃至更高，则会产生很多空值，平滑之后的分数大多很难低于阈值。因此，对于语义关联上的错误，我们打算采用双向LSTM检测，这就是后话了。</p>\n<h4 id=\"感悟\"><a href=\"#感悟\" class=\"headerlink\" title=\"感悟\"></a>感悟</h4><p>经过从目标分析、文本数据分析以及原因诊断，再到选择模型、获取语料，之后进行预处理、构建模型，最后实际使用模型以及评估模型，这么个基本完整的流程走下来之后，我对机器学习在项目中的实际应用有了进一步的理解。此外，在任务进行的过程中有多个小任务，如何又快又好地完成小任务也同样需要考虑，这需要多语言之间的协作，JAVA的快速，Python的易用与多功能，都在完成任务的过程中给予我很大帮助。</p>\n<p>项目进行过程中同样也遇到了很多小问题，并且由于经验不足以及不像做题那般有答案可以对，时不时还会走下弯路，但最后还是靠着坚持和努力，比较好地完成了任务。</p>\n","site":{"data":{}},"excerpt":"<p>有幸参加研究生师兄的创新创业项目，一个和金融企业合作的对话文本分析与挖掘的项目。项目组从公司处获得语音识别后的客服对话文本，我们对文本进行纠错、情感分析与挖掘等并最终给公司反馈，让公司能够从客服对话文本中获得有效信息。我在项目中参与的部分是文本处理的第一步：文本检错纠错。这几个月中，在研究生师兄的带领下，我们基于机器学习构建了数个用于语音识别后文本的检错纠错模型，在此将主要的两个方法：n-gram+拼音相似度+词语搭配， 双向LSTM模型的整个构建过程进行总结。</p>\n<p>本文介绍了我们采用的第一个方法：n-gram+拼音相似度+词语搭配。</p>\n<p>整体分为四个部分：</p>\n<ol>\n<li>错误文本分析，语料获取、处理与利用</li>\n<li>错误检测</li>\n<li>错误纠正</li>\n<li>模型评估</li>\n</ol>","more":"<h3 id=\"Part-0-前置理论简述\"><a href=\"#Part-0-前置理论简述\" class=\"headerlink\" title=\"Part  0  :  前置理论简述\"></a>Part  0  :  前置理论简述</h3><h4 id=\"n-gram\"><a href=\"#n-gram\" class=\"headerlink\" title=\"n-gram\"></a>n-gram</h4><p>n-gram的思路非常简单易懂，即假设一个字或词出现仅与前n个词相关（n为人为给定），句子整体的概率等于所有词语搭配概率的乘积。常用的有2-gram（bi-gram）和3-gram（Tri-gram），词语概率的计算方法用到了概率论中的条件概率，此外用频数计算计算频率代替概率。人们通常用n-gram来评估一个句子是否合理。在这里，我们通过计算一个词语的n-gram分数来评估这个词语是否合理，以此检测错误词语。</p>\n<h4 id=\"依存句法\"><a href=\"#依存句法\" class=\"headerlink\" title=\"依存句法\"></a>依存句法</h4><p>依存句法通过分析词语间的依存关系揭示句子的结构，它可以识别出句子中的主谓宾、定状补等语法成分并分析各个成分之间的关系。除了能够解析句子并划分结构之外，它还能够找到句子的核心词并且分析词语之间的语义距离。</p>\n<h4 id=\"编辑距离与最长公共子串（LCS）\"><a href=\"#编辑距离与最长公共子串（LCS）\" class=\"headerlink\" title=\"编辑距离与最长公共子串（LCS）\"></a>编辑距离与最长公共子串（LCS）</h4><p>编辑距离和LCS通常用于字符串的相似度匹配。</p>\n<p>LCS的思想很简单，就是两个字符串共有的子串的最大长度。</p>\n<p>编辑距离稍微复杂一点，编辑的方式分为三种：修改一个字符、增加一个字符、删去一个字符，第一个字符串通过应用以上三种编辑方式变成第二个字符串，所需要的最少的编辑次数（不限种类）称为编辑距离。</p>\n<h3 id=\"Part-1-错误文本分析，语料获取、处理与利用\"><a href=\"#Part-1-错误文本分析，语料获取、处理与利用\" class=\"headerlink\" title=\"Part   1  :  错误文本分析，语料获取、处理与利用\"></a>Part   1  :  错误文本分析，语料获取、处理与利用</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram1.PNG\" alt=\"语料利用\"></p>\n<p>得到待测语料后，我们首先对文本进行观察，并结合这是语音识别后的前提，分析得到一下结果：</p>\n<h4 id=\"错误类型\"><a href=\"#错误类型\" class=\"headerlink\" title=\"错误类型\"></a>错误类型</h4><p>我们通过对待测语料的观察发现，对话文本中的错误除了包括常用词语的错误外，还包括金融方面的错误。并且由于是语音识别后的文本，错误主要与拼音有关。</p>\n<p>错误类型主要包括以下两大方面：</p>\n<ol>\n<li>拼音相关：<ol>\n<li>错音</li>\n<li>缺音</li>\n<li>多音</li>\n<li>拼音正确但词识别错误</li>\n</ol>\n</li>\n<li>说话者相关：<ol>\n<li>反复：因为对话发生在打电话中，而说话者在想要尽力表达自己的意思时常常会将某个词或某个短句重复数次。</li>\n<li>倒装：与说话人的习惯以及对话情况有关。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"错误原因分析\"><a href=\"#错误原因分析\" class=\"headerlink\" title=\"错误原因分析\"></a>错误原因分析</h4><p>在观察得到有哪些错误之后，我们开始着手对错误背后的原因进行分析并试图给出解决方案。</p>\n<p>语音识别方面：</p>\n<p>​    由于语音识别是使用较为通用的工具，而客服对话涉及到很多金融方面的名词尤其是该企业的特定产品，因此在名词方面容易发生拼音正确但词识别错误的情况。这类错误既然集中于名词，那么我们通过构建专有名词库再通过拼音相似度进行识别即可。</p>\n<p>说话者方面：</p>\n<p>​    考虑到这是电话咨询中的对话，客服人员方面由于经过专门的筛选和训练，因此普通话较为标准且吐字清晰，说话音量合理且很少有外部噪音。而咨询者没有限定，其口音、音量等方面会对识别造成较大影响。</p>\n<p>​    此外，说话者的知识背景及成长环境会对其陈述的句子的语法结构有影响，可能会更倾向于使用倒装句。</p>\n<p>​    第三，说话过程中咨询者一方可能会有额外噪音或突发事件，这些噪音起码会导致语句无法被识别，还可能导致误识别，在文本中增加一些无用词。</p>\n<p>​    这方面的错误是识别错误的主体部分，我们打算采用的是基于统计的n-gram模型结合拼音的方案，通过n-gram找到说话者可能原本想说的词语，因为这是语音识别后的文本，因此在n-gram识别后再通过拼音相似度来纠正的正确率会很高。</p>\n<p>语言方面：</p>\n<p>​    中文本身就极为复杂，多义性的句子比比皆是，拼音类似在不同的应用场景之下词语也不同，这类语义上的错误很难通过统计解决，如本文采用的n-gram模型，若要捕获长距离的句子依赖关系来对句子进行诊断，则需要构建不止2-gram、3-gram，那么模型对时间空间的消耗较大。而另一篇文章采用的双向LSTM则在这个问题的解决上会优于n-gram基于统计的方式。</p>\n<h4 id=\"训练语料获取\"><a href=\"#训练语料获取\" class=\"headerlink\" title=\"训练语料获取\"></a>训练语料获取</h4><ol>\n<li>从网络上获取的搜狗通用新闻语料（数GB级）</li>\n<li>网络获取的金融新闻语料（数百MB级）</li>\n<li>人工从待测的句子中检测并纠正少部分句子（数MB级）</li>\n</ol>\n<h4 id=\"模型选择\"><a href=\"#模型选择\" class=\"headerlink\" title=\"模型选择\"></a>模型选择</h4><p>在经过对错误类型和错误原因经过分析之后，我们打算初步使用n-gram模型进行低级错误识别。考虑到错误除了涉及通用领域外还有金融领域，以及该企业特有名词，那构造n-gram模型就得同时考虑到这几个方面，构造一个通用的n-gram以及一个专业领域的n-gram。</p>\n<p>对于n的选择，考虑到对话主要是短文本，并且短句之间的联系并不大，因此我们将每个长句子都剪成短句子并以短句子为单位进行错误检测，因此构建2-gram与3-gram模型足够解决需要。</p>\n<p>最终我们敲定的n-gram模型如下：</p>\n<ol>\n<li>由通用语料训练的模型，分为2-gram和3-gram，用来识别通常对话中的错误。</li>\n<li>由金融新闻以及人工纠正过的待测句子训练的专业模型，同样分为2-gram和3-gram，用于识别金融领域乃至该公司领域的错误。</li>\n</ol>\n<h4 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h4><p>在了解了目标和解决方向之后，就要实际开始处理语料了。</p>\n<p>数据处理要点：</p>\n<ol>\n<li>重新分词（语料和待纠句子）</li>\n<li>数字变星号</li>\n<li>长句剪断（全角转半角），根据逗号、句号、问号、感叹号裁剪句子</li>\n</ol>\n<p>首先我要从项目的服务器上获取待纠错的文本数据，师兄先前已经做过一些工作，首先在java利用JDBC访问数据库，得到每份对话的id、分完词的对话。训练的通用语料以及专业语料则直接从服务器上下载。</p>\n<p>之后对待测语料和训练语料统一进行处理，由于训练语料未经过分词，而待测语料的分词工具未知，分词又对检测的结果有很大的影响，因此我对待测文本重新用和训练语料一样的工具进行分词。</p>\n<p>接下来我们将目光转向文本中的数字。文本中包含各种数字，但我们知道，它们虽然各异，但在不考虑数值差异的情况下基本相近，且前后可以连接的词也差不多。比如年月日，在给定格式的前提下里面只要是合理的数字即可，而在检错中我们并不需要考虑数字的合理性，因此对于待测语料和训练语料，我们统一将数字变成星号以去除不同数字相同模式的影响。去除方式也很简单粗暴，用正则表达式匹配替换即可。</p>\n<p>再之后就是句子裁剪了。如上文所提，我们用n-gram捕获低级的句子错误，并且对话中句子关联度并不如文章句子那般大，而对话长距离的语义错误n-gram本身就无法捕获，因此我们直接根据逗号、句号、问号等明显分割句子的标点符号进行句子切分，将长句子划分成数个短句子，而后以短句子为单位检测错误。</p>\n<h4 id=\"模型构建\"><a href=\"#模型构建\" class=\"headerlink\" title=\"模型构建\"></a>模型构建</h4><p>在对语料处理完之后，接下来进行n-gram模型的构建。在模型构建方面，我们利用berkeley提供的<a href=\"http://mvnrepository.com/artifact/edu.berkeley.nlp/berkeleylm/1.1.2\" target=\"_blank\" rel=\"noopener\">自然语言处理工具包</a> 来生成n-gram模型，平滑(Smoothing)方面选用了工具包内置的较为优秀的平滑方法Kneser-Ney。</p>\n<p>工具包会将导入的分好词的txt文件生成成.arpa模型文件保存下来，以后要用到计算好的模型时直接读取arpa模型文件而后将待检测的句子分好词逐几个喂进去检测概率即可。</p>\n<p>在得到模型之后我自然要试试产生什么结果以及效果如何，在给出一个样例之后得到如下结果：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram4.PNG\" alt=\"\"></p>\n<p>其中-100是给模型的设置参数，当在ngram中找不到类似的匹配对时会输出-100.</p>\n<p>看到这结果有些让人疑惑，n-gram出来的不应该是概率吗？虽然在大规模语料中某个特定对的概率很低，但也应该分布在0和1之间呐，这负数又是怎么回事？在经过查阅和总结之后，我知道它采用的是log之后的概率，原因如下：</p>\n<ol>\n<li>n-gram的原理：一系列小于1的概率的乘积，当它们相乘之后可能会变得非常小以至于float无法放下，而使用了log之后将乘积放大。</li>\n<li>便于求导和公式推导，套上log之后将概率的乘法变成了log的加法。</li>\n<li>不改变大小关系，原本概率越大的句子在使用log之后的数值是负数，但更靠近0，原本的大小顺序没有被破坏。</li>\n</ol>\n<p>由此，模型构建完成，接下来就要将文本导入模型进行错误检测了。</p>\n<h3 id=\"Part-2-错误检测\"><a href=\"#Part-2-错误检测\" class=\"headerlink\" title=\"Part   2  :  错误检测\"></a>Part   2  :  错误检测</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram0.PNG\" alt=\"错误检测\"></p>\n<p>模型的使用很简单，将待检测句子进行分词（在项目中我们的待测句子已经分好了词），而后扫描一遍句子获取词语对列表，对于2-gram则是从第二个词开始每个词语及其前面的词。如“ 系统 提示 查询 密码 不 正确”，那么2-gram的词语对列表就是： [系统，提示]、[提示，查询]、[查询，密码]、[密码，不]、[不，正确]。同理得到3-gram的词语对列表。</p>\n<p>将词语对列表分别导入两个n-gram模型，得到两个模型的2-gram和3-gram分数，总共四个分数，若四个分数均低于某个阈值，则认为该词出错。阈值为人工选定的数字，在我们的项目中选定的阈值为-5.5。</p>\n<p>在扫描过后，我们得到模型认为出错了的词语，为了在网页上进行标红以及之后的纠正处理，我们要将结果保存为JSON文件，文件以 中括号[] 嵌套的形式 记录每个大句子的id，大句子分割成的小句子的错误词语索引及词语本身，以及词语的2-gram，3-gram分数。</p>\n<h3 id=\"Part-3-错误纠正\"><a href=\"#Part-3-错误纠正\" class=\"headerlink\" title=\"Part   3  :  错误纠正\"></a>Part   3  :  错误纠正</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram2.PNG\" alt=\"错误纠正\"></p>\n<p>在获得错误词语之后，接下来就要根据词语搭配和拼音相似度来纠正词语了。</p>\n<p>首先要获取词语搭配，师兄已经通过依存句法在语料中提取了词语搭配，然而提取之后的顺序是乱序。这时候之前训练的2-gram就派上用场了，将词语搭配的两个顺序导入两个2-gram中，最后选择分数较高的作为词语顺序保存下来。</p>\n<p>将词语搭配文件导入哈希表中，每个前驱词都对应一个备选词集，词集中的词是通常接在前驱词后面的词。</p>\n<p>获得词语搭配之后，接下来就要获取拼音并计算相似度了。纠正步骤如下：</p>\n<ol>\n<li>首先，通过hanlp获取待纠正词语以及词语搭配表的拼音</li>\n<li>根据待检测语料以及错误词语的索引获取错误词语的前一个词，查询搭配表得到备选词集</li>\n<li>将错误词语的拼音和备选词集每个词的拼音求 编辑距离和LCS 的加权分数，取超过阈值的前几个词语进行观察</li>\n<li>将备选词替换疑似错误词并代回n-gram模型中进行分数比较，取分数高者保存。</li>\n</ol>\n<p>分数的算法方面，第一想法是直接最长公共子串的匹配，但是在错误识别中有很多错音、多音、少音的例子，因为一个拼音而导致公共子串断裂，由此额外考虑编辑距离，两个算法都是用动态规划自行实现的。</p>\n<p>选定算法之后，我们还需要结合两个算法的结果。</p>\n<p>​    对于最长公共子串，最终的结果是两个字符串最长公共子串的长度，越大则两个字符串匹配程度越高。考虑到越长的字符串最后的公共子串更可能越长，这对短字符串不公平，因此我将最终的最长子串长度除以第一个字符串（错误词语的拼音）的长度进行归一化。</p>\n<p>​    对于编辑距离，最终的分数是第一个字符串需要改动多少才能变到第二个字符串，越小说明两个字符串匹配程度越高。我将最终分数取倒数，考虑到分数可能是0（两个字符串完全相同），则先在最终结果上+1而后再取倒数，这样同样对编辑距离进行归一化并且匹配程度越高，分数越高。</p>\n<p>​    两个算法的分数结合方面，虽然两个算法有些相似但仍有不同点，我们更倾向于选择最长公共子串分数更高的，但是同样得考虑编辑距离，在经过观察与实验后选定最终分数为 0.5*编辑距离 + 0.8*LCS。这样，两个字符串在匹配的时候，既能以公共子串为主，又能考虑到少部分拼音出错的因素。</p>\n<h3 id=\"Part-4-模型简单评估\"><a href=\"#Part-4-模型简单评估\" class=\"headerlink\" title=\"Part  4  :  模型简单评估\"></a>Part  4  :  模型简单评估</h3><p>在构建模型之后，我们还对模型检测错误的效果进行一个简单的评估。评估从待测语料中挑选50条句子，每句扩成几个只有一处错误的句子，句子不涉及语义错误，和完全正确的句子放在一起给模型进行测试，共176个测试样本。</p>\n<p>50条完全正确的句子，126个只含一处词语错误的句子，若模型给出的所有分数均低于阈值则模型认为这个句子完全完全正确。</p>\n<p>最终结果如图：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ngram5.jpg\" alt=\"\"></p>\n<p>TP ：模型判断正确：模型认为句子中有错误并且正确指出错误词语</p>\n<p>TN ：模型判断正确：模型认为句子没错误，句子本身完全正确</p>\n<p>FP ：模型判断出错：模型认为句子有错误但其判断出错，分为两种情况：</p>\n<ol>\n<li>句子本身完全正确，但模型认为有错</li>\n<li>句子本身有错，但模型认为错误的词语与句子的错误词语不匹配</li>\n</ol>\n<p>FN ：模型判断出错：模型认为句子无错误，句子包含错误</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h4><p>n-gram模型在检测低级错误上表现良好，准确率颇高，但这个方案仍有不足之处。</p>\n<h5 id=\"1-训练语料：\"><a href=\"#1-训练语料：\" class=\"headerlink\" title=\"1. 训练语料：\"></a>1. 训练语料：</h5><p>我们采用的搜狗通用语料是从新闻网页上爬取的结果，包含很多噪声文本，若要进行处理则需要花费较多额外功夫。</p>\n<p>金融新闻方面亦如此，此外还有些问题。虽然语料有金融方面的知识，但和对话相比过于正式，对话通常使用口语化表述，和正式的新闻文本的匹配程度并不是很高。</p>\n<p>除了语料本身的问题之外，在语料规模上也有待加强，n-gram这类基于统计的模型训练数据自然越多越好（噪声少的情况下），照目前结果来看，GB级的通用语料表现还不错，若要再加强一下效果还需要更多更好的训练数据，尤其是在金融方面以及对话方面的文本数据。</p>\n<p>我们所要识别的是对话过程中的错误，因此若有大量正确的对话文本用于训练那是再好不过，然而受限于对话文本语料库的规模，我们额外加入的人工纠正的对话文本虽然噪声较少，但样本数过少且费时费力。</p>\n<h5 id=\"2-模型缺陷\"><a href=\"#2-模型缺陷\" class=\"headerlink\" title=\"2. 模型缺陷\"></a>2. 模型缺陷</h5><p>除了训练语料上的缺陷外，模型本身也并不完美。基于统计的模型并不能很好地捕获语义关联，长距离依赖以及上下句关联，若是试图将n扩展到4、5乃至更高，则会产生很多空值，平滑之后的分数大多很难低于阈值。因此，对于语义关联上的错误，我们打算采用双向LSTM检测，这就是后话了。</p>\n<h4 id=\"感悟\"><a href=\"#感悟\" class=\"headerlink\" title=\"感悟\"></a>感悟</h4><p>经过从目标分析、文本数据分析以及原因诊断，再到选择模型、获取语料，之后进行预处理、构建模型，最后实际使用模型以及评估模型，这么个基本完整的流程走下来之后，我对机器学习在项目中的实际应用有了进一步的理解。此外，在任务进行的过程中有多个小任务，如何又快又好地完成小任务也同样需要考虑，这需要多语言之间的协作，JAVA的快速，Python的易用与多功能，都在完成任务的过程中给予我很大帮助。</p>\n<p>项目进行过程中同样也遇到了很多小问题，并且由于经验不足以及不像做题那般有答案可以对，时不时还会走下弯路，但最后还是靠着坚持和努力，比较好地完成了任务。</p>"},{"layout":"post","title":"tensorflow 文本序列检错的tricks (0)","date":"2018-08-28T16:00:00.000Z","comments":1,"_content":"\n这一大段时期，笔者一直在研究序列检错问题，最近涉及到字级序列的检错。字级序列进行错误检测其实就是一个和标注词性一样的序列标注问题，对于给定的字级序列，预测该序列中每个字是正确还是错误。在用tensorflow使用双向lstm对序列进行检错的过程中，笔者不断根据需要和模型反映的问题对模型进行修改，再加上参考其他人写的代码和总结，由此有了一些体会，在此说说其中几个。\n\n本文介绍两个tricks：\n\n1.  Sequence Mask\n2.  Weighted Loss\n\n<!-- more -->\n\n### Sequence Mask\n\n在获得文本语料之后，我们会将文本根据逗号、句号等标点符号切分成一个个句子序列，句子序列显然并不是固定长度的，然而在构造batch时需要所有的序列是同一长度才可以形成矩阵方便运算，由此需要设定一个最大长度，并将句子序列进行尾填充至最大长度。但在训练中，我们希望lstm只考虑非填充部分的序列，由此我们可以使用dynamic_rnn并将sequence length（sequence length的size为[batch_size, 1]）作为参数传进去，这样lstm会根据当前句子的length进行计算，由此提高了准确度和效率。\n\n在lstm和全连接后，我们得到了句子序列每个字的概率值，将其和标准答案计算得到loss，但填充部分也同样有loss，我们不希望填充部分的loss被考虑进去，由此就需要sequence mask了，它以sequence length( size 为 [batch_size, ])和max length( size 为 [1,])为参数，构造出 [batch_size, max_length]的bool矩阵：\n\n```python\nfrom random import randint\nimport tensorflow as tf\nfrom numpy import *\n\nmax_length = 3\nbatch_size = 5\n\nsequence_length = array([randint(1,max_length) for _ in range(batch_size)])\nloss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))\n\nprint(loss_mask)\nprint(\"sequence length: \"+str(sequence_length))\nwith tf.Session() as sess:\n\tprint(\"sequence mask:\")\n\tprint(sess.run(loss_mask))\n```\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask0.png)\n\n可以看到，我们构造出了一个二维的bool矩阵，里面每行true的数目和sequence相应索引的数值是一样的，再将bool转换成float之后，我们就可以将它和loss相乘，把无关部分的loss遮挡去了。\n\n```python\ntargets = array([[1 for _ in range(max_length)] for _ in range(batch_size)])\nlogits = array([[[randint(0,10)/10,randint(0,10)/10] for _ in range(max_length)] for _ in range(batch_size)])\n\ntargets = tf.convert_to_tensor(targets, dtype = tf.int32)\nlogits = tf.convert_to_tensor(logits, dtype = tf.float32)\n\nloss_before_mask = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=targets)\nloss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))\nloss_after_mask = loss_before_mask * tf.to_float(loss_mask)\n\nwith tf.Session() as sess:\n  print(\"loss before mask:\")\n  print((loss_before_mask))\n  print(sess.run(loss_before_mask))\n  print(\"*\"*20)\n  print(\"loss after mask:\")\n  print((loss_after_mask))\n  print(sess.run(loss_after_mask))\n```\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask1.png)\n\n之后我们就可以将loss累加或取均值作为整体的cost并进行优化了，当然，我们也可以同样将mask用于序列的准确率计算上。\n\n\n\n### Weighted Loss\n\n在对每个字进行正确与否的二分类时，有一个很大的问题就是类别分布不均衡。显然，正确字的数目要远远大于不正确的字的数目。对于包含错误的句子，一个很长的句子中或许只有一两个字是错的，更别提全对的句子了。类别分布不均在其它分类问题上也很常见，更是由此引发了f1等评价指标的诞生。毕竟若只看正确率的话，一个将所有字都认为是正确的模型在以字为单位统计正确率时将会近似于1！当然，在以句子为单位，即只有模型正确诊断出错误点时整句才算一个正确样本时，正确率将低得伤人。\n\n因此我们想要让模型更加重视样本数本身就少的类别，从目的上看，就是让模型更大胆地预测错误字，而不是胆小地把所有字都标记为正确，以此求得较小的loss。\n\n既然模型只盯着优化最小Loss这个目标，并且更新参数也是以Loss作为基准，那么我们下手的地方自然就是loss了。核心思想很简单，就是将原本的loss再根据类别的权重进行加权并求和得到最终的cost，为了最小化带了权重的loss，模型会将权重也同样进行反向传播。因此，与权重大的类别有关的更新会更加得到重视，而模型也敢放开手脚大胆预测错误字了。\n\n接下来我们通过一个简单的例子来看看Weighted loss 的使用：\n\n首先，随机生成batch_size 为3的二分类one_hot 标签label，标签转换成索引的targets，随机生成模型的最终预测logits：\n\n```python\nimport tensorflow as tf\nfrom numpy import *\nfrom random import randint\n\nbatch_size = 3\n\nlabel = zeros([batch_size,2])\nfor i in range(batch_size):\n\tlabel[i][randint(0,1)]=1\n\ntargets = argmax(label, axis=1)\nlogits = array([[randint(0,10)/10,randint(0,10)/10] for _ in range(batch_size)])\n```\n\n随机生成的结果如下：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result0.png)\n\n而后，我们开始计算loss，将targets和logits作为参数传入损失函数中计算得到加权前的loss。\n\n将标签和转置后的权重进行矩阵乘，得到加权后的标签矩阵，因标签是one hot，所以只有特定类别的权重才会保留下来。\n\n将转置后的加权标签与loss进行点乘，每个loss乘以对应标签的权重，此时的loss是特定类别上的loss，如类0的loss，而后乘以类0的权重，由此得到加权后的loss。\n\n```python\nlabel = tf.convert_to_tensor(label, dtype=tf.float32)\t# shape : [3,2]\ntargets = tf.convert_to_tensor(targets, dtype=tf.int32)\t# shape : [3,]\nlogits = tf.convert_to_tensor(logits, dtype=tf.float32)\t# shape : [3,2]\nclass_weight = tf.constant([1.0, 0.2], shape=[1,2], dtype=tf.float32)  # shape : [1,2]\n\nloss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)\n# shape : [3,]\nweighted_label = tf.transpose( tf.matmul(label, tf.transpose(class_weight)) )\t\n# shape : [1,3]\nloss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)\t\n# shape : [1,3]\n\nwith tf.Session() as sess:\n\tprint(\"Class Weight:\")\n\tprint(sess.run(class_weight))\n\tprint(\"\\nWeighted Label:\")\n\tprint(sess.run(weighted_label))\n\tprint(\"\\nLoss before weighted:\")\n\tprint(sess.run(loss_before_weighted))\n\tprint(\"\\nLoss after weighted:\")\n\tprint(sess.run(loss_after_weighted))\n\n```\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result1.png)\n\n可以看到，加权前的loss分布较为正常，而在加权之后，类0的loss保持不变，而类1的loss为原来的0.2，在反向传播的时候，参数的更新也会参考权重，使得模型更注重类0的判断。\n\n值得一提的是，显然类别的权重是一个超参数，一般可以根据样本数目比率得到，也可以人为设定而后观察并调整。\n\n以上是在普通分类问题上的加权，我们同样可以将加权应用到文本序列中，即矩阵多了一维（max_length）：\n\n```python\nmax_length = 2\nbatch_size = 3\n\nlabel = array([[[0,0] for _ in range(max_length)] for _ in range(batch_size)])\nfor i in range(batch_size):\n\tfor j in range(max_length):\n\t\tlabel[i][j][randint(0,1)]=1\ntargets = argmax(label, axis=2)\nlogits = array([[[randint(0,10)/10,randint(0,10)/10] for _ in range(max_length)] for _ in range(batch_size)])\n\nprint(\"label\"+str(label))\nprint(\"targets\"+str(targets))\nprint(\"logits\"+str(logits))\n\nlabel = tf.convert_to_tensor(label, dtype=tf.float32)\ntargets = tf.convert_to_tensor(targets, dtype=tf.int32)\nlogits = tf.convert_to_tensor(logits, dtype=tf.float32)\nclass_weight = tf.constant([1.0, 0.2], shape=[1,2], dtype=tf.float32)\n\nloss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)\n# shape [batch_size, max_length]\nweighted_label = tf.transpose( tf.matmul(tf.reshape(label,[-1,2]), tf.transpose(class_weight)) ) \n# shape [1, max_length*batch_size]\nweighted_label = tf.reshape(weighted_label,[batch_size,max_length])\n# shape [batch_size, max_length]\nloss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)\n# shape [batch_size, max_length]\n\nwith tf.Session() as sess:\n\tprint(\"Class Weight:\")\n\tprint(sess.run(class_weight))\n\tprint(\"\\nWeighted Label:\")\n\tprint(sess.run(weighted_label))\n\tprint(\"\\nLoss before weighted:\")\n\tprint(sess.run(loss_before_weighted))\n\tprint(\"\\nLoss after weighted:\")\n\tprint(sess.run(loss_after_weighted))\n\n```\n\n结果如下：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result2.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result3.png)\n\n\n\n\n\n\n\n","source":"_posts/tf_csc_trick.md","raw":"---\nlayout: post\ntitle: \"tensorflow 文本序列检错的tricks (0)\"\ndate: 2018-08-29\ncomments: true\ntags: \n\t- NLP\n\t- 文本纠错\n\t- tensorflow\n---\n\n这一大段时期，笔者一直在研究序列检错问题，最近涉及到字级序列的检错。字级序列进行错误检测其实就是一个和标注词性一样的序列标注问题，对于给定的字级序列，预测该序列中每个字是正确还是错误。在用tensorflow使用双向lstm对序列进行检错的过程中，笔者不断根据需要和模型反映的问题对模型进行修改，再加上参考其他人写的代码和总结，由此有了一些体会，在此说说其中几个。\n\n本文介绍两个tricks：\n\n1.  Sequence Mask\n2.  Weighted Loss\n\n<!-- more -->\n\n### Sequence Mask\n\n在获得文本语料之后，我们会将文本根据逗号、句号等标点符号切分成一个个句子序列，句子序列显然并不是固定长度的，然而在构造batch时需要所有的序列是同一长度才可以形成矩阵方便运算，由此需要设定一个最大长度，并将句子序列进行尾填充至最大长度。但在训练中，我们希望lstm只考虑非填充部分的序列，由此我们可以使用dynamic_rnn并将sequence length（sequence length的size为[batch_size, 1]）作为参数传进去，这样lstm会根据当前句子的length进行计算，由此提高了准确度和效率。\n\n在lstm和全连接后，我们得到了句子序列每个字的概率值，将其和标准答案计算得到loss，但填充部分也同样有loss，我们不希望填充部分的loss被考虑进去，由此就需要sequence mask了，它以sequence length( size 为 [batch_size, ])和max length( size 为 [1,])为参数，构造出 [batch_size, max_length]的bool矩阵：\n\n```python\nfrom random import randint\nimport tensorflow as tf\nfrom numpy import *\n\nmax_length = 3\nbatch_size = 5\n\nsequence_length = array([randint(1,max_length) for _ in range(batch_size)])\nloss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))\n\nprint(loss_mask)\nprint(\"sequence length: \"+str(sequence_length))\nwith tf.Session() as sess:\n\tprint(\"sequence mask:\")\n\tprint(sess.run(loss_mask))\n```\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask0.png)\n\n可以看到，我们构造出了一个二维的bool矩阵，里面每行true的数目和sequence相应索引的数值是一样的，再将bool转换成float之后，我们就可以将它和loss相乘，把无关部分的loss遮挡去了。\n\n```python\ntargets = array([[1 for _ in range(max_length)] for _ in range(batch_size)])\nlogits = array([[[randint(0,10)/10,randint(0,10)/10] for _ in range(max_length)] for _ in range(batch_size)])\n\ntargets = tf.convert_to_tensor(targets, dtype = tf.int32)\nlogits = tf.convert_to_tensor(logits, dtype = tf.float32)\n\nloss_before_mask = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=targets)\nloss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))\nloss_after_mask = loss_before_mask * tf.to_float(loss_mask)\n\nwith tf.Session() as sess:\n  print(\"loss before mask:\")\n  print((loss_before_mask))\n  print(sess.run(loss_before_mask))\n  print(\"*\"*20)\n  print(\"loss after mask:\")\n  print((loss_after_mask))\n  print(sess.run(loss_after_mask))\n```\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask1.png)\n\n之后我们就可以将loss累加或取均值作为整体的cost并进行优化了，当然，我们也可以同样将mask用于序列的准确率计算上。\n\n\n\n### Weighted Loss\n\n在对每个字进行正确与否的二分类时，有一个很大的问题就是类别分布不均衡。显然，正确字的数目要远远大于不正确的字的数目。对于包含错误的句子，一个很长的句子中或许只有一两个字是错的，更别提全对的句子了。类别分布不均在其它分类问题上也很常见，更是由此引发了f1等评价指标的诞生。毕竟若只看正确率的话，一个将所有字都认为是正确的模型在以字为单位统计正确率时将会近似于1！当然，在以句子为单位，即只有模型正确诊断出错误点时整句才算一个正确样本时，正确率将低得伤人。\n\n因此我们想要让模型更加重视样本数本身就少的类别，从目的上看，就是让模型更大胆地预测错误字，而不是胆小地把所有字都标记为正确，以此求得较小的loss。\n\n既然模型只盯着优化最小Loss这个目标，并且更新参数也是以Loss作为基准，那么我们下手的地方自然就是loss了。核心思想很简单，就是将原本的loss再根据类别的权重进行加权并求和得到最终的cost，为了最小化带了权重的loss，模型会将权重也同样进行反向传播。因此，与权重大的类别有关的更新会更加得到重视，而模型也敢放开手脚大胆预测错误字了。\n\n接下来我们通过一个简单的例子来看看Weighted loss 的使用：\n\n首先，随机生成batch_size 为3的二分类one_hot 标签label，标签转换成索引的targets，随机生成模型的最终预测logits：\n\n```python\nimport tensorflow as tf\nfrom numpy import *\nfrom random import randint\n\nbatch_size = 3\n\nlabel = zeros([batch_size,2])\nfor i in range(batch_size):\n\tlabel[i][randint(0,1)]=1\n\ntargets = argmax(label, axis=1)\nlogits = array([[randint(0,10)/10,randint(0,10)/10] for _ in range(batch_size)])\n```\n\n随机生成的结果如下：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result0.png)\n\n而后，我们开始计算loss，将targets和logits作为参数传入损失函数中计算得到加权前的loss。\n\n将标签和转置后的权重进行矩阵乘，得到加权后的标签矩阵，因标签是one hot，所以只有特定类别的权重才会保留下来。\n\n将转置后的加权标签与loss进行点乘，每个loss乘以对应标签的权重，此时的loss是特定类别上的loss，如类0的loss，而后乘以类0的权重，由此得到加权后的loss。\n\n```python\nlabel = tf.convert_to_tensor(label, dtype=tf.float32)\t# shape : [3,2]\ntargets = tf.convert_to_tensor(targets, dtype=tf.int32)\t# shape : [3,]\nlogits = tf.convert_to_tensor(logits, dtype=tf.float32)\t# shape : [3,2]\nclass_weight = tf.constant([1.0, 0.2], shape=[1,2], dtype=tf.float32)  # shape : [1,2]\n\nloss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)\n# shape : [3,]\nweighted_label = tf.transpose( tf.matmul(label, tf.transpose(class_weight)) )\t\n# shape : [1,3]\nloss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)\t\n# shape : [1,3]\n\nwith tf.Session() as sess:\n\tprint(\"Class Weight:\")\n\tprint(sess.run(class_weight))\n\tprint(\"\\nWeighted Label:\")\n\tprint(sess.run(weighted_label))\n\tprint(\"\\nLoss before weighted:\")\n\tprint(sess.run(loss_before_weighted))\n\tprint(\"\\nLoss after weighted:\")\n\tprint(sess.run(loss_after_weighted))\n\n```\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result1.png)\n\n可以看到，加权前的loss分布较为正常，而在加权之后，类0的loss保持不变，而类1的loss为原来的0.2，在反向传播的时候，参数的更新也会参考权重，使得模型更注重类0的判断。\n\n值得一提的是，显然类别的权重是一个超参数，一般可以根据样本数目比率得到，也可以人为设定而后观察并调整。\n\n以上是在普通分类问题上的加权，我们同样可以将加权应用到文本序列中，即矩阵多了一维（max_length）：\n\n```python\nmax_length = 2\nbatch_size = 3\n\nlabel = array([[[0,0] for _ in range(max_length)] for _ in range(batch_size)])\nfor i in range(batch_size):\n\tfor j in range(max_length):\n\t\tlabel[i][j][randint(0,1)]=1\ntargets = argmax(label, axis=2)\nlogits = array([[[randint(0,10)/10,randint(0,10)/10] for _ in range(max_length)] for _ in range(batch_size)])\n\nprint(\"label\"+str(label))\nprint(\"targets\"+str(targets))\nprint(\"logits\"+str(logits))\n\nlabel = tf.convert_to_tensor(label, dtype=tf.float32)\ntargets = tf.convert_to_tensor(targets, dtype=tf.int32)\nlogits = tf.convert_to_tensor(logits, dtype=tf.float32)\nclass_weight = tf.constant([1.0, 0.2], shape=[1,2], dtype=tf.float32)\n\nloss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)\n# shape [batch_size, max_length]\nweighted_label = tf.transpose( tf.matmul(tf.reshape(label,[-1,2]), tf.transpose(class_weight)) ) \n# shape [1, max_length*batch_size]\nweighted_label = tf.reshape(weighted_label,[batch_size,max_length])\n# shape [batch_size, max_length]\nloss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)\n# shape [batch_size, max_length]\n\nwith tf.Session() as sess:\n\tprint(\"Class Weight:\")\n\tprint(sess.run(class_weight))\n\tprint(\"\\nWeighted Label:\")\n\tprint(sess.run(weighted_label))\n\tprint(\"\\nLoss before weighted:\")\n\tprint(sess.run(loss_before_weighted))\n\tprint(\"\\nLoss after weighted:\")\n\tprint(sess.run(loss_after_weighted))\n\n```\n\n结果如下：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result2.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result3.png)\n\n\n\n\n\n\n\n","slug":"tf_csc_trick","published":1,"updated":"2018-08-29T07:00:29.198Z","_id":"cjleshqjr000sryfcw60sajfr","photos":[],"link":"","content":"<p>这一大段时期，笔者一直在研究序列检错问题，最近涉及到字级序列的检错。字级序列进行错误检测其实就是一个和标注词性一样的序列标注问题，对于给定的字级序列，预测该序列中每个字是正确还是错误。在用tensorflow使用双向lstm对序列进行检错的过程中，笔者不断根据需要和模型反映的问题对模型进行修改，再加上参考其他人写的代码和总结，由此有了一些体会，在此说说其中几个。</p>\n<p>本文介绍两个tricks：</p>\n<ol>\n<li>Sequence Mask</li>\n<li>Weighted Loss</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"Sequence-Mask\"><a href=\"#Sequence-Mask\" class=\"headerlink\" title=\"Sequence Mask\"></a>Sequence Mask</h3><p>在获得文本语料之后，我们会将文本根据逗号、句号等标点符号切分成一个个句子序列，句子序列显然并不是固定长度的，然而在构造batch时需要所有的序列是同一长度才可以形成矩阵方便运算，由此需要设定一个最大长度，并将句子序列进行尾填充至最大长度。但在训练中，我们希望lstm只考虑非填充部分的序列，由此我们可以使用dynamic_rnn并将sequence length（sequence length的size为[batch_size, 1]）作为参数传进去，这样lstm会根据当前句子的length进行计算，由此提高了准确度和效率。</p>\n<p>在lstm和全连接后，我们得到了句子序列每个字的概率值，将其和标准答案计算得到loss，但填充部分也同样有loss，我们不希望填充部分的loss被考虑进去，由此就需要sequence mask了，它以sequence length( size 为 [batch_size, ])和max length( size 为 [1,])为参数，构造出 [batch_size, max_length]的bool矩阵：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randint</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">max_length = <span class=\"number\">3</span></span><br><span class=\"line\">batch_size = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">sequence_length = array([randint(<span class=\"number\">1</span>,max_length) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\">loss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))</span><br><span class=\"line\"></span><br><span class=\"line\">print(loss_mask)</span><br><span class=\"line\">print(<span class=\"string\">\"sequence length: \"</span>+str(sequence_length))</span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">\tprint(<span class=\"string\">\"sequence mask:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_mask))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask0.png\" alt=\"\"></p>\n<p>可以看到，我们构造出了一个二维的bool矩阵，里面每行true的数目和sequence相应索引的数值是一样的，再将bool转换成float之后，我们就可以将它和loss相乘，把无关部分的loss遮挡去了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets = array([[<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\">logits = array([[[randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>,randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\"></span><br><span class=\"line\">targets = tf.convert_to_tensor(targets, dtype = tf.int32)</span><br><span class=\"line\">logits = tf.convert_to_tensor(logits, dtype = tf.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">loss_before_mask = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=targets)</span><br><span class=\"line\">loss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))</span><br><span class=\"line\">loss_after_mask = loss_before_mask * tf.to_float(loss_mask)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">  print(<span class=\"string\">\"loss before mask:\"</span>)</span><br><span class=\"line\">  print((loss_before_mask))</span><br><span class=\"line\">  print(sess.run(loss_before_mask))</span><br><span class=\"line\">  print(<span class=\"string\">\"*\"</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"loss after mask:\"</span>)</span><br><span class=\"line\">  print((loss_after_mask))</span><br><span class=\"line\">  print(sess.run(loss_after_mask))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask1.png\" alt=\"\"></p>\n<p>之后我们就可以将loss累加或取均值作为整体的cost并进行优化了，当然，我们也可以同样将mask用于序列的准确率计算上。</p>\n<h3 id=\"Weighted-Loss\"><a href=\"#Weighted-Loss\" class=\"headerlink\" title=\"Weighted Loss\"></a>Weighted Loss</h3><p>在对每个字进行正确与否的二分类时，有一个很大的问题就是类别分布不均衡。显然，正确字的数目要远远大于不正确的字的数目。对于包含错误的句子，一个很长的句子中或许只有一两个字是错的，更别提全对的句子了。类别分布不均在其它分类问题上也很常见，更是由此引发了f1等评价指标的诞生。毕竟若只看正确率的话，一个将所有字都认为是正确的模型在以字为单位统计正确率时将会近似于1！当然，在以句子为单位，即只有模型正确诊断出错误点时整句才算一个正确样本时，正确率将低得伤人。</p>\n<p>因此我们想要让模型更加重视样本数本身就少的类别，从目的上看，就是让模型更大胆地预测错误字，而不是胆小地把所有字都标记为正确，以此求得较小的loss。</p>\n<p>既然模型只盯着优化最小Loss这个目标，并且更新参数也是以Loss作为基准，那么我们下手的地方自然就是loss了。核心思想很简单，就是将原本的loss再根据类别的权重进行加权并求和得到最终的cost，为了最小化带了权重的loss，模型会将权重也同样进行反向传播。因此，与权重大的类别有关的更新会更加得到重视，而模型也敢放开手脚大胆预测错误字了。</p>\n<p>接下来我们通过一个简单的例子来看看Weighted loss 的使用：</p>\n<p>首先，随机生成batch_size 为3的二分类one_hot 标签label，标签转换成索引的targets，随机生成模型的最终预测logits：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randint</span><br><span class=\"line\"></span><br><span class=\"line\">batch_size = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">label = zeros([batch_size,<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(batch_size):</span><br><span class=\"line\">\tlabel[i][randint(<span class=\"number\">0</span>,<span class=\"number\">1</span>)]=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">targets = argmax(label, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">logits = array([[randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>,randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br></pre></td></tr></table></figure>\n<p>随机生成的结果如下：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result0.png\" alt=\"\"></p>\n<p>而后，我们开始计算loss，将targets和logits作为参数传入损失函数中计算得到加权前的loss。</p>\n<p>将标签和转置后的权重进行矩阵乘，得到加权后的标签矩阵，因标签是one hot，所以只有特定类别的权重才会保留下来。</p>\n<p>将转置后的加权标签与loss进行点乘，每个loss乘以对应标签的权重，此时的loss是特定类别上的loss，如类0的loss，而后乘以类0的权重，由此得到加权后的loss。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label = tf.convert_to_tensor(label, dtype=tf.float32)\t<span class=\"comment\"># shape : [3,2]</span></span><br><span class=\"line\">targets = tf.convert_to_tensor(targets, dtype=tf.int32)\t<span class=\"comment\"># shape : [3,]</span></span><br><span class=\"line\">logits = tf.convert_to_tensor(logits, dtype=tf.float32)\t<span class=\"comment\"># shape : [3,2]</span></span><br><span class=\"line\">class_weight = tf.constant([<span class=\"number\">1.0</span>, <span class=\"number\">0.2</span>], shape=[<span class=\"number\">1</span>,<span class=\"number\">2</span>], dtype=tf.float32)  <span class=\"comment\"># shape : [1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">loss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)</span><br><span class=\"line\"><span class=\"comment\"># shape : [3,]</span></span><br><span class=\"line\">weighted_label = tf.transpose( tf.matmul(label, tf.transpose(class_weight)) )\t</span><br><span class=\"line\"><span class=\"comment\"># shape : [1,3]</span></span><br><span class=\"line\">loss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)\t</span><br><span class=\"line\"><span class=\"comment\"># shape : [1,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">\tprint(<span class=\"string\">\"Class Weight:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(class_weight))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nWeighted Label:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(weighted_label))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss before weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_before_weighted))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss after weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_after_weighted))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result1.png\" alt=\"\"></p>\n<p>可以看到，加权前的loss分布较为正常，而在加权之后，类0的loss保持不变，而类1的loss为原来的0.2，在反向传播的时候，参数的更新也会参考权重，使得模型更注重类0的判断。</p>\n<p>值得一提的是，显然类别的权重是一个超参数，一般可以根据样本数目比率得到，也可以人为设定而后观察并调整。</p>\n<p>以上是在普通分类问题上的加权，我们同样可以将加权应用到文本序列中，即矩阵多了一维（max_length）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_length = <span class=\"number\">2</span></span><br><span class=\"line\">batch_size = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">label = array([[[<span class=\"number\">0</span>,<span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(batch_size):</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(max_length):</span><br><span class=\"line\">\t\tlabel[i][j][randint(<span class=\"number\">0</span>,<span class=\"number\">1</span>)]=<span class=\"number\">1</span></span><br><span class=\"line\">targets = argmax(label, axis=<span class=\"number\">2</span>)</span><br><span class=\"line\">logits = array([[[randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>,randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"label\"</span>+str(label))</span><br><span class=\"line\">print(<span class=\"string\">\"targets\"</span>+str(targets))</span><br><span class=\"line\">print(<span class=\"string\">\"logits\"</span>+str(logits))</span><br><span class=\"line\"></span><br><span class=\"line\">label = tf.convert_to_tensor(label, dtype=tf.float32)</span><br><span class=\"line\">targets = tf.convert_to_tensor(targets, dtype=tf.int32)</span><br><span class=\"line\">logits = tf.convert_to_tensor(logits, dtype=tf.float32)</span><br><span class=\"line\">class_weight = tf.constant([<span class=\"number\">1.0</span>, <span class=\"number\">0.2</span>], shape=[<span class=\"number\">1</span>,<span class=\"number\">2</span>], dtype=tf.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">loss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)</span><br><span class=\"line\"><span class=\"comment\"># shape [batch_size, max_length]</span></span><br><span class=\"line\">weighted_label = tf.transpose( tf.matmul(tf.reshape(label,[<span class=\"number\">-1</span>,<span class=\"number\">2</span>]), tf.transpose(class_weight)) ) </span><br><span class=\"line\"><span class=\"comment\"># shape [1, max_length*batch_size]</span></span><br><span class=\"line\">weighted_label = tf.reshape(weighted_label,[batch_size,max_length])</span><br><span class=\"line\"><span class=\"comment\"># shape [batch_size, max_length]</span></span><br><span class=\"line\">loss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)</span><br><span class=\"line\"><span class=\"comment\"># shape [batch_size, max_length]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">\tprint(<span class=\"string\">\"Class Weight:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(class_weight))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nWeighted Label:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(weighted_label))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss before weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_before_weighted))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss after weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_after_weighted))</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result2.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result3.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>这一大段时期，笔者一直在研究序列检错问题，最近涉及到字级序列的检错。字级序列进行错误检测其实就是一个和标注词性一样的序列标注问题，对于给定的字级序列，预测该序列中每个字是正确还是错误。在用tensorflow使用双向lstm对序列进行检错的过程中，笔者不断根据需要和模型反映的问题对模型进行修改，再加上参考其他人写的代码和总结，由此有了一些体会，在此说说其中几个。</p>\n<p>本文介绍两个tricks：</p>\n<ol>\n<li>Sequence Mask</li>\n<li>Weighted Loss</li>\n</ol>","more":"<h3 id=\"Sequence-Mask\"><a href=\"#Sequence-Mask\" class=\"headerlink\" title=\"Sequence Mask\"></a>Sequence Mask</h3><p>在获得文本语料之后，我们会将文本根据逗号、句号等标点符号切分成一个个句子序列，句子序列显然并不是固定长度的，然而在构造batch时需要所有的序列是同一长度才可以形成矩阵方便运算，由此需要设定一个最大长度，并将句子序列进行尾填充至最大长度。但在训练中，我们希望lstm只考虑非填充部分的序列，由此我们可以使用dynamic_rnn并将sequence length（sequence length的size为[batch_size, 1]）作为参数传进去，这样lstm会根据当前句子的length进行计算，由此提高了准确度和效率。</p>\n<p>在lstm和全连接后，我们得到了句子序列每个字的概率值，将其和标准答案计算得到loss，但填充部分也同样有loss，我们不希望填充部分的loss被考虑进去，由此就需要sequence mask了，它以sequence length( size 为 [batch_size, ])和max length( size 为 [1,])为参数，构造出 [batch_size, max_length]的bool矩阵：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randint</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">max_length = <span class=\"number\">3</span></span><br><span class=\"line\">batch_size = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">sequence_length = array([randint(<span class=\"number\">1</span>,max_length) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\">loss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))</span><br><span class=\"line\"></span><br><span class=\"line\">print(loss_mask)</span><br><span class=\"line\">print(<span class=\"string\">\"sequence length: \"</span>+str(sequence_length))</span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">\tprint(<span class=\"string\">\"sequence mask:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_mask))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask0.png\" alt=\"\"></p>\n<p>可以看到，我们构造出了一个二维的bool矩阵，里面每行true的数目和sequence相应索引的数值是一样的，再将bool转换成float之后，我们就可以将它和loss相乘，把无关部分的loss遮挡去了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets = array([[<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\">logits = array([[[randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>,randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\"></span><br><span class=\"line\">targets = tf.convert_to_tensor(targets, dtype = tf.int32)</span><br><span class=\"line\">logits = tf.convert_to_tensor(logits, dtype = tf.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">loss_before_mask = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=targets)</span><br><span class=\"line\">loss_mask = tf.sequence_mask(tf.to_int32(sequence_length), tf.to_int32(max_length))</span><br><span class=\"line\">loss_after_mask = loss_before_mask * tf.to_float(loss_mask)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">  print(<span class=\"string\">\"loss before mask:\"</span>)</span><br><span class=\"line\">  print((loss_before_mask))</span><br><span class=\"line\">  print(sess.run(loss_before_mask))</span><br><span class=\"line\">  print(<span class=\"string\">\"*\"</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"loss after mask:\"</span>)</span><br><span class=\"line\">  print((loss_after_mask))</span><br><span class=\"line\">  print(sess.run(loss_after_mask))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_trick_smask1.png\" alt=\"\"></p>\n<p>之后我们就可以将loss累加或取均值作为整体的cost并进行优化了，当然，我们也可以同样将mask用于序列的准确率计算上。</p>\n<h3 id=\"Weighted-Loss\"><a href=\"#Weighted-Loss\" class=\"headerlink\" title=\"Weighted Loss\"></a>Weighted Loss</h3><p>在对每个字进行正确与否的二分类时，有一个很大的问题就是类别分布不均衡。显然，正确字的数目要远远大于不正确的字的数目。对于包含错误的句子，一个很长的句子中或许只有一两个字是错的，更别提全对的句子了。类别分布不均在其它分类问题上也很常见，更是由此引发了f1等评价指标的诞生。毕竟若只看正确率的话，一个将所有字都认为是正确的模型在以字为单位统计正确率时将会近似于1！当然，在以句子为单位，即只有模型正确诊断出错误点时整句才算一个正确样本时，正确率将低得伤人。</p>\n<p>因此我们想要让模型更加重视样本数本身就少的类别，从目的上看，就是让模型更大胆地预测错误字，而不是胆小地把所有字都标记为正确，以此求得较小的loss。</p>\n<p>既然模型只盯着优化最小Loss这个目标，并且更新参数也是以Loss作为基准，那么我们下手的地方自然就是loss了。核心思想很简单，就是将原本的loss再根据类别的权重进行加权并求和得到最终的cost，为了最小化带了权重的loss，模型会将权重也同样进行反向传播。因此，与权重大的类别有关的更新会更加得到重视，而模型也敢放开手脚大胆预测错误字了。</p>\n<p>接下来我们通过一个简单的例子来看看Weighted loss 的使用：</p>\n<p>首先，随机生成batch_size 为3的二分类one_hot 标签label，标签转换成索引的targets，随机生成模型的最终预测logits：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randint</span><br><span class=\"line\"></span><br><span class=\"line\">batch_size = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">label = zeros([batch_size,<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(batch_size):</span><br><span class=\"line\">\tlabel[i][randint(<span class=\"number\">0</span>,<span class=\"number\">1</span>)]=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">targets = argmax(label, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">logits = array([[randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>,randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br></pre></td></tr></table></figure>\n<p>随机生成的结果如下：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result0.png\" alt=\"\"></p>\n<p>而后，我们开始计算loss，将targets和logits作为参数传入损失函数中计算得到加权前的loss。</p>\n<p>将标签和转置后的权重进行矩阵乘，得到加权后的标签矩阵，因标签是one hot，所以只有特定类别的权重才会保留下来。</p>\n<p>将转置后的加权标签与loss进行点乘，每个loss乘以对应标签的权重，此时的loss是特定类别上的loss，如类0的loss，而后乘以类0的权重，由此得到加权后的loss。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label = tf.convert_to_tensor(label, dtype=tf.float32)\t<span class=\"comment\"># shape : [3,2]</span></span><br><span class=\"line\">targets = tf.convert_to_tensor(targets, dtype=tf.int32)\t<span class=\"comment\"># shape : [3,]</span></span><br><span class=\"line\">logits = tf.convert_to_tensor(logits, dtype=tf.float32)\t<span class=\"comment\"># shape : [3,2]</span></span><br><span class=\"line\">class_weight = tf.constant([<span class=\"number\">1.0</span>, <span class=\"number\">0.2</span>], shape=[<span class=\"number\">1</span>,<span class=\"number\">2</span>], dtype=tf.float32)  <span class=\"comment\"># shape : [1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">loss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)</span><br><span class=\"line\"><span class=\"comment\"># shape : [3,]</span></span><br><span class=\"line\">weighted_label = tf.transpose( tf.matmul(label, tf.transpose(class_weight)) )\t</span><br><span class=\"line\"><span class=\"comment\"># shape : [1,3]</span></span><br><span class=\"line\">loss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)\t</span><br><span class=\"line\"><span class=\"comment\"># shape : [1,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">\tprint(<span class=\"string\">\"Class Weight:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(class_weight))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nWeighted Label:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(weighted_label))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss before weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_before_weighted))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss after weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_after_weighted))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result1.png\" alt=\"\"></p>\n<p>可以看到，加权前的loss分布较为正常，而在加权之后，类0的loss保持不变，而类1的loss为原来的0.2，在反向传播的时候，参数的更新也会参考权重，使得模型更注重类0的判断。</p>\n<p>值得一提的是，显然类别的权重是一个超参数，一般可以根据样本数目比率得到，也可以人为设定而后观察并调整。</p>\n<p>以上是在普通分类问题上的加权，我们同样可以将加权应用到文本序列中，即矩阵多了一维（max_length）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_length = <span class=\"number\">2</span></span><br><span class=\"line\">batch_size = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">label = array([[[<span class=\"number\">0</span>,<span class=\"number\">0</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(batch_size):</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(max_length):</span><br><span class=\"line\">\t\tlabel[i][j][randint(<span class=\"number\">0</span>,<span class=\"number\">1</span>)]=<span class=\"number\">1</span></span><br><span class=\"line\">targets = argmax(label, axis=<span class=\"number\">2</span>)</span><br><span class=\"line\">logits = array([[[randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>,randint(<span class=\"number\">0</span>,<span class=\"number\">10</span>)/<span class=\"number\">10</span>] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(max_length)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(batch_size)])</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"label\"</span>+str(label))</span><br><span class=\"line\">print(<span class=\"string\">\"targets\"</span>+str(targets))</span><br><span class=\"line\">print(<span class=\"string\">\"logits\"</span>+str(logits))</span><br><span class=\"line\"></span><br><span class=\"line\">label = tf.convert_to_tensor(label, dtype=tf.float32)</span><br><span class=\"line\">targets = tf.convert_to_tensor(targets, dtype=tf.int32)</span><br><span class=\"line\">logits = tf.convert_to_tensor(logits, dtype=tf.float32)</span><br><span class=\"line\">class_weight = tf.constant([<span class=\"number\">1.0</span>, <span class=\"number\">0.2</span>], shape=[<span class=\"number\">1</span>,<span class=\"number\">2</span>], dtype=tf.float32)</span><br><span class=\"line\"></span><br><span class=\"line\">loss_before_weighted = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = logits, labels=targets)</span><br><span class=\"line\"><span class=\"comment\"># shape [batch_size, max_length]</span></span><br><span class=\"line\">weighted_label = tf.transpose( tf.matmul(tf.reshape(label,[<span class=\"number\">-1</span>,<span class=\"number\">2</span>]), tf.transpose(class_weight)) ) </span><br><span class=\"line\"><span class=\"comment\"># shape [1, max_length*batch_size]</span></span><br><span class=\"line\">weighted_label = tf.reshape(weighted_label,[batch_size,max_length])</span><br><span class=\"line\"><span class=\"comment\"># shape [batch_size, max_length]</span></span><br><span class=\"line\">loss_after_weighted = tf.multiply(weighted_label, loss_before_weighted)</span><br><span class=\"line\"><span class=\"comment\"># shape [batch_size, max_length]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">\tprint(<span class=\"string\">\"Class Weight:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(class_weight))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nWeighted Label:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(weighted_label))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss before weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_before_weighted))</span><br><span class=\"line\">\tprint(<span class=\"string\">\"\\nLoss after weighted:\"</span>)</span><br><span class=\"line\">\tprint(sess.run(loss_after_weighted))</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result2.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/tf_csc_trick0_result3.png\" alt=\"\"></p>"},{"layout":"post","title":"软件开发综合实训小结：基于Qt的排序算法演示系统","date":"2018-07-13T16:00:00.000Z","comments":1,"_content":"\n2018年 6月4日 - 7月5日 间， 我们进行了为其一个月的软件开发综合实训。 在实训中我们以5-6人的小组为单位进行团队开发，使用c++最终完成基于Qt的排序算法演示系统。在这一个月中，我担任小组的组长，和团队成员一起学习Qt、学习团队开发、进行需求分析、功能设计、系统模块设计，并到后来的编码实现及测试。通过这次实训我收获颇多，在此将整个实训过程梳理并小结一番。\n\n<!-- more -->\n\n### 题目背景与需求分析\n\n限定语言为C++，可选题目为：线性表、堆栈、队列、树、图5个基本结构（或基本排序算法-插入、冒泡、选择、快速、堆排序、归并、基数排序）的算法演示系统。\n\n经过小组讨论，我们选择排序算法演示系统。\n\n而后，我们查找了当前已有的排序算法演示系统，并以 [这个算法可视化网站](https://visualgo.net/zh) 作为参考。 通过实际使用已有的算法可视化系统，我们将要实现的功能分为三类：\n\n1. 算法功能：系统所支持的排序算法，以题目给出的七种排序算法为准。\n2. 演示功能：一开始的讨论中我们认为演示起码要有连续执行和单步执行，连续执行要能够在连续和暂停之间切换。而返回上一步的功能作为备选功能。\n3. 数组生成功能：系统应当支持随机生成和用户自定义数组。通过对数组进行分析，我们确定了两个用户可修改的属性：数组规模和具体的数组元素。\n\n此外，对于数据的表现形式，我们认为采用数字并不直观，以图形的形式表示更好，并且最好数字的相对大小能够反映到图形的相对大小上，由此我们直接采用了上文已有的可视化形式：用矩形+数字来表示一个数组元素，矩形的宽度固定而长度不定，根据数组内元素分布而动态变化。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo0.png)\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo1.png)\n\n### 模块划分与小组分工\n\n通过对演示系统进行分析、观察已有的算法演示系统，我们根据经验以及观察的结果，首先将系统划分成各个模块：窗口模块、图形元素及按钮的静态模块、算法演示模块、辅助模块（如记录日志、数组等）以及能够在图形元素上进行的操作模块。\n\n对于小组分工，起初我们的设想是由一个同学统一封装好图形操作并提供简单的接口，就是我们所学的 Facade 模式。但在讨论的过程中发现我们需要对很多操作进行约定，但这些约定是建立在有经验的基础上的，而对于我们这些初学者来说，开始时建立的约定很可能会不断变更，那么维护接口并根据接口调整程序就变得相当麻烦。此外，我们还需要那位封装接口的同学尽可能快地完成封装任务，才能确定其它模块实现的可行性。\n\n后来我们想到，团队分工其实是和软件的类设计以及职责分配是一样的，虽然提倡高内聚且低耦合，但一般很难同时达到这两点。为了项目开发进度着想，并且我们对项目的可维护性要求并不高，因此我们采用每个人完成一到两个算法演示部分的方法，每个人自行完成单步演示、连续播放、暂停以及重设数组等操作，至于每个操作具体如何实现则由实现的同学自行考虑。而最后我们仅需要将算法演示和主窗口结合起来即可。\n\n这样的分工虽然内聚性较低且重复性也比较高，但是每个人都能够参与算法完整演示的开发，每个人都能够学到东西，并且团队的耦合性也比较低，每个人能够较为独立地进行开发。这对我们目前的团队和任务来说是比较优的方法了。\n\n而要具体划分算法模块时，我们还遇到一个问题：算法的难度不同。\n\n对于三个基本排序（选择、插入、冒泡）以及快排，演示时涉及到的仅是块的颜色变换以及块的交换。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo2.png)\n\n对于归并排序，我们还需要块能够上下移动，以表明一个归并的过程：\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo3.png)\n\n对于堆排序，我们需要矩形以二叉树的形式进行演示，在这种情况下不需要矩形的长度随着数据大小进行变化。涉及到的演示过程主要为变色与矩形块的交换。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo4.png)\n\n对于基数排序，我们需要有基数槽。此外，矩形的操作除了变色外并不需要交换，但它需要方便地进行移动。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo5.png)\n\n在将每个算法演示涉及到的操作列举出来之后，我们认为在难度方面： 三个基本排序+快排 < 归并 < 基数 ≈ 堆排，此外我们还需要绘制窗口、处理用户事件以及撰写过程文档。\n\n最终我们的分工如下：\n\n1. 一名同学负责窗口设计与绘制，并负责一个基本的排序算法\n2. 一名同学负责用户事件处理（点击、输入数据等事件）并做最后整合，且负责一个基本排序算法\n3. 一名同学作为文档负责人，并且负责一个基本排序算法\n4. 一名同学完成两个排序算法：归并与快排\n5. 两名同学分别完成两个较为困难的排序算法的演示：堆排序和基数排序\n\n我负责的为第二点，用户事件处理、最终整合以及选择排序的实现。\n\n### 选择排序演示的实现\n\n#### 1. 类设计与功能划分\n\n在学习Qt的基本操作以及了解了图形移动的实现方式之后，我就开始着手进行类的设计以及功能划分了。\n\nQt中静态的窗口及元素由QWidget完成，而涉及到矩形、圆形等的几何图形绘制及移动，就需要用到View 和 Scene了，在算法演示系统中，我们不仅需要矩形等几何图形，也同样需要QWidget的按钮等元素，由此我们利用scene的addWidget函数将Widget作为其中一个元素加入场景中。这样我们就能够专心在Widget中处理各种按钮及其它事件，在主类中生成矩形以及进行各种演示操作。\n\n了解到矩形移动需要使用定时器来控制移动时间和频率，为了提高类的内聚性以及提高通用性，我将各种计时器统一提取出来放到一个单例模式辅助类，在之后整合的时候，这个类还可以放入其它杂属性来保存一些全局信息。\n\n在大的框架上总共有三个类（不考虑排序算法的虚基类）：\n\n1.  排序算法主类，进行数组生成、记录生成及演示\n2.  Widget类，静态窗口类，用于放置各种静态按钮、文本输入框以及处理和它们相关的事件\n3.  辅助类Event，用来保存全局信息和各种计时器。\n\n而到了底层，我们还需要以下几个类作为框架类的属性并提供支持：\n\n1.  矩形类，使用了Qt允许的自定义的图像元素，方便根据需要生成变长矩形\n2.  图形元素类，封装了矩形类+数字文本类，并保存了这个图形元素对应的数组数字，是排序算法操作的基本单位。\n3.  记录类，描述单个记录需要保存哪些信息：记录的类型（变色或移动）、模式（变什么颜色或往哪里移动）、图形元素的索引（哪个图形要发生变化）。此外还有一个前驱指针和一个后继指针。\n4.  记录链表，使用双向链表保存一系列记录，包含首尾两个哨兵以及一个指向当前正在读取的记录的指针current。当中实现了些常用的双向链表的操作（清空、尾插入、判空等）。\n\n#### 2. 数组、记录生成及演示操作\n\n在数组的生成方面，为了方便用户使用，我们首先随机在规定范围内生成一个数组以供用户直接使用演示功能。而后，用户能够随时更改数组规模和具体的数组元素。数组生成共分为四大类情况：\n\n1.  用户未设置数组规模及具体数组元素，则系统随机生成数组。\n2.  用户设置了数组规模未设置具体元素，则系统根据规模生成随机数组。\n3.  用户仅设置了具体的数组元素但未设置规模，则系统原样根据元素生成数组。\n4.  用户同时设置了数组规模和元素（原则：以规模数为准）：\n   1.  元素数目和规模匹配：则系统原样生成。\n   2.  规模数大于元素数：系统补足剩余元素。\n   3.  规模数小于元素数：系统截取规模数以内的元素。\n\n每当数组生成之后，系统就会立刻根据排序算法生成记录列表，之后的演示就只是移动双向链表中的current指针依次读取记录并执行了。\n\n那么记录是如何生成的呢？在生成的函数内，实际上有个临时数组复制了生成的数组，而后对临时数组执行相应的排序算法，在算法执行的过程中在关键的部分创建记录并插入链表中。\n\n记录包含三个属性：type，attribute1，attribute2：\n\n1. type = 0 代表变色，此时attribute1表明变色的模式，attribute2表明要变色的矩形下标：\n   1. attribute1 = 0 将矩形变为正常颜色\n   2. attribute1 = 1 矩形此时被选中，变为选中模式的颜色，若前一个矩形不是最小的矩形，则将上一个矩形恢复未正常颜色\n   3. attribute1 = 2 矩形为当前最小，变为最小模式的颜色\n   4. attribute1 = 3 若矩形不是当前最小，则恢复为正常颜色\n2. type = 1 代表交换：attribute1和attribute2记录要交换位置的两个图形元素的索引。\n\n#### 3. 演示与定时器\n\n在演示部分，用户可以选择连续演示、暂停和单步演示。\n\n从上一次演示到下一次演示是通过设定计时器并等待计时器触发，执行相应触发函数完成的。\n\n演示模式分为播放和暂停，当前的演示模式通过辅助类的一个全局变量记录下来，每读取并执行完一条记录，则检查全局变量标签，若此时为播放模式，则开启下一轮计时器，当计时器达到设定值时系统开始读取并执行下一条记录，直到用户暂停或执行完最后一条记录。若此时为暂停模式，则不做任何操作，等待用户下一步操作。\n\n用户能够单击连续演示、暂停、下一步和重新开始按钮：\n\n1.  连续演示按钮实则将标签设置为播放，而后手动开启一次计时器\n2.  暂停按钮则将当前的计时器关闭，将标签设置为暂停\n3.  下一步按钮则将标签设置为暂停并手动开启一次定时器\n4.  重新开始按钮则会调用算法类实现的重设功能，我们将current指针一步步向前移动并根据恢复换位操作，最终将所有的矩形块变为正常颜色。\n\n对于动画演示至关重要的计时器在选择排序部分总共分为两个：\n\n1. 第一个全局计时器描述执行一条记录所需要的时间，这个时间视当前执行的记录的类型而定，反映到界面上就是每个变化之间的时间间隔，变色的时间间隔要比交换的时间间隔短得多。\n2. 第二个交换计时器描述交换一小步的时间，我们将一个完整的交换过程切成固定数目的段并用一个常量记录下来，而交换计时器每触发一次，就会将两个要交换位置的矩形稍微向对方位置移动一小点，同时更新一个临时计数器，一旦临时计数器达到先前提到的常量，则说明两个矩形到达目标位置了，那么就关闭交换计时器。\n\n### 用户事件处理及整合\n\n用户所能够进行的操作共分为三类：\n\n1.  设定数组\n2.  切换演示模式\n3.  切换算法\n\n前面介绍了前两类操作，而第三种分为两种情况：\n\n1.  用户当前在主界面，界面列出用户可选的算法，用户通过点击选择一个算法并进入演示界面\n\n   ![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png)\n\n2.  用户已经进入了某个算法的演示界面，想要直接切换到另外一个算法\n\n   ![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF11.png)\n\n对于整合，在开发的过程中，我就根据自己实现的选择排序算法类构造了一个虚基类并规定了几个必须要实现的接口，因此拿到其他成员实现的算法类我并不需要知道它们内部是怎么实现的，只需要用虚基类的指针指向对应的实例对象然后通过多态调用相应的函数即可。\n\n整合的方法总共尝试了三种，前两种均因不明情况而宣告失败，最后选用了最简单粗暴的方案三解决了。\n\n1. 方案一：全局使用一个view、scene和widget，每个算法的单例对象在创建后不删除。每当用户选择其它排序算法时，将当前算法类的图形元素一个个从场景中抹去，而后将虚基类指针指向新的算法类单例对象，完成初始化并调用重设函数。\n2. 方案二：全局使用一个view，算法的单例对象创建后不删除，scene和widget在每次切换都重新生成，需要调用算法的重设函数重新向scene中添加元素。\n3. 方案三：全局使用一个view，算法对象、scene和widget每次切换都重新生成。\n\n采用方案一、方案二实现的过程中，总会在切换时发生各样奇怪的bug。由此看来问题很可能出现在算法对象的重设以及和scene的交互上，进一步推测很可能出现在指针指向对象的存在性以及空间分配和回收上。鉴于项目时间紧迫，我们就没有再采用方案一或二深入纠正了。\n\n### 成果展示\n\n最终我们的系统成品如下，所有的交换过程均为实际动画。\n\n起始界面:\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png)\n\n冒泡排序算法的演示界面:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF1.png)\n\n块互换位置的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF2.png)\n\n块被选中及进行大小比较:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF3.png)\n\n归并的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF4.png)\n\n归并归位的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF5.png)\n\n堆排序建堆过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF6.png)\n\n堆排序构建有序数组过程(粉色代表已经有序)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF7.png)\n\n基数排序初始样式:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF8.png)\n\n基数排序取个位数选槽的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF9.png)\n\n第一轮基数排序即将完成:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF10.png)\n\n### 总结\n\n本次实训我的收获很大，收获分为以下几个方面：\n\n1. 团队合作开发软件的经历。作为组长不仅要考虑从需求转换到功能，更要根据需求的可实现性对需求进行挑选。此外还需要尽可能地合理划分模块并进行分工。在开发过程中需要时时确认开发进度，锁定开发中遇到的问题并组织讨论解决。在开始时有预想好分工，但后来想到，团队分工其实和类的设计是一样的，要尽可能提高内聚，降低耦合，尤其大家都没有开发经验，因此一开始约定的接口很可能变来变去，于是就直接划分算法让大家自行实现，最后直接整合。\n2. 第二自然是对Qt开发和使用有了了解，对于C++带界面的应用程序也总算有了接触。因为Qt极其庞大，功能奇多，之前也没有C++界面应用程序的开发经验，因此一开始总有种畏惧情绪。但后来实际接触下来，发现其实和java的fx差不多，尤其creator已经集成了很多很方便的功能，如界面设计直接拖控件即可等。并且Qt虽然功能很多，但我们仅需要其中的很少一部分，只要在用的时候查对应的部分即可，以往想要全部掌握再开工的学生思维很不适合这样的开发。\n3. 第三则是C++本身的使用了，大一过后除了实验课之外就很少再用C++进行开发了，java的面向对象更为直观，python方便快速易用，让我很少再使用C++。而这次综合实训让我重新把c++捡起来并且再度体会到它的博大精深，有相当多玄妙而精巧的设计，难怪其难度远远在其它语言之上，尤其在开发过程中我们大量使用指针，在debug过程中也相当艰辛。\n\n这次实训让我收获匪浅，不仅认识到自己的不足，开拓了自己的眼界，掌握了新的知识，还实际进行了团队开发。以往自己个人开发时不需要考虑太多代码和接口的易读性，以及界面的易用性等，但团队开发时这些都非常重要。我的团队意识也有了非常大的提高。\n\n### 源代码\n\n整个项目的源代码可以在[我的github](https://github.com/zedom1/Class_Project/tree/master/Sorting%20Algorithm)看到。\n","source":"_posts/sorting algorithm.md","raw":"---\nlayout: post\ntitle: \"软件开发综合实训小结：基于Qt的排序算法演示系统\"\ndate: 2018-07-14\ncomments: true\ntags: \n\t- C++\n\t- 软件开发\n\t- Qt\n---\n\n2018年 6月4日 - 7月5日 间， 我们进行了为其一个月的软件开发综合实训。 在实训中我们以5-6人的小组为单位进行团队开发，使用c++最终完成基于Qt的排序算法演示系统。在这一个月中，我担任小组的组长，和团队成员一起学习Qt、学习团队开发、进行需求分析、功能设计、系统模块设计，并到后来的编码实现及测试。通过这次实训我收获颇多，在此将整个实训过程梳理并小结一番。\n\n<!-- more -->\n\n### 题目背景与需求分析\n\n限定语言为C++，可选题目为：线性表、堆栈、队列、树、图5个基本结构（或基本排序算法-插入、冒泡、选择、快速、堆排序、归并、基数排序）的算法演示系统。\n\n经过小组讨论，我们选择排序算法演示系统。\n\n而后，我们查找了当前已有的排序算法演示系统，并以 [这个算法可视化网站](https://visualgo.net/zh) 作为参考。 通过实际使用已有的算法可视化系统，我们将要实现的功能分为三类：\n\n1. 算法功能：系统所支持的排序算法，以题目给出的七种排序算法为准。\n2. 演示功能：一开始的讨论中我们认为演示起码要有连续执行和单步执行，连续执行要能够在连续和暂停之间切换。而返回上一步的功能作为备选功能。\n3. 数组生成功能：系统应当支持随机生成和用户自定义数组。通过对数组进行分析，我们确定了两个用户可修改的属性：数组规模和具体的数组元素。\n\n此外，对于数据的表现形式，我们认为采用数字并不直观，以图形的形式表示更好，并且最好数字的相对大小能够反映到图形的相对大小上，由此我们直接采用了上文已有的可视化形式：用矩形+数字来表示一个数组元素，矩形的宽度固定而长度不定，根据数组内元素分布而动态变化。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo0.png)\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo1.png)\n\n### 模块划分与小组分工\n\n通过对演示系统进行分析、观察已有的算法演示系统，我们根据经验以及观察的结果，首先将系统划分成各个模块：窗口模块、图形元素及按钮的静态模块、算法演示模块、辅助模块（如记录日志、数组等）以及能够在图形元素上进行的操作模块。\n\n对于小组分工，起初我们的设想是由一个同学统一封装好图形操作并提供简单的接口，就是我们所学的 Facade 模式。但在讨论的过程中发现我们需要对很多操作进行约定，但这些约定是建立在有经验的基础上的，而对于我们这些初学者来说，开始时建立的约定很可能会不断变更，那么维护接口并根据接口调整程序就变得相当麻烦。此外，我们还需要那位封装接口的同学尽可能快地完成封装任务，才能确定其它模块实现的可行性。\n\n后来我们想到，团队分工其实是和软件的类设计以及职责分配是一样的，虽然提倡高内聚且低耦合，但一般很难同时达到这两点。为了项目开发进度着想，并且我们对项目的可维护性要求并不高，因此我们采用每个人完成一到两个算法演示部分的方法，每个人自行完成单步演示、连续播放、暂停以及重设数组等操作，至于每个操作具体如何实现则由实现的同学自行考虑。而最后我们仅需要将算法演示和主窗口结合起来即可。\n\n这样的分工虽然内聚性较低且重复性也比较高，但是每个人都能够参与算法完整演示的开发，每个人都能够学到东西，并且团队的耦合性也比较低，每个人能够较为独立地进行开发。这对我们目前的团队和任务来说是比较优的方法了。\n\n而要具体划分算法模块时，我们还遇到一个问题：算法的难度不同。\n\n对于三个基本排序（选择、插入、冒泡）以及快排，演示时涉及到的仅是块的颜色变换以及块的交换。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo2.png)\n\n对于归并排序，我们还需要块能够上下移动，以表明一个归并的过程：\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo3.png)\n\n对于堆排序，我们需要矩形以二叉树的形式进行演示，在这种情况下不需要矩形的长度随着数据大小进行变化。涉及到的演示过程主要为变色与矩形块的交换。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo4.png)\n\n对于基数排序，我们需要有基数槽。此外，矩形的操作除了变色外并不需要交换，但它需要方便地进行移动。\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo5.png)\n\n在将每个算法演示涉及到的操作列举出来之后，我们认为在难度方面： 三个基本排序+快排 < 归并 < 基数 ≈ 堆排，此外我们还需要绘制窗口、处理用户事件以及撰写过程文档。\n\n最终我们的分工如下：\n\n1. 一名同学负责窗口设计与绘制，并负责一个基本的排序算法\n2. 一名同学负责用户事件处理（点击、输入数据等事件）并做最后整合，且负责一个基本排序算法\n3. 一名同学作为文档负责人，并且负责一个基本排序算法\n4. 一名同学完成两个排序算法：归并与快排\n5. 两名同学分别完成两个较为困难的排序算法的演示：堆排序和基数排序\n\n我负责的为第二点，用户事件处理、最终整合以及选择排序的实现。\n\n### 选择排序演示的实现\n\n#### 1. 类设计与功能划分\n\n在学习Qt的基本操作以及了解了图形移动的实现方式之后，我就开始着手进行类的设计以及功能划分了。\n\nQt中静态的窗口及元素由QWidget完成，而涉及到矩形、圆形等的几何图形绘制及移动，就需要用到View 和 Scene了，在算法演示系统中，我们不仅需要矩形等几何图形，也同样需要QWidget的按钮等元素，由此我们利用scene的addWidget函数将Widget作为其中一个元素加入场景中。这样我们就能够专心在Widget中处理各种按钮及其它事件，在主类中生成矩形以及进行各种演示操作。\n\n了解到矩形移动需要使用定时器来控制移动时间和频率，为了提高类的内聚性以及提高通用性，我将各种计时器统一提取出来放到一个单例模式辅助类，在之后整合的时候，这个类还可以放入其它杂属性来保存一些全局信息。\n\n在大的框架上总共有三个类（不考虑排序算法的虚基类）：\n\n1.  排序算法主类，进行数组生成、记录生成及演示\n2.  Widget类，静态窗口类，用于放置各种静态按钮、文本输入框以及处理和它们相关的事件\n3.  辅助类Event，用来保存全局信息和各种计时器。\n\n而到了底层，我们还需要以下几个类作为框架类的属性并提供支持：\n\n1.  矩形类，使用了Qt允许的自定义的图像元素，方便根据需要生成变长矩形\n2.  图形元素类，封装了矩形类+数字文本类，并保存了这个图形元素对应的数组数字，是排序算法操作的基本单位。\n3.  记录类，描述单个记录需要保存哪些信息：记录的类型（变色或移动）、模式（变什么颜色或往哪里移动）、图形元素的索引（哪个图形要发生变化）。此外还有一个前驱指针和一个后继指针。\n4.  记录链表，使用双向链表保存一系列记录，包含首尾两个哨兵以及一个指向当前正在读取的记录的指针current。当中实现了些常用的双向链表的操作（清空、尾插入、判空等）。\n\n#### 2. 数组、记录生成及演示操作\n\n在数组的生成方面，为了方便用户使用，我们首先随机在规定范围内生成一个数组以供用户直接使用演示功能。而后，用户能够随时更改数组规模和具体的数组元素。数组生成共分为四大类情况：\n\n1.  用户未设置数组规模及具体数组元素，则系统随机生成数组。\n2.  用户设置了数组规模未设置具体元素，则系统根据规模生成随机数组。\n3.  用户仅设置了具体的数组元素但未设置规模，则系统原样根据元素生成数组。\n4.  用户同时设置了数组规模和元素（原则：以规模数为准）：\n   1.  元素数目和规模匹配：则系统原样生成。\n   2.  规模数大于元素数：系统补足剩余元素。\n   3.  规模数小于元素数：系统截取规模数以内的元素。\n\n每当数组生成之后，系统就会立刻根据排序算法生成记录列表，之后的演示就只是移动双向链表中的current指针依次读取记录并执行了。\n\n那么记录是如何生成的呢？在生成的函数内，实际上有个临时数组复制了生成的数组，而后对临时数组执行相应的排序算法，在算法执行的过程中在关键的部分创建记录并插入链表中。\n\n记录包含三个属性：type，attribute1，attribute2：\n\n1. type = 0 代表变色，此时attribute1表明变色的模式，attribute2表明要变色的矩形下标：\n   1. attribute1 = 0 将矩形变为正常颜色\n   2. attribute1 = 1 矩形此时被选中，变为选中模式的颜色，若前一个矩形不是最小的矩形，则将上一个矩形恢复未正常颜色\n   3. attribute1 = 2 矩形为当前最小，变为最小模式的颜色\n   4. attribute1 = 3 若矩形不是当前最小，则恢复为正常颜色\n2. type = 1 代表交换：attribute1和attribute2记录要交换位置的两个图形元素的索引。\n\n#### 3. 演示与定时器\n\n在演示部分，用户可以选择连续演示、暂停和单步演示。\n\n从上一次演示到下一次演示是通过设定计时器并等待计时器触发，执行相应触发函数完成的。\n\n演示模式分为播放和暂停，当前的演示模式通过辅助类的一个全局变量记录下来，每读取并执行完一条记录，则检查全局变量标签，若此时为播放模式，则开启下一轮计时器，当计时器达到设定值时系统开始读取并执行下一条记录，直到用户暂停或执行完最后一条记录。若此时为暂停模式，则不做任何操作，等待用户下一步操作。\n\n用户能够单击连续演示、暂停、下一步和重新开始按钮：\n\n1.  连续演示按钮实则将标签设置为播放，而后手动开启一次计时器\n2.  暂停按钮则将当前的计时器关闭，将标签设置为暂停\n3.  下一步按钮则将标签设置为暂停并手动开启一次定时器\n4.  重新开始按钮则会调用算法类实现的重设功能，我们将current指针一步步向前移动并根据恢复换位操作，最终将所有的矩形块变为正常颜色。\n\n对于动画演示至关重要的计时器在选择排序部分总共分为两个：\n\n1. 第一个全局计时器描述执行一条记录所需要的时间，这个时间视当前执行的记录的类型而定，反映到界面上就是每个变化之间的时间间隔，变色的时间间隔要比交换的时间间隔短得多。\n2. 第二个交换计时器描述交换一小步的时间，我们将一个完整的交换过程切成固定数目的段并用一个常量记录下来，而交换计时器每触发一次，就会将两个要交换位置的矩形稍微向对方位置移动一小点，同时更新一个临时计数器，一旦临时计数器达到先前提到的常量，则说明两个矩形到达目标位置了，那么就关闭交换计时器。\n\n### 用户事件处理及整合\n\n用户所能够进行的操作共分为三类：\n\n1.  设定数组\n2.  切换演示模式\n3.  切换算法\n\n前面介绍了前两类操作，而第三种分为两种情况：\n\n1.  用户当前在主界面，界面列出用户可选的算法，用户通过点击选择一个算法并进入演示界面\n\n   ![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png)\n\n2.  用户已经进入了某个算法的演示界面，想要直接切换到另外一个算法\n\n   ![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF11.png)\n\n对于整合，在开发的过程中，我就根据自己实现的选择排序算法类构造了一个虚基类并规定了几个必须要实现的接口，因此拿到其他成员实现的算法类我并不需要知道它们内部是怎么实现的，只需要用虚基类的指针指向对应的实例对象然后通过多态调用相应的函数即可。\n\n整合的方法总共尝试了三种，前两种均因不明情况而宣告失败，最后选用了最简单粗暴的方案三解决了。\n\n1. 方案一：全局使用一个view、scene和widget，每个算法的单例对象在创建后不删除。每当用户选择其它排序算法时，将当前算法类的图形元素一个个从场景中抹去，而后将虚基类指针指向新的算法类单例对象，完成初始化并调用重设函数。\n2. 方案二：全局使用一个view，算法的单例对象创建后不删除，scene和widget在每次切换都重新生成，需要调用算法的重设函数重新向scene中添加元素。\n3. 方案三：全局使用一个view，算法对象、scene和widget每次切换都重新生成。\n\n采用方案一、方案二实现的过程中，总会在切换时发生各样奇怪的bug。由此看来问题很可能出现在算法对象的重设以及和scene的交互上，进一步推测很可能出现在指针指向对象的存在性以及空间分配和回收上。鉴于项目时间紧迫，我们就没有再采用方案一或二深入纠正了。\n\n### 成果展示\n\n最终我们的系统成品如下，所有的交换过程均为实际动画。\n\n起始界面:\n\n![矩形](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png)\n\n冒泡排序算法的演示界面:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF1.png)\n\n块互换位置的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF2.png)\n\n块被选中及进行大小比较:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF3.png)\n\n归并的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF4.png)\n\n归并归位的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF5.png)\n\n堆排序建堆过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF6.png)\n\n堆排序构建有序数组过程(粉色代表已经有序)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF7.png)\n\n基数排序初始样式:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF8.png)\n\n基数排序取个位数选槽的过程:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF9.png)\n\n第一轮基数排序即将完成:\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF10.png)\n\n### 总结\n\n本次实训我的收获很大，收获分为以下几个方面：\n\n1. 团队合作开发软件的经历。作为组长不仅要考虑从需求转换到功能，更要根据需求的可实现性对需求进行挑选。此外还需要尽可能地合理划分模块并进行分工。在开发过程中需要时时确认开发进度，锁定开发中遇到的问题并组织讨论解决。在开始时有预想好分工，但后来想到，团队分工其实和类的设计是一样的，要尽可能提高内聚，降低耦合，尤其大家都没有开发经验，因此一开始约定的接口很可能变来变去，于是就直接划分算法让大家自行实现，最后直接整合。\n2. 第二自然是对Qt开发和使用有了了解，对于C++带界面的应用程序也总算有了接触。因为Qt极其庞大，功能奇多，之前也没有C++界面应用程序的开发经验，因此一开始总有种畏惧情绪。但后来实际接触下来，发现其实和java的fx差不多，尤其creator已经集成了很多很方便的功能，如界面设计直接拖控件即可等。并且Qt虽然功能很多，但我们仅需要其中的很少一部分，只要在用的时候查对应的部分即可，以往想要全部掌握再开工的学生思维很不适合这样的开发。\n3. 第三则是C++本身的使用了，大一过后除了实验课之外就很少再用C++进行开发了，java的面向对象更为直观，python方便快速易用，让我很少再使用C++。而这次综合实训让我重新把c++捡起来并且再度体会到它的博大精深，有相当多玄妙而精巧的设计，难怪其难度远远在其它语言之上，尤其在开发过程中我们大量使用指针，在debug过程中也相当艰辛。\n\n这次实训让我收获匪浅，不仅认识到自己的不足，开拓了自己的眼界，掌握了新的知识，还实际进行了团队开发。以往自己个人开发时不需要考虑太多代码和接口的易读性，以及界面的易用性等，但团队开发时这些都非常重要。我的团队意识也有了非常大的提高。\n\n### 源代码\n\n整个项目的源代码可以在[我的github](https://github.com/zedom1/Class_Project/tree/master/Sorting%20Algorithm)看到。\n","slug":"sorting algorithm","published":1,"updated":"2018-07-14T13:21:28.523Z","photos":[],"link":"","_id":"cjleshqjs000vryfcbakvocg3","content":"<p>2018年 6月4日 - 7月5日 间， 我们进行了为其一个月的软件开发综合实训。 在实训中我们以5-6人的小组为单位进行团队开发，使用c++最终完成基于Qt的排序算法演示系统。在这一个月中，我担任小组的组长，和团队成员一起学习Qt、学习团队开发、进行需求分析、功能设计、系统模块设计，并到后来的编码实现及测试。通过这次实训我收获颇多，在此将整个实训过程梳理并小结一番。</p>\n<a id=\"more\"></a>\n<h3 id=\"题目背景与需求分析\"><a href=\"#题目背景与需求分析\" class=\"headerlink\" title=\"题目背景与需求分析\"></a>题目背景与需求分析</h3><p>限定语言为C++，可选题目为：线性表、堆栈、队列、树、图5个基本结构（或基本排序算法-插入、冒泡、选择、快速、堆排序、归并、基数排序）的算法演示系统。</p>\n<p>经过小组讨论，我们选择排序算法演示系统。</p>\n<p>而后，我们查找了当前已有的排序算法演示系统，并以 <a href=\"https://visualgo.net/zh\" target=\"_blank\" rel=\"noopener\">这个算法可视化网站</a> 作为参考。 通过实际使用已有的算法可视化系统，我们将要实现的功能分为三类：</p>\n<ol>\n<li>算法功能：系统所支持的排序算法，以题目给出的七种排序算法为准。</li>\n<li>演示功能：一开始的讨论中我们认为演示起码要有连续执行和单步执行，连续执行要能够在连续和暂停之间切换。而返回上一步的功能作为备选功能。</li>\n<li>数组生成功能：系统应当支持随机生成和用户自定义数组。通过对数组进行分析，我们确定了两个用户可修改的属性：数组规模和具体的数组元素。</li>\n</ol>\n<p>此外，对于数据的表现形式，我们认为采用数字并不直观，以图形的形式表示更好，并且最好数字的相对大小能够反映到图形的相对大小上，由此我们直接采用了上文已有的可视化形式：用矩形+数字来表示一个数组元素，矩形的宽度固定而长度不定，根据数组内元素分布而动态变化。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo0.png\" alt=\"矩形\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo1.png\" alt=\"矩形\"></p>\n<h3 id=\"模块划分与小组分工\"><a href=\"#模块划分与小组分工\" class=\"headerlink\" title=\"模块划分与小组分工\"></a>模块划分与小组分工</h3><p>通过对演示系统进行分析、观察已有的算法演示系统，我们根据经验以及观察的结果，首先将系统划分成各个模块：窗口模块、图形元素及按钮的静态模块、算法演示模块、辅助模块（如记录日志、数组等）以及能够在图形元素上进行的操作模块。</p>\n<p>对于小组分工，起初我们的设想是由一个同学统一封装好图形操作并提供简单的接口，就是我们所学的 Facade 模式。但在讨论的过程中发现我们需要对很多操作进行约定，但这些约定是建立在有经验的基础上的，而对于我们这些初学者来说，开始时建立的约定很可能会不断变更，那么维护接口并根据接口调整程序就变得相当麻烦。此外，我们还需要那位封装接口的同学尽可能快地完成封装任务，才能确定其它模块实现的可行性。</p>\n<p>后来我们想到，团队分工其实是和软件的类设计以及职责分配是一样的，虽然提倡高内聚且低耦合，但一般很难同时达到这两点。为了项目开发进度着想，并且我们对项目的可维护性要求并不高，因此我们采用每个人完成一到两个算法演示部分的方法，每个人自行完成单步演示、连续播放、暂停以及重设数组等操作，至于每个操作具体如何实现则由实现的同学自行考虑。而最后我们仅需要将算法演示和主窗口结合起来即可。</p>\n<p>这样的分工虽然内聚性较低且重复性也比较高，但是每个人都能够参与算法完整演示的开发，每个人都能够学到东西，并且团队的耦合性也比较低，每个人能够较为独立地进行开发。这对我们目前的团队和任务来说是比较优的方法了。</p>\n<p>而要具体划分算法模块时，我们还遇到一个问题：算法的难度不同。</p>\n<p>对于三个基本排序（选择、插入、冒泡）以及快排，演示时涉及到的仅是块的颜色变换以及块的交换。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo2.png\" alt=\"矩形\"></p>\n<p>对于归并排序，我们还需要块能够上下移动，以表明一个归并的过程：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo3.png\" alt=\"矩形\"></p>\n<p>对于堆排序，我们需要矩形以二叉树的形式进行演示，在这种情况下不需要矩形的长度随着数据大小进行变化。涉及到的演示过程主要为变色与矩形块的交换。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo4.png\" alt=\"矩形\"></p>\n<p>对于基数排序，我们需要有基数槽。此外，矩形的操作除了变色外并不需要交换，但它需要方便地进行移动。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo5.png\" alt=\"矩形\"></p>\n<p>在将每个算法演示涉及到的操作列举出来之后，我们认为在难度方面： 三个基本排序+快排 &lt; 归并 &lt; 基数 ≈ 堆排，此外我们还需要绘制窗口、处理用户事件以及撰写过程文档。</p>\n<p>最终我们的分工如下：</p>\n<ol>\n<li>一名同学负责窗口设计与绘制，并负责一个基本的排序算法</li>\n<li>一名同学负责用户事件处理（点击、输入数据等事件）并做最后整合，且负责一个基本排序算法</li>\n<li>一名同学作为文档负责人，并且负责一个基本排序算法</li>\n<li>一名同学完成两个排序算法：归并与快排</li>\n<li>两名同学分别完成两个较为困难的排序算法的演示：堆排序和基数排序</li>\n</ol>\n<p>我负责的为第二点，用户事件处理、最终整合以及选择排序的实现。</p>\n<h3 id=\"选择排序演示的实现\"><a href=\"#选择排序演示的实现\" class=\"headerlink\" title=\"选择排序演示的实现\"></a>选择排序演示的实现</h3><h4 id=\"1-类设计与功能划分\"><a href=\"#1-类设计与功能划分\" class=\"headerlink\" title=\"1. 类设计与功能划分\"></a>1. 类设计与功能划分</h4><p>在学习Qt的基本操作以及了解了图形移动的实现方式之后，我就开始着手进行类的设计以及功能划分了。</p>\n<p>Qt中静态的窗口及元素由QWidget完成，而涉及到矩形、圆形等的几何图形绘制及移动，就需要用到View 和 Scene了，在算法演示系统中，我们不仅需要矩形等几何图形，也同样需要QWidget的按钮等元素，由此我们利用scene的addWidget函数将Widget作为其中一个元素加入场景中。这样我们就能够专心在Widget中处理各种按钮及其它事件，在主类中生成矩形以及进行各种演示操作。</p>\n<p>了解到矩形移动需要使用定时器来控制移动时间和频率，为了提高类的内聚性以及提高通用性，我将各种计时器统一提取出来放到一个单例模式辅助类，在之后整合的时候，这个类还可以放入其它杂属性来保存一些全局信息。</p>\n<p>在大的框架上总共有三个类（不考虑排序算法的虚基类）：</p>\n<ol>\n<li>排序算法主类，进行数组生成、记录生成及演示</li>\n<li>Widget类，静态窗口类，用于放置各种静态按钮、文本输入框以及处理和它们相关的事件</li>\n<li>辅助类Event，用来保存全局信息和各种计时器。</li>\n</ol>\n<p>而到了底层，我们还需要以下几个类作为框架类的属性并提供支持：</p>\n<ol>\n<li>矩形类，使用了Qt允许的自定义的图像元素，方便根据需要生成变长矩形</li>\n<li>图形元素类，封装了矩形类+数字文本类，并保存了这个图形元素对应的数组数字，是排序算法操作的基本单位。</li>\n<li>记录类，描述单个记录需要保存哪些信息：记录的类型（变色或移动）、模式（变什么颜色或往哪里移动）、图形元素的索引（哪个图形要发生变化）。此外还有一个前驱指针和一个后继指针。</li>\n<li>记录链表，使用双向链表保存一系列记录，包含首尾两个哨兵以及一个指向当前正在读取的记录的指针current。当中实现了些常用的双向链表的操作（清空、尾插入、判空等）。</li>\n</ol>\n<h4 id=\"2-数组、记录生成及演示操作\"><a href=\"#2-数组、记录生成及演示操作\" class=\"headerlink\" title=\"2. 数组、记录生成及演示操作\"></a>2. 数组、记录生成及演示操作</h4><p>在数组的生成方面，为了方便用户使用，我们首先随机在规定范围内生成一个数组以供用户直接使用演示功能。而后，用户能够随时更改数组规模和具体的数组元素。数组生成共分为四大类情况：</p>\n<ol>\n<li>用户未设置数组规模及具体数组元素，则系统随机生成数组。</li>\n<li>用户设置了数组规模未设置具体元素，则系统根据规模生成随机数组。</li>\n<li>用户仅设置了具体的数组元素但未设置规模，则系统原样根据元素生成数组。</li>\n<li>用户同时设置了数组规模和元素（原则：以规模数为准）：<ol>\n<li>元素数目和规模匹配：则系统原样生成。</li>\n<li>规模数大于元素数：系统补足剩余元素。</li>\n<li>规模数小于元素数：系统截取规模数以内的元素。</li>\n</ol>\n</li>\n</ol>\n<p>每当数组生成之后，系统就会立刻根据排序算法生成记录列表，之后的演示就只是移动双向链表中的current指针依次读取记录并执行了。</p>\n<p>那么记录是如何生成的呢？在生成的函数内，实际上有个临时数组复制了生成的数组，而后对临时数组执行相应的排序算法，在算法执行的过程中在关键的部分创建记录并插入链表中。</p>\n<p>记录包含三个属性：type，attribute1，attribute2：</p>\n<ol>\n<li>type = 0 代表变色，此时attribute1表明变色的模式，attribute2表明要变色的矩形下标：<ol>\n<li>attribute1 = 0 将矩形变为正常颜色</li>\n<li>attribute1 = 1 矩形此时被选中，变为选中模式的颜色，若前一个矩形不是最小的矩形，则将上一个矩形恢复未正常颜色</li>\n<li>attribute1 = 2 矩形为当前最小，变为最小模式的颜色</li>\n<li>attribute1 = 3 若矩形不是当前最小，则恢复为正常颜色</li>\n</ol>\n</li>\n<li>type = 1 代表交换：attribute1和attribute2记录要交换位置的两个图形元素的索引。</li>\n</ol>\n<h4 id=\"3-演示与定时器\"><a href=\"#3-演示与定时器\" class=\"headerlink\" title=\"3. 演示与定时器\"></a>3. 演示与定时器</h4><p>在演示部分，用户可以选择连续演示、暂停和单步演示。</p>\n<p>从上一次演示到下一次演示是通过设定计时器并等待计时器触发，执行相应触发函数完成的。</p>\n<p>演示模式分为播放和暂停，当前的演示模式通过辅助类的一个全局变量记录下来，每读取并执行完一条记录，则检查全局变量标签，若此时为播放模式，则开启下一轮计时器，当计时器达到设定值时系统开始读取并执行下一条记录，直到用户暂停或执行完最后一条记录。若此时为暂停模式，则不做任何操作，等待用户下一步操作。</p>\n<p>用户能够单击连续演示、暂停、下一步和重新开始按钮：</p>\n<ol>\n<li>连续演示按钮实则将标签设置为播放，而后手动开启一次计时器</li>\n<li>暂停按钮则将当前的计时器关闭，将标签设置为暂停</li>\n<li>下一步按钮则将标签设置为暂停并手动开启一次定时器</li>\n<li>重新开始按钮则会调用算法类实现的重设功能，我们将current指针一步步向前移动并根据恢复换位操作，最终将所有的矩形块变为正常颜色。</li>\n</ol>\n<p>对于动画演示至关重要的计时器在选择排序部分总共分为两个：</p>\n<ol>\n<li>第一个全局计时器描述执行一条记录所需要的时间，这个时间视当前执行的记录的类型而定，反映到界面上就是每个变化之间的时间间隔，变色的时间间隔要比交换的时间间隔短得多。</li>\n<li>第二个交换计时器描述交换一小步的时间，我们将一个完整的交换过程切成固定数目的段并用一个常量记录下来，而交换计时器每触发一次，就会将两个要交换位置的矩形稍微向对方位置移动一小点，同时更新一个临时计数器，一旦临时计数器达到先前提到的常量，则说明两个矩形到达目标位置了，那么就关闭交换计时器。</li>\n</ol>\n<h3 id=\"用户事件处理及整合\"><a href=\"#用户事件处理及整合\" class=\"headerlink\" title=\"用户事件处理及整合\"></a>用户事件处理及整合</h3><p>用户所能够进行的操作共分为三类：</p>\n<ol>\n<li>设定数组</li>\n<li>切换演示模式</li>\n<li>切换算法</li>\n</ol>\n<p>前面介绍了前两类操作，而第三种分为两种情况：</p>\n<ol>\n<li><p>用户当前在主界面，界面列出用户可选的算法，用户通过点击选择一个算法并进入演示界面</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png\" alt=\"\"></p>\n</li>\n<li><p>用户已经进入了某个算法的演示界面，想要直接切换到另外一个算法</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF11.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>对于整合，在开发的过程中，我就根据自己实现的选择排序算法类构造了一个虚基类并规定了几个必须要实现的接口，因此拿到其他成员实现的算法类我并不需要知道它们内部是怎么实现的，只需要用虚基类的指针指向对应的实例对象然后通过多态调用相应的函数即可。</p>\n<p>整合的方法总共尝试了三种，前两种均因不明情况而宣告失败，最后选用了最简单粗暴的方案三解决了。</p>\n<ol>\n<li>方案一：全局使用一个view、scene和widget，每个算法的单例对象在创建后不删除。每当用户选择其它排序算法时，将当前算法类的图形元素一个个从场景中抹去，而后将虚基类指针指向新的算法类单例对象，完成初始化并调用重设函数。</li>\n<li>方案二：全局使用一个view，算法的单例对象创建后不删除，scene和widget在每次切换都重新生成，需要调用算法的重设函数重新向scene中添加元素。</li>\n<li>方案三：全局使用一个view，算法对象、scene和widget每次切换都重新生成。</li>\n</ol>\n<p>采用方案一、方案二实现的过程中，总会在切换时发生各样奇怪的bug。由此看来问题很可能出现在算法对象的重设以及和scene的交互上，进一步推测很可能出现在指针指向对象的存在性以及空间分配和回收上。鉴于项目时间紧迫，我们就没有再采用方案一或二深入纠正了。</p>\n<h3 id=\"成果展示\"><a href=\"#成果展示\" class=\"headerlink\" title=\"成果展示\"></a>成果展示</h3><p>最终我们的系统成品如下，所有的交换过程均为实际动画。</p>\n<p>起始界面:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png\" alt=\"矩形\"></p>\n<p>冒泡排序算法的演示界面:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF1.png\" alt=\"\"></p>\n<p>块互换位置的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF2.png\" alt=\"\"></p>\n<p>块被选中及进行大小比较:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF3.png\" alt=\"\"></p>\n<p>归并的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF4.png\" alt=\"\"></p>\n<p>归并归位的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF5.png\" alt=\"\"></p>\n<p>堆排序建堆过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF6.png\" alt=\"\"></p>\n<p>堆排序构建有序数组过程(粉色代表已经有序)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF7.png\" alt=\"\"></p>\n<p>基数排序初始样式:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF8.png\" alt=\"\"></p>\n<p>基数排序取个位数选槽的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF9.png\" alt=\"\"></p>\n<p>第一轮基数排序即将完成:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF10.png\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本次实训我的收获很大，收获分为以下几个方面：</p>\n<ol>\n<li>团队合作开发软件的经历。作为组长不仅要考虑从需求转换到功能，更要根据需求的可实现性对需求进行挑选。此外还需要尽可能地合理划分模块并进行分工。在开发过程中需要时时确认开发进度，锁定开发中遇到的问题并组织讨论解决。在开始时有预想好分工，但后来想到，团队分工其实和类的设计是一样的，要尽可能提高内聚，降低耦合，尤其大家都没有开发经验，因此一开始约定的接口很可能变来变去，于是就直接划分算法让大家自行实现，最后直接整合。</li>\n<li>第二自然是对Qt开发和使用有了了解，对于C++带界面的应用程序也总算有了接触。因为Qt极其庞大，功能奇多，之前也没有C++界面应用程序的开发经验，因此一开始总有种畏惧情绪。但后来实际接触下来，发现其实和java的fx差不多，尤其creator已经集成了很多很方便的功能，如界面设计直接拖控件即可等。并且Qt虽然功能很多，但我们仅需要其中的很少一部分，只要在用的时候查对应的部分即可，以往想要全部掌握再开工的学生思维很不适合这样的开发。</li>\n<li>第三则是C++本身的使用了，大一过后除了实验课之外就很少再用C++进行开发了，java的面向对象更为直观，python方便快速易用，让我很少再使用C++。而这次综合实训让我重新把c++捡起来并且再度体会到它的博大精深，有相当多玄妙而精巧的设计，难怪其难度远远在其它语言之上，尤其在开发过程中我们大量使用指针，在debug过程中也相当艰辛。</li>\n</ol>\n<p>这次实训让我收获匪浅，不仅认识到自己的不足，开拓了自己的眼界，掌握了新的知识，还实际进行了团队开发。以往自己个人开发时不需要考虑太多代码和接口的易读性，以及界面的易用性等，但团队开发时这些都非常重要。我的团队意识也有了非常大的提高。</p>\n<h3 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h3><p>整个项目的源代码可以在<a href=\"https://github.com/zedom1/Class_Project/tree/master/Sorting%20Algorithm\" target=\"_blank\" rel=\"noopener\">我的github</a>看到。</p>\n","site":{"data":{}},"excerpt":"<p>2018年 6月4日 - 7月5日 间， 我们进行了为其一个月的软件开发综合实训。 在实训中我们以5-6人的小组为单位进行团队开发，使用c++最终完成基于Qt的排序算法演示系统。在这一个月中，我担任小组的组长，和团队成员一起学习Qt、学习团队开发、进行需求分析、功能设计、系统模块设计，并到后来的编码实现及测试。通过这次实训我收获颇多，在此将整个实训过程梳理并小结一番。</p>","more":"<h3 id=\"题目背景与需求分析\"><a href=\"#题目背景与需求分析\" class=\"headerlink\" title=\"题目背景与需求分析\"></a>题目背景与需求分析</h3><p>限定语言为C++，可选题目为：线性表、堆栈、队列、树、图5个基本结构（或基本排序算法-插入、冒泡、选择、快速、堆排序、归并、基数排序）的算法演示系统。</p>\n<p>经过小组讨论，我们选择排序算法演示系统。</p>\n<p>而后，我们查找了当前已有的排序算法演示系统，并以 <a href=\"https://visualgo.net/zh\" target=\"_blank\" rel=\"noopener\">这个算法可视化网站</a> 作为参考。 通过实际使用已有的算法可视化系统，我们将要实现的功能分为三类：</p>\n<ol>\n<li>算法功能：系统所支持的排序算法，以题目给出的七种排序算法为准。</li>\n<li>演示功能：一开始的讨论中我们认为演示起码要有连续执行和单步执行，连续执行要能够在连续和暂停之间切换。而返回上一步的功能作为备选功能。</li>\n<li>数组生成功能：系统应当支持随机生成和用户自定义数组。通过对数组进行分析，我们确定了两个用户可修改的属性：数组规模和具体的数组元素。</li>\n</ol>\n<p>此外，对于数据的表现形式，我们认为采用数字并不直观，以图形的形式表示更好，并且最好数字的相对大小能够反映到图形的相对大小上，由此我们直接采用了上文已有的可视化形式：用矩形+数字来表示一个数组元素，矩形的宽度固定而长度不定，根据数组内元素分布而动态变化。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo0.png\" alt=\"矩形\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo1.png\" alt=\"矩形\"></p>\n<h3 id=\"模块划分与小组分工\"><a href=\"#模块划分与小组分工\" class=\"headerlink\" title=\"模块划分与小组分工\"></a>模块划分与小组分工</h3><p>通过对演示系统进行分析、观察已有的算法演示系统，我们根据经验以及观察的结果，首先将系统划分成各个模块：窗口模块、图形元素及按钮的静态模块、算法演示模块、辅助模块（如记录日志、数组等）以及能够在图形元素上进行的操作模块。</p>\n<p>对于小组分工，起初我们的设想是由一个同学统一封装好图形操作并提供简单的接口，就是我们所学的 Facade 模式。但在讨论的过程中发现我们需要对很多操作进行约定，但这些约定是建立在有经验的基础上的，而对于我们这些初学者来说，开始时建立的约定很可能会不断变更，那么维护接口并根据接口调整程序就变得相当麻烦。此外，我们还需要那位封装接口的同学尽可能快地完成封装任务，才能确定其它模块实现的可行性。</p>\n<p>后来我们想到，团队分工其实是和软件的类设计以及职责分配是一样的，虽然提倡高内聚且低耦合，但一般很难同时达到这两点。为了项目开发进度着想，并且我们对项目的可维护性要求并不高，因此我们采用每个人完成一到两个算法演示部分的方法，每个人自行完成单步演示、连续播放、暂停以及重设数组等操作，至于每个操作具体如何实现则由实现的同学自行考虑。而最后我们仅需要将算法演示和主窗口结合起来即可。</p>\n<p>这样的分工虽然内聚性较低且重复性也比较高，但是每个人都能够参与算法完整演示的开发，每个人都能够学到东西，并且团队的耦合性也比较低，每个人能够较为独立地进行开发。这对我们目前的团队和任务来说是比较优的方法了。</p>\n<p>而要具体划分算法模块时，我们还遇到一个问题：算法的难度不同。</p>\n<p>对于三个基本排序（选择、插入、冒泡）以及快排，演示时涉及到的仅是块的颜色变换以及块的交换。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo2.png\" alt=\"矩形\"></p>\n<p>对于归并排序，我们还需要块能够上下移动，以表明一个归并的过程：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo3.png\" alt=\"矩形\"></p>\n<p>对于堆排序，我们需要矩形以二叉树的形式进行演示，在这种情况下不需要矩形的长度随着数据大小进行变化。涉及到的演示过程主要为变色与矩形块的交换。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo4.png\" alt=\"矩形\"></p>\n<p>对于基数排序，我们需要有基数槽。此外，矩形的操作除了变色外并不需要交换，但它需要方便地进行移动。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgo5.png\" alt=\"矩形\"></p>\n<p>在将每个算法演示涉及到的操作列举出来之后，我们认为在难度方面： 三个基本排序+快排 &lt; 归并 &lt; 基数 ≈ 堆排，此外我们还需要绘制窗口、处理用户事件以及撰写过程文档。</p>\n<p>最终我们的分工如下：</p>\n<ol>\n<li>一名同学负责窗口设计与绘制，并负责一个基本的排序算法</li>\n<li>一名同学负责用户事件处理（点击、输入数据等事件）并做最后整合，且负责一个基本排序算法</li>\n<li>一名同学作为文档负责人，并且负责一个基本排序算法</li>\n<li>一名同学完成两个排序算法：归并与快排</li>\n<li>两名同学分别完成两个较为困难的排序算法的演示：堆排序和基数排序</li>\n</ol>\n<p>我负责的为第二点，用户事件处理、最终整合以及选择排序的实现。</p>\n<h3 id=\"选择排序演示的实现\"><a href=\"#选择排序演示的实现\" class=\"headerlink\" title=\"选择排序演示的实现\"></a>选择排序演示的实现</h3><h4 id=\"1-类设计与功能划分\"><a href=\"#1-类设计与功能划分\" class=\"headerlink\" title=\"1. 类设计与功能划分\"></a>1. 类设计与功能划分</h4><p>在学习Qt的基本操作以及了解了图形移动的实现方式之后，我就开始着手进行类的设计以及功能划分了。</p>\n<p>Qt中静态的窗口及元素由QWidget完成，而涉及到矩形、圆形等的几何图形绘制及移动，就需要用到View 和 Scene了，在算法演示系统中，我们不仅需要矩形等几何图形，也同样需要QWidget的按钮等元素，由此我们利用scene的addWidget函数将Widget作为其中一个元素加入场景中。这样我们就能够专心在Widget中处理各种按钮及其它事件，在主类中生成矩形以及进行各种演示操作。</p>\n<p>了解到矩形移动需要使用定时器来控制移动时间和频率，为了提高类的内聚性以及提高通用性，我将各种计时器统一提取出来放到一个单例模式辅助类，在之后整合的时候，这个类还可以放入其它杂属性来保存一些全局信息。</p>\n<p>在大的框架上总共有三个类（不考虑排序算法的虚基类）：</p>\n<ol>\n<li>排序算法主类，进行数组生成、记录生成及演示</li>\n<li>Widget类，静态窗口类，用于放置各种静态按钮、文本输入框以及处理和它们相关的事件</li>\n<li>辅助类Event，用来保存全局信息和各种计时器。</li>\n</ol>\n<p>而到了底层，我们还需要以下几个类作为框架类的属性并提供支持：</p>\n<ol>\n<li>矩形类，使用了Qt允许的自定义的图像元素，方便根据需要生成变长矩形</li>\n<li>图形元素类，封装了矩形类+数字文本类，并保存了这个图形元素对应的数组数字，是排序算法操作的基本单位。</li>\n<li>记录类，描述单个记录需要保存哪些信息：记录的类型（变色或移动）、模式（变什么颜色或往哪里移动）、图形元素的索引（哪个图形要发生变化）。此外还有一个前驱指针和一个后继指针。</li>\n<li>记录链表，使用双向链表保存一系列记录，包含首尾两个哨兵以及一个指向当前正在读取的记录的指针current。当中实现了些常用的双向链表的操作（清空、尾插入、判空等）。</li>\n</ol>\n<h4 id=\"2-数组、记录生成及演示操作\"><a href=\"#2-数组、记录生成及演示操作\" class=\"headerlink\" title=\"2. 数组、记录生成及演示操作\"></a>2. 数组、记录生成及演示操作</h4><p>在数组的生成方面，为了方便用户使用，我们首先随机在规定范围内生成一个数组以供用户直接使用演示功能。而后，用户能够随时更改数组规模和具体的数组元素。数组生成共分为四大类情况：</p>\n<ol>\n<li>用户未设置数组规模及具体数组元素，则系统随机生成数组。</li>\n<li>用户设置了数组规模未设置具体元素，则系统根据规模生成随机数组。</li>\n<li>用户仅设置了具体的数组元素但未设置规模，则系统原样根据元素生成数组。</li>\n<li>用户同时设置了数组规模和元素（原则：以规模数为准）：<ol>\n<li>元素数目和规模匹配：则系统原样生成。</li>\n<li>规模数大于元素数：系统补足剩余元素。</li>\n<li>规模数小于元素数：系统截取规模数以内的元素。</li>\n</ol>\n</li>\n</ol>\n<p>每当数组生成之后，系统就会立刻根据排序算法生成记录列表，之后的演示就只是移动双向链表中的current指针依次读取记录并执行了。</p>\n<p>那么记录是如何生成的呢？在生成的函数内，实际上有个临时数组复制了生成的数组，而后对临时数组执行相应的排序算法，在算法执行的过程中在关键的部分创建记录并插入链表中。</p>\n<p>记录包含三个属性：type，attribute1，attribute2：</p>\n<ol>\n<li>type = 0 代表变色，此时attribute1表明变色的模式，attribute2表明要变色的矩形下标：<ol>\n<li>attribute1 = 0 将矩形变为正常颜色</li>\n<li>attribute1 = 1 矩形此时被选中，变为选中模式的颜色，若前一个矩形不是最小的矩形，则将上一个矩形恢复未正常颜色</li>\n<li>attribute1 = 2 矩形为当前最小，变为最小模式的颜色</li>\n<li>attribute1 = 3 若矩形不是当前最小，则恢复为正常颜色</li>\n</ol>\n</li>\n<li>type = 1 代表交换：attribute1和attribute2记录要交换位置的两个图形元素的索引。</li>\n</ol>\n<h4 id=\"3-演示与定时器\"><a href=\"#3-演示与定时器\" class=\"headerlink\" title=\"3. 演示与定时器\"></a>3. 演示与定时器</h4><p>在演示部分，用户可以选择连续演示、暂停和单步演示。</p>\n<p>从上一次演示到下一次演示是通过设定计时器并等待计时器触发，执行相应触发函数完成的。</p>\n<p>演示模式分为播放和暂停，当前的演示模式通过辅助类的一个全局变量记录下来，每读取并执行完一条记录，则检查全局变量标签，若此时为播放模式，则开启下一轮计时器，当计时器达到设定值时系统开始读取并执行下一条记录，直到用户暂停或执行完最后一条记录。若此时为暂停模式，则不做任何操作，等待用户下一步操作。</p>\n<p>用户能够单击连续演示、暂停、下一步和重新开始按钮：</p>\n<ol>\n<li>连续演示按钮实则将标签设置为播放，而后手动开启一次计时器</li>\n<li>暂停按钮则将当前的计时器关闭，将标签设置为暂停</li>\n<li>下一步按钮则将标签设置为暂停并手动开启一次定时器</li>\n<li>重新开始按钮则会调用算法类实现的重设功能，我们将current指针一步步向前移动并根据恢复换位操作，最终将所有的矩形块变为正常颜色。</li>\n</ol>\n<p>对于动画演示至关重要的计时器在选择排序部分总共分为两个：</p>\n<ol>\n<li>第一个全局计时器描述执行一条记录所需要的时间，这个时间视当前执行的记录的类型而定，反映到界面上就是每个变化之间的时间间隔，变色的时间间隔要比交换的时间间隔短得多。</li>\n<li>第二个交换计时器描述交换一小步的时间，我们将一个完整的交换过程切成固定数目的段并用一个常量记录下来，而交换计时器每触发一次，就会将两个要交换位置的矩形稍微向对方位置移动一小点，同时更新一个临时计数器，一旦临时计数器达到先前提到的常量，则说明两个矩形到达目标位置了，那么就关闭交换计时器。</li>\n</ol>\n<h3 id=\"用户事件处理及整合\"><a href=\"#用户事件处理及整合\" class=\"headerlink\" title=\"用户事件处理及整合\"></a>用户事件处理及整合</h3><p>用户所能够进行的操作共分为三类：</p>\n<ol>\n<li>设定数组</li>\n<li>切换演示模式</li>\n<li>切换算法</li>\n</ol>\n<p>前面介绍了前两类操作，而第三种分为两种情况：</p>\n<ol>\n<li><p>用户当前在主界面，界面列出用户可选的算法，用户通过点击选择一个算法并进入演示界面</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png\" alt=\"\"></p>\n</li>\n<li><p>用户已经进入了某个算法的演示界面，想要直接切换到另外一个算法</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF11.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>对于整合，在开发的过程中，我就根据自己实现的选择排序算法类构造了一个虚基类并规定了几个必须要实现的接口，因此拿到其他成员实现的算法类我并不需要知道它们内部是怎么实现的，只需要用虚基类的指针指向对应的实例对象然后通过多态调用相应的函数即可。</p>\n<p>整合的方法总共尝试了三种，前两种均因不明情况而宣告失败，最后选用了最简单粗暴的方案三解决了。</p>\n<ol>\n<li>方案一：全局使用一个view、scene和widget，每个算法的单例对象在创建后不删除。每当用户选择其它排序算法时，将当前算法类的图形元素一个个从场景中抹去，而后将虚基类指针指向新的算法类单例对象，完成初始化并调用重设函数。</li>\n<li>方案二：全局使用一个view，算法的单例对象创建后不删除，scene和widget在每次切换都重新生成，需要调用算法的重设函数重新向scene中添加元素。</li>\n<li>方案三：全局使用一个view，算法对象、scene和widget每次切换都重新生成。</li>\n</ol>\n<p>采用方案一、方案二实现的过程中，总会在切换时发生各样奇怪的bug。由此看来问题很可能出现在算法对象的重设以及和scene的交互上，进一步推测很可能出现在指针指向对象的存在性以及空间分配和回收上。鉴于项目时间紧迫，我们就没有再采用方案一或二深入纠正了。</p>\n<h3 id=\"成果展示\"><a href=\"#成果展示\" class=\"headerlink\" title=\"成果展示\"></a>成果展示</h3><p>最终我们的系统成品如下，所有的交换过程均为实际动画。</p>\n<p>起始界面:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF0.png\" alt=\"矩形\"></p>\n<p>冒泡排序算法的演示界面:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF1.png\" alt=\"\"></p>\n<p>块互换位置的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF2.png\" alt=\"\"></p>\n<p>块被选中及进行大小比较:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF3.png\" alt=\"\"></p>\n<p>归并的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF4.png\" alt=\"\"></p>\n<p>归并归位的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF5.png\" alt=\"\"></p>\n<p>堆排序建堆过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF6.png\" alt=\"\"></p>\n<p>堆排序构建有序数组过程(粉色代表已经有序)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF7.png\" alt=\"\"></p>\n<p>基数排序初始样式:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF8.png\" alt=\"\"></p>\n<p>基数排序取个位数选槽的过程:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF9.png\" alt=\"\"></p>\n<p>第一轮基数排序即将完成:</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sortingAlgF10.png\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本次实训我的收获很大，收获分为以下几个方面：</p>\n<ol>\n<li>团队合作开发软件的经历。作为组长不仅要考虑从需求转换到功能，更要根据需求的可实现性对需求进行挑选。此外还需要尽可能地合理划分模块并进行分工。在开发过程中需要时时确认开发进度，锁定开发中遇到的问题并组织讨论解决。在开始时有预想好分工，但后来想到，团队分工其实和类的设计是一样的，要尽可能提高内聚，降低耦合，尤其大家都没有开发经验，因此一开始约定的接口很可能变来变去，于是就直接划分算法让大家自行实现，最后直接整合。</li>\n<li>第二自然是对Qt开发和使用有了了解，对于C++带界面的应用程序也总算有了接触。因为Qt极其庞大，功能奇多，之前也没有C++界面应用程序的开发经验，因此一开始总有种畏惧情绪。但后来实际接触下来，发现其实和java的fx差不多，尤其creator已经集成了很多很方便的功能，如界面设计直接拖控件即可等。并且Qt虽然功能很多，但我们仅需要其中的很少一部分，只要在用的时候查对应的部分即可，以往想要全部掌握再开工的学生思维很不适合这样的开发。</li>\n<li>第三则是C++本身的使用了，大一过后除了实验课之外就很少再用C++进行开发了，java的面向对象更为直观，python方便快速易用，让我很少再使用C++。而这次综合实训让我重新把c++捡起来并且再度体会到它的博大精深，有相当多玄妙而精巧的设计，难怪其难度远远在其它语言之上，尤其在开发过程中我们大量使用指针，在debug过程中也相当艰辛。</li>\n</ol>\n<p>这次实训让我收获匪浅，不仅认识到自己的不足，开拓了自己的眼界，掌握了新的知识，还实际进行了团队开发。以往自己个人开发时不需要考虑太多代码和接口的易读性，以及界面的易用性等，但团队开发时这些都非常重要。我的团队意识也有了非常大的提高。</p>\n<h3 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h3><p>整个项目的源代码可以在<a href=\"https://github.com/zedom1/Class_Project/tree/master/Sorting%20Algorithm\" target=\"_blank\" rel=\"noopener\">我的github</a>看到。</p>"},{"layout":"post","title":"拼音型简单错误语料获取与处理","date":"2018-08-27T16:00:00.000Z","comments":1,"_content":"\n在自然语言处理领域中，语料是非常关键的一个部分。然而，中文的自然语言处理领域在大的通用型语料上虽然不少，但在特定方向上的语料仍然匮乏。在要进行拼音型文本纠错任务过程中，我发现这方面的语料着实少，因此在语料的获取和处理上花费较多时间，以下是我面对语料匮乏情况下的探索和总结。\n\n<!-- more -->\n\n### 语料的获取\n\n语料获取分为两个部分，一是搜索：查询并获取已有的特定方向的语料。二是制造：自行制造出需要的语料。\n\n#### 语料搜索\n\n首先我们自然要考虑能否找到已经标记好的公开语料。\n\n没有查询到相应结果之后，开始寻找这方面的公开比赛，最好是去年或前年这类年份较近且比赛已经结束的，一来更可能可以获取完整语料，二来可以参考比赛结束后放出的优胜者的论文，而年份越近则参赛者更可能用上更先进的方法。\n\n此外还可以参考这方面的论文，论文中会给出评测的方法和样例文本，根据文中出现的语料来源关键词再进行搜索。由此我搜索到几份台湾的拼音型质量较高的语料，分别是13-15年的Chinese Spelling Check Task的语料：\n\n[汇总链接](https://www.sigcall.org/data-sets.html)\n\n[SIGHAN 2013 Bake-off: Chinese Spelling Check Task](http://ir.itc.ntnu.edu.tw/lre/sighan7csc.html)\n\n[CLP 2014 Bake-off: Chinese Spelling Check Task](http://ir.itc.ntnu.edu.tw/lre/clp14csc.html)\n\n[SIGHAN 2015 Bake-off: Chinese Spelling Check Task](http://ir.itc.ntnu.edu.tw/lre/sighan8csc.html)\n\n以下是语料的一个样例：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_training.png)\n\n可以看出，这份语料的错误类型是拼音相近的词语，它不仅标出了错误词语，还给出了正确答案，由此还可以将错误检测模型扩展为纠正模型。\n\n填写资料下载后可以看到，压缩包中除了训练、测试语料外还包含相似拼音字表和相近字形字表。\n\n虽然语料质量较高，但还是有些缺点的：\n\n 　1.  首先自然是语料的规模不足，将三份语料汇总之后也不过得到3M左右的语料\n 　2.  其次是文本问题，可以看出语料使用的是繁体字，在建立面向简体字的模型的过程中，我们需要将其转换为简体字\n 　3.  第三是文化问题，文字虽然可以转换为简体字，但文本的组织结构、表述以及用词还是附带较浓的台湾气息，如“幼儿园”在文本中称为“幼稚园”，“什么”在文本中为“什幺”\n\n在浏览完各类论文和语料库之后，就可以开始发散思维了。原本打算爬取小学生病句作为语料，然而点开几份病句题之后却发现，小学生的病句里就已经涉及到知识推理、指代不明等高难度问题了，由此不得让人感慨，我们还有很长的路要走。\n\n可以直接用于训练的语料并不多，接下来该考虑语料制造了\n\n####　语料制造\n\n语料制造分为人工制作新语料和在现有语料上进行改造。\n\n##### 人工制作\n\n人工制作新语料可以是完全人为构造新句子，当然还有方便得多的方法就是从已有的句子上挑选词语，选择相近音的字词进行替换。除了项目人员自行替换之外，也可外包出去花费金钱获取有一定数目和质量的人工语料。\n\n此外，也可以从外国人学习中文的作文着手，已有的语法错误、词语错误语料有相当一部分是来自外国人的作文加上人工标记形成的，如[北京语言大学的HSK动态作文语料库](http://202.112.194.56:8088/hsk/)，但笔者并未发现有能够获取完整语料的地方。仅有官方提供的各种小规模查询方式。\n\n##### 改造语料\n\n在网上各类公开语料库上得到大量中文通用语料并进行预处理之后，最简单的方法就是对于每个句子以一定的概率随机替换掉某个字或词（取决于模型是基于字还是基于词的，但一般来说基于字效果更好、字典更小、速度更快），替换的字或词的数目可以自行调整， 不同的概率对应不同的替换数目。优点是足够自动化、方便快速、语料数目大，缺点则是语料和将要纠错的句子的贴合度并不高。\n\n在前面的方法之上为了更贴近待纠错句子，可以构造相近音的字表或词表，替换时查表随机替换。\n\n\n\n以上就是语料获取方面的总结。在获取到Chinese Spelling Check Task的语料之后，还需要对其进行处理。\n\n### CSC语料处理\n\n#### 繁体转简体工具介绍及安装\n\n为了建立面向简体中文的纠错模型，我们首先得将繁体语料转换成简体。在搜索python转换的工具包时，网上博客一水的推荐<https://github.com/skydark/nstools/tree/master/zhtools>的转换工具，然而在实际使用过后发现效果并不是很好，在剔除使用zhtools的文章之后，发现一个在github有3k stars的工具包opencc：https://github.com/BYVoid/OpenCC\n\n使用python的可以 pip install opencc，但会报错并且需要各种设置。以下介绍一下Ubuntu下编译安装的方法，安装完成后直接可以在命令行中使用opencc而无需特定语言。\n\n```bash\n先找个空白文件夹安装需要的其它工具：\ngit clone https://github.com/doxygen/doxygen.git\ncd doxygen\nmkdir build\ncd build\nsudo apt-get install flex\nsudo apt-get install bison\ncmake -G \"Unix Makefiles\" ..\nmake\nsudo make install\n\n而后就可以开始安装opencc了：\ngit clone git@github.com:BYVoid/OpenCC.git\ncd OpenCC\nmake\nsudo make install\n```\n\n安装完成后就可以在命令行中以：\n\n```\nopencc -c <配置文件名> -i <输入文件名> -o <输出文件名>\n```\n\n的格式进行使用了，-c中支持的配置文件名可以在github上找到，若不加-o选项则会直接将转换后的结果显示出来。\n\n#### 进一步处理\n\n将所有的Input txt 和Truth txt拷到一个文件夹后，使用\n\n```\ncat *Input* > input.txt\ncat *Truth* > truth.txt\n\nopencc -c tw2sp.json -i input.txt -o input.txt\nopencc -c tw2sp.json -i truth.txt -o truth.txt\n```\n\n就可以得到转换后的文件了。\n\n在进行简繁转换后，笔者发现其内部的英文和数字使用的是全角字符，然后在网上找段转换代码将文本转换成半角，之后再将数字转换成星号\n\n在检测阶段，我们还不需要正确的词语，只需要错误词语的索引即可，在用正则表达式将truth中的汉字剔除后，就得到处理后的文本了：\n\n文本\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_input.png)\n\n答案（只有索引）\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_truth.png)\n\n答案（带正确字）\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_truth1.png)\n\n值得注意的是，测试语料中错误字所使用的索引是从1开始的，并且0代表句子完全正确。\n\n训练语料使用的sgml格式，可以用parser处理也可以直接暴力用正则表达式替换再用python细处理。\n\n#### 其它\n\n上面的处理完成之后，已经可以投入训练了，但是也可以进一步进行处理：\n\n1.  长句切短句。将长句子按照逗号、句号、感叹号等切分成几个短句子，因为只是要检测简单的词语错误，因此不大需要考虑前后短句子的逻辑关系，将句子切开之后语料数目也同样增加了。\n2.  增加STA、END、UNK标签，自然语言处理领域中常常使用的方法，对于要输入LSTM的句子，开头加上STA标签，结尾加上END标签（也可以开头和结尾使用同一个标签），加上标签可以让模型知道是句子开头和结尾，由此可以加强判断第一个词和最后一个词正确与否的能力。而UNK则是用于标记词表外单词的标签，若单词频率太低则将其替换成UNK，减少词表大小。\n3.  保存字词和索引转换表，提前切分并替换成索引。将字词和索引的转换以固定文件保存下来，而后将语料预先转换成索引序列，可以省去大规模语料在内存中转换成索引的时间。要注意STA、END和UNK标签不要被单独切开了。\n\n以上就是我在语料方面的探索和总结，希望能对读者有些许帮助。","source":"_posts/csc_corpus.md","raw":"---\nlayout: post\ntitle: \"拼音型简单错误语料获取与处理\"\ndate: 2018-08-28\ncomments: true\ntags: \n\t- NLP\n\t- 文本纠错\n---\n\n在自然语言处理领域中，语料是非常关键的一个部分。然而，中文的自然语言处理领域在大的通用型语料上虽然不少，但在特定方向上的语料仍然匮乏。在要进行拼音型文本纠错任务过程中，我发现这方面的语料着实少，因此在语料的获取和处理上花费较多时间，以下是我面对语料匮乏情况下的探索和总结。\n\n<!-- more -->\n\n### 语料的获取\n\n语料获取分为两个部分，一是搜索：查询并获取已有的特定方向的语料。二是制造：自行制造出需要的语料。\n\n#### 语料搜索\n\n首先我们自然要考虑能否找到已经标记好的公开语料。\n\n没有查询到相应结果之后，开始寻找这方面的公开比赛，最好是去年或前年这类年份较近且比赛已经结束的，一来更可能可以获取完整语料，二来可以参考比赛结束后放出的优胜者的论文，而年份越近则参赛者更可能用上更先进的方法。\n\n此外还可以参考这方面的论文，论文中会给出评测的方法和样例文本，根据文中出现的语料来源关键词再进行搜索。由此我搜索到几份台湾的拼音型质量较高的语料，分别是13-15年的Chinese Spelling Check Task的语料：\n\n[汇总链接](https://www.sigcall.org/data-sets.html)\n\n[SIGHAN 2013 Bake-off: Chinese Spelling Check Task](http://ir.itc.ntnu.edu.tw/lre/sighan7csc.html)\n\n[CLP 2014 Bake-off: Chinese Spelling Check Task](http://ir.itc.ntnu.edu.tw/lre/clp14csc.html)\n\n[SIGHAN 2015 Bake-off: Chinese Spelling Check Task](http://ir.itc.ntnu.edu.tw/lre/sighan8csc.html)\n\n以下是语料的一个样例：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_training.png)\n\n可以看出，这份语料的错误类型是拼音相近的词语，它不仅标出了错误词语，还给出了正确答案，由此还可以将错误检测模型扩展为纠正模型。\n\n填写资料下载后可以看到，压缩包中除了训练、测试语料外还包含相似拼音字表和相近字形字表。\n\n虽然语料质量较高，但还是有些缺点的：\n\n 　1.  首先自然是语料的规模不足，将三份语料汇总之后也不过得到3M左右的语料\n 　2.  其次是文本问题，可以看出语料使用的是繁体字，在建立面向简体字的模型的过程中，我们需要将其转换为简体字\n 　3.  第三是文化问题，文字虽然可以转换为简体字，但文本的组织结构、表述以及用词还是附带较浓的台湾气息，如“幼儿园”在文本中称为“幼稚园”，“什么”在文本中为“什幺”\n\n在浏览完各类论文和语料库之后，就可以开始发散思维了。原本打算爬取小学生病句作为语料，然而点开几份病句题之后却发现，小学生的病句里就已经涉及到知识推理、指代不明等高难度问题了，由此不得让人感慨，我们还有很长的路要走。\n\n可以直接用于训练的语料并不多，接下来该考虑语料制造了\n\n####　语料制造\n\n语料制造分为人工制作新语料和在现有语料上进行改造。\n\n##### 人工制作\n\n人工制作新语料可以是完全人为构造新句子，当然还有方便得多的方法就是从已有的句子上挑选词语，选择相近音的字词进行替换。除了项目人员自行替换之外，也可外包出去花费金钱获取有一定数目和质量的人工语料。\n\n此外，也可以从外国人学习中文的作文着手，已有的语法错误、词语错误语料有相当一部分是来自外国人的作文加上人工标记形成的，如[北京语言大学的HSK动态作文语料库](http://202.112.194.56:8088/hsk/)，但笔者并未发现有能够获取完整语料的地方。仅有官方提供的各种小规模查询方式。\n\n##### 改造语料\n\n在网上各类公开语料库上得到大量中文通用语料并进行预处理之后，最简单的方法就是对于每个句子以一定的概率随机替换掉某个字或词（取决于模型是基于字还是基于词的，但一般来说基于字效果更好、字典更小、速度更快），替换的字或词的数目可以自行调整， 不同的概率对应不同的替换数目。优点是足够自动化、方便快速、语料数目大，缺点则是语料和将要纠错的句子的贴合度并不高。\n\n在前面的方法之上为了更贴近待纠错句子，可以构造相近音的字表或词表，替换时查表随机替换。\n\n\n\n以上就是语料获取方面的总结。在获取到Chinese Spelling Check Task的语料之后，还需要对其进行处理。\n\n### CSC语料处理\n\n#### 繁体转简体工具介绍及安装\n\n为了建立面向简体中文的纠错模型，我们首先得将繁体语料转换成简体。在搜索python转换的工具包时，网上博客一水的推荐<https://github.com/skydark/nstools/tree/master/zhtools>的转换工具，然而在实际使用过后发现效果并不是很好，在剔除使用zhtools的文章之后，发现一个在github有3k stars的工具包opencc：https://github.com/BYVoid/OpenCC\n\n使用python的可以 pip install opencc，但会报错并且需要各种设置。以下介绍一下Ubuntu下编译安装的方法，安装完成后直接可以在命令行中使用opencc而无需特定语言。\n\n```bash\n先找个空白文件夹安装需要的其它工具：\ngit clone https://github.com/doxygen/doxygen.git\ncd doxygen\nmkdir build\ncd build\nsudo apt-get install flex\nsudo apt-get install bison\ncmake -G \"Unix Makefiles\" ..\nmake\nsudo make install\n\n而后就可以开始安装opencc了：\ngit clone git@github.com:BYVoid/OpenCC.git\ncd OpenCC\nmake\nsudo make install\n```\n\n安装完成后就可以在命令行中以：\n\n```\nopencc -c <配置文件名> -i <输入文件名> -o <输出文件名>\n```\n\n的格式进行使用了，-c中支持的配置文件名可以在github上找到，若不加-o选项则会直接将转换后的结果显示出来。\n\n#### 进一步处理\n\n将所有的Input txt 和Truth txt拷到一个文件夹后，使用\n\n```\ncat *Input* > input.txt\ncat *Truth* > truth.txt\n\nopencc -c tw2sp.json -i input.txt -o input.txt\nopencc -c tw2sp.json -i truth.txt -o truth.txt\n```\n\n就可以得到转换后的文件了。\n\n在进行简繁转换后，笔者发现其内部的英文和数字使用的是全角字符，然后在网上找段转换代码将文本转换成半角，之后再将数字转换成星号\n\n在检测阶段，我们还不需要正确的词语，只需要错误词语的索引即可，在用正则表达式将truth中的汉字剔除后，就得到处理后的文本了：\n\n文本\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_input.png)\n\n答案（只有索引）\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_truth.png)\n\n答案（带正确字）\n\n![](http://ot1c7ttzm.bkt.clouddn.com/csc_truth1.png)\n\n值得注意的是，测试语料中错误字所使用的索引是从1开始的，并且0代表句子完全正确。\n\n训练语料使用的sgml格式，可以用parser处理也可以直接暴力用正则表达式替换再用python细处理。\n\n#### 其它\n\n上面的处理完成之后，已经可以投入训练了，但是也可以进一步进行处理：\n\n1.  长句切短句。将长句子按照逗号、句号、感叹号等切分成几个短句子，因为只是要检测简单的词语错误，因此不大需要考虑前后短句子的逻辑关系，将句子切开之后语料数目也同样增加了。\n2.  增加STA、END、UNK标签，自然语言处理领域中常常使用的方法，对于要输入LSTM的句子，开头加上STA标签，结尾加上END标签（也可以开头和结尾使用同一个标签），加上标签可以让模型知道是句子开头和结尾，由此可以加强判断第一个词和最后一个词正确与否的能力。而UNK则是用于标记词表外单词的标签，若单词频率太低则将其替换成UNK，减少词表大小。\n3.  保存字词和索引转换表，提前切分并替换成索引。将字词和索引的转换以固定文件保存下来，而后将语料预先转换成索引序列，可以省去大规模语料在内存中转换成索引的时间。要注意STA、END和UNK标签不要被单独切开了。\n\n以上就是我在语料方面的探索和总结，希望能对读者有些许帮助。","slug":"csc_corpus","published":1,"updated":"2018-08-28T09:04:43.251Z","photos":[],"link":"","_id":"cjleshqjt000wryfca5rn4n9f","content":"<p>在自然语言处理领域中，语料是非常关键的一个部分。然而，中文的自然语言处理领域在大的通用型语料上虽然不少，但在特定方向上的语料仍然匮乏。在要进行拼音型文本纠错任务过程中，我发现这方面的语料着实少，因此在语料的获取和处理上花费较多时间，以下是我面对语料匮乏情况下的探索和总结。</p>\n<a id=\"more\"></a>\n<h3 id=\"语料的获取\"><a href=\"#语料的获取\" class=\"headerlink\" title=\"语料的获取\"></a>语料的获取</h3><p>语料获取分为两个部分，一是搜索：查询并获取已有的特定方向的语料。二是制造：自行制造出需要的语料。</p>\n<h4 id=\"语料搜索\"><a href=\"#语料搜索\" class=\"headerlink\" title=\"语料搜索\"></a>语料搜索</h4><p>首先我们自然要考虑能否找到已经标记好的公开语料。</p>\n<p>没有查询到相应结果之后，开始寻找这方面的公开比赛，最好是去年或前年这类年份较近且比赛已经结束的，一来更可能可以获取完整语料，二来可以参考比赛结束后放出的优胜者的论文，而年份越近则参赛者更可能用上更先进的方法。</p>\n<p>此外还可以参考这方面的论文，论文中会给出评测的方法和样例文本，根据文中出现的语料来源关键词再进行搜索。由此我搜索到几份台湾的拼音型质量较高的语料，分别是13-15年的Chinese Spelling Check Task的语料：</p>\n<p><a href=\"https://www.sigcall.org/data-sets.html\" target=\"_blank\" rel=\"noopener\">汇总链接</a></p>\n<p><a href=\"http://ir.itc.ntnu.edu.tw/lre/sighan7csc.html\" target=\"_blank\" rel=\"noopener\">SIGHAN 2013 Bake-off: Chinese Spelling Check Task</a></p>\n<p><a href=\"http://ir.itc.ntnu.edu.tw/lre/clp14csc.html\" target=\"_blank\" rel=\"noopener\">CLP 2014 Bake-off: Chinese Spelling Check Task</a></p>\n<p><a href=\"http://ir.itc.ntnu.edu.tw/lre/sighan8csc.html\" target=\"_blank\" rel=\"noopener\">SIGHAN 2015 Bake-off: Chinese Spelling Check Task</a></p>\n<p>以下是语料的一个样例：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_training.png\" alt=\"\"></p>\n<p>可以看出，这份语料的错误类型是拼音相近的词语，它不仅标出了错误词语，还给出了正确答案，由此还可以将错误检测模型扩展为纠正模型。</p>\n<p>填写资料下载后可以看到，压缩包中除了训练、测试语料外还包含相似拼音字表和相近字形字表。</p>\n<p>虽然语料质量较高，但还是有些缺点的：</p>\n<p> 　1.  首先自然是语料的规模不足，将三份语料汇总之后也不过得到3M左右的语料<br> 　2.  其次是文本问题，可以看出语料使用的是繁体字，在建立面向简体字的模型的过程中，我们需要将其转换为简体字<br> 　3.  第三是文化问题，文字虽然可以转换为简体字，但文本的组织结构、表述以及用词还是附带较浓的台湾气息，如“幼儿园”在文本中称为“幼稚园”，“什么”在文本中为“什幺”</p>\n<p>在浏览完各类论文和语料库之后，就可以开始发散思维了。原本打算爬取小学生病句作为语料，然而点开几份病句题之后却发现，小学生的病句里就已经涉及到知识推理、指代不明等高难度问题了，由此不得让人感慨，我们还有很长的路要走。</p>\n<p>可以直接用于训练的语料并不多，接下来该考虑语料制造了</p>\n<h4 id=\"语料制造\"><a href=\"#语料制造\" class=\"headerlink\" title=\"　语料制造\"></a>　语料制造</h4><p>语料制造分为人工制作新语料和在现有语料上进行改造。</p>\n<h5 id=\"人工制作\"><a href=\"#人工制作\" class=\"headerlink\" title=\"人工制作\"></a>人工制作</h5><p>人工制作新语料可以是完全人为构造新句子，当然还有方便得多的方法就是从已有的句子上挑选词语，选择相近音的字词进行替换。除了项目人员自行替换之外，也可外包出去花费金钱获取有一定数目和质量的人工语料。</p>\n<p>此外，也可以从外国人学习中文的作文着手，已有的语法错误、词语错误语料有相当一部分是来自外国人的作文加上人工标记形成的，如<a href=\"http://202.112.194.56:8088/hsk/\" target=\"_blank\" rel=\"noopener\">北京语言大学的HSK动态作文语料库</a>，但笔者并未发现有能够获取完整语料的地方。仅有官方提供的各种小规模查询方式。</p>\n<h5 id=\"改造语料\"><a href=\"#改造语料\" class=\"headerlink\" title=\"改造语料\"></a>改造语料</h5><p>在网上各类公开语料库上得到大量中文通用语料并进行预处理之后，最简单的方法就是对于每个句子以一定的概率随机替换掉某个字或词（取决于模型是基于字还是基于词的，但一般来说基于字效果更好、字典更小、速度更快），替换的字或词的数目可以自行调整， 不同的概率对应不同的替换数目。优点是足够自动化、方便快速、语料数目大，缺点则是语料和将要纠错的句子的贴合度并不高。</p>\n<p>在前面的方法之上为了更贴近待纠错句子，可以构造相近音的字表或词表，替换时查表随机替换。</p>\n<p>以上就是语料获取方面的总结。在获取到Chinese Spelling Check Task的语料之后，还需要对其进行处理。</p>\n<h3 id=\"CSC语料处理\"><a href=\"#CSC语料处理\" class=\"headerlink\" title=\"CSC语料处理\"></a>CSC语料处理</h3><h4 id=\"繁体转简体工具介绍及安装\"><a href=\"#繁体转简体工具介绍及安装\" class=\"headerlink\" title=\"繁体转简体工具介绍及安装\"></a>繁体转简体工具介绍及安装</h4><p>为了建立面向简体中文的纠错模型，我们首先得将繁体语料转换成简体。在搜索python转换的工具包时，网上博客一水的推荐<a href=\"https://github.com/skydark/nstools/tree/master/zhtools\" target=\"_blank\" rel=\"noopener\">https://github.com/skydark/nstools/tree/master/zhtools</a>的转换工具，然而在实际使用过后发现效果并不是很好，在剔除使用zhtools的文章之后，发现一个在github有3k stars的工具包opencc：<a href=\"https://github.com/BYVoid/OpenCC\" target=\"_blank\" rel=\"noopener\">https://github.com/BYVoid/OpenCC</a></p>\n<p>使用python的可以 pip install opencc，但会报错并且需要各种设置。以下介绍一下Ubuntu下编译安装的方法，安装完成后直接可以在命令行中使用opencc而无需特定语言。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先找个空白文件夹安装需要的其它工具：</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/doxygen/doxygen.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> doxygen</span><br><span class=\"line\">mkdir build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\">sudo apt-get install flex</span><br><span class=\"line\">sudo apt-get install bison</span><br><span class=\"line\">cmake -G <span class=\"string\">\"Unix Makefiles\"</span> ..</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br><span class=\"line\"></span><br><span class=\"line\">而后就可以开始安装opencc了：</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:BYVoid/OpenCC.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> OpenCC</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n<p>安装完成后就可以在命令行中以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opencc -c &lt;配置文件名&gt; -i &lt;输入文件名&gt; -o &lt;输出文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>的格式进行使用了，-c中支持的配置文件名可以在github上找到，若不加-o选项则会直接将转换后的结果显示出来。</p>\n<h4 id=\"进一步处理\"><a href=\"#进一步处理\" class=\"headerlink\" title=\"进一步处理\"></a>进一步处理</h4><p>将所有的Input txt 和Truth txt拷到一个文件夹后，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat *Input* &gt; input.txt</span><br><span class=\"line\">cat *Truth* &gt; truth.txt</span><br><span class=\"line\"></span><br><span class=\"line\">opencc -c tw2sp.json -i input.txt -o input.txt</span><br><span class=\"line\">opencc -c tw2sp.json -i truth.txt -o truth.txt</span><br></pre></td></tr></table></figure>\n<p>就可以得到转换后的文件了。</p>\n<p>在进行简繁转换后，笔者发现其内部的英文和数字使用的是全角字符，然后在网上找段转换代码将文本转换成半角，之后再将数字转换成星号</p>\n<p>在检测阶段，我们还不需要正确的词语，只需要错误词语的索引即可，在用正则表达式将truth中的汉字剔除后，就得到处理后的文本了：</p>\n<p>文本</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_input.png\" alt=\"\"></p>\n<p>答案（只有索引）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_truth.png\" alt=\"\"></p>\n<p>答案（带正确字）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_truth1.png\" alt=\"\"></p>\n<p>值得注意的是，测试语料中错误字所使用的索引是从1开始的，并且0代表句子完全正确。</p>\n<p>训练语料使用的sgml格式，可以用parser处理也可以直接暴力用正则表达式替换再用python细处理。</p>\n<h4 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h4><p>上面的处理完成之后，已经可以投入训练了，但是也可以进一步进行处理：</p>\n<ol>\n<li>长句切短句。将长句子按照逗号、句号、感叹号等切分成几个短句子，因为只是要检测简单的词语错误，因此不大需要考虑前后短句子的逻辑关系，将句子切开之后语料数目也同样增加了。</li>\n<li>增加STA、END、UNK标签，自然语言处理领域中常常使用的方法，对于要输入LSTM的句子，开头加上STA标签，结尾加上END标签（也可以开头和结尾使用同一个标签），加上标签可以让模型知道是句子开头和结尾，由此可以加强判断第一个词和最后一个词正确与否的能力。而UNK则是用于标记词表外单词的标签，若单词频率太低则将其替换成UNK，减少词表大小。</li>\n<li>保存字词和索引转换表，提前切分并替换成索引。将字词和索引的转换以固定文件保存下来，而后将语料预先转换成索引序列，可以省去大规模语料在内存中转换成索引的时间。要注意STA、END和UNK标签不要被单独切开了。</li>\n</ol>\n<p>以上就是我在语料方面的探索和总结，希望能对读者有些许帮助。</p>\n","site":{"data":{}},"excerpt":"<p>在自然语言处理领域中，语料是非常关键的一个部分。然而，中文的自然语言处理领域在大的通用型语料上虽然不少，但在特定方向上的语料仍然匮乏。在要进行拼音型文本纠错任务过程中，我发现这方面的语料着实少，因此在语料的获取和处理上花费较多时间，以下是我面对语料匮乏情况下的探索和总结。</p>","more":"<h3 id=\"语料的获取\"><a href=\"#语料的获取\" class=\"headerlink\" title=\"语料的获取\"></a>语料的获取</h3><p>语料获取分为两个部分，一是搜索：查询并获取已有的特定方向的语料。二是制造：自行制造出需要的语料。</p>\n<h4 id=\"语料搜索\"><a href=\"#语料搜索\" class=\"headerlink\" title=\"语料搜索\"></a>语料搜索</h4><p>首先我们自然要考虑能否找到已经标记好的公开语料。</p>\n<p>没有查询到相应结果之后，开始寻找这方面的公开比赛，最好是去年或前年这类年份较近且比赛已经结束的，一来更可能可以获取完整语料，二来可以参考比赛结束后放出的优胜者的论文，而年份越近则参赛者更可能用上更先进的方法。</p>\n<p>此外还可以参考这方面的论文，论文中会给出评测的方法和样例文本，根据文中出现的语料来源关键词再进行搜索。由此我搜索到几份台湾的拼音型质量较高的语料，分别是13-15年的Chinese Spelling Check Task的语料：</p>\n<p><a href=\"https://www.sigcall.org/data-sets.html\" target=\"_blank\" rel=\"noopener\">汇总链接</a></p>\n<p><a href=\"http://ir.itc.ntnu.edu.tw/lre/sighan7csc.html\" target=\"_blank\" rel=\"noopener\">SIGHAN 2013 Bake-off: Chinese Spelling Check Task</a></p>\n<p><a href=\"http://ir.itc.ntnu.edu.tw/lre/clp14csc.html\" target=\"_blank\" rel=\"noopener\">CLP 2014 Bake-off: Chinese Spelling Check Task</a></p>\n<p><a href=\"http://ir.itc.ntnu.edu.tw/lre/sighan8csc.html\" target=\"_blank\" rel=\"noopener\">SIGHAN 2015 Bake-off: Chinese Spelling Check Task</a></p>\n<p>以下是语料的一个样例：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_training.png\" alt=\"\"></p>\n<p>可以看出，这份语料的错误类型是拼音相近的词语，它不仅标出了错误词语，还给出了正确答案，由此还可以将错误检测模型扩展为纠正模型。</p>\n<p>填写资料下载后可以看到，压缩包中除了训练、测试语料外还包含相似拼音字表和相近字形字表。</p>\n<p>虽然语料质量较高，但还是有些缺点的：</p>\n<p> 　1.  首先自然是语料的规模不足，将三份语料汇总之后也不过得到3M左右的语料<br> 　2.  其次是文本问题，可以看出语料使用的是繁体字，在建立面向简体字的模型的过程中，我们需要将其转换为简体字<br> 　3.  第三是文化问题，文字虽然可以转换为简体字，但文本的组织结构、表述以及用词还是附带较浓的台湾气息，如“幼儿园”在文本中称为“幼稚园”，“什么”在文本中为“什幺”</p>\n<p>在浏览完各类论文和语料库之后，就可以开始发散思维了。原本打算爬取小学生病句作为语料，然而点开几份病句题之后却发现，小学生的病句里就已经涉及到知识推理、指代不明等高难度问题了，由此不得让人感慨，我们还有很长的路要走。</p>\n<p>可以直接用于训练的语料并不多，接下来该考虑语料制造了</p>\n<h4 id=\"语料制造\"><a href=\"#语料制造\" class=\"headerlink\" title=\"　语料制造\"></a>　语料制造</h4><p>语料制造分为人工制作新语料和在现有语料上进行改造。</p>\n<h5 id=\"人工制作\"><a href=\"#人工制作\" class=\"headerlink\" title=\"人工制作\"></a>人工制作</h5><p>人工制作新语料可以是完全人为构造新句子，当然还有方便得多的方法就是从已有的句子上挑选词语，选择相近音的字词进行替换。除了项目人员自行替换之外，也可外包出去花费金钱获取有一定数目和质量的人工语料。</p>\n<p>此外，也可以从外国人学习中文的作文着手，已有的语法错误、词语错误语料有相当一部分是来自外国人的作文加上人工标记形成的，如<a href=\"http://202.112.194.56:8088/hsk/\" target=\"_blank\" rel=\"noopener\">北京语言大学的HSK动态作文语料库</a>，但笔者并未发现有能够获取完整语料的地方。仅有官方提供的各种小规模查询方式。</p>\n<h5 id=\"改造语料\"><a href=\"#改造语料\" class=\"headerlink\" title=\"改造语料\"></a>改造语料</h5><p>在网上各类公开语料库上得到大量中文通用语料并进行预处理之后，最简单的方法就是对于每个句子以一定的概率随机替换掉某个字或词（取决于模型是基于字还是基于词的，但一般来说基于字效果更好、字典更小、速度更快），替换的字或词的数目可以自行调整， 不同的概率对应不同的替换数目。优点是足够自动化、方便快速、语料数目大，缺点则是语料和将要纠错的句子的贴合度并不高。</p>\n<p>在前面的方法之上为了更贴近待纠错句子，可以构造相近音的字表或词表，替换时查表随机替换。</p>\n<p>以上就是语料获取方面的总结。在获取到Chinese Spelling Check Task的语料之后，还需要对其进行处理。</p>\n<h3 id=\"CSC语料处理\"><a href=\"#CSC语料处理\" class=\"headerlink\" title=\"CSC语料处理\"></a>CSC语料处理</h3><h4 id=\"繁体转简体工具介绍及安装\"><a href=\"#繁体转简体工具介绍及安装\" class=\"headerlink\" title=\"繁体转简体工具介绍及安装\"></a>繁体转简体工具介绍及安装</h4><p>为了建立面向简体中文的纠错模型，我们首先得将繁体语料转换成简体。在搜索python转换的工具包时，网上博客一水的推荐<a href=\"https://github.com/skydark/nstools/tree/master/zhtools\" target=\"_blank\" rel=\"noopener\">https://github.com/skydark/nstools/tree/master/zhtools</a>的转换工具，然而在实际使用过后发现效果并不是很好，在剔除使用zhtools的文章之后，发现一个在github有3k stars的工具包opencc：<a href=\"https://github.com/BYVoid/OpenCC\" target=\"_blank\" rel=\"noopener\">https://github.com/BYVoid/OpenCC</a></p>\n<p>使用python的可以 pip install opencc，但会报错并且需要各种设置。以下介绍一下Ubuntu下编译安装的方法，安装完成后直接可以在命令行中使用opencc而无需特定语言。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先找个空白文件夹安装需要的其它工具：</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/doxygen/doxygen.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> doxygen</span><br><span class=\"line\">mkdir build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\">sudo apt-get install flex</span><br><span class=\"line\">sudo apt-get install bison</span><br><span class=\"line\">cmake -G <span class=\"string\">\"Unix Makefiles\"</span> ..</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br><span class=\"line\"></span><br><span class=\"line\">而后就可以开始安装opencc了：</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:BYVoid/OpenCC.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> OpenCC</span><br><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n<p>安装完成后就可以在命令行中以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opencc -c &lt;配置文件名&gt; -i &lt;输入文件名&gt; -o &lt;输出文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>的格式进行使用了，-c中支持的配置文件名可以在github上找到，若不加-o选项则会直接将转换后的结果显示出来。</p>\n<h4 id=\"进一步处理\"><a href=\"#进一步处理\" class=\"headerlink\" title=\"进一步处理\"></a>进一步处理</h4><p>将所有的Input txt 和Truth txt拷到一个文件夹后，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat *Input* &gt; input.txt</span><br><span class=\"line\">cat *Truth* &gt; truth.txt</span><br><span class=\"line\"></span><br><span class=\"line\">opencc -c tw2sp.json -i input.txt -o input.txt</span><br><span class=\"line\">opencc -c tw2sp.json -i truth.txt -o truth.txt</span><br></pre></td></tr></table></figure>\n<p>就可以得到转换后的文件了。</p>\n<p>在进行简繁转换后，笔者发现其内部的英文和数字使用的是全角字符，然后在网上找段转换代码将文本转换成半角，之后再将数字转换成星号</p>\n<p>在检测阶段，我们还不需要正确的词语，只需要错误词语的索引即可，在用正则表达式将truth中的汉字剔除后，就得到处理后的文本了：</p>\n<p>文本</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_input.png\" alt=\"\"></p>\n<p>答案（只有索引）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_truth.png\" alt=\"\"></p>\n<p>答案（带正确字）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/csc_truth1.png\" alt=\"\"></p>\n<p>值得注意的是，测试语料中错误字所使用的索引是从1开始的，并且0代表句子完全正确。</p>\n<p>训练语料使用的sgml格式，可以用parser处理也可以直接暴力用正则表达式替换再用python细处理。</p>\n<h4 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h4><p>上面的处理完成之后，已经可以投入训练了，但是也可以进一步进行处理：</p>\n<ol>\n<li>长句切短句。将长句子按照逗号、句号、感叹号等切分成几个短句子，因为只是要检测简单的词语错误，因此不大需要考虑前后短句子的逻辑关系，将句子切开之后语料数目也同样增加了。</li>\n<li>增加STA、END、UNK标签，自然语言处理领域中常常使用的方法，对于要输入LSTM的句子，开头加上STA标签，结尾加上END标签（也可以开头和结尾使用同一个标签），加上标签可以让模型知道是句子开头和结尾，由此可以加强判断第一个词和最后一个词正确与否的能力。而UNK则是用于标记词表外单词的标签，若单词频率太低则将其替换成UNK，减少词表大小。</li>\n<li>保存字词和索引转换表，提前切分并替换成索引。将字词和索引的转换以固定文件保存下来，而后将语料预先转换成索引序列，可以省去大规模语料在内存中转换成索引的时间。要注意STA、END和UNK标签不要被单独切开了。</li>\n</ol>\n<p>以上就是我在语料方面的探索和总结，希望能对读者有些许帮助。</p>"},{"layout":"post","title":"计算机网络笔记","date":"2018-02-19T16:00:00.000Z","comments":1,"_content":"\n### 概述（上）\n\n计算机网络学习笔记，包括：\n\n1. 基本概念：网络结构、体系结构\n2. 网络层：web、Email、DNS、P2P、Socket\n3. 传输层：TCP、UDP\n4. 网络层：IP、CIDR、DHCP、NAT、ICMP、路由\n5. 数据链路层：差错编码、MAC\n6. 局域网：ARP、以太网\n\n<!-- more -->\n\n#### 基本概念\n\n计算机网络 = 通信技术 + 计算机技术\n\n定义： 计算机网络是互连的、自治的计算机集合\n\n网络结构：\n\n* 网络边缘： 主机、网络应用\n  *  主机（端系统）：运行网络应用程序\n  *  模型：\n    * client、server 客户 服务器模型：客户发送请求，服务器响应\n    * p2p模型：无专用服务器，通信在对等实体间直接进行\n* 接入网络，物理介质： 有线或无线通信链路\n  *  DSL 数字用户线路：用电话线连接，FDM分频\n* 网络核心（核心网络）：互联的路由器、网络的网络\n  * 核心功能：路由routing + 转发 forwarding\n    * 路由：确定分组从源到目的传输路径\n    * 转发：分组从路由器输入端口转发至正确的输出端口\n  * **数据交换**\n\n端系统通过 接入ISP 连接到Internet， 接入ISP互连\n\n#### 网络核心\n\n数据交换：数据通过网络核心从源主机到达目的主机的手段\n\n数据交换分类：\n\n1. 电路交换\n2. 报文交换\n3. 分组交换\n\n##### 电路交换\n\n最典型的电路交换网络：电话网络\n\n三个阶段：\n\n* 建立连接\n* 通信\n* 释放连接\n\n特点：资源**独占**\n\n如何共享中继线： 多路复用（Multiplexing）\n\n多路复用： 链路、网络资源划分资源片，每路独占分配的资源片，资源片可能闲置\n\n典型多路复用方法：\n\n* 频分多路复用 FDM\n  * 各用户占用不同频率带宽\n  * 通信过程中始终使用一个频带\n* 时分多路复用 TDM\n  * 将时间划分为等长的帧，帧划分为时隙，每个用户使用固定序号的时隙\n  * 每个用户的时隙周期性出现（周期为帧长度）\n  * 所有用户使用所有频带宽度\n* 波分多路复用 WDM\n  * 光的频分复用\n* 码分多路复用 CDM\n  * 广泛应用于无线链路共享\n  * 每个用户有唯一的码片序列，码片序列之间正交\n  * 用户用码片序列编码自己的数据\n\n##### 报文交换 message switching\n\n一次发送信息整体\n\n##### 分组交换 package switching\n\n分组： 报文拆分出的一系列较小的数据包\n\n需要报文的拆分和重组\n\n每个分组需要额外的分组头\n\n**统计多路复用 statistical multiplexing**： 按需共享（传输数据多的速度快，数据少的速度慢）\n\n交换方式： **存储-转发**：\n\n​\t一次存储整个分组，而后转发\n\n分组交换和电路交换：\n\n分组交换适用于突发数据传输：\n\n* 优点\n    * 资源充分共享\n  * 简单、无需建立呼叫电路\n* 缺点：\n  * 可能产生拥塞 congestion： 分组延迟和丢包\n  * 需要协议处理可靠数据传输和拥塞控制\n\n### 概述（下）\n\n#### 计算机网络性能\n\n速率：\n\n* 速率、数据率、比特率： 单位时间(秒)内传输信息（比特）量， b/s ,bps, kb/s\n* 速率往往指的是额定速率、标称速率（理论值）\n\n带宽： \n\n* 原本：信号具有的频带宽度，最高频率和最低频率之差，单位 hz\n* 网络：数字信道所能传输的最大数据率，单位 b/s\n\n延迟delay、时延 latency：\n\n* 原因： 分组在路由器缓存中排队\n* 四种类型：\n  * 处理延迟( nodal processing delay)：\n    * 差错检测\n    * 确定输出链路\n    * 通常毫秒、微秒级 \n  * 排队延迟 (queueing delay)\n    * 等待输出链路可用\n    * 取决于路由器拥塞程度\n  * 传输延迟 (transmission delay) ：路由器到链路\n    * 取决于分组长度L、链路带宽R， d trans = L/R\n  * 传播延迟 (propagation delay)：链路上到下一个路由器\n    * 取决于链路长度d，信号传播速度s，　d prop = d/s\n* d nodal = d proc + d queue + d trans + d prop\n\n时延带宽积＝传播时延＊带宽 = 链路上能容纳多少比特\n\n丢包：\n\n * 原因：队列缓存有限\n * 分组到达已满队列将被丢弃\n * 丢弃分组可能由前序结点或源重发\n * 以丢包率衡量\n\n吞吐量  throughput\n\n * 发送端与接收端之间的速率\n * 分类：\n    * 即时吞吐量\n    * 平均吞吐量\n* 取决于端到端路径上，最小速率的链路\n\n#### 计算机网络体系结构\n\n用**分层结构**从**功能上**描述计算机网络体系\n\n每层完成一个特定功能，每层依赖底层提供的服务\n\n每层遵循某个协议完成本层功能\n\n计算机网络体系结构是计算机网络各层及其协议的集合\n\n分层结构的优点\n\n* 结构清晰\n* 模块化思想，易于系统更新、维护\n  * 任何一层服务实现上的改变对其它层不影响​\n\n基本概念：\n\n* 实体 entity ： 任何可发送或接收信息的硬件或软件进程\n* 协议 protocol：控制两个对等实体进行通信的规则的集合（同层的，水平的）\n* 服务是垂直的，任一层实体需要使用下层服务，遵循本层协议，实现本层功能，对上层提供服务\n* 下层实现对上层是不可见的\n* 相邻层之间通过接口进行交互，通过服务访问点SAP\n\n##### OSI参考模型\n\n概念：\n\n* 目的： 支持异构网络系统的互联互通\n* 异构网络系统互连的国际标准\n* 理解网络通信的最佳学习工具（理论模型，市场失败）\n\n分层： 7层：\n\n* 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n* 主机需要完成7层\n* 路由器只需要完成3层，物理层、链路层、网络层\n* 数据纵向流动，协议水平\n* 端到端层 end-end： 应用层到传输层 四层\n\n数据封装和通信过程：\n\n1. APDU 应用层数据单元\n2. PPDU 表示层\n3. SPDU 会话层\n4. TPDU 传输层\n5. NPDU 网络层\n6. DPDU 链路层加头加尾\n7. 物理层对应比特，不加额外信息\n\n* 增加控制信息： 最终构造成 PDU 构造协议数据单元\n* 控制信息包括：\n  * 地址： 标识发送端、接收端\n  * 差错检测编码：差错检测或纠正\n  * 协议控制：实现协议功能的附加信息\n\n功能：\n\n* 物理层功能：   总：实现比特的传输\n  * 定义、规范接口特性\n    * 机械特性：接口的几何形状\n    * 电气特性：接口的电平、电压\n    * 功能特性：多少引脚、引脚的功能\n    * 规程特性：接口的使用规则，也叫过程特性\n  * 比特编码\n  * 数据率\n  * 比特同步： 时钟同步问题\n  * 传输模式\n    * 单工模式 simplex ： 单向发信（如电视）\n    * 半双工 half-duplex ： 可双向，但只能交替进行（如对讲机）\n    * 全双工 full-duplex ： 可同时收发\n* 数据链路层功能：\n  * 负责结点-结点 node-to-node数据传输\n  * 以帧为单位进行传输\n  * 功能：\n    * 组帧 framing ： 加头加尾 ： 使得接收方能够切分帧病识别控制信息\n    * 物理寻址 physical addressing：包含源和目的物理地址\n    * 流量控制 flow control ： 避免淹没接收端\n    * 差错控制 error control ： 检测并重传损坏或丢失帧，并避免重复帧\n    * 访问（接入）控制 access control：决定哪个设备拥有链路的控制使用权\n* 网络层功能：负责数据分组packet的交付\n  * 原因：可能穿越多个网络\n  * 逻辑寻址 logical addressing： 全局唯一逻辑地址，确保数据分组被送到目的地，如IP地址\n  * 路由 routing： 选择路径\n  * 分组转发\n* 传输层功能： 负责端-端 完整报文的传输\n  * 报文的分段和重组\n  * SAP寻址：确保报文提交给正确进程，如端口号\n  * 连接控制：逻辑连接\n  * 流量控制\n  * 差错控制\n* 会话层功能： 插入控制信息\n  * 对话控制 dialog controlling： 对话的建立与维护\n  * 对话同步 synchronization： 数据流中插入同步点\n  * 最“薄”的一层\n* 表示层功能： 编码、加密、压缩数据\n  * 数据表示转化\n    * 转换为主机独立的编码\n  * 加密解密\n  * 压缩解压缩\n* 应用层功能：支持用户通过接口使用网络服务\n  * 典型类型：\n    * FTP 文件传输\n    * HTTP WEB\n    * SMTP 电子邮件\n\n##### TCP / IP模型\n\n四层： 应用层、运输层、网际层、网络接口层\n\n##### 五层参考模型\n\n综合OSI和TCP/IP模型的优点\n\n应用层、传输层、网络层、数据链路层、物理层\n\n层次：\n\n* 主机 五层\n* 路由器 三层\n* 交换机 两层\n\n#### 网络发展历史\n\n1961-1972： 交换分组原理提出与应用\n\n1972-1980：网络互连，大量新型、私有网络的涌现\n\n1980-1990：新型网络协议与网络的激增\n\n1990-2000初： 商业化，web，新应用\n\n2005-今\n\n### 网络应用（上）\n\n应用层 - 传输层 - 网络层 - 链路层 - 物理层\n\n#### 网络应用层概述\n\n* 网络应用体系结构\n* 网络应用的服务需求\n* Internet传输层服务模型\n* 特定网络应用与协议\n* Socket编程\n\n#### 网络应用的基本原理\n\n##### 网络应用的体系结构\n\n* 客户机、服务器结构  C/S  Client-Server\n  * 服务器\n    * 7*24小时提供服务\n    * 永久性访问地址\\域名\n    * 利用大量服务器实现可扩展性（处理大量并发请求）\n  * 客户机\n    * 与服务器通信，使用服务器提供的服务\n    * 间歇性接入网络\n    * 可能使用动态IP\n    * 不会和其他客户机直接通信\n* 点对点结构 P2P Peer-to-peer\n  * 没有永远在线的服务器\n  * 任意端系统之间可以直接通信\n  * 节点间歇性接入网络\n  * 节点可能改变IP\n  * 优点：高度可伸缩、可扩展\n  * 缺点：难以管理\n* 混合结构 hyrid\n\n##### 网络应用进程通信\n\n同一主机上进程通信：\n\n* 进程间通信机制\n* 由操作系统提供\n\n不同主机进程通信：消息交换\n\nSocket套接字：进程间利用socket发送和接受消息\n\n传输基础设施向进程提供API：\n\n* 传输协议的选择\n* 参数的设置\n\n进程寻址：\n\n* 不同主机进程通信，每个进程必须有标识符\n* 寻址主机：IP地址\n* 端口号 port number：主机上每个需要通信的进程分配一个端口号\n* 已经分配的端口： HTTP：80     mail：25\n* 进程的标识符： IP+端口号\n\n应用层协议：\n\n* 网络应用都应该遵循应用层协议\n* 公开协议： \n   * 由 RFC（request for comments）定义\n   * 允许互操作\n   * 例如： HTTP、SMTP\n* 私有协议：\n  * 多数P2P文件共享应用\n* 内容：\n  * 消息的类型type：\n    * 请求消息\n    * 响应消息\n  * 消息的语法syntax 、格式\n    * 消息中由哪些字段 field\n    * 每个字段如何描述\n  * 字段的语义 semantics ：信息的含义\n  * 规则 rules： 何时、如何发送、相应消息\n\n##### 网络应用的需求与传输层服务\n\n需求：\n\n* 数据丢失 data loss、 可靠性reliability\n  * 某些可容忍一定的数据丢失：网络电话\n  * 某些要求100%可靠的数据传输\n* 时间timing 、 延迟 delay：\n  * 延迟低才有效（网络电话、网络游戏）\n* 带宽 bandwidth：\n  * 带宽达到最低要求才有效：网路视频\n  * 可适应任何带宽——弹性应用：email、文件下载\n\n传输服务：\n\n* TCP服务：\n  * 面向连接：客户机和服务器需要建立连接\n  * 可靠的传输\n  * 流量控制：发送方不会发送速度过快\n  * 拥塞控制：网络负载过重时能限制发送方发送速度\n  * 不提供时间保障\n  * 不提供最小带宽保障\n* UDP服务：\n  * 无连接\n  * 不可靠\n  * 不提供：可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障\n\n#### Web应用\n\n##### web与http\n\nweb：\n\n* 网页\n* 网页互相链接\n\n网页 webpage 包含多个对象 objects：\n\n* 对象：html文件、jpeg图片、视频、动态脚本\n* 基本html文件：包含对其他对象引用的链接\n\n对象的寻址 addressing：\n\n* URL（uniform resource locator）：统一资源定位器\n* 格式：  Scheme:// host:port/path\n\nHTTP协议 hypertext transfer protocol 超文本传输协议：\n\n* CS结构：\n  * 客户- browser：请求、接受、展示web对象\n  * 服务器-web server：相应客户请求、发送对象\n* 使用TCP传输服务\n* 无状态 stateless：服务器不维护任何过去发送请求的信息\n\n##### HTTP连接\n\n非持久性连接 nonpersistent http：\n\n* 每个TCP连接最多允许传输一个对象\n* 在HTTP 1.0版本\n* 缺点：\n  * 每个对象需要2个RTT\n  * 操作系统要为每个TCP连接开销资源\n  * 浏览器需要打开多个并行TCP连接获取对象\n\n持久性连接：\n\n* 每个TCP连接允许传输多个对象\n* HTTP 1.1默认\n* 发送响应后，服务器保持TCP连接打开以发送后续HTTP消息\n* 分类：\n  * 无流水pipelining的持久性连接\n    * 客户端受到一个响应才发送一个新请求\n    * 每个对象消耗 1RTT\n  * 流水机制的持久性连接：\n    * HTTP 1.1默认\n    * 客户端遇到一个引用对象就尽快发送请求\n    * 理想情况下收到所有引用对象只需要约 1RTT\n\n响应时间 RTT ： round trip time：从客户端发送一个很小数据包到服务器并返回所经历的时间\n\n##### HTTP请求消息\n\nHTTP协议两类信息：\n\n* 请求消息 request\n  * ASCII：人直接可读\n  * 上传输入的方法：\n    * POST方法：在请求消息的消息体中输入\n    * URL方法：GET方法：输入信息通过request行中的URL段上传\n    * HEAD：请求服务器不要把所请求对象放入相应消息中（只返回头，一般用作测试）\n    * PUT：（HTTP  1.1）消息体中的文件上传到URL段所指定的路径（上传文件到服务器）\n    * DELETE：（HTTP1.1）删除URL字段指定文件\n* 响应消息 response\n  * 状态响应代码：相应消息的第一行\n  * 如 200 OK， 404 Not Found\n\n##### Cookie 方法\n\ncookie技术：网站为辨明用户身份、通过session跟踪而存储在用户本地终端的数据\n\nRFC 6265\n\nCookie组件：\n\n* HTTP响应消息的Cookie头部行\n* HTTP请求消息的Cookie头部行\n* 保存在客户端主机的Cookie文件，由浏览器管理\n* web服务器端的后台数据库\n\nCookie的作用：\n\n* 身份认证、购物车、推荐、email\n\n隐私问题\n\n##### web缓存、代理服务器技术\n\n功能：在不访问服务器的前提下满足客户端的HTTP请求\n\n原因： 性能优化\n\n* 缩短客户请求响应时间\n* 减少机构、组织流量\n* 在大范围内实现有效内容分发\n\n步骤：\n\n* 用户设定浏览器通过缓存进行web访问\n* 浏览器向缓存、代理服务器发送所有HTTP请求\n  * 若请求对象在缓存中 ，则缓存返回对象\n  * 若不在缓存，则缓存服务器向原始服务器发送HTTP请求，获取对象并返回给客户端、并保存对象\n\n解决对象更新问题： 条件性GET\n\n* 若缓存为最新版本，则不需要发送请求对象\n* 缓存服务器请求信息中声明持有版本的日期 modified 日期\n* 目标服务器：\n  * 若缓存版本是最新的，响应消息中不包含对象，返回 304 Not Modified\n  * 若缓存版本不是最新，则返回对象\n\n#### Email 应用\n\n##### email应用概述\n\n构成组件：\n\n* 客户端\n* 服务器\n  * 邮箱：存储发给该用户的email\n  * 消息队列 msessage queue：存储等待发送的email\n* SMTP协议：email消息传输、交换协议\n  * 邮件服务器之间传递消息所使用的协议\n  * 客户端：发送消息的服务器\n  * 服务器：接受消息的服务器\n  * 端口25\n  * 使用TCP 进行可靠传输、持久性连接\n  * 三个阶段：\n    * 握手\n    * 消息传输\n    * 关闭\n  * 命令、相应交互模式：\n    * 命令 command：ASCII文本\n    * 响应 response：状态代码和语句\n  * email消息只能包含7位ASCII码\n\n##### Email消息格式与POP3协议\n\nRFC 822：文本消息格式标准：\n\n* 头部行 header\n  * To 、 From、 Subject\n* 消息体 body\n  * 消息本身，只能是ASCII字符\n\n为了支持多媒体： 使用 MIME 多媒体邮件扩展\n\n* 在邮件头部增加额外的行声明MIME的内容类型\n\n邮件访问协议：收件方从服务器获取邮件\n\n* POP：post office protocol 协议：两个阶段：认证/授权和下载\n  * 模式：\n    * 下载并删除模式：用户换了客户端软件，则无法重读邮件\n    * 下载并保持模式：不同客户端都可以保存拷贝\n  * POP3是无状态协议（服务器没有记忆功能）\n* IMAP: internet mail access protocol协议\n  * 更多功能、更复杂，新于POP3\n  * 可操纵服务器上存储的消息\n  * 所有消息统一保存在服务器\n  * 允许用户利用文件夹组织消息\n  * 支持跨会话Session 的用户状态\n  * 有状态协议\n* HTTP协议： 163、 qq 、 mail\n\n#### DNS应用\n\n##### DNS概述\n\nDNS：domain name system 域名系统：解决Internet上主机、路由器识别问题\n\nDNS域名解析系统：域名和IP地址的映射\n\n* 多层命名服务器构成的分布式数据库\n* 应用层协议：完成名字的解析\n  * Internet核心功能，用应用层协议实现\n  * 网络边界复杂\n\n服务：\n\n* 域名向IP地址翻译\n* 主机别名\n* 邮件服务器别名\n* 负载均衡：web服务器\n\n集中式DNS的问题： 不可伸缩\n\n* 单点失败问题：服务器坏掉\n* 流量问题\n* 距离问题\n* 维护性问题\n\n分布式层次式数据库：\n\n1. 根服务器 root\n2. 顶级域名服务器  com、org、edu等\n\n根域名服务器： 本地域名解析服务器无法解析域名时，访问根域名服务器\n\n* 不知道映射时，访问权威域名服务器\n\n顶级域名服务器 TLD top-level domain：负责com、edu等\n\n权威域名服务器：组织的域名解析服务器，负责解析组织内部服务器的解析服务\n\n* 组织负责维护\n* 服务提供商负责维护\n\n本地域名解析服务器：\n\n* 不严格属于层次体系\n* 每个ISP都有一个本地域名服务器：默认的服务器\n* 本地服务器作为代理，把查询转发给域名解析服务器系统\n* 查询方式：\n  * 迭代查询：获得下一个服务器地址，本地服务器挨个询问\n  * 递归查询：本地服务器把询问任务交给根服务器\n\nDNS记录缓存与更新：\n\n* 本地域名服务器一般会缓存顶级域名服务器的映射\n  * 因此根域名服务器不经常被访问\n\n##### DNS记录与消息格式\n\n资源记录 RR resource records\n\n格式： name value type ttl\n\n类型：\n\n* Type = A\n  * Name：主机域名\n  * value：IP地址\n* Type = NS\n  * Name：域\n  * value：该域的权威域名解析服务器的主机域名\n* Type = CNAME\n  * Name：某一域名的别名\n  * Value：真实域名\n* Type = MX\n  * Value ：与name对应的邮件服务器\n\nDNS协议：\n\n* 查询query 和回复 reply\n* 消息格式相同\n  * 头部：\n    * identification：16位查询编号，回复使用相同编号\n    * flags\n\n### 网络应用（下）\n\n#### P2P应用\n\n##### P2P应用：原理与文件分发\n\n典型协议：BT BitTorrent：\n\n* torrent：交换同一个文件的文件块的节点组\n* tracker：跟踪参与torrent的节点\n\n获取chunk：\n\n* 给定任意时刻，不同节点持有文件的不同chunk集合\n* 节点定期查询每个邻居持有的chunk列表\n* 节点发送请求，请求获取缺失的chunk：\n  * 稀缺优先原则\n\n发送chunk： tit-for-tat：\n\n* 向4个邻居发送chunk：正在向其发送chunk且速率最快的四个\n  * 每10s重新评估top4\n* 每30s随机选择一个其他节点，向其发送chunk\n\n##### P2P应用；索引技术\n\n索引：信息到节点位置（IP地址+端口号）的映射\n\n文件共享：\n\n* 利用索引动态跟踪节点所共享的文件的位置\n* 节点告诉索引它拥有哪些文件\n* 节点搜索索引，获知能够得知哪些文件\n\n即时消息：\n\n* 索引把用户名映射到位置\n* 用户开启IM应用时，需要通知索引它的位置\n* 节点检索索引，确定用户的IP地址\n\n###### 集中式索引\n\nNapster最早采用\n\n1. 节点加入时，通知中央服务器\n   * IP地址\n   * 内容\n2. 节点向中央服务器查找文件\n3. 节点向用户请求文件\n\n缺点： 内容定位高度集中\n\n* 单点失效问题\n* 性能瓶颈\n* 版权问题\n\n###### 洪泛式查询 query flooding\n\n完全分布式架构\n\n每个节点只对自己共享的文件进行索引\n\n覆盖网络 overlay network：\n\n* 节点之间若有TCP连接，则构成一条边\n* 所有活动节点和边构成网络\n* 边：虚拟链路\n* 节点邻居数一般少于10\n\n查询：\n\n* 查询消息通过已有的TCP连接发送\n* 节点转发查询消息\n* 查询命中，则利用反向路径发回查询节点\n\n缺点：消息泛滥、造成网络阻塞\n\n###### 层次式覆盖网络\n\n介于集中式索引和洪泛查询之间\n\n每个节点 要么是超级节点，要么被分配一个超级节点\n\n* 节点和超级节点之间维持TCP连接（集中式索引）\n* 超级节点之间维持TCP连接（洪泛式查询）\n\n超级节点负责跟踪子节点内容\n\n#### Socket编程\n\n###### 应用编程接口API\n\n将应用进程的控制权和操作系统的控制权进行转换的系统接口\n\n典型接口：\n\n* 套接字 socket\n* winsock：Windows Socket interface，微软的套接字接口\n* TLI，transport layer interface 传输层接口\n\n##### Socket API概述\n\n最初面向 BSD UNIX-Berkley\n\nInternet网络应用最典型的API接口\n\n通信模型： 客户、服务器模型\n\n应用进程间通信的抽象机制\n\n标识通信端点（对外）：IP地址+端口号\n\n对内管理套接字：套接字描述符 Socket descriptor\n\nSocket抽象：\n\n* 类似文件的抽象\n* 应用程序创建套接字时，操作系统分配一个数据结构存储该套接字相关信息\n* 返回套接字描述符\n\n##### Socket API函数 Winsock：\n\nWSAStartup：初始化api  ->  应用程序  -> WSACleanup\n\nsocket(protofamily , type, proto )：\n\n * 创建套接字，返回套接字描述符\n * protofamily 协议族  （TCP/IP = PF_INET）\n * type：套接字类型\n * proto：协议号，0为默认\n\n面向TCP/IP 服务类型：\n\n* SOCK_DGRAM：传输层UDP协议：不可靠、无连接、数据报传输\n* SOCK_STREAM：传输层TCP协议：可靠、面向连接、字节流传输、点对点\n* SOCK_RAW：网络层，IP/ICMP/IGMP\n\nint Closesocket( SOCKET sd);\n\n * 关闭一个描述符为sd的套接字\n * 多个进程共享一个套接字时，调用该函数将套接字引用计数减一，减到0才关闭\n * 一个进程多线程对一个套接字使用无计数\n * 返回值：0成功\n\nint bind(sd, localaddr, addrlen);\n\n* 绑定套接字的本地端点地址（IP+端口号）\n* 参数：\n  * 套接字描述符 sd\n  * 端点地址 localaddr： 结构 sockaddr_in\n* 客户端程序一般不必调用bind函数\n* 服务器绑定多IP地址：地址通配符：INADDR_ANY\n\nint listen(sd, queuesize);\n\n* 置服务器端的流套接字处于监听状态\n  * 仅服务器端调用\n  * 仅用于面向连接的流套接字\n* 设置连接请求队列大小 queuesize\n* 返回值：成功 0\n\nconnect( sd, addr , saddrlen);\n\n* 仅用于客户端，使客户套接字与特定计算机的特定端口saddr的套接字进行连接\n* 可用于TCP、 UDP\n  * TCP：建立连接\n  * UDP：指定服务器端点地址\n\nnewsock = accept( sd, caddr, caddrlen);\n\n* 只用于服务器端，只用于TCP套接字\n* 从客户连接请求队列中取出最前的客户请求，并创建一个新的套接字和客户套接字创建连接通道\n* 利用新创建的套接字和客户通信（TCP是点对点的）\n\nsend( sd , *buf, len , flags);\n\nsendto( sd, * buf , len, flags, destaddr, addrlen);\n\n* send函数TCP套接字（客户端或服务器）或调用了connect函数的UDP客户端套接字\n* sendto用于UDP服务器端套接字和未调用connect函数的UDP客户端套接字\n\nrecv，recvfrom 类似send，sendto\n\nsetsockopt、 getsockopt 设置或获取套接字设置\n\n网络字节顺序 network byte order：\n\n​\tTCP/IP定义了标准的用于协议头中的二进制整数表示\n\n​\t某些socket API函数参数需要存储为网络字节顺序（如IP地址、端口号等）\n\n##### 客户端软件设计\n\n解析服务器IP地址： 域名或IP地址转换为32位二进制IP地址：\n\n* inet_addr() 点分十进制IP到32位IP地址\n* gethostbyname() 域名到32位IP地址： 返回指向结构hostent的指针\n* 都返回网络字节顺序\n\n解析端口号： 可能使用服务名（如HTTP）或端口号\n\n* getservbyname() 服务名转为熟知端口号\n\n解析协议号：可能使用协议名（如TCP）指定协议\n\n* getprotobyname() 协议名到协议号的转换\n\nTCP客户端软件流程：\n\n1. 确定服务器IP地址+端口号\n2. 创建客户端套接字\n3. 分配本地端点地址（IP+端口号） （系统自动完成）\n4. 连接服务器套接字\n5. 遵循应用层协议进行通信\n6. 关闭或释放连接\n\nUDP客户端软件流程：\n\n1. 确定服务器IP地址+端口号\n2. 创建客户端套接字\n3. 分配本地端点地址（IP+端口号） （系统自动完成）\n4. 指定服务器端点地址，构造UDP数据报\n5. 遵循应用层协议进行通信\n6. 关闭或释放套接字\n\n##### 服务器软件设计\n\n基本服务器类型：\n\n1. 循环无连接 IteratIve connectionless\n   * 一次只接受一个客户端请求\n   * 无连接：基于UDP\n   * 流程：\n     1. 创建套接字\n     2. 绑定端点地址（INADDR_ANY+端口号）\n     3. 反复接收来自客户端的请求\n     4. 遵循应用层协议，构造响应报文，发送给客户\n   * 服务器端不能使用connect函数\n   * 无连接服务器使用 sendto发送数据报\n   * 客户端端点地址在调用recvfrom接收数据时自动提取\n2. 循环面向连接 Iterative connection-oriented\n   * 流程：\n     1. 创建主套接字，绑定熟知端口号\n     2. 主套接字设置为被动监听模式\n     3. 调用accept接收连接请求，创建新套接字和客户建立连接\n     4. 通过新套接字接收请求、构造并发送响应\n     5. 完成服务后，关闭连接，返回3\n3. 并发无连接 Concurrent connectionless\n   * 流程：\n     1. 主线程1 创建套接字，绑定熟知端口号\n     2. 主线程2 反复调用recvfrom函数，接收请求，创建新线程处理响应\n     3. 子线程1 接收请求\n     4. 子线程2 构造响应报文，调用sendto发送\n     5. 子线程3 退出\n4. 并发面向连接 Concurrent connection-oriented\n   * 流程：\n     1. 主线程1 创建套接字，绑定熟知端口号\n     2. 主线程2 设置主套接字为被动监听模式\n     3. 主线程3 反复调用accept接收连接请求，创建新的子线程处理客户响应\n     4. 子线程1 接收请求（通过新套接字）\n     5. 子线程2 根据协议进行交互\n     6. 子线程3 关闭、释放连接并退出（线程终止）\n\n\n### 传输层（上）\n\n#### 传输层服务概述\n\n传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制\n\n端系统运行传输层协议：\n\n* 发送方：把消息分成多个Segment并传给网络层\n* 接收方：把segment组装成消息，交给应用层\n\n协议类型：\n\n* TCP、UDP\n\n与网络层的区别：\n\n* 网络层提供主机之间的逻辑通信机制\n* 位于网络层之上、依赖网络层\n* 对网络层服务进行（可能的）增强\n\n#### 复用和分用\n\n原因：\n\n* 接收端（多路分用）：传输层将segment交给正确的socket 即正确的进程\n* 发送端（多路复用）：从多个socket接收消息，每块数据封装头部消息，生成Segment，交给网络层\n\n分用工作：\n\n* 主机接收到IP数据报 datagram\n* 每个数据报携带源IP、目的IP，一个传输层的段\n* 每个段携带源端口号、目的端口号\n* 传输层协议根据IP地址和端口号，把Segment导向Socket\n  * TCP做更多处理\n* 无连接分用：UDP：用二元组标识（目的IP，目的端口号）\n* 面向连接的分用：TCP：用四元组（源IP，源端口号，目的IP，目的端口号）\n\n#### UDP\n\nUDP：user datagram protocol 【RFC 768】\n\n特点：\n\n* 基于 IP协议：\n  * 多路复用、分用\n  * 简单的错误校验：端到端原则，不能确保所有链路层协议都有错误检测，也不能确保转发时错误不发生\n* Best effort（尽力而为）服务，UDP可能：\n  * 丢失\n  * 非按序到达\n* 无连接：\n  * 发送方接收方不需要握手、不需要建立连接\n  * 每个UDP段处理独立\n\n价值：\n\n* 无需建立连接：延迟显著减少（2个RTT）（DNS用UDP）\n* 实现简单，无需维护连接状态\n* 头部开销少（8字节 VS  20字节）\n* 没有拥塞控制，上层控制发送时间和速率\n\n用途：\n\n* 常用于流媒体：容忍丢失、速率敏感\n* DNS、SNMP\n* 在其之上实现可靠数据传输：（应用层开发）\n  * 在应用层增加可靠性机制\n  * 应用特定的错误恢复机制\n\n![UDP](http://ot1c7ttzm.bkt.clouddn.com/UDP.png)\n\nUDP校验和 checksum： \n\n* 目的：检测UDP段传输过程中是否发生错误\n* 发送方：\n  * 段内容视为16-bit证书\n  * 校验和计算：求和，进位加到和后面，按位取反\n  * 校验和填入校验和字段\n* 发送方：\n  * 计算校验和\n  * 进行比对：\n    * 不相等：检错\n    * 相等：未检测到错误（可能有错）\n\n#### 可靠数据传输原理\n\n可靠的定义：不错、不丢、不乱\n\n可靠数据传输协议：\n\n* 对应用层、传输层、链路层都重要\n* 信道的不可靠特性决定了可靠数据传输协议rdt的复杂性\n\nRdt 1.0：可靠信道上的可靠数据传输\n\n* 底层信道完全可靠\n* 发送方和接收方 FSM独立\n\nRdt 2.0： 产生位错误：\n\n* 底层信道可能翻转分组中的位\n\n  * 用校验和检测位错误\n\n* 如何从错误中恢复：\n\n  * 确认机制 ACK acknowledgements：接收方显式告知发送方分组已经正确接收\n  * NAK：接收方显式告诉发送方分组有错误\n  * 发送方收到NAK后，重传分组\n\n* 基于重传机制的rdt协议成为ARQ automatic repeat request 协议\n\n* 新机制：\n\n  * 差错检测\n  * 接收方反馈控制消息： ACK、 NAK\n  * 重传\n\n  ![rdt2.0](http://ot1c7ttzm.bkt.clouddn.com/rdt2.0.png)\n\n* 缺陷： ACK、NAK消息发生错误或被破坏 corrupted：\n\n* 解决方案： rdt 2.1\n\n  1. ACK、NAK增加校验和，检错并纠错（代价高）\n  2. 添加额外控制消息\n  3. 发送方重传：可能产生重复分组\n     * 解决重复分组： 序列号 sequence number：发送方给每个分组增加序列号\n     * 接收方丢弃重复分组\n\n* ![rdt2.1](http://ot1c7ttzm.bkt.clouddn.com/rdt2.1.png)\n\n* ![rdt2.1rev](http://ot1c7ttzm.bkt.clouddn.com/rdt2.1rev.png)\n\n  发送方变化：\n\n  * 每个分组增加了序列号(0,1序号)\n  * 需要校验ACK、NAK消息是否错误\n  * 状态数量翻倍\n\n  接收方变化：\n\n  * 需要判断分组是否重复\n\n* Rdt 2.2 ：只使用ACK：检验和+序列号+ACK+重传\n\n  * 接收方通过ACK告知最后一个被正确接收的分组\n  * ACK中显式加入被确认分组的序列号\n  * 发送方收到重复ACK后，重传当前分组\n\nRdt 3.0：既可能错误，也可能丢失：\n\n* 方法：发送方等待 合理 时间：\n  * 没收到ACK，重传\n  * 分组或ACK只是延迟而不是丢了\n  * 增加定时器\n* ![rdt3.0send](http://ot1c7ttzm.bkt.clouddn.com/rdt3.0send.png)\n* 问题：性能很差：停等操作\n\n#### 流水线与滑动窗口协议\n\n流水线机制：\n\n* 允许发送方收到ACK之前连续发送多个分组：\n  * 更大的序列号范围\n  * 发送方、接收方需要更大存储空间缓存分组\n\n滑动窗口协议 sliding-window protocol：\n\n* 窗口：\n  * 允许使用的序列号范围\n  * 窗口尺寸为N：最多由N个等待确认的消息\n* 滑动窗口：\n  * 随着协议的运行，窗口在序列号空间内向前滑动\n* 滑动窗口协议：GBN，SR\n\nGBN go-back-N 协议：\n\n* 发送方：\n  * 分组头有k-bit序列号\n  * 窗口尺寸为N，最多允许N个分组未确认\n  * 累计确认机制：ACK(n)：确认到序列号n（包含n）的分组都被正常接收\n    * 可能收到重复ACK\n  * 空中分组设置计时器 timer\n  * timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组\n* 接收方：\n  * ACK机制：发送拥有最高序列号的，已经被正确接收的分组的ACK\n    * 可能产生重复ACK\n    * 只需记住唯一的expectedseqnum\n  * 乱序到达的分组：\n    * 直接丢弃\n    * 重新确认序列号最大的、按序到达的分组\n* 缺陷：\n  * 重传大量不必要分组\n\nSR selective repeat协议：\n\n* 接收方对每个分组单独进行确认\n  * 设置缓存机制，缓存乱序到达的分组\n* 发送方只重发没收到ACK的分组\n  * 为每个分组设置定时器\n* 发送方窗口不变化\n* 新增接收方窗口\n* ![sr](http://ot1c7ttzm.bkt.clouddn.com/sr.png)\n* SR协议问题： 困境\n  * 出现原因：序列号少且窗口尺寸大\n  * 解决： $N_S + N_R <= 2^k $\n\n\n### 传输层（下）\n\n#### 面向连接传输协议 TCP\n\n概述：\n\n* 点对点\n* 可靠的、按序的字节流\n* 流水线机制： TCP拥塞控制和流量控制机制动态设置窗口尺寸\n* 发送方、接收方缓存\n* 全双工：同一连接双向传输数据\n* 面向连接：\n  * 通信双方在发送数据前必须建立连接\n  * 连接状态只在两端维护\n  * TCP连接包括： 两台主机上的缓存、连接状态变量、Socket等\n* 流量控制机制\n\n\n序列号：\n\n* 序列号指的是Segment第一个字节的编号，而不是Segment的编号\n* 建立连接时，双方随机选择序列号\n\nACK：\n\n* 希望接收的下一个字节的序列号\n* 累计确认：该序列号之前的所有字节都已被正确接收\n\n乱序到达的Segment：没有规定，由TCP实现者做决策\n\n![TCP](http://ot1c7ttzm.bkt.clouddn.com/TCP.png)\n\n##### TCP可靠数据传输\n\n概述：\n\n* 流水线机制\n* 累计确认\n* 单一重传计时器\n* 触发重传事件：\n  * 超时\n  * 受到重复ACK\n\nRTT与超时时间设置：\n\n* 需要大于RTT：但RTT是变化的\n* 超时时间 = 平均RTT + 4*安全时间\n* 安全时间 =  0.25*|平均RTT-RTT|+0.75旧安全时间\n\n发送方事件：\n\n* 从应用层收到数据：\n  * 创建Segment\n  * 开启计时器\n  * 设置超时时间\n* 超时：\n  * 重传超时的Segment\n  * 重启计时器\n* 收到ACK\n  * 未确认的Segment：\n    * 更新sendbase\n    * 窗口若还有未确认的分组，重启计时器\n\n快速重传机制：\n\n* 如果超时，超时时间间隔重新设置，导致其很大\n* 通过重复ACK检测分组丢失：\n  * 发送方收到同一分组的3次ACK，则立刻重传\n\n##### TCP 流量控制\n\n原因：接收方为TCP设置了buffer，上层应用可能处理buffer的速度太慢\n\n实现：接受者在Segment的头部信息的revwindow告诉发送方还剩余多少可用空间，发送方限制数据不超过revwindow的大小\n\n##### TCP连接管理\n\n* 初始化TCP变量：\n  * 选择序列号\n  * 设置缓存和流量控制信息\n* client：连接发起者\n* server：等待连接请求\n* 三次握手建立连接：\n  1. 客户端向server发送 SYN段\n     * 不携带任何数据\n     * SYN标志位为1\n     * 传递初始序列号\n     * SYN=1，seq=client_isn\n  2. 服务器接到SYN，同意后发送 SYNACK段\n     * 服务器分配缓存\n     * 选择自己的初始序列号\n     * SYN=1, seq=server_isn，ack=client_isn+1\n  3. 客户端受到SYNACK，回复ACK报文段，SYN不再置1，可能有数据\n     * SYN=0, seq=client_isn+1 , ack=server_isn+1\n* 连接关闭：\n  1. 客户端向服务器发送 FIN 控制段\n  2. 服务器收到FIN，回复ACK，关闭连接，发送FIN\n  3. 客户端收到FIN，回复ACK：进入等待状态，若收到FIN，重发ACK\n  4. 服务器收到ACK，真正关闭连接\n\n#### 拥塞控制问题\n\n拥塞 congestion： 太多主机发送太多数据或速度太快以致网络无法处理\n\n表现：\n\n* 分组丢失（路由器缓存溢出）\n* 分组延迟过大（在路由器缓存中排队）\n\n拥塞控制 （网络阻塞） vs 流量控制（接收方处理不过来）\n\n为什么拥塞控制要在传输层进行\n\n拥塞控制方法：\n\n* 端到端的拥塞控制：\n  * 网络层不需要显式提供支持\n  * 端系统通过观察loss、delay等网络行为判断是否发生拥塞\n  * TCP采用这种方法\n* 网络辅助的拥塞控制：\n  * 路由器向发送方显式反馈网络拥塞信息\n  * 简单的拥塞指示(1-bit)：SNA、DECbit，TCP/IP ECN, ATM\n  * 指示发送方应该采用何种速率\n\nATM ABR拥塞控制  available bit rate：\n\n* 弹性服务\n* 发送方路径可用：使用可用贷款\n* 发送方路径堵塞：发送速率降到最低保障速率\n* RM resource management cell：\n  * 发送几个数据段就发送一个RM cell\n  * 发送方发送\n  * 交换机设置 RM cell位（网络辅助）\n    * NI bit：rate不许增长\n    * CI bit：拥塞指示\n  * RM cell由接收方返回给发送方\n  * RM cell有显式的速率ER 字段：两个字节：\n    * 拥塞的交换机可以把ER设置为更低的值\n    * 发送方获知路径所能支持的最小速率\n  * 数据cell的EFCI位：拥塞的交换机将其设置为1：\n    * 若RM cell前data cell的EFCI位设置为1，那么发送方在返回的RM cell中置CI位\n\nTCP拥塞控制：\n\n* 如何控制发送速率：\n\n  * 拥塞窗口 CongWin：\n    * LastByteSent-LastByteAcked <= CongWin\n    * 速率 ≈ CongWin / RTT byte/sec\n    * 动态调整以改变发送速率\n    * 反映所感知的网络拥塞\n\n* 如何感知拥塞状况：\n\n  * Loss事件 = timeout 或 3个重复ACK\n  * 发生loss事件后，发送方降低速率\n\n* 如何合理调整发送速率：\n\n  * 加性增- 乘性减： AIMD\n    * 原理：谨慎探测可用带宽，逐渐增加速率，直到loss，一旦loss，快速降低速率\n    * additive increase：每个RTT将CongWin增大一个MSS（拥塞避免）\n    * multiplicative decrease：发生loss后CongWin减半\n  * 慢启动： SS\n    * TCP建立时，CongWin=1，可用带宽可能远高于初始速率，希望快速增长\n    * 原理：连接开始时，速率指数增长（收到每个ack时 CongWin+1）\n  * 何时从指数增长切换到线性增长：\n    * 当CongWin达到loss事件前值的一半时\n    * Threshold记录loss事件前CongWin值的1/2\n  * Loss事件的处理：\n    * 3个重复ACK：\n      * CongWin切到一半\n      * 而后线性增长\n      * 原因：能收到3个ACK说明网络还能传输\n    * timeout：\n      * CongWin直接减为1个MSS\n      * 而后指数增长\n      * 达到threshold后再线性增长\n      * 原因：timeout说明网络拥塞更严重\n\nTCP的公平性：\n\n* 公平性与UDP：\n  * 多媒体应用通常不适用TCP，以免被拥塞控制机制限制速率\n  * 使用UDP：以恒定速率发送，能容忍丢失\n  * 产生不公平\n* 都使用TCP：\n  * 可能打开多个并发连接\n  * 如WEB浏览器\n  * 产生公平性问题\n\n### 网络层服务（上）\n\n#### 网络层\n\n源主机向目的主机发送数据报\n\n每个主机和路由器都运行网络层协议\n\n路由器检验所有穿越它的IP数据报的头部域：决策如何处理IP数据报\n\n网络层核心功能：\n\n* 转发 forwarding：\n  * 功能：分组从路由器输入端口转移到合适的输出端口\n  * 路由器维护转发表：确定在该路由器中根据地址信息转发到哪条链路\n* 路由 routing：\n  * 确定分组从源到目的经过的路径\n  * 根据 路由算法 routing algorithms\n* 连接建立：不是所有网络都需要\n  * 数据分组传输之前两端主机需要首先建立虚拟连接\n    * 网络设备（路由器）参与连接的建立\n\n网络层服务模型：\n\n* 无连接服务 connection-less service：\n  * 特点：\n    * 不事先为系列分组的传输确定传输路径\n    * 每个分组独立确定传输路径\n    * 不同分组可能路径不同\n  * 典型例子：数据报网络 datagram network\n* 连接服务：\n  * 特点：\n    * 首先为系列分组传输确定路径\n    * 沿路径传输系列分组\n    * 系列分组传输路径相同\n    * 传输结束后拆除连接\n  * 典型例子：虚电路网络 virtual-circuit network\n\n#### 虚电路网络和数据报网络\n\n##### 虚电路网络\n\n提供网络层连接服务\n\n一条从源主机到目的主机，类似电路的路径：\n\n* 分组交换\n* 每个分组的传输利用链路的全部带宽\n* 源到目的主机经过网络层设备共同完成虚电路建设\n\n通信过程： 呼叫建立 call setup -> 数据传输 -> 拆除呼叫\n\n每个分组携带虚电路标识 VCID，而不是目标主机地址\n\n每个网络设备都需要维护经过它的虚电路连接状态\n\n可以面向虚电路VC 进行预分配资源：\n\n* 如ATM的电路仿真 CBR\n\n具体实现：\n\n* 每条虚电路包括：\n  1. 从源主机到目的主机的一条路径\n  2. 虚电路号 VCID，沿路每段链路一个编号（不可能统一编号，因为每段链路负载不一样）\n  3. 沿途每个网络设备，利用转发表记录经过的每条虚电路\n* 路由器转发分组时根据转发表改写、替换VCID\n* 转发表包括： 输入接口+输入VC+输出接口+输出VC\n\n虚电路信令协议 signaling protocols：\n\n* 用于虚电路的建立、维护及拆除\n  * 路径选择\n* 应用于虚电路网络，如ATM，帧中继 frame-relay网络等\n* 目前的Internet不采用\n\n##### 数据报网络\n\n提供网络层无连接服务\n\n每个分组携带目的地址\n\n路由器根据目的地址转发分组：\n\n* 根据路由协议、路由算法构建转发表\n* 检索转发表\n* 每个分组独立选路\n\n数据报转发表：\n\n* 转发表中目的地址针对地址范围\n* 最长前缀匹配优先：优先选择匹配前缀最长的入口\n\n\n\n数据报网络和VC网络的对比：\n\n* 数据报网络 Internet：\n  * 计算机之间数据交换：\n    * 时间要求不严格\n  * 链路类型众多：\n    * 特点、性能各异\n    * 统一服务困难\n  * 智能端系统（计算机）\n  * 简化网络，复杂边缘\n* VC网络 ATM：\n  * 电话网络演化而来\n  * 核心业务是实时对话：\n    * 严格时间、可靠性\n  * 非智能端系统（电话机、传真机）\n  * 简化边缘，复杂网络\n\n#### IP协议\n\nICMP协议（IP协议的伴随协议）：\n\n* 差错报告\n* 路由器信令\n\nIP数据报：\n\n* 格式：\n  * 头部\n    * 固定部分：20字节\n    * ![IP](http://ot1c7ttzm.bkt.clouddn.com/IP.png)\n      * 版本号： 4-bit，IP协议的版本： 4：ipv4, 6：ipv6\n      * 首部长度：4-bit：IP分组首部长度，以4字节为单位\n      * 服务类型 TOS，占 8-bit：指示期望获得哪种类型的服务\n        * 98年改名为区分服务，只有在网络提供区分服务diffserv时使用\n        * 一般不使用，通常为00H\n      * 总长度： 16-bit， IP分组的总字节数（首部+数据），最多可以放65535-20 Byte\n      * 生存时间 TTL，8-bit：IP分组在网络中可以通过的路由器数，路由器转发一次分组，TTL-1，TTL==0时路由器丢弃该分组\n      * 协议，8-bit：指示IP分组封装的是哪个协议的数据报，实现复用、分解， 6：TCP， 17：UDP\n      * 首部校验和 16-bit：对IP首部差错检测，计算校验和时该字段置0，逐跳计算，逐跳检验\n      * 源IP地址、目的IP地址，各32-bit\n    * 可变部分： 0字节<=长度<=40字节，携带安全、源选路径、时间戳和路由记录等内容，实际很少被使用\n    * 填充部分：长度可变， 0<=长度<=3B，目的是补齐首部符合32位对齐\n  * 数据\n\nIP分片：\n\n* 最大传输单元 MTU：链路层 数据帧可封装数据的上限，不同链路MTU不同\n* 当大IP分组向小MTU链路转发时，**可以**被分片 fragmented，若不允许分片且放不下，则将分组扔掉\n* 一个大IP分组分成多个小IP分片，IP分片到达目的主机进行重装 reassembled\n* IP首部的相关字段用于标识分片以及确定分片的相对顺序\n* 涉及字段：\n  * 总长度\n  * 标识 16-bit：用于标识一个IP分组，每产生一个IP分组计时器加1，作为该IP分组的标识\n  * 标志位 3-bit：保留，DF don't fragment ， MF more fragment：\n    * DF=1：禁止分片   DF=0：允许分片\n    * MF=1：非最后一片， MF=0：最后一片（或未分片）\n  * 片偏移 13-bit：一个IP分组分片封装原数据的相对偏移量（未分片则为0），以8字节为单位\n\n分片过程：\n\n* 若 总长度>MTU且 DF=0，则分片\n* 每个分片标识复制原IP分组的标识\n* 除最后一片，其他分片均分为MUT最大允许分片\n* 一个最大分片可封装的数据应该是8的倍数，可封装数据为 d = [ (M-20) / 8]*8（向下取整）（20字节头部）\n* 需要总的片数  n = [(L-20)/d] (向上取整)\n* 每片的片偏移字段取值为  F = d/8 * (i-1)  1<=i<=n\n* 每片总字段长度   Li = d+20 （非最后一片）  Li= L-(n-1)d （最后一片）\n\n#### IP编址 addressing\n\n接口 interface：主机、路由器与物理链路的连接：\n\n* 实现网络层功能\n* 路由器通常有多个接口\n* 主机通常只有一个或两个接口\n\nIP地址：32-bit  IPv4：\n\n* 编号标识主机、路由器的接口\n* 32-bit =》  4个8bit的点分十进制地址\n* IP地址与每个接口关联\n* 如何为接口分配IP地址：\n  * IP地址分为两部分：网络号netID （高位）+ 主机号hostID（低位）：\n  * IP子网 subnet：\n    * IP地址具有相同网络号的设备接口\n    * 不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口\n\n##### 有类IP地址\n\n有类编址：\n\n* A类地址 （50%） （第一位为0）  netID 8-bit，hostID 24-bit  0.0.0.0~127.255.255.255\n\n* B类地址 （25%）（1\\2位为10） netID 16-bit  hostID 16-bit   128.0.0.0~191.255.255.255\n\n* C类地址（12.5%）（11） netID 24-bit， hostID 8-bit   192.0.0.0~223.255.255.255\n\n* D、E不再区分netID和hostID\n\n  * D类地址（6.25%）（1110） ：多播地址\n    * 用作特殊目的：命名或标识一组主机，理论上可分布在任何地方，只能向其发送数据\n  * E类地址（6.25%）（1111）：研究所用\n\n* 特殊IP地址\n\n  ![特殊IP](http://ot1c7ttzm.bkt.clouddn.com/specialIP.png)\n\n* 私有地址：只用于内部网络，在公共环境无效\n\n  * A类： netID 10 ，1个\n  * B类： netID 172.16到172.31      16个\n  * C类： netID 192.168.0 到 192.168.255      255个 \n\n##### IP子网及子网掩码\n\n子网划分：\n\n* IP地址：\n  * 网络号 netID：高位比特\n  * 子网号 subid ：原网络主机号部分比特\n  * 主机号 hostID：低位比特\n* 子网掩码：\n  * 确定是否划分了子网，利用多少位划分子网\n  * 形式和IP地址相同， 32-bit，点分十进制形式\n  * 取值： netID、subID全取1，hostID位全取0\n  * 默认子网掩码：\n    * A类默认子网掩码：255.0.0.0\n    * B类默认子网掩码：255.255.0.0\n    * C类默认子网掩码：255.255.255.0\n    * 借用3比特划分子网的B类子网掩码 255.255.224.0\n  * 子网地址 + 子网掩码 ：准确确定子网大小\n  * 应用：\n    * IP分组的目标IP地址与子网掩码按位与运算提取子网地址\n    * 子网地址，地址范围 -> 去除不可用地址 -> 可分配地址范围\n\n\n### 网络层（中）\n\n#### CIDR与路由聚合\n\n无类域间路由 classless interdomain routing：\n\n* 消除ABC类地址界限\n  * netID + subID -> 网络前缀 prefix  任意长度\n* 融合子网地址和子网掩码，方便子网划分\n  * 无类地址格式： a.b.c.d/x  x为前缀长度\n* 优点：\n  * 提高IPV4地址空间分配效率\n  * 提高路由效率：\n    * 将多个子网聚合成一个大网\n    * 构造超网（supernetting）\n    * 路由聚合（route aggregation）\n\n\n#### DHCP协议\n\n主机如何获得IP地址：\n\n* 硬编码：\n  * 静态配置（自行填写）\n    * 默认网关：数据报转发到的路由器默认接口的IP地址\n  * 动态配置协议 DHCP dynamic host configuration protocol：\n    * 从服务器动态获取\n      * IP地址\n      * 子网掩码\n      * 默认网关\n      * DNS服务器名称及IP\n    * 在应用层实现，封装在UDP数据报\n    * 即插即用的协议\n    * 允许地址重用\n    * 支持在用地址续租\n    * 支持移动用户加入网络\n    * 与DHCP服务器交换报文：\n      * 发现报文DHCP discover：客户端进行广播，确认服务器的地址\n      * 提供报文DHCP offer：DHCP服务器利用提供报文进行广播响应并发送IP地址\n      * 请求报文DHCP request：主机广播发送以请求IP地址，并通知其它可能的DHCP服务器回收资源\n      * 确认报文DHCP ack：服务器向主机发送确认消息\n\n#### NAT 网络地址转换\n\n所有离开内网的源IP需要替换成相同NAT的IP地址及不同端口号\n\n动机：\n\n* 只需/只能从ISP申请到一个IP地址\n  * IPV4耗尽\n* 本地网络设备IP地址变更，无需通告外界网络\n* 变更ISP时无需修改内网IP\n* 内网设备对外网不可见，不能直接寻址（安全）\n\n实现：\n\n* 替换：（内到外）\n  * 离开内网的IP数据报的源IP地址及源端口号替换NAT的IP地址及新端口号\n* 记录：\n  * 每对（NAT IP地址及新端口号）与（源IP地址及端口号）替换信息存储到NAT转换表\n* 替换：（外到内）\n  * 发回的数据报，利用NAT转换表替换IP地址和端口号\n\n问题：\n\n* 16-bit端口号字段（0-65535），可以同时支持6万多并行连接\n* 争议：\n  * 路由器应只处理第三层功能（NAT修改了第四层数据段的内容）\n  * 违背了端到端通信原则\n    * 应用开发者必须考虑到NAT的存在，如P2P应用\n  * 地址短缺问题应该由IPv6解决\n\nNAT穿透方案：\n\n* 静态配置NAT：特定端口总是与特定内部IP及端口连接\n* 利用UPnP universal plug and play 互联网网关设备协议IGD internet gateway device自动配置:\n  * 内网主机自动学习到NAT公共IP地址\n  * 在NAT转换表中，增删端口映射\n* 中继 （如 Skype）：\n  * NAT内部客户与中继服务器建立连接\n  * 外部客户也和中继服务器建立连接\n  * 中继服务器桥接两个连接的分组\n\n#### ICMP互联网控制报文协议\n\ninternet control message protocol 互联网控制报文协议支持主机和路由器：\n\n* 差错或异常报告（反馈）\n* 网络探询（主动发送）\n\n分类：\n\n* 差错报告报文（5种）：\n  * 目的不可达\n  * 源抑制 source quench：拥塞控制，路由器向源主机发送，让其降低发送分组速度\n  * 超时、超期（如TTL 可以跨越的路由器数目）\n  * 参数问题：路由器认为IP数据报头部数据有问题\n  * 重定向 redirect：路由器认定路径不对\n* 网络探询（2组）：\n  * 回声（Echo）请求与应答报文（Reply）：探测到目标主机的网络是否通达，如 ping\n  * 时间戳请求与应答报文\n\n不发送ICMP的特殊情况：\n\n* 对ICMP差错报文不再发送ICMP\n* 除对第一个分片外，后续分片都不发送ICMP\n* 所有多播IP数据报都不发送\n* 对特殊地址的IP数据报不发送ICMP\n\n不再使用的ICMP报文：\n\n* 信息请求与应答\n* 子网掩码请求与应答\n* 路由器询问和通告\n\n报文格式：\n\n* ICMP报文封装到IP数据报的数据部分传输\n* ICMP头部：类型、代码、校验和\n\nICMP的应用：Traceroute\n\n#### IPv6\n\n动机：\n\n* 32位ipv4地址空间分配殆尽\n* 改进首部格式：\n  * 快速处理、转发数据报\n  * 支持QoS\n\n数据报格式：\n\n* 固定长度的40字节基本首部\n* 路由器不允许分片（若要分片，源主机分）\n* 基本首部+扩展首部（路由器一般不处理）+数据部分\n* 扩展首部+数据 = 载荷（0至64KB）\n* ![ipv6](http://ot1c7ttzm.bkt.clouddn.com/ipv6.png)\n* 流标签 flow label：标识同一流中的数据报\n* 下一个首部 next header：标识下一个选项首部或上层协议首部\n* 跳步限制：TTL：允许经过的路由器数目\n\n与IPV4的对比：\n\n* 无校验和：以减少每跳处理时间\n* 通过多个选项首部 支持 选项\n* ICMPv6：新版ICMP：\n  * 附加报文类型： packet too big\n  * 多播组管理功能\n\n地址表示：\n\n* 一般形式：冒号分割的8组16进制数，每组4个数字\n* 压缩：用两个连续冒号省略中间的0\n* 兼容ipv4：前8个bit都为0:0:0:0:0：FFFF：ipv4地址 或 ::FFFF:ipv4\n* 地址前缀：ipv6不再使用掩码\n\n基本地址类型：\n\n* 单播unicast： 一对一通信\n* 多播multicast：一对多通信\n* 任意播 anycast：一对一组之一（最近一个）通信\n\nIPV4向IPV6过渡：\n\n* 隧道 tunneling：IPV6数据报作为ipv4数据报的载荷进行封装穿越ipv4的网络\n\n\n### 网络层（下）\n\n#### 路由算法\n\n概念：寻找最小费用路径的算法\n\n静态路由 vs 动态路由：\n\n* 静态路由：\n  * 手工配置的路由\n  * 路由更新慢\n  * 优先级高\n* 动态路由：\n  * 计算得来的路由\n  * 更新快\n    * 定期更新\n    * 及时响应连路费用或网络拓扑变化\n\n全局信息 vs 分散信息：\n\n* 全局信息：\n  * 所有路由器掌握完整网络拓扑和链路费用\n  * 典型算法：链路状态LS路由算法\n* 分散decentralized信息：\n  * 只掌握物理相连的邻居及链路费用\n  * 通过邻居间信息交换及迭代运算\n  * 典型算法：距离向量DV路由算法\n\n\n\n链路状态路由算法：\n\n* 所有路由器掌握网络拓扑和链路费用\n* 通过链路状态广播\n* 采用 dijkstra算法在每个路由器计算单源最短路\n* 存在 震荡oscillations 可能\n\n距离向量（Distance Vector）路由算法：\n\n* 每个路由器只掌握物理相连的邻居及链路费用\n* Bellman-Ford方程（动态规划）\n* 步骤：\n  * 每个结点不定时将自己的DV估计发送给邻居\n  * 结点接收到邻居的新的DV估计时，依据BF更新其自身估计，若估计变化了，则传播给邻居\n  * 距离最终收敛于实际的最小费用\n* 特点：\n  * 异步迭代\n    * 引发局部迭代的因素：\n      * 局部链路费用改变\n      * 邻居的DV更新\n  * 分布式：结点只当自己DV变化时才告诉邻居\n  * 好消息（高费降低费）传播快，坏消息（低费升高费）传播慢\n  * 可能有 无穷计数 count to infinite 问题，解决方案：\n    * 毒性逆转技术 poisoned reverse：\n      * 若Z到X的最小路径是通过Y，则y收到Z到X的费用是正无穷\n    * 定义最大度量 maximum metric：\n      * 定义一个最大的有效费用值，超过最大费用的记为无穷\n\n层次路由：\n\n* 提出原因：把网络抽象为一个图计算路由过于理想化，网络规模过大，管理自治\n* 聚合路由器为一个区域：自治系统AS autonomous system\n* 同一AS内路由器运行相同路由协议算法\n  * 自治系统内部路由协议\n  * 不同自治系统内的路由器可以运行不同的AS内部路由协议\n* 网关路由器 gateway router：\n  * 位于AS边缘\n  * 通过链路连接其他AS的网关路由器\n* 转发表由AS内部路由算法和AS间路由算法共同配置\n* 热土豆路由：将分组发给最近的网关路由器\n\n#### Internet 路由\n\n路由协议：\n\n* AS内部路由： 内部网关协议 IGP interior gateway protocols\n  * 路由信息协议  RIP routing information protocol：\n    * 距离向量路由算法\n    * 距离用跳步数度量（最大有效为15跳步）\n    * 通告advertisement ：每30s，邻居交换一次DV\n    * 每次通告：最多25个目的子网\n    * 链路失效、恢复：\n      * 180s没有收到通告 -> 邻居、链路失效 -> 重新计算路由 -> 向邻居发送新的通告 -> 邻居可能向外发送通告\n    * RIP路由表处理：利用一个称作route-d的应用层进程进行管理\n    * 通告报文周期性通过UDP数据报发送\n  * 开放最短路径优先 OSPF open shortest path first：\n    * 链路状态路由算法：所有路由器对整个网络已知，dijkstra求解：\n      * LS分组扩散（通告）\n      * 每个路由器构造完整的网络AS拓扑图\n      * 利用dijkstra计算\n    * 每个入口对应一个邻居\n    * 通告在整个AS中泛洪\n    * 通告报文直接封装到IP数据报中\n    * 优点：\n      * 安全：所有OSPF报文可以被认证（预防恶意入侵）\n      * 允许使用多条到同一目的的相同费用的路径（RIP只能从中选一条）\n      * 对同一链路针对不同TOS设置不同费用度量\n      * 集成单播与多播路由：\n        * 多播OSPF协议（MOSPF）与OSPF利用相同的拓扑数据\n      * 支持大规模AS分层 hierarchical：\n        * 区边界路由器：同时在主干区和分支区的路由器\n        * 主干路由器：只在主干区\n        * AS边界路由器：连接其它AS\n  * 内部网关路由协议 IGRP interior gateway routing protocol（思科的私有协议）\n* AS间路由协议：BGP border gateway protocol：\n  * 事实上的标准域间路由协议\n  * 为每个AS提供了一种手段：\n    * eBGP：从邻居AS获取子网可传达性信息（外部会话）\n    * iBGP：向所有AS内部路由器传播子网可达性信息（内部会话）\n  * 基础：\n    * BGP会话session：两个路由器交换BGP报文\n      * 通告去往不同目的前缀（子网）的路径\n      * 报文交换基于半永久的TCP连接\n    * BGP报文：\n      * OPEN：建立TCP连接并认证发送方\n      * UPDATE：通告新路径（或撤销原路径）\n      * KEEPALIVE：无UPDATE时保活连接，也用于对OPEN的确认\n      * NOTIFICATION：报告先前报文的差错，也用于关闭连接\n    * 路径信息与BGP路由：\n      * 通告的前缀信息包括BGP属性\n        * 前缀+属性 = “路由”\n      * 两个重要属性：\n        * AS-PATH  AS路径：包含前缀通告所经过的AS路径\n        * NEXT-HOP下一跳：开始一个AS-PATH的路由器的接口，指向下一跳AS\n  * 路由选择：网关路由器收到路由通告后，利用输入策略import policy决策接收或拒绝路由：\n  * 多条路径的挑选准则：\n    1. 本地偏好preference值策略\n    2. 最短AS-PATH\n    3. 最近NEXT-HOP路由器：热土豆路由\n    4. 附加准则\n* 采用不同的AS内、AS间路由协议原因：\n  * 策略：\n    * AS间inter-AS：希望能够管理控制流量如何被路由，谁路由经过网络\n    * intra-AS 内部：单一管理，无需策略决策\n  * 规模：\n    * 层次路由节省路由表大小，减少更新流量\n    * 适应大规模互联网\n  * 性能：\n    * inter-AS间：策略主导\n    * intra-AS内：侧重性能\n\n\n### 数据链路层\n\n#### 链路层服务\n\n术语：\n\n* 结点 nodes：主机和路由器\n* 链路 links：连接相邻结点的通信信道：\n  * 有线链路 wired links\n  * 无线链路 wireless links\n  * 局域网 LANS\n* 帧 frame：链路层的数据分组，封装网络层的数据报\n\n功能：负责通过链路在相邻结点间传输数据报\n\n服务：\n\n* 组帧 framing：\n  * 封装数据报构成数据帧，加头加尾\n  * 帧同步\n* 链路接入 link access：\n  * 若是共享介质时，需要解决信道接入 channel access\n  * 帧首部的MAC地址 ( 物理地址 )，用于标识帧的源和目的\n* 相邻结点间的可靠交付\n  * 低误码率的有线链路很少采用（如光纤，某些双绞线）\n  * 无线链路：误码率高，需要可靠交付\n* 流量控制 flow control：\n  * 协调pacing相邻发送结点与接收\n* 差错检测 error detection：\n  * 应对信号衰减和噪声\n  * 接收端检测到差错：重传或丢弃\n* 差错纠正 error correction （个别协议）：\n  * 纠错编码：接收端可以直接纠正比特差错\n* 全双工和半双工的通信控制\n\n具体实现：\n\n* 链路层在网络接口卡实现\n* 由硬件、软件和固件组成\n* 链接主机的系统总线\n\n#### 差错编码\n\n原理：\n\n* 在数据上增加冗余信息 R 称为监督位或冗余比特\n\n分类：\n\n* 分组码\n  * 线性码\n  * 非线性码\n* 卷积码\n\n差错编码的检错能力：\n\n* 差错编码分为 检错码 和 纠错码\n* 对于检错码，若编码集的汉明距离d = r+1 ， 则该差错编码可以100%检测 r位差错\n  * 汉明距离：编码集中任意两个字符编码不同比特数目的最小值\n* 对于纠错码，汉明距离 d=2r+1，则该差错编码可以100%纠正r位差错（纠成与之距离最近的码字）\n\n常见差错编码：\n\n* 奇偶校验码：0的个数或1的个数加上冗余位为奇数或偶数\n  * 1比特校验位：检测奇数位差错，冗余位少\n  * 二维奇偶校验：\n    * 检测所有奇数位差错、部分偶数位差错\n    * 可以检测同一行或同一列差错\n* Internet校验和  checksum：\n  * 数据划分为16位二进制整数序列\n  * 求和后取反码\n* 循环冗余校验码 CRC\n  * 数据 D 看成一个二进制数\n  * 选择一个 r+1 位的生成比特模式 G\n  * 目标：选择 r 位CRC比特 R 满足 < D,R >刚好可以被G整除\n  * R计算方法： \n    * $ D*2^{r} (XOR)  R = n*G$\n    * $ R =( D*2^r ) mod G $\n  * 可以检测所有突发长度小于r+1位差错\n  * 广泛应用于实际网络\n\n#### 多路访问控制 MAC 协议\n\n两类链路：\n\n* 点对点链路：\n  * 拨号接入的PPP\n  * 以太网交换机和主机间的点对点链路\n* 广播链路（共享介质）\n  * 单一共享广播信道\n  * 两个或两个以上结点同时传输：干扰 interference\n    * 冲突 collision：结点同时接收多个信号\n  * 多路访问控制协议 MAC multiple access control protocol：\n    * 采用分布式算法决定结点如何共享信道\n    * 基于信道本身进行协调\n      * 无带外信道进行协调\n    * 理想的MAC协议：\n      * 完全分散控制：\n        * 无需特定结点协调\n        * 无需时钟、时隙同步\n      * 需要发送数据的结点平分链路带宽\n      * 简单\n    * 分类：\n      * 信道划分 channel partitioning MAC协议：\n        * 多路复用技术 TDMA、FDMA、CDMA、WDMA等\n        * 网络负载重时公平、效率高\n        * 负载轻时效率低\n      * 随机访问 random access MAC协议：\n        * 信道不划分，允许冲突\n        * 采用冲突恢复机制\n        * 结点要发送数据时\n          * 用信道的全部速率发送分组\n          * 没有事先的节点间协调\n        * 需要定义：\n          * 如何检测冲突\n          * 如何从冲突中恢复（通常是延迟重传）\n        * 负载重时冲突大、效率低\n        * 负载低时效率高\n        * 典型随机访问MAC协议：\n          * 时隙soted ALOHA：\n            * 假定：\n              * 假设所有帧大小相等\n              * 时间划分成等长时隙（每个时隙可以传1个帧）\n              * 结点只能在时隙开始时发送帧\n              * 结点间时钟同步\n            * 运行：\n              * 有帧时，在下一个时隙发送：\n                * 无冲突：在下一个时隙发新的帧\n                * 有冲突：在下一个时隙以概率p重发，直至成功\n            * 优点：\n              * 单个结点活动时用整个信道速率\n              * 高度分散化：只需要同步时隙\n              * 简单\n            * 缺点：\n              * 容易冲突，浪费时隙\n              * 空闲时隙\n              * 时钟同步\n              * 效率低，最好情况 37%\n          * ALOHA：\n            * 无时隙划分，纯ALOHA，更简单，无需同步\n            * 有新的帧生成时：立即发送\n            * 冲突可能性大\n            * 比时隙ALOHA协议效率更低，18%\n          * CSMA、CSMA/CD、CSMA/CA\n            * CSMA 载波监听多路访问协议 carrier sense multiple access：发送帧之前监听信道：\n              * 信道空闲：发送完整帧\n              * 信道忙：推迟发送：\n                * 1-坚持CSMA：以概率p=1监听信道\n                * 非坚持CSMA：随机等待一段时间后再监听\n                * P-坚持CSMA：以概率p坚持监听，1-p非坚持\n              * 冲突仍然可能发送：信号传播延迟\n              * 继续发送冲突帧：浪费信道资源\n            * CSMA/CD CSMA with Collision Detection 带冲突检测的CSMA协议：短时间内可以检测冲突\n              * 广泛用于以太网\n              * 检测到冲突后，立刻停止传输\n              * 冲突检测：\n                * 有线局域网易实现：测量信号强度\n                * 无线局域网难实现：接收信号强度淹没在本地发射信号强度下\n              * 边发边听，不发不听\n              * Lmin / R = RTTmax （Lmin：数据帧最小长度，R：网络带宽，RTT：消息来回的时间），发送数据时能够检测到冲突的最小长度，防止数据在冲突时已经发完，因不发不听而不知道有冲突\n            * CSMA/CA 应用于802.11无线局域网\n      * 轮转 taking turns MAC协议：\n        * 结点轮流使用信道\n        * 综合信道划分和随机访问的优点\n        * 类型：\n          * 轮询 polling：\n            * 主结点轮流邀请从属结点发送数据\n            * 典型应用： 哑dump（非智能、蓝牙）从属设备\n            * 问题：\n              * 轮询开销，数据占用带宽\n              * 等待延迟\n              * 单点故障，主结点故障问题\n          * 令牌传递 token passing：\n            * 控制令牌依次从一个结点传递到下一个结点\n            * 令牌：特殊帧，网络中有且只有一个令牌\n            * 网络可能构成环形网络\n            * 问题：\n              * 令牌开销，带宽开销\n              * 等待延迟\n              * 单点故障：令牌丢失\n\n### 局域网\n\n#### ARP协议\n\nMAC地址：物理地址、LAN地址、以太网地址\n\n* 作用：在局域网中标识一个帧从哪个接口发出，到达哪个物理相连的其它接口\n* 48位（16进制6字节）MAC地址，固化在网卡的ROM中，有时可以软件设置\n* 局域网中每块网卡都有唯一的MAC地址\n* 由IEEE统一管理与分配\n* 网卡厂商在IEEE购买前24比特MAC地址空间\n* 与IP地址区别：\n  * MAC地址是“平面地址”，可以从一个LAN移到另一个LAN，用于标识帧\n  * IP地址是层次地址，依赖结点连接到哪个子网，用于标识数据报\n\nARP：地址解析协议\n\n* 已知目的接口的IP地址下确定MAC地址\n* ARP表：LAN中每个IP结点维护一个表，存储某些LAN结点IP/MAC地址映射关系：< IP; MAC ; TTL>(TTL time to live:经过这个时间后该映射关系会丢弃，一般为20min)\n* ARP是“即插即用”协议：结点无需干预，自主创建ARP表\n* 获取目标主机的MAC地址：\n  * 同一局域网内：\n    * 若A的ARP表不包含B的MAC地址，则A广播ARP查询分组，其中包含B的IP地址，只有B向A利用单播帧响应B的MAC地址，A缓存B的地址对直至超时\n  * 不同局域网内：\n    * A发数据帧至网关路由器（源IP为A，目标IP为B，源MAC为A，目的MAC为网关路由器的一端口），网关路由器转发数据报，更改源MAC地址为发出端口的MAC地址，若双方都在公网，则不需要更改IP地址\n\n#### 以太网 Ethernet\n\n有线LAN技术、应用最广泛的LAN技术\n\n物理拓扑：\n\n* 总线 bus：同轴电缆，上世纪90年代中期流行\n  * 所有结点在同一冲突域 collision domain ，可能彼此冲突\n* 星型 star：目前主流网络拓扑\n  * 利用中心交换机 switch\n  * 每个结点一个单独冲突域，结点间彼此不冲突\n\n特点:\n\n* 无连接 connectionless：发送帧的网卡和接收帧的网卡没有握手过程\n* 不可靠 unreliable：接收网卡不向发送网卡进行确认\n  * 出错可能性低，差错帧直接丢弃，依靠高层协议恢复数据\n* 采用二进制指数退避算法CSMA/CD的 MAC协议：\n  1. 网卡从网络层接收数据报，创建数据帧\n  2. 监听信道：\n     1. 监听到信道空闲，则发送帧\n     2. 信道忙，一直等待到信道空闲，然后发送\n  3. 发送完整个帧没有检测到其他结点数据发送，则确认发送成功\n  4. 若检测到其他结点传输数据，终止发送并发送阻塞信号 jam signal\n  5. 网卡进入二进制指数退避：\n     * 第m次连续冲突后：\n       * 取n=Max(m,10)\n       * 网卡从 0到 $2^n-1$随机取一个数K\n       * 等待 K * 512bit的传输延迟时间，再返回第2步\n     * 连续16次冲突后，报告差错\n\n帧结构：\n\n* 把IP数据报封装到以太网帧中\n* 前导码 preamble   8B：\n  * 前7个字节为10101010，第八字节为10101011\n  * 用于发送端和接收端的时钟一致\n* 目的MAC和源MAC地址（各6B）\n* 类型 Type  2B：指示帧中封装哪种高层协议的分组\n* 数据 Data 46-1500B：上层协议载荷 （CSMA/CD发送数据时能够检测到冲突的最小长度）\n* CRC 4B：循环冗余校验码\n","source":"_posts/network_note.md","raw":"---\nlayout: post\ntitle: \"计算机网络笔记\"\ndate: 2018-02-20\ncomments: true\ntags: \n  - 学习笔记\n  - network\n---\n\n### 概述（上）\n\n计算机网络学习笔记，包括：\n\n1. 基本概念：网络结构、体系结构\n2. 网络层：web、Email、DNS、P2P、Socket\n3. 传输层：TCP、UDP\n4. 网络层：IP、CIDR、DHCP、NAT、ICMP、路由\n5. 数据链路层：差错编码、MAC\n6. 局域网：ARP、以太网\n\n<!-- more -->\n\n#### 基本概念\n\n计算机网络 = 通信技术 + 计算机技术\n\n定义： 计算机网络是互连的、自治的计算机集合\n\n网络结构：\n\n* 网络边缘： 主机、网络应用\n  *  主机（端系统）：运行网络应用程序\n  *  模型：\n    * client、server 客户 服务器模型：客户发送请求，服务器响应\n    * p2p模型：无专用服务器，通信在对等实体间直接进行\n* 接入网络，物理介质： 有线或无线通信链路\n  *  DSL 数字用户线路：用电话线连接，FDM分频\n* 网络核心（核心网络）：互联的路由器、网络的网络\n  * 核心功能：路由routing + 转发 forwarding\n    * 路由：确定分组从源到目的传输路径\n    * 转发：分组从路由器输入端口转发至正确的输出端口\n  * **数据交换**\n\n端系统通过 接入ISP 连接到Internet， 接入ISP互连\n\n#### 网络核心\n\n数据交换：数据通过网络核心从源主机到达目的主机的手段\n\n数据交换分类：\n\n1. 电路交换\n2. 报文交换\n3. 分组交换\n\n##### 电路交换\n\n最典型的电路交换网络：电话网络\n\n三个阶段：\n\n* 建立连接\n* 通信\n* 释放连接\n\n特点：资源**独占**\n\n如何共享中继线： 多路复用（Multiplexing）\n\n多路复用： 链路、网络资源划分资源片，每路独占分配的资源片，资源片可能闲置\n\n典型多路复用方法：\n\n* 频分多路复用 FDM\n  * 各用户占用不同频率带宽\n  * 通信过程中始终使用一个频带\n* 时分多路复用 TDM\n  * 将时间划分为等长的帧，帧划分为时隙，每个用户使用固定序号的时隙\n  * 每个用户的时隙周期性出现（周期为帧长度）\n  * 所有用户使用所有频带宽度\n* 波分多路复用 WDM\n  * 光的频分复用\n* 码分多路复用 CDM\n  * 广泛应用于无线链路共享\n  * 每个用户有唯一的码片序列，码片序列之间正交\n  * 用户用码片序列编码自己的数据\n\n##### 报文交换 message switching\n\n一次发送信息整体\n\n##### 分组交换 package switching\n\n分组： 报文拆分出的一系列较小的数据包\n\n需要报文的拆分和重组\n\n每个分组需要额外的分组头\n\n**统计多路复用 statistical multiplexing**： 按需共享（传输数据多的速度快，数据少的速度慢）\n\n交换方式： **存储-转发**：\n\n​\t一次存储整个分组，而后转发\n\n分组交换和电路交换：\n\n分组交换适用于突发数据传输：\n\n* 优点\n    * 资源充分共享\n  * 简单、无需建立呼叫电路\n* 缺点：\n  * 可能产生拥塞 congestion： 分组延迟和丢包\n  * 需要协议处理可靠数据传输和拥塞控制\n\n### 概述（下）\n\n#### 计算机网络性能\n\n速率：\n\n* 速率、数据率、比特率： 单位时间(秒)内传输信息（比特）量， b/s ,bps, kb/s\n* 速率往往指的是额定速率、标称速率（理论值）\n\n带宽： \n\n* 原本：信号具有的频带宽度，最高频率和最低频率之差，单位 hz\n* 网络：数字信道所能传输的最大数据率，单位 b/s\n\n延迟delay、时延 latency：\n\n* 原因： 分组在路由器缓存中排队\n* 四种类型：\n  * 处理延迟( nodal processing delay)：\n    * 差错检测\n    * 确定输出链路\n    * 通常毫秒、微秒级 \n  * 排队延迟 (queueing delay)\n    * 等待输出链路可用\n    * 取决于路由器拥塞程度\n  * 传输延迟 (transmission delay) ：路由器到链路\n    * 取决于分组长度L、链路带宽R， d trans = L/R\n  * 传播延迟 (propagation delay)：链路上到下一个路由器\n    * 取决于链路长度d，信号传播速度s，　d prop = d/s\n* d nodal = d proc + d queue + d trans + d prop\n\n时延带宽积＝传播时延＊带宽 = 链路上能容纳多少比特\n\n丢包：\n\n * 原因：队列缓存有限\n * 分组到达已满队列将被丢弃\n * 丢弃分组可能由前序结点或源重发\n * 以丢包率衡量\n\n吞吐量  throughput\n\n * 发送端与接收端之间的速率\n * 分类：\n    * 即时吞吐量\n    * 平均吞吐量\n* 取决于端到端路径上，最小速率的链路\n\n#### 计算机网络体系结构\n\n用**分层结构**从**功能上**描述计算机网络体系\n\n每层完成一个特定功能，每层依赖底层提供的服务\n\n每层遵循某个协议完成本层功能\n\n计算机网络体系结构是计算机网络各层及其协议的集合\n\n分层结构的优点\n\n* 结构清晰\n* 模块化思想，易于系统更新、维护\n  * 任何一层服务实现上的改变对其它层不影响​\n\n基本概念：\n\n* 实体 entity ： 任何可发送或接收信息的硬件或软件进程\n* 协议 protocol：控制两个对等实体进行通信的规则的集合（同层的，水平的）\n* 服务是垂直的，任一层实体需要使用下层服务，遵循本层协议，实现本层功能，对上层提供服务\n* 下层实现对上层是不可见的\n* 相邻层之间通过接口进行交互，通过服务访问点SAP\n\n##### OSI参考模型\n\n概念：\n\n* 目的： 支持异构网络系统的互联互通\n* 异构网络系统互连的国际标准\n* 理解网络通信的最佳学习工具（理论模型，市场失败）\n\n分层： 7层：\n\n* 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n* 主机需要完成7层\n* 路由器只需要完成3层，物理层、链路层、网络层\n* 数据纵向流动，协议水平\n* 端到端层 end-end： 应用层到传输层 四层\n\n数据封装和通信过程：\n\n1. APDU 应用层数据单元\n2. PPDU 表示层\n3. SPDU 会话层\n4. TPDU 传输层\n5. NPDU 网络层\n6. DPDU 链路层加头加尾\n7. 物理层对应比特，不加额外信息\n\n* 增加控制信息： 最终构造成 PDU 构造协议数据单元\n* 控制信息包括：\n  * 地址： 标识发送端、接收端\n  * 差错检测编码：差错检测或纠正\n  * 协议控制：实现协议功能的附加信息\n\n功能：\n\n* 物理层功能：   总：实现比特的传输\n  * 定义、规范接口特性\n    * 机械特性：接口的几何形状\n    * 电气特性：接口的电平、电压\n    * 功能特性：多少引脚、引脚的功能\n    * 规程特性：接口的使用规则，也叫过程特性\n  * 比特编码\n  * 数据率\n  * 比特同步： 时钟同步问题\n  * 传输模式\n    * 单工模式 simplex ： 单向发信（如电视）\n    * 半双工 half-duplex ： 可双向，但只能交替进行（如对讲机）\n    * 全双工 full-duplex ： 可同时收发\n* 数据链路层功能：\n  * 负责结点-结点 node-to-node数据传输\n  * 以帧为单位进行传输\n  * 功能：\n    * 组帧 framing ： 加头加尾 ： 使得接收方能够切分帧病识别控制信息\n    * 物理寻址 physical addressing：包含源和目的物理地址\n    * 流量控制 flow control ： 避免淹没接收端\n    * 差错控制 error control ： 检测并重传损坏或丢失帧，并避免重复帧\n    * 访问（接入）控制 access control：决定哪个设备拥有链路的控制使用权\n* 网络层功能：负责数据分组packet的交付\n  * 原因：可能穿越多个网络\n  * 逻辑寻址 logical addressing： 全局唯一逻辑地址，确保数据分组被送到目的地，如IP地址\n  * 路由 routing： 选择路径\n  * 分组转发\n* 传输层功能： 负责端-端 完整报文的传输\n  * 报文的分段和重组\n  * SAP寻址：确保报文提交给正确进程，如端口号\n  * 连接控制：逻辑连接\n  * 流量控制\n  * 差错控制\n* 会话层功能： 插入控制信息\n  * 对话控制 dialog controlling： 对话的建立与维护\n  * 对话同步 synchronization： 数据流中插入同步点\n  * 最“薄”的一层\n* 表示层功能： 编码、加密、压缩数据\n  * 数据表示转化\n    * 转换为主机独立的编码\n  * 加密解密\n  * 压缩解压缩\n* 应用层功能：支持用户通过接口使用网络服务\n  * 典型类型：\n    * FTP 文件传输\n    * HTTP WEB\n    * SMTP 电子邮件\n\n##### TCP / IP模型\n\n四层： 应用层、运输层、网际层、网络接口层\n\n##### 五层参考模型\n\n综合OSI和TCP/IP模型的优点\n\n应用层、传输层、网络层、数据链路层、物理层\n\n层次：\n\n* 主机 五层\n* 路由器 三层\n* 交换机 两层\n\n#### 网络发展历史\n\n1961-1972： 交换分组原理提出与应用\n\n1972-1980：网络互连，大量新型、私有网络的涌现\n\n1980-1990：新型网络协议与网络的激增\n\n1990-2000初： 商业化，web，新应用\n\n2005-今\n\n### 网络应用（上）\n\n应用层 - 传输层 - 网络层 - 链路层 - 物理层\n\n#### 网络应用层概述\n\n* 网络应用体系结构\n* 网络应用的服务需求\n* Internet传输层服务模型\n* 特定网络应用与协议\n* Socket编程\n\n#### 网络应用的基本原理\n\n##### 网络应用的体系结构\n\n* 客户机、服务器结构  C/S  Client-Server\n  * 服务器\n    * 7*24小时提供服务\n    * 永久性访问地址\\域名\n    * 利用大量服务器实现可扩展性（处理大量并发请求）\n  * 客户机\n    * 与服务器通信，使用服务器提供的服务\n    * 间歇性接入网络\n    * 可能使用动态IP\n    * 不会和其他客户机直接通信\n* 点对点结构 P2P Peer-to-peer\n  * 没有永远在线的服务器\n  * 任意端系统之间可以直接通信\n  * 节点间歇性接入网络\n  * 节点可能改变IP\n  * 优点：高度可伸缩、可扩展\n  * 缺点：难以管理\n* 混合结构 hyrid\n\n##### 网络应用进程通信\n\n同一主机上进程通信：\n\n* 进程间通信机制\n* 由操作系统提供\n\n不同主机进程通信：消息交换\n\nSocket套接字：进程间利用socket发送和接受消息\n\n传输基础设施向进程提供API：\n\n* 传输协议的选择\n* 参数的设置\n\n进程寻址：\n\n* 不同主机进程通信，每个进程必须有标识符\n* 寻址主机：IP地址\n* 端口号 port number：主机上每个需要通信的进程分配一个端口号\n* 已经分配的端口： HTTP：80     mail：25\n* 进程的标识符： IP+端口号\n\n应用层协议：\n\n* 网络应用都应该遵循应用层协议\n* 公开协议： \n   * 由 RFC（request for comments）定义\n   * 允许互操作\n   * 例如： HTTP、SMTP\n* 私有协议：\n  * 多数P2P文件共享应用\n* 内容：\n  * 消息的类型type：\n    * 请求消息\n    * 响应消息\n  * 消息的语法syntax 、格式\n    * 消息中由哪些字段 field\n    * 每个字段如何描述\n  * 字段的语义 semantics ：信息的含义\n  * 规则 rules： 何时、如何发送、相应消息\n\n##### 网络应用的需求与传输层服务\n\n需求：\n\n* 数据丢失 data loss、 可靠性reliability\n  * 某些可容忍一定的数据丢失：网络电话\n  * 某些要求100%可靠的数据传输\n* 时间timing 、 延迟 delay：\n  * 延迟低才有效（网络电话、网络游戏）\n* 带宽 bandwidth：\n  * 带宽达到最低要求才有效：网路视频\n  * 可适应任何带宽——弹性应用：email、文件下载\n\n传输服务：\n\n* TCP服务：\n  * 面向连接：客户机和服务器需要建立连接\n  * 可靠的传输\n  * 流量控制：发送方不会发送速度过快\n  * 拥塞控制：网络负载过重时能限制发送方发送速度\n  * 不提供时间保障\n  * 不提供最小带宽保障\n* UDP服务：\n  * 无连接\n  * 不可靠\n  * 不提供：可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障\n\n#### Web应用\n\n##### web与http\n\nweb：\n\n* 网页\n* 网页互相链接\n\n网页 webpage 包含多个对象 objects：\n\n* 对象：html文件、jpeg图片、视频、动态脚本\n* 基本html文件：包含对其他对象引用的链接\n\n对象的寻址 addressing：\n\n* URL（uniform resource locator）：统一资源定位器\n* 格式：  Scheme:// host:port/path\n\nHTTP协议 hypertext transfer protocol 超文本传输协议：\n\n* CS结构：\n  * 客户- browser：请求、接受、展示web对象\n  * 服务器-web server：相应客户请求、发送对象\n* 使用TCP传输服务\n* 无状态 stateless：服务器不维护任何过去发送请求的信息\n\n##### HTTP连接\n\n非持久性连接 nonpersistent http：\n\n* 每个TCP连接最多允许传输一个对象\n* 在HTTP 1.0版本\n* 缺点：\n  * 每个对象需要2个RTT\n  * 操作系统要为每个TCP连接开销资源\n  * 浏览器需要打开多个并行TCP连接获取对象\n\n持久性连接：\n\n* 每个TCP连接允许传输多个对象\n* HTTP 1.1默认\n* 发送响应后，服务器保持TCP连接打开以发送后续HTTP消息\n* 分类：\n  * 无流水pipelining的持久性连接\n    * 客户端受到一个响应才发送一个新请求\n    * 每个对象消耗 1RTT\n  * 流水机制的持久性连接：\n    * HTTP 1.1默认\n    * 客户端遇到一个引用对象就尽快发送请求\n    * 理想情况下收到所有引用对象只需要约 1RTT\n\n响应时间 RTT ： round trip time：从客户端发送一个很小数据包到服务器并返回所经历的时间\n\n##### HTTP请求消息\n\nHTTP协议两类信息：\n\n* 请求消息 request\n  * ASCII：人直接可读\n  * 上传输入的方法：\n    * POST方法：在请求消息的消息体中输入\n    * URL方法：GET方法：输入信息通过request行中的URL段上传\n    * HEAD：请求服务器不要把所请求对象放入相应消息中（只返回头，一般用作测试）\n    * PUT：（HTTP  1.1）消息体中的文件上传到URL段所指定的路径（上传文件到服务器）\n    * DELETE：（HTTP1.1）删除URL字段指定文件\n* 响应消息 response\n  * 状态响应代码：相应消息的第一行\n  * 如 200 OK， 404 Not Found\n\n##### Cookie 方法\n\ncookie技术：网站为辨明用户身份、通过session跟踪而存储在用户本地终端的数据\n\nRFC 6265\n\nCookie组件：\n\n* HTTP响应消息的Cookie头部行\n* HTTP请求消息的Cookie头部行\n* 保存在客户端主机的Cookie文件，由浏览器管理\n* web服务器端的后台数据库\n\nCookie的作用：\n\n* 身份认证、购物车、推荐、email\n\n隐私问题\n\n##### web缓存、代理服务器技术\n\n功能：在不访问服务器的前提下满足客户端的HTTP请求\n\n原因： 性能优化\n\n* 缩短客户请求响应时间\n* 减少机构、组织流量\n* 在大范围内实现有效内容分发\n\n步骤：\n\n* 用户设定浏览器通过缓存进行web访问\n* 浏览器向缓存、代理服务器发送所有HTTP请求\n  * 若请求对象在缓存中 ，则缓存返回对象\n  * 若不在缓存，则缓存服务器向原始服务器发送HTTP请求，获取对象并返回给客户端、并保存对象\n\n解决对象更新问题： 条件性GET\n\n* 若缓存为最新版本，则不需要发送请求对象\n* 缓存服务器请求信息中声明持有版本的日期 modified 日期\n* 目标服务器：\n  * 若缓存版本是最新的，响应消息中不包含对象，返回 304 Not Modified\n  * 若缓存版本不是最新，则返回对象\n\n#### Email 应用\n\n##### email应用概述\n\n构成组件：\n\n* 客户端\n* 服务器\n  * 邮箱：存储发给该用户的email\n  * 消息队列 msessage queue：存储等待发送的email\n* SMTP协议：email消息传输、交换协议\n  * 邮件服务器之间传递消息所使用的协议\n  * 客户端：发送消息的服务器\n  * 服务器：接受消息的服务器\n  * 端口25\n  * 使用TCP 进行可靠传输、持久性连接\n  * 三个阶段：\n    * 握手\n    * 消息传输\n    * 关闭\n  * 命令、相应交互模式：\n    * 命令 command：ASCII文本\n    * 响应 response：状态代码和语句\n  * email消息只能包含7位ASCII码\n\n##### Email消息格式与POP3协议\n\nRFC 822：文本消息格式标准：\n\n* 头部行 header\n  * To 、 From、 Subject\n* 消息体 body\n  * 消息本身，只能是ASCII字符\n\n为了支持多媒体： 使用 MIME 多媒体邮件扩展\n\n* 在邮件头部增加额外的行声明MIME的内容类型\n\n邮件访问协议：收件方从服务器获取邮件\n\n* POP：post office protocol 协议：两个阶段：认证/授权和下载\n  * 模式：\n    * 下载并删除模式：用户换了客户端软件，则无法重读邮件\n    * 下载并保持模式：不同客户端都可以保存拷贝\n  * POP3是无状态协议（服务器没有记忆功能）\n* IMAP: internet mail access protocol协议\n  * 更多功能、更复杂，新于POP3\n  * 可操纵服务器上存储的消息\n  * 所有消息统一保存在服务器\n  * 允许用户利用文件夹组织消息\n  * 支持跨会话Session 的用户状态\n  * 有状态协议\n* HTTP协议： 163、 qq 、 mail\n\n#### DNS应用\n\n##### DNS概述\n\nDNS：domain name system 域名系统：解决Internet上主机、路由器识别问题\n\nDNS域名解析系统：域名和IP地址的映射\n\n* 多层命名服务器构成的分布式数据库\n* 应用层协议：完成名字的解析\n  * Internet核心功能，用应用层协议实现\n  * 网络边界复杂\n\n服务：\n\n* 域名向IP地址翻译\n* 主机别名\n* 邮件服务器别名\n* 负载均衡：web服务器\n\n集中式DNS的问题： 不可伸缩\n\n* 单点失败问题：服务器坏掉\n* 流量问题\n* 距离问题\n* 维护性问题\n\n分布式层次式数据库：\n\n1. 根服务器 root\n2. 顶级域名服务器  com、org、edu等\n\n根域名服务器： 本地域名解析服务器无法解析域名时，访问根域名服务器\n\n* 不知道映射时，访问权威域名服务器\n\n顶级域名服务器 TLD top-level domain：负责com、edu等\n\n权威域名服务器：组织的域名解析服务器，负责解析组织内部服务器的解析服务\n\n* 组织负责维护\n* 服务提供商负责维护\n\n本地域名解析服务器：\n\n* 不严格属于层次体系\n* 每个ISP都有一个本地域名服务器：默认的服务器\n* 本地服务器作为代理，把查询转发给域名解析服务器系统\n* 查询方式：\n  * 迭代查询：获得下一个服务器地址，本地服务器挨个询问\n  * 递归查询：本地服务器把询问任务交给根服务器\n\nDNS记录缓存与更新：\n\n* 本地域名服务器一般会缓存顶级域名服务器的映射\n  * 因此根域名服务器不经常被访问\n\n##### DNS记录与消息格式\n\n资源记录 RR resource records\n\n格式： name value type ttl\n\n类型：\n\n* Type = A\n  * Name：主机域名\n  * value：IP地址\n* Type = NS\n  * Name：域\n  * value：该域的权威域名解析服务器的主机域名\n* Type = CNAME\n  * Name：某一域名的别名\n  * Value：真实域名\n* Type = MX\n  * Value ：与name对应的邮件服务器\n\nDNS协议：\n\n* 查询query 和回复 reply\n* 消息格式相同\n  * 头部：\n    * identification：16位查询编号，回复使用相同编号\n    * flags\n\n### 网络应用（下）\n\n#### P2P应用\n\n##### P2P应用：原理与文件分发\n\n典型协议：BT BitTorrent：\n\n* torrent：交换同一个文件的文件块的节点组\n* tracker：跟踪参与torrent的节点\n\n获取chunk：\n\n* 给定任意时刻，不同节点持有文件的不同chunk集合\n* 节点定期查询每个邻居持有的chunk列表\n* 节点发送请求，请求获取缺失的chunk：\n  * 稀缺优先原则\n\n发送chunk： tit-for-tat：\n\n* 向4个邻居发送chunk：正在向其发送chunk且速率最快的四个\n  * 每10s重新评估top4\n* 每30s随机选择一个其他节点，向其发送chunk\n\n##### P2P应用；索引技术\n\n索引：信息到节点位置（IP地址+端口号）的映射\n\n文件共享：\n\n* 利用索引动态跟踪节点所共享的文件的位置\n* 节点告诉索引它拥有哪些文件\n* 节点搜索索引，获知能够得知哪些文件\n\n即时消息：\n\n* 索引把用户名映射到位置\n* 用户开启IM应用时，需要通知索引它的位置\n* 节点检索索引，确定用户的IP地址\n\n###### 集中式索引\n\nNapster最早采用\n\n1. 节点加入时，通知中央服务器\n   * IP地址\n   * 内容\n2. 节点向中央服务器查找文件\n3. 节点向用户请求文件\n\n缺点： 内容定位高度集中\n\n* 单点失效问题\n* 性能瓶颈\n* 版权问题\n\n###### 洪泛式查询 query flooding\n\n完全分布式架构\n\n每个节点只对自己共享的文件进行索引\n\n覆盖网络 overlay network：\n\n* 节点之间若有TCP连接，则构成一条边\n* 所有活动节点和边构成网络\n* 边：虚拟链路\n* 节点邻居数一般少于10\n\n查询：\n\n* 查询消息通过已有的TCP连接发送\n* 节点转发查询消息\n* 查询命中，则利用反向路径发回查询节点\n\n缺点：消息泛滥、造成网络阻塞\n\n###### 层次式覆盖网络\n\n介于集中式索引和洪泛查询之间\n\n每个节点 要么是超级节点，要么被分配一个超级节点\n\n* 节点和超级节点之间维持TCP连接（集中式索引）\n* 超级节点之间维持TCP连接（洪泛式查询）\n\n超级节点负责跟踪子节点内容\n\n#### Socket编程\n\n###### 应用编程接口API\n\n将应用进程的控制权和操作系统的控制权进行转换的系统接口\n\n典型接口：\n\n* 套接字 socket\n* winsock：Windows Socket interface，微软的套接字接口\n* TLI，transport layer interface 传输层接口\n\n##### Socket API概述\n\n最初面向 BSD UNIX-Berkley\n\nInternet网络应用最典型的API接口\n\n通信模型： 客户、服务器模型\n\n应用进程间通信的抽象机制\n\n标识通信端点（对外）：IP地址+端口号\n\n对内管理套接字：套接字描述符 Socket descriptor\n\nSocket抽象：\n\n* 类似文件的抽象\n* 应用程序创建套接字时，操作系统分配一个数据结构存储该套接字相关信息\n* 返回套接字描述符\n\n##### Socket API函数 Winsock：\n\nWSAStartup：初始化api  ->  应用程序  -> WSACleanup\n\nsocket(protofamily , type, proto )：\n\n * 创建套接字，返回套接字描述符\n * protofamily 协议族  （TCP/IP = PF_INET）\n * type：套接字类型\n * proto：协议号，0为默认\n\n面向TCP/IP 服务类型：\n\n* SOCK_DGRAM：传输层UDP协议：不可靠、无连接、数据报传输\n* SOCK_STREAM：传输层TCP协议：可靠、面向连接、字节流传输、点对点\n* SOCK_RAW：网络层，IP/ICMP/IGMP\n\nint Closesocket( SOCKET sd);\n\n * 关闭一个描述符为sd的套接字\n * 多个进程共享一个套接字时，调用该函数将套接字引用计数减一，减到0才关闭\n * 一个进程多线程对一个套接字使用无计数\n * 返回值：0成功\n\nint bind(sd, localaddr, addrlen);\n\n* 绑定套接字的本地端点地址（IP+端口号）\n* 参数：\n  * 套接字描述符 sd\n  * 端点地址 localaddr： 结构 sockaddr_in\n* 客户端程序一般不必调用bind函数\n* 服务器绑定多IP地址：地址通配符：INADDR_ANY\n\nint listen(sd, queuesize);\n\n* 置服务器端的流套接字处于监听状态\n  * 仅服务器端调用\n  * 仅用于面向连接的流套接字\n* 设置连接请求队列大小 queuesize\n* 返回值：成功 0\n\nconnect( sd, addr , saddrlen);\n\n* 仅用于客户端，使客户套接字与特定计算机的特定端口saddr的套接字进行连接\n* 可用于TCP、 UDP\n  * TCP：建立连接\n  * UDP：指定服务器端点地址\n\nnewsock = accept( sd, caddr, caddrlen);\n\n* 只用于服务器端，只用于TCP套接字\n* 从客户连接请求队列中取出最前的客户请求，并创建一个新的套接字和客户套接字创建连接通道\n* 利用新创建的套接字和客户通信（TCP是点对点的）\n\nsend( sd , *buf, len , flags);\n\nsendto( sd, * buf , len, flags, destaddr, addrlen);\n\n* send函数TCP套接字（客户端或服务器）或调用了connect函数的UDP客户端套接字\n* sendto用于UDP服务器端套接字和未调用connect函数的UDP客户端套接字\n\nrecv，recvfrom 类似send，sendto\n\nsetsockopt、 getsockopt 设置或获取套接字设置\n\n网络字节顺序 network byte order：\n\n​\tTCP/IP定义了标准的用于协议头中的二进制整数表示\n\n​\t某些socket API函数参数需要存储为网络字节顺序（如IP地址、端口号等）\n\n##### 客户端软件设计\n\n解析服务器IP地址： 域名或IP地址转换为32位二进制IP地址：\n\n* inet_addr() 点分十进制IP到32位IP地址\n* gethostbyname() 域名到32位IP地址： 返回指向结构hostent的指针\n* 都返回网络字节顺序\n\n解析端口号： 可能使用服务名（如HTTP）或端口号\n\n* getservbyname() 服务名转为熟知端口号\n\n解析协议号：可能使用协议名（如TCP）指定协议\n\n* getprotobyname() 协议名到协议号的转换\n\nTCP客户端软件流程：\n\n1. 确定服务器IP地址+端口号\n2. 创建客户端套接字\n3. 分配本地端点地址（IP+端口号） （系统自动完成）\n4. 连接服务器套接字\n5. 遵循应用层协议进行通信\n6. 关闭或释放连接\n\nUDP客户端软件流程：\n\n1. 确定服务器IP地址+端口号\n2. 创建客户端套接字\n3. 分配本地端点地址（IP+端口号） （系统自动完成）\n4. 指定服务器端点地址，构造UDP数据报\n5. 遵循应用层协议进行通信\n6. 关闭或释放套接字\n\n##### 服务器软件设计\n\n基本服务器类型：\n\n1. 循环无连接 IteratIve connectionless\n   * 一次只接受一个客户端请求\n   * 无连接：基于UDP\n   * 流程：\n     1. 创建套接字\n     2. 绑定端点地址（INADDR_ANY+端口号）\n     3. 反复接收来自客户端的请求\n     4. 遵循应用层协议，构造响应报文，发送给客户\n   * 服务器端不能使用connect函数\n   * 无连接服务器使用 sendto发送数据报\n   * 客户端端点地址在调用recvfrom接收数据时自动提取\n2. 循环面向连接 Iterative connection-oriented\n   * 流程：\n     1. 创建主套接字，绑定熟知端口号\n     2. 主套接字设置为被动监听模式\n     3. 调用accept接收连接请求，创建新套接字和客户建立连接\n     4. 通过新套接字接收请求、构造并发送响应\n     5. 完成服务后，关闭连接，返回3\n3. 并发无连接 Concurrent connectionless\n   * 流程：\n     1. 主线程1 创建套接字，绑定熟知端口号\n     2. 主线程2 反复调用recvfrom函数，接收请求，创建新线程处理响应\n     3. 子线程1 接收请求\n     4. 子线程2 构造响应报文，调用sendto发送\n     5. 子线程3 退出\n4. 并发面向连接 Concurrent connection-oriented\n   * 流程：\n     1. 主线程1 创建套接字，绑定熟知端口号\n     2. 主线程2 设置主套接字为被动监听模式\n     3. 主线程3 反复调用accept接收连接请求，创建新的子线程处理客户响应\n     4. 子线程1 接收请求（通过新套接字）\n     5. 子线程2 根据协议进行交互\n     6. 子线程3 关闭、释放连接并退出（线程终止）\n\n\n### 传输层（上）\n\n#### 传输层服务概述\n\n传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制\n\n端系统运行传输层协议：\n\n* 发送方：把消息分成多个Segment并传给网络层\n* 接收方：把segment组装成消息，交给应用层\n\n协议类型：\n\n* TCP、UDP\n\n与网络层的区别：\n\n* 网络层提供主机之间的逻辑通信机制\n* 位于网络层之上、依赖网络层\n* 对网络层服务进行（可能的）增强\n\n#### 复用和分用\n\n原因：\n\n* 接收端（多路分用）：传输层将segment交给正确的socket 即正确的进程\n* 发送端（多路复用）：从多个socket接收消息，每块数据封装头部消息，生成Segment，交给网络层\n\n分用工作：\n\n* 主机接收到IP数据报 datagram\n* 每个数据报携带源IP、目的IP，一个传输层的段\n* 每个段携带源端口号、目的端口号\n* 传输层协议根据IP地址和端口号，把Segment导向Socket\n  * TCP做更多处理\n* 无连接分用：UDP：用二元组标识（目的IP，目的端口号）\n* 面向连接的分用：TCP：用四元组（源IP，源端口号，目的IP，目的端口号）\n\n#### UDP\n\nUDP：user datagram protocol 【RFC 768】\n\n特点：\n\n* 基于 IP协议：\n  * 多路复用、分用\n  * 简单的错误校验：端到端原则，不能确保所有链路层协议都有错误检测，也不能确保转发时错误不发生\n* Best effort（尽力而为）服务，UDP可能：\n  * 丢失\n  * 非按序到达\n* 无连接：\n  * 发送方接收方不需要握手、不需要建立连接\n  * 每个UDP段处理独立\n\n价值：\n\n* 无需建立连接：延迟显著减少（2个RTT）（DNS用UDP）\n* 实现简单，无需维护连接状态\n* 头部开销少（8字节 VS  20字节）\n* 没有拥塞控制，上层控制发送时间和速率\n\n用途：\n\n* 常用于流媒体：容忍丢失、速率敏感\n* DNS、SNMP\n* 在其之上实现可靠数据传输：（应用层开发）\n  * 在应用层增加可靠性机制\n  * 应用特定的错误恢复机制\n\n![UDP](http://ot1c7ttzm.bkt.clouddn.com/UDP.png)\n\nUDP校验和 checksum： \n\n* 目的：检测UDP段传输过程中是否发生错误\n* 发送方：\n  * 段内容视为16-bit证书\n  * 校验和计算：求和，进位加到和后面，按位取反\n  * 校验和填入校验和字段\n* 发送方：\n  * 计算校验和\n  * 进行比对：\n    * 不相等：检错\n    * 相等：未检测到错误（可能有错）\n\n#### 可靠数据传输原理\n\n可靠的定义：不错、不丢、不乱\n\n可靠数据传输协议：\n\n* 对应用层、传输层、链路层都重要\n* 信道的不可靠特性决定了可靠数据传输协议rdt的复杂性\n\nRdt 1.0：可靠信道上的可靠数据传输\n\n* 底层信道完全可靠\n* 发送方和接收方 FSM独立\n\nRdt 2.0： 产生位错误：\n\n* 底层信道可能翻转分组中的位\n\n  * 用校验和检测位错误\n\n* 如何从错误中恢复：\n\n  * 确认机制 ACK acknowledgements：接收方显式告知发送方分组已经正确接收\n  * NAK：接收方显式告诉发送方分组有错误\n  * 发送方收到NAK后，重传分组\n\n* 基于重传机制的rdt协议成为ARQ automatic repeat request 协议\n\n* 新机制：\n\n  * 差错检测\n  * 接收方反馈控制消息： ACK、 NAK\n  * 重传\n\n  ![rdt2.0](http://ot1c7ttzm.bkt.clouddn.com/rdt2.0.png)\n\n* 缺陷： ACK、NAK消息发生错误或被破坏 corrupted：\n\n* 解决方案： rdt 2.1\n\n  1. ACK、NAK增加校验和，检错并纠错（代价高）\n  2. 添加额外控制消息\n  3. 发送方重传：可能产生重复分组\n     * 解决重复分组： 序列号 sequence number：发送方给每个分组增加序列号\n     * 接收方丢弃重复分组\n\n* ![rdt2.1](http://ot1c7ttzm.bkt.clouddn.com/rdt2.1.png)\n\n* ![rdt2.1rev](http://ot1c7ttzm.bkt.clouddn.com/rdt2.1rev.png)\n\n  发送方变化：\n\n  * 每个分组增加了序列号(0,1序号)\n  * 需要校验ACK、NAK消息是否错误\n  * 状态数量翻倍\n\n  接收方变化：\n\n  * 需要判断分组是否重复\n\n* Rdt 2.2 ：只使用ACK：检验和+序列号+ACK+重传\n\n  * 接收方通过ACK告知最后一个被正确接收的分组\n  * ACK中显式加入被确认分组的序列号\n  * 发送方收到重复ACK后，重传当前分组\n\nRdt 3.0：既可能错误，也可能丢失：\n\n* 方法：发送方等待 合理 时间：\n  * 没收到ACK，重传\n  * 分组或ACK只是延迟而不是丢了\n  * 增加定时器\n* ![rdt3.0send](http://ot1c7ttzm.bkt.clouddn.com/rdt3.0send.png)\n* 问题：性能很差：停等操作\n\n#### 流水线与滑动窗口协议\n\n流水线机制：\n\n* 允许发送方收到ACK之前连续发送多个分组：\n  * 更大的序列号范围\n  * 发送方、接收方需要更大存储空间缓存分组\n\n滑动窗口协议 sliding-window protocol：\n\n* 窗口：\n  * 允许使用的序列号范围\n  * 窗口尺寸为N：最多由N个等待确认的消息\n* 滑动窗口：\n  * 随着协议的运行，窗口在序列号空间内向前滑动\n* 滑动窗口协议：GBN，SR\n\nGBN go-back-N 协议：\n\n* 发送方：\n  * 分组头有k-bit序列号\n  * 窗口尺寸为N，最多允许N个分组未确认\n  * 累计确认机制：ACK(n)：确认到序列号n（包含n）的分组都被正常接收\n    * 可能收到重复ACK\n  * 空中分组设置计时器 timer\n  * timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组\n* 接收方：\n  * ACK机制：发送拥有最高序列号的，已经被正确接收的分组的ACK\n    * 可能产生重复ACK\n    * 只需记住唯一的expectedseqnum\n  * 乱序到达的分组：\n    * 直接丢弃\n    * 重新确认序列号最大的、按序到达的分组\n* 缺陷：\n  * 重传大量不必要分组\n\nSR selective repeat协议：\n\n* 接收方对每个分组单独进行确认\n  * 设置缓存机制，缓存乱序到达的分组\n* 发送方只重发没收到ACK的分组\n  * 为每个分组设置定时器\n* 发送方窗口不变化\n* 新增接收方窗口\n* ![sr](http://ot1c7ttzm.bkt.clouddn.com/sr.png)\n* SR协议问题： 困境\n  * 出现原因：序列号少且窗口尺寸大\n  * 解决： $N_S + N_R <= 2^k $\n\n\n### 传输层（下）\n\n#### 面向连接传输协议 TCP\n\n概述：\n\n* 点对点\n* 可靠的、按序的字节流\n* 流水线机制： TCP拥塞控制和流量控制机制动态设置窗口尺寸\n* 发送方、接收方缓存\n* 全双工：同一连接双向传输数据\n* 面向连接：\n  * 通信双方在发送数据前必须建立连接\n  * 连接状态只在两端维护\n  * TCP连接包括： 两台主机上的缓存、连接状态变量、Socket等\n* 流量控制机制\n\n\n序列号：\n\n* 序列号指的是Segment第一个字节的编号，而不是Segment的编号\n* 建立连接时，双方随机选择序列号\n\nACK：\n\n* 希望接收的下一个字节的序列号\n* 累计确认：该序列号之前的所有字节都已被正确接收\n\n乱序到达的Segment：没有规定，由TCP实现者做决策\n\n![TCP](http://ot1c7ttzm.bkt.clouddn.com/TCP.png)\n\n##### TCP可靠数据传输\n\n概述：\n\n* 流水线机制\n* 累计确认\n* 单一重传计时器\n* 触发重传事件：\n  * 超时\n  * 受到重复ACK\n\nRTT与超时时间设置：\n\n* 需要大于RTT：但RTT是变化的\n* 超时时间 = 平均RTT + 4*安全时间\n* 安全时间 =  0.25*|平均RTT-RTT|+0.75旧安全时间\n\n发送方事件：\n\n* 从应用层收到数据：\n  * 创建Segment\n  * 开启计时器\n  * 设置超时时间\n* 超时：\n  * 重传超时的Segment\n  * 重启计时器\n* 收到ACK\n  * 未确认的Segment：\n    * 更新sendbase\n    * 窗口若还有未确认的分组，重启计时器\n\n快速重传机制：\n\n* 如果超时，超时时间间隔重新设置，导致其很大\n* 通过重复ACK检测分组丢失：\n  * 发送方收到同一分组的3次ACK，则立刻重传\n\n##### TCP 流量控制\n\n原因：接收方为TCP设置了buffer，上层应用可能处理buffer的速度太慢\n\n实现：接受者在Segment的头部信息的revwindow告诉发送方还剩余多少可用空间，发送方限制数据不超过revwindow的大小\n\n##### TCP连接管理\n\n* 初始化TCP变量：\n  * 选择序列号\n  * 设置缓存和流量控制信息\n* client：连接发起者\n* server：等待连接请求\n* 三次握手建立连接：\n  1. 客户端向server发送 SYN段\n     * 不携带任何数据\n     * SYN标志位为1\n     * 传递初始序列号\n     * SYN=1，seq=client_isn\n  2. 服务器接到SYN，同意后发送 SYNACK段\n     * 服务器分配缓存\n     * 选择自己的初始序列号\n     * SYN=1, seq=server_isn，ack=client_isn+1\n  3. 客户端受到SYNACK，回复ACK报文段，SYN不再置1，可能有数据\n     * SYN=0, seq=client_isn+1 , ack=server_isn+1\n* 连接关闭：\n  1. 客户端向服务器发送 FIN 控制段\n  2. 服务器收到FIN，回复ACK，关闭连接，发送FIN\n  3. 客户端收到FIN，回复ACK：进入等待状态，若收到FIN，重发ACK\n  4. 服务器收到ACK，真正关闭连接\n\n#### 拥塞控制问题\n\n拥塞 congestion： 太多主机发送太多数据或速度太快以致网络无法处理\n\n表现：\n\n* 分组丢失（路由器缓存溢出）\n* 分组延迟过大（在路由器缓存中排队）\n\n拥塞控制 （网络阻塞） vs 流量控制（接收方处理不过来）\n\n为什么拥塞控制要在传输层进行\n\n拥塞控制方法：\n\n* 端到端的拥塞控制：\n  * 网络层不需要显式提供支持\n  * 端系统通过观察loss、delay等网络行为判断是否发生拥塞\n  * TCP采用这种方法\n* 网络辅助的拥塞控制：\n  * 路由器向发送方显式反馈网络拥塞信息\n  * 简单的拥塞指示(1-bit)：SNA、DECbit，TCP/IP ECN, ATM\n  * 指示发送方应该采用何种速率\n\nATM ABR拥塞控制  available bit rate：\n\n* 弹性服务\n* 发送方路径可用：使用可用贷款\n* 发送方路径堵塞：发送速率降到最低保障速率\n* RM resource management cell：\n  * 发送几个数据段就发送一个RM cell\n  * 发送方发送\n  * 交换机设置 RM cell位（网络辅助）\n    * NI bit：rate不许增长\n    * CI bit：拥塞指示\n  * RM cell由接收方返回给发送方\n  * RM cell有显式的速率ER 字段：两个字节：\n    * 拥塞的交换机可以把ER设置为更低的值\n    * 发送方获知路径所能支持的最小速率\n  * 数据cell的EFCI位：拥塞的交换机将其设置为1：\n    * 若RM cell前data cell的EFCI位设置为1，那么发送方在返回的RM cell中置CI位\n\nTCP拥塞控制：\n\n* 如何控制发送速率：\n\n  * 拥塞窗口 CongWin：\n    * LastByteSent-LastByteAcked <= CongWin\n    * 速率 ≈ CongWin / RTT byte/sec\n    * 动态调整以改变发送速率\n    * 反映所感知的网络拥塞\n\n* 如何感知拥塞状况：\n\n  * Loss事件 = timeout 或 3个重复ACK\n  * 发生loss事件后，发送方降低速率\n\n* 如何合理调整发送速率：\n\n  * 加性增- 乘性减： AIMD\n    * 原理：谨慎探测可用带宽，逐渐增加速率，直到loss，一旦loss，快速降低速率\n    * additive increase：每个RTT将CongWin增大一个MSS（拥塞避免）\n    * multiplicative decrease：发生loss后CongWin减半\n  * 慢启动： SS\n    * TCP建立时，CongWin=1，可用带宽可能远高于初始速率，希望快速增长\n    * 原理：连接开始时，速率指数增长（收到每个ack时 CongWin+1）\n  * 何时从指数增长切换到线性增长：\n    * 当CongWin达到loss事件前值的一半时\n    * Threshold记录loss事件前CongWin值的1/2\n  * Loss事件的处理：\n    * 3个重复ACK：\n      * CongWin切到一半\n      * 而后线性增长\n      * 原因：能收到3个ACK说明网络还能传输\n    * timeout：\n      * CongWin直接减为1个MSS\n      * 而后指数增长\n      * 达到threshold后再线性增长\n      * 原因：timeout说明网络拥塞更严重\n\nTCP的公平性：\n\n* 公平性与UDP：\n  * 多媒体应用通常不适用TCP，以免被拥塞控制机制限制速率\n  * 使用UDP：以恒定速率发送，能容忍丢失\n  * 产生不公平\n* 都使用TCP：\n  * 可能打开多个并发连接\n  * 如WEB浏览器\n  * 产生公平性问题\n\n### 网络层服务（上）\n\n#### 网络层\n\n源主机向目的主机发送数据报\n\n每个主机和路由器都运行网络层协议\n\n路由器检验所有穿越它的IP数据报的头部域：决策如何处理IP数据报\n\n网络层核心功能：\n\n* 转发 forwarding：\n  * 功能：分组从路由器输入端口转移到合适的输出端口\n  * 路由器维护转发表：确定在该路由器中根据地址信息转发到哪条链路\n* 路由 routing：\n  * 确定分组从源到目的经过的路径\n  * 根据 路由算法 routing algorithms\n* 连接建立：不是所有网络都需要\n  * 数据分组传输之前两端主机需要首先建立虚拟连接\n    * 网络设备（路由器）参与连接的建立\n\n网络层服务模型：\n\n* 无连接服务 connection-less service：\n  * 特点：\n    * 不事先为系列分组的传输确定传输路径\n    * 每个分组独立确定传输路径\n    * 不同分组可能路径不同\n  * 典型例子：数据报网络 datagram network\n* 连接服务：\n  * 特点：\n    * 首先为系列分组传输确定路径\n    * 沿路径传输系列分组\n    * 系列分组传输路径相同\n    * 传输结束后拆除连接\n  * 典型例子：虚电路网络 virtual-circuit network\n\n#### 虚电路网络和数据报网络\n\n##### 虚电路网络\n\n提供网络层连接服务\n\n一条从源主机到目的主机，类似电路的路径：\n\n* 分组交换\n* 每个分组的传输利用链路的全部带宽\n* 源到目的主机经过网络层设备共同完成虚电路建设\n\n通信过程： 呼叫建立 call setup -> 数据传输 -> 拆除呼叫\n\n每个分组携带虚电路标识 VCID，而不是目标主机地址\n\n每个网络设备都需要维护经过它的虚电路连接状态\n\n可以面向虚电路VC 进行预分配资源：\n\n* 如ATM的电路仿真 CBR\n\n具体实现：\n\n* 每条虚电路包括：\n  1. 从源主机到目的主机的一条路径\n  2. 虚电路号 VCID，沿路每段链路一个编号（不可能统一编号，因为每段链路负载不一样）\n  3. 沿途每个网络设备，利用转发表记录经过的每条虚电路\n* 路由器转发分组时根据转发表改写、替换VCID\n* 转发表包括： 输入接口+输入VC+输出接口+输出VC\n\n虚电路信令协议 signaling protocols：\n\n* 用于虚电路的建立、维护及拆除\n  * 路径选择\n* 应用于虚电路网络，如ATM，帧中继 frame-relay网络等\n* 目前的Internet不采用\n\n##### 数据报网络\n\n提供网络层无连接服务\n\n每个分组携带目的地址\n\n路由器根据目的地址转发分组：\n\n* 根据路由协议、路由算法构建转发表\n* 检索转发表\n* 每个分组独立选路\n\n数据报转发表：\n\n* 转发表中目的地址针对地址范围\n* 最长前缀匹配优先：优先选择匹配前缀最长的入口\n\n\n\n数据报网络和VC网络的对比：\n\n* 数据报网络 Internet：\n  * 计算机之间数据交换：\n    * 时间要求不严格\n  * 链路类型众多：\n    * 特点、性能各异\n    * 统一服务困难\n  * 智能端系统（计算机）\n  * 简化网络，复杂边缘\n* VC网络 ATM：\n  * 电话网络演化而来\n  * 核心业务是实时对话：\n    * 严格时间、可靠性\n  * 非智能端系统（电话机、传真机）\n  * 简化边缘，复杂网络\n\n#### IP协议\n\nICMP协议（IP协议的伴随协议）：\n\n* 差错报告\n* 路由器信令\n\nIP数据报：\n\n* 格式：\n  * 头部\n    * 固定部分：20字节\n    * ![IP](http://ot1c7ttzm.bkt.clouddn.com/IP.png)\n      * 版本号： 4-bit，IP协议的版本： 4：ipv4, 6：ipv6\n      * 首部长度：4-bit：IP分组首部长度，以4字节为单位\n      * 服务类型 TOS，占 8-bit：指示期望获得哪种类型的服务\n        * 98年改名为区分服务，只有在网络提供区分服务diffserv时使用\n        * 一般不使用，通常为00H\n      * 总长度： 16-bit， IP分组的总字节数（首部+数据），最多可以放65535-20 Byte\n      * 生存时间 TTL，8-bit：IP分组在网络中可以通过的路由器数，路由器转发一次分组，TTL-1，TTL==0时路由器丢弃该分组\n      * 协议，8-bit：指示IP分组封装的是哪个协议的数据报，实现复用、分解， 6：TCP， 17：UDP\n      * 首部校验和 16-bit：对IP首部差错检测，计算校验和时该字段置0，逐跳计算，逐跳检验\n      * 源IP地址、目的IP地址，各32-bit\n    * 可变部分： 0字节<=长度<=40字节，携带安全、源选路径、时间戳和路由记录等内容，实际很少被使用\n    * 填充部分：长度可变， 0<=长度<=3B，目的是补齐首部符合32位对齐\n  * 数据\n\nIP分片：\n\n* 最大传输单元 MTU：链路层 数据帧可封装数据的上限，不同链路MTU不同\n* 当大IP分组向小MTU链路转发时，**可以**被分片 fragmented，若不允许分片且放不下，则将分组扔掉\n* 一个大IP分组分成多个小IP分片，IP分片到达目的主机进行重装 reassembled\n* IP首部的相关字段用于标识分片以及确定分片的相对顺序\n* 涉及字段：\n  * 总长度\n  * 标识 16-bit：用于标识一个IP分组，每产生一个IP分组计时器加1，作为该IP分组的标识\n  * 标志位 3-bit：保留，DF don't fragment ， MF more fragment：\n    * DF=1：禁止分片   DF=0：允许分片\n    * MF=1：非最后一片， MF=0：最后一片（或未分片）\n  * 片偏移 13-bit：一个IP分组分片封装原数据的相对偏移量（未分片则为0），以8字节为单位\n\n分片过程：\n\n* 若 总长度>MTU且 DF=0，则分片\n* 每个分片标识复制原IP分组的标识\n* 除最后一片，其他分片均分为MUT最大允许分片\n* 一个最大分片可封装的数据应该是8的倍数，可封装数据为 d = [ (M-20) / 8]*8（向下取整）（20字节头部）\n* 需要总的片数  n = [(L-20)/d] (向上取整)\n* 每片的片偏移字段取值为  F = d/8 * (i-1)  1<=i<=n\n* 每片总字段长度   Li = d+20 （非最后一片）  Li= L-(n-1)d （最后一片）\n\n#### IP编址 addressing\n\n接口 interface：主机、路由器与物理链路的连接：\n\n* 实现网络层功能\n* 路由器通常有多个接口\n* 主机通常只有一个或两个接口\n\nIP地址：32-bit  IPv4：\n\n* 编号标识主机、路由器的接口\n* 32-bit =》  4个8bit的点分十进制地址\n* IP地址与每个接口关联\n* 如何为接口分配IP地址：\n  * IP地址分为两部分：网络号netID （高位）+ 主机号hostID（低位）：\n  * IP子网 subnet：\n    * IP地址具有相同网络号的设备接口\n    * 不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口\n\n##### 有类IP地址\n\n有类编址：\n\n* A类地址 （50%） （第一位为0）  netID 8-bit，hostID 24-bit  0.0.0.0~127.255.255.255\n\n* B类地址 （25%）（1\\2位为10） netID 16-bit  hostID 16-bit   128.0.0.0~191.255.255.255\n\n* C类地址（12.5%）（11） netID 24-bit， hostID 8-bit   192.0.0.0~223.255.255.255\n\n* D、E不再区分netID和hostID\n\n  * D类地址（6.25%）（1110） ：多播地址\n    * 用作特殊目的：命名或标识一组主机，理论上可分布在任何地方，只能向其发送数据\n  * E类地址（6.25%）（1111）：研究所用\n\n* 特殊IP地址\n\n  ![特殊IP](http://ot1c7ttzm.bkt.clouddn.com/specialIP.png)\n\n* 私有地址：只用于内部网络，在公共环境无效\n\n  * A类： netID 10 ，1个\n  * B类： netID 172.16到172.31      16个\n  * C类： netID 192.168.0 到 192.168.255      255个 \n\n##### IP子网及子网掩码\n\n子网划分：\n\n* IP地址：\n  * 网络号 netID：高位比特\n  * 子网号 subid ：原网络主机号部分比特\n  * 主机号 hostID：低位比特\n* 子网掩码：\n  * 确定是否划分了子网，利用多少位划分子网\n  * 形式和IP地址相同， 32-bit，点分十进制形式\n  * 取值： netID、subID全取1，hostID位全取0\n  * 默认子网掩码：\n    * A类默认子网掩码：255.0.0.0\n    * B类默认子网掩码：255.255.0.0\n    * C类默认子网掩码：255.255.255.0\n    * 借用3比特划分子网的B类子网掩码 255.255.224.0\n  * 子网地址 + 子网掩码 ：准确确定子网大小\n  * 应用：\n    * IP分组的目标IP地址与子网掩码按位与运算提取子网地址\n    * 子网地址，地址范围 -> 去除不可用地址 -> 可分配地址范围\n\n\n### 网络层（中）\n\n#### CIDR与路由聚合\n\n无类域间路由 classless interdomain routing：\n\n* 消除ABC类地址界限\n  * netID + subID -> 网络前缀 prefix  任意长度\n* 融合子网地址和子网掩码，方便子网划分\n  * 无类地址格式： a.b.c.d/x  x为前缀长度\n* 优点：\n  * 提高IPV4地址空间分配效率\n  * 提高路由效率：\n    * 将多个子网聚合成一个大网\n    * 构造超网（supernetting）\n    * 路由聚合（route aggregation）\n\n\n#### DHCP协议\n\n主机如何获得IP地址：\n\n* 硬编码：\n  * 静态配置（自行填写）\n    * 默认网关：数据报转发到的路由器默认接口的IP地址\n  * 动态配置协议 DHCP dynamic host configuration protocol：\n    * 从服务器动态获取\n      * IP地址\n      * 子网掩码\n      * 默认网关\n      * DNS服务器名称及IP\n    * 在应用层实现，封装在UDP数据报\n    * 即插即用的协议\n    * 允许地址重用\n    * 支持在用地址续租\n    * 支持移动用户加入网络\n    * 与DHCP服务器交换报文：\n      * 发现报文DHCP discover：客户端进行广播，确认服务器的地址\n      * 提供报文DHCP offer：DHCP服务器利用提供报文进行广播响应并发送IP地址\n      * 请求报文DHCP request：主机广播发送以请求IP地址，并通知其它可能的DHCP服务器回收资源\n      * 确认报文DHCP ack：服务器向主机发送确认消息\n\n#### NAT 网络地址转换\n\n所有离开内网的源IP需要替换成相同NAT的IP地址及不同端口号\n\n动机：\n\n* 只需/只能从ISP申请到一个IP地址\n  * IPV4耗尽\n* 本地网络设备IP地址变更，无需通告外界网络\n* 变更ISP时无需修改内网IP\n* 内网设备对外网不可见，不能直接寻址（安全）\n\n实现：\n\n* 替换：（内到外）\n  * 离开内网的IP数据报的源IP地址及源端口号替换NAT的IP地址及新端口号\n* 记录：\n  * 每对（NAT IP地址及新端口号）与（源IP地址及端口号）替换信息存储到NAT转换表\n* 替换：（外到内）\n  * 发回的数据报，利用NAT转换表替换IP地址和端口号\n\n问题：\n\n* 16-bit端口号字段（0-65535），可以同时支持6万多并行连接\n* 争议：\n  * 路由器应只处理第三层功能（NAT修改了第四层数据段的内容）\n  * 违背了端到端通信原则\n    * 应用开发者必须考虑到NAT的存在，如P2P应用\n  * 地址短缺问题应该由IPv6解决\n\nNAT穿透方案：\n\n* 静态配置NAT：特定端口总是与特定内部IP及端口连接\n* 利用UPnP universal plug and play 互联网网关设备协议IGD internet gateway device自动配置:\n  * 内网主机自动学习到NAT公共IP地址\n  * 在NAT转换表中，增删端口映射\n* 中继 （如 Skype）：\n  * NAT内部客户与中继服务器建立连接\n  * 外部客户也和中继服务器建立连接\n  * 中继服务器桥接两个连接的分组\n\n#### ICMP互联网控制报文协议\n\ninternet control message protocol 互联网控制报文协议支持主机和路由器：\n\n* 差错或异常报告（反馈）\n* 网络探询（主动发送）\n\n分类：\n\n* 差错报告报文（5种）：\n  * 目的不可达\n  * 源抑制 source quench：拥塞控制，路由器向源主机发送，让其降低发送分组速度\n  * 超时、超期（如TTL 可以跨越的路由器数目）\n  * 参数问题：路由器认为IP数据报头部数据有问题\n  * 重定向 redirect：路由器认定路径不对\n* 网络探询（2组）：\n  * 回声（Echo）请求与应答报文（Reply）：探测到目标主机的网络是否通达，如 ping\n  * 时间戳请求与应答报文\n\n不发送ICMP的特殊情况：\n\n* 对ICMP差错报文不再发送ICMP\n* 除对第一个分片外，后续分片都不发送ICMP\n* 所有多播IP数据报都不发送\n* 对特殊地址的IP数据报不发送ICMP\n\n不再使用的ICMP报文：\n\n* 信息请求与应答\n* 子网掩码请求与应答\n* 路由器询问和通告\n\n报文格式：\n\n* ICMP报文封装到IP数据报的数据部分传输\n* ICMP头部：类型、代码、校验和\n\nICMP的应用：Traceroute\n\n#### IPv6\n\n动机：\n\n* 32位ipv4地址空间分配殆尽\n* 改进首部格式：\n  * 快速处理、转发数据报\n  * 支持QoS\n\n数据报格式：\n\n* 固定长度的40字节基本首部\n* 路由器不允许分片（若要分片，源主机分）\n* 基本首部+扩展首部（路由器一般不处理）+数据部分\n* 扩展首部+数据 = 载荷（0至64KB）\n* ![ipv6](http://ot1c7ttzm.bkt.clouddn.com/ipv6.png)\n* 流标签 flow label：标识同一流中的数据报\n* 下一个首部 next header：标识下一个选项首部或上层协议首部\n* 跳步限制：TTL：允许经过的路由器数目\n\n与IPV4的对比：\n\n* 无校验和：以减少每跳处理时间\n* 通过多个选项首部 支持 选项\n* ICMPv6：新版ICMP：\n  * 附加报文类型： packet too big\n  * 多播组管理功能\n\n地址表示：\n\n* 一般形式：冒号分割的8组16进制数，每组4个数字\n* 压缩：用两个连续冒号省略中间的0\n* 兼容ipv4：前8个bit都为0:0:0:0:0：FFFF：ipv4地址 或 ::FFFF:ipv4\n* 地址前缀：ipv6不再使用掩码\n\n基本地址类型：\n\n* 单播unicast： 一对一通信\n* 多播multicast：一对多通信\n* 任意播 anycast：一对一组之一（最近一个）通信\n\nIPV4向IPV6过渡：\n\n* 隧道 tunneling：IPV6数据报作为ipv4数据报的载荷进行封装穿越ipv4的网络\n\n\n### 网络层（下）\n\n#### 路由算法\n\n概念：寻找最小费用路径的算法\n\n静态路由 vs 动态路由：\n\n* 静态路由：\n  * 手工配置的路由\n  * 路由更新慢\n  * 优先级高\n* 动态路由：\n  * 计算得来的路由\n  * 更新快\n    * 定期更新\n    * 及时响应连路费用或网络拓扑变化\n\n全局信息 vs 分散信息：\n\n* 全局信息：\n  * 所有路由器掌握完整网络拓扑和链路费用\n  * 典型算法：链路状态LS路由算法\n* 分散decentralized信息：\n  * 只掌握物理相连的邻居及链路费用\n  * 通过邻居间信息交换及迭代运算\n  * 典型算法：距离向量DV路由算法\n\n\n\n链路状态路由算法：\n\n* 所有路由器掌握网络拓扑和链路费用\n* 通过链路状态广播\n* 采用 dijkstra算法在每个路由器计算单源最短路\n* 存在 震荡oscillations 可能\n\n距离向量（Distance Vector）路由算法：\n\n* 每个路由器只掌握物理相连的邻居及链路费用\n* Bellman-Ford方程（动态规划）\n* 步骤：\n  * 每个结点不定时将自己的DV估计发送给邻居\n  * 结点接收到邻居的新的DV估计时，依据BF更新其自身估计，若估计变化了，则传播给邻居\n  * 距离最终收敛于实际的最小费用\n* 特点：\n  * 异步迭代\n    * 引发局部迭代的因素：\n      * 局部链路费用改变\n      * 邻居的DV更新\n  * 分布式：结点只当自己DV变化时才告诉邻居\n  * 好消息（高费降低费）传播快，坏消息（低费升高费）传播慢\n  * 可能有 无穷计数 count to infinite 问题，解决方案：\n    * 毒性逆转技术 poisoned reverse：\n      * 若Z到X的最小路径是通过Y，则y收到Z到X的费用是正无穷\n    * 定义最大度量 maximum metric：\n      * 定义一个最大的有效费用值，超过最大费用的记为无穷\n\n层次路由：\n\n* 提出原因：把网络抽象为一个图计算路由过于理想化，网络规模过大，管理自治\n* 聚合路由器为一个区域：自治系统AS autonomous system\n* 同一AS内路由器运行相同路由协议算法\n  * 自治系统内部路由协议\n  * 不同自治系统内的路由器可以运行不同的AS内部路由协议\n* 网关路由器 gateway router：\n  * 位于AS边缘\n  * 通过链路连接其他AS的网关路由器\n* 转发表由AS内部路由算法和AS间路由算法共同配置\n* 热土豆路由：将分组发给最近的网关路由器\n\n#### Internet 路由\n\n路由协议：\n\n* AS内部路由： 内部网关协议 IGP interior gateway protocols\n  * 路由信息协议  RIP routing information protocol：\n    * 距离向量路由算法\n    * 距离用跳步数度量（最大有效为15跳步）\n    * 通告advertisement ：每30s，邻居交换一次DV\n    * 每次通告：最多25个目的子网\n    * 链路失效、恢复：\n      * 180s没有收到通告 -> 邻居、链路失效 -> 重新计算路由 -> 向邻居发送新的通告 -> 邻居可能向外发送通告\n    * RIP路由表处理：利用一个称作route-d的应用层进程进行管理\n    * 通告报文周期性通过UDP数据报发送\n  * 开放最短路径优先 OSPF open shortest path first：\n    * 链路状态路由算法：所有路由器对整个网络已知，dijkstra求解：\n      * LS分组扩散（通告）\n      * 每个路由器构造完整的网络AS拓扑图\n      * 利用dijkstra计算\n    * 每个入口对应一个邻居\n    * 通告在整个AS中泛洪\n    * 通告报文直接封装到IP数据报中\n    * 优点：\n      * 安全：所有OSPF报文可以被认证（预防恶意入侵）\n      * 允许使用多条到同一目的的相同费用的路径（RIP只能从中选一条）\n      * 对同一链路针对不同TOS设置不同费用度量\n      * 集成单播与多播路由：\n        * 多播OSPF协议（MOSPF）与OSPF利用相同的拓扑数据\n      * 支持大规模AS分层 hierarchical：\n        * 区边界路由器：同时在主干区和分支区的路由器\n        * 主干路由器：只在主干区\n        * AS边界路由器：连接其它AS\n  * 内部网关路由协议 IGRP interior gateway routing protocol（思科的私有协议）\n* AS间路由协议：BGP border gateway protocol：\n  * 事实上的标准域间路由协议\n  * 为每个AS提供了一种手段：\n    * eBGP：从邻居AS获取子网可传达性信息（外部会话）\n    * iBGP：向所有AS内部路由器传播子网可达性信息（内部会话）\n  * 基础：\n    * BGP会话session：两个路由器交换BGP报文\n      * 通告去往不同目的前缀（子网）的路径\n      * 报文交换基于半永久的TCP连接\n    * BGP报文：\n      * OPEN：建立TCP连接并认证发送方\n      * UPDATE：通告新路径（或撤销原路径）\n      * KEEPALIVE：无UPDATE时保活连接，也用于对OPEN的确认\n      * NOTIFICATION：报告先前报文的差错，也用于关闭连接\n    * 路径信息与BGP路由：\n      * 通告的前缀信息包括BGP属性\n        * 前缀+属性 = “路由”\n      * 两个重要属性：\n        * AS-PATH  AS路径：包含前缀通告所经过的AS路径\n        * NEXT-HOP下一跳：开始一个AS-PATH的路由器的接口，指向下一跳AS\n  * 路由选择：网关路由器收到路由通告后，利用输入策略import policy决策接收或拒绝路由：\n  * 多条路径的挑选准则：\n    1. 本地偏好preference值策略\n    2. 最短AS-PATH\n    3. 最近NEXT-HOP路由器：热土豆路由\n    4. 附加准则\n* 采用不同的AS内、AS间路由协议原因：\n  * 策略：\n    * AS间inter-AS：希望能够管理控制流量如何被路由，谁路由经过网络\n    * intra-AS 内部：单一管理，无需策略决策\n  * 规模：\n    * 层次路由节省路由表大小，减少更新流量\n    * 适应大规模互联网\n  * 性能：\n    * inter-AS间：策略主导\n    * intra-AS内：侧重性能\n\n\n### 数据链路层\n\n#### 链路层服务\n\n术语：\n\n* 结点 nodes：主机和路由器\n* 链路 links：连接相邻结点的通信信道：\n  * 有线链路 wired links\n  * 无线链路 wireless links\n  * 局域网 LANS\n* 帧 frame：链路层的数据分组，封装网络层的数据报\n\n功能：负责通过链路在相邻结点间传输数据报\n\n服务：\n\n* 组帧 framing：\n  * 封装数据报构成数据帧，加头加尾\n  * 帧同步\n* 链路接入 link access：\n  * 若是共享介质时，需要解决信道接入 channel access\n  * 帧首部的MAC地址 ( 物理地址 )，用于标识帧的源和目的\n* 相邻结点间的可靠交付\n  * 低误码率的有线链路很少采用（如光纤，某些双绞线）\n  * 无线链路：误码率高，需要可靠交付\n* 流量控制 flow control：\n  * 协调pacing相邻发送结点与接收\n* 差错检测 error detection：\n  * 应对信号衰减和噪声\n  * 接收端检测到差错：重传或丢弃\n* 差错纠正 error correction （个别协议）：\n  * 纠错编码：接收端可以直接纠正比特差错\n* 全双工和半双工的通信控制\n\n具体实现：\n\n* 链路层在网络接口卡实现\n* 由硬件、软件和固件组成\n* 链接主机的系统总线\n\n#### 差错编码\n\n原理：\n\n* 在数据上增加冗余信息 R 称为监督位或冗余比特\n\n分类：\n\n* 分组码\n  * 线性码\n  * 非线性码\n* 卷积码\n\n差错编码的检错能力：\n\n* 差错编码分为 检错码 和 纠错码\n* 对于检错码，若编码集的汉明距离d = r+1 ， 则该差错编码可以100%检测 r位差错\n  * 汉明距离：编码集中任意两个字符编码不同比特数目的最小值\n* 对于纠错码，汉明距离 d=2r+1，则该差错编码可以100%纠正r位差错（纠成与之距离最近的码字）\n\n常见差错编码：\n\n* 奇偶校验码：0的个数或1的个数加上冗余位为奇数或偶数\n  * 1比特校验位：检测奇数位差错，冗余位少\n  * 二维奇偶校验：\n    * 检测所有奇数位差错、部分偶数位差错\n    * 可以检测同一行或同一列差错\n* Internet校验和  checksum：\n  * 数据划分为16位二进制整数序列\n  * 求和后取反码\n* 循环冗余校验码 CRC\n  * 数据 D 看成一个二进制数\n  * 选择一个 r+1 位的生成比特模式 G\n  * 目标：选择 r 位CRC比特 R 满足 < D,R >刚好可以被G整除\n  * R计算方法： \n    * $ D*2^{r} (XOR)  R = n*G$\n    * $ R =( D*2^r ) mod G $\n  * 可以检测所有突发长度小于r+1位差错\n  * 广泛应用于实际网络\n\n#### 多路访问控制 MAC 协议\n\n两类链路：\n\n* 点对点链路：\n  * 拨号接入的PPP\n  * 以太网交换机和主机间的点对点链路\n* 广播链路（共享介质）\n  * 单一共享广播信道\n  * 两个或两个以上结点同时传输：干扰 interference\n    * 冲突 collision：结点同时接收多个信号\n  * 多路访问控制协议 MAC multiple access control protocol：\n    * 采用分布式算法决定结点如何共享信道\n    * 基于信道本身进行协调\n      * 无带外信道进行协调\n    * 理想的MAC协议：\n      * 完全分散控制：\n        * 无需特定结点协调\n        * 无需时钟、时隙同步\n      * 需要发送数据的结点平分链路带宽\n      * 简单\n    * 分类：\n      * 信道划分 channel partitioning MAC协议：\n        * 多路复用技术 TDMA、FDMA、CDMA、WDMA等\n        * 网络负载重时公平、效率高\n        * 负载轻时效率低\n      * 随机访问 random access MAC协议：\n        * 信道不划分，允许冲突\n        * 采用冲突恢复机制\n        * 结点要发送数据时\n          * 用信道的全部速率发送分组\n          * 没有事先的节点间协调\n        * 需要定义：\n          * 如何检测冲突\n          * 如何从冲突中恢复（通常是延迟重传）\n        * 负载重时冲突大、效率低\n        * 负载低时效率高\n        * 典型随机访问MAC协议：\n          * 时隙soted ALOHA：\n            * 假定：\n              * 假设所有帧大小相等\n              * 时间划分成等长时隙（每个时隙可以传1个帧）\n              * 结点只能在时隙开始时发送帧\n              * 结点间时钟同步\n            * 运行：\n              * 有帧时，在下一个时隙发送：\n                * 无冲突：在下一个时隙发新的帧\n                * 有冲突：在下一个时隙以概率p重发，直至成功\n            * 优点：\n              * 单个结点活动时用整个信道速率\n              * 高度分散化：只需要同步时隙\n              * 简单\n            * 缺点：\n              * 容易冲突，浪费时隙\n              * 空闲时隙\n              * 时钟同步\n              * 效率低，最好情况 37%\n          * ALOHA：\n            * 无时隙划分，纯ALOHA，更简单，无需同步\n            * 有新的帧生成时：立即发送\n            * 冲突可能性大\n            * 比时隙ALOHA协议效率更低，18%\n          * CSMA、CSMA/CD、CSMA/CA\n            * CSMA 载波监听多路访问协议 carrier sense multiple access：发送帧之前监听信道：\n              * 信道空闲：发送完整帧\n              * 信道忙：推迟发送：\n                * 1-坚持CSMA：以概率p=1监听信道\n                * 非坚持CSMA：随机等待一段时间后再监听\n                * P-坚持CSMA：以概率p坚持监听，1-p非坚持\n              * 冲突仍然可能发送：信号传播延迟\n              * 继续发送冲突帧：浪费信道资源\n            * CSMA/CD CSMA with Collision Detection 带冲突检测的CSMA协议：短时间内可以检测冲突\n              * 广泛用于以太网\n              * 检测到冲突后，立刻停止传输\n              * 冲突检测：\n                * 有线局域网易实现：测量信号强度\n                * 无线局域网难实现：接收信号强度淹没在本地发射信号强度下\n              * 边发边听，不发不听\n              * Lmin / R = RTTmax （Lmin：数据帧最小长度，R：网络带宽，RTT：消息来回的时间），发送数据时能够检测到冲突的最小长度，防止数据在冲突时已经发完，因不发不听而不知道有冲突\n            * CSMA/CA 应用于802.11无线局域网\n      * 轮转 taking turns MAC协议：\n        * 结点轮流使用信道\n        * 综合信道划分和随机访问的优点\n        * 类型：\n          * 轮询 polling：\n            * 主结点轮流邀请从属结点发送数据\n            * 典型应用： 哑dump（非智能、蓝牙）从属设备\n            * 问题：\n              * 轮询开销，数据占用带宽\n              * 等待延迟\n              * 单点故障，主结点故障问题\n          * 令牌传递 token passing：\n            * 控制令牌依次从一个结点传递到下一个结点\n            * 令牌：特殊帧，网络中有且只有一个令牌\n            * 网络可能构成环形网络\n            * 问题：\n              * 令牌开销，带宽开销\n              * 等待延迟\n              * 单点故障：令牌丢失\n\n### 局域网\n\n#### ARP协议\n\nMAC地址：物理地址、LAN地址、以太网地址\n\n* 作用：在局域网中标识一个帧从哪个接口发出，到达哪个物理相连的其它接口\n* 48位（16进制6字节）MAC地址，固化在网卡的ROM中，有时可以软件设置\n* 局域网中每块网卡都有唯一的MAC地址\n* 由IEEE统一管理与分配\n* 网卡厂商在IEEE购买前24比特MAC地址空间\n* 与IP地址区别：\n  * MAC地址是“平面地址”，可以从一个LAN移到另一个LAN，用于标识帧\n  * IP地址是层次地址，依赖结点连接到哪个子网，用于标识数据报\n\nARP：地址解析协议\n\n* 已知目的接口的IP地址下确定MAC地址\n* ARP表：LAN中每个IP结点维护一个表，存储某些LAN结点IP/MAC地址映射关系：< IP; MAC ; TTL>(TTL time to live:经过这个时间后该映射关系会丢弃，一般为20min)\n* ARP是“即插即用”协议：结点无需干预，自主创建ARP表\n* 获取目标主机的MAC地址：\n  * 同一局域网内：\n    * 若A的ARP表不包含B的MAC地址，则A广播ARP查询分组，其中包含B的IP地址，只有B向A利用单播帧响应B的MAC地址，A缓存B的地址对直至超时\n  * 不同局域网内：\n    * A发数据帧至网关路由器（源IP为A，目标IP为B，源MAC为A，目的MAC为网关路由器的一端口），网关路由器转发数据报，更改源MAC地址为发出端口的MAC地址，若双方都在公网，则不需要更改IP地址\n\n#### 以太网 Ethernet\n\n有线LAN技术、应用最广泛的LAN技术\n\n物理拓扑：\n\n* 总线 bus：同轴电缆，上世纪90年代中期流行\n  * 所有结点在同一冲突域 collision domain ，可能彼此冲突\n* 星型 star：目前主流网络拓扑\n  * 利用中心交换机 switch\n  * 每个结点一个单独冲突域，结点间彼此不冲突\n\n特点:\n\n* 无连接 connectionless：发送帧的网卡和接收帧的网卡没有握手过程\n* 不可靠 unreliable：接收网卡不向发送网卡进行确认\n  * 出错可能性低，差错帧直接丢弃，依靠高层协议恢复数据\n* 采用二进制指数退避算法CSMA/CD的 MAC协议：\n  1. 网卡从网络层接收数据报，创建数据帧\n  2. 监听信道：\n     1. 监听到信道空闲，则发送帧\n     2. 信道忙，一直等待到信道空闲，然后发送\n  3. 发送完整个帧没有检测到其他结点数据发送，则确认发送成功\n  4. 若检测到其他结点传输数据，终止发送并发送阻塞信号 jam signal\n  5. 网卡进入二进制指数退避：\n     * 第m次连续冲突后：\n       * 取n=Max(m,10)\n       * 网卡从 0到 $2^n-1$随机取一个数K\n       * 等待 K * 512bit的传输延迟时间，再返回第2步\n     * 连续16次冲突后，报告差错\n\n帧结构：\n\n* 把IP数据报封装到以太网帧中\n* 前导码 preamble   8B：\n  * 前7个字节为10101010，第八字节为10101011\n  * 用于发送端和接收端的时钟一致\n* 目的MAC和源MAC地址（各6B）\n* 类型 Type  2B：指示帧中封装哪种高层协议的分组\n* 数据 Data 46-1500B：上层协议载荷 （CSMA/CD发送数据时能够检测到冲突的最小长度）\n* CRC 4B：循环冗余校验码\n","slug":"network_note","published":1,"updated":"2018-06-02T12:59:25.606Z","photos":[],"link":"","_id":"cjleshqkm002xryfcp9pcq7pq","content":"<h3 id=\"概述（上）\"><a href=\"#概述（上）\" class=\"headerlink\" title=\"概述（上）\"></a>概述（上）</h3><p>计算机网络学习笔记，包括：</p>\n<ol>\n<li>基本概念：网络结构、体系结构</li>\n<li>网络层：web、Email、DNS、P2P、Socket</li>\n<li>传输层：TCP、UDP</li>\n<li>网络层：IP、CIDR、DHCP、NAT、ICMP、路由</li>\n<li>数据链路层：差错编码、MAC</li>\n<li>局域网：ARP、以太网</li>\n</ol>\n<a id=\"more\"></a>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>计算机网络 = 通信技术 + 计算机技术</p>\n<p>定义： 计算机网络是互连的、自治的计算机集合</p>\n<p>网络结构：</p>\n<ul>\n<li>网络边缘： 主机、网络应用<ul>\n<li>主机（端系统）：运行网络应用程序</li>\n<li>模型：<ul>\n<li>client、server 客户 服务器模型：客户发送请求，服务器响应</li>\n<li>p2p模型：无专用服务器，通信在对等实体间直接进行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>接入网络，物理介质： 有线或无线通信链路<ul>\n<li>DSL 数字用户线路：用电话线连接，FDM分频</li>\n</ul>\n</li>\n<li>网络核心（核心网络）：互联的路由器、网络的网络<ul>\n<li>核心功能：路由routing + 转发 forwarding<ul>\n<li>路由：确定分组从源到目的传输路径</li>\n<li>转发：分组从路由器输入端口转发至正确的输出端口</li>\n</ul>\n</li>\n<li><strong>数据交换</strong></li>\n</ul>\n</li>\n</ul>\n<p>端系统通过 接入ISP 连接到Internet， 接入ISP互连</p>\n<h4 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h4><p>数据交换：数据通过网络核心从源主机到达目的主机的手段</p>\n<p>数据交换分类：</p>\n<ol>\n<li>电路交换</li>\n<li>报文交换</li>\n<li>分组交换</li>\n</ol>\n<h5 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h5><p>最典型的电路交换网络：电话网络</p>\n<p>三个阶段：</p>\n<ul>\n<li>建立连接</li>\n<li>通信</li>\n<li>释放连接</li>\n</ul>\n<p>特点：资源<strong>独占</strong></p>\n<p>如何共享中继线： 多路复用（Multiplexing）</p>\n<p>多路复用： 链路、网络资源划分资源片，每路独占分配的资源片，资源片可能闲置</p>\n<p>典型多路复用方法：</p>\n<ul>\n<li>频分多路复用 FDM<ul>\n<li>各用户占用不同频率带宽</li>\n<li>通信过程中始终使用一个频带</li>\n</ul>\n</li>\n<li>时分多路复用 TDM<ul>\n<li>将时间划分为等长的帧，帧划分为时隙，每个用户使用固定序号的时隙</li>\n<li>每个用户的时隙周期性出现（周期为帧长度）</li>\n<li>所有用户使用所有频带宽度</li>\n</ul>\n</li>\n<li>波分多路复用 WDM<ul>\n<li>光的频分复用</li>\n</ul>\n</li>\n<li>码分多路复用 CDM<ul>\n<li>广泛应用于无线链路共享</li>\n<li>每个用户有唯一的码片序列，码片序列之间正交</li>\n<li>用户用码片序列编码自己的数据</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"报文交换-message-switching\"><a href=\"#报文交换-message-switching\" class=\"headerlink\" title=\"报文交换 message switching\"></a>报文交换 message switching</h5><p>一次发送信息整体</p>\n<h5 id=\"分组交换-package-switching\"><a href=\"#分组交换-package-switching\" class=\"headerlink\" title=\"分组交换 package switching\"></a>分组交换 package switching</h5><p>分组： 报文拆分出的一系列较小的数据包</p>\n<p>需要报文的拆分和重组</p>\n<p>每个分组需要额外的分组头</p>\n<p><strong>统计多路复用 statistical multiplexing</strong>： 按需共享（传输数据多的速度快，数据少的速度慢）</p>\n<p>交换方式： <strong>存储-转发</strong>：</p>\n<p>​    一次存储整个分组，而后转发</p>\n<p>分组交换和电路交换：</p>\n<p>分组交换适用于突发数据传输：</p>\n<ul>\n<li>优点<ul>\n<li>资源充分共享<ul>\n<li>简单、无需建立呼叫电路</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>可能产生拥塞 congestion： 分组延迟和丢包</li>\n<li>需要协议处理可靠数据传输和拥塞控制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概述（下）\"><a href=\"#概述（下）\" class=\"headerlink\" title=\"概述（下）\"></a>概述（下）</h3><h4 id=\"计算机网络性能\"><a href=\"#计算机网络性能\" class=\"headerlink\" title=\"计算机网络性能\"></a>计算机网络性能</h4><p>速率：</p>\n<ul>\n<li>速率、数据率、比特率： 单位时间(秒)内传输信息（比特）量， b/s ,bps, kb/s</li>\n<li>速率往往指的是额定速率、标称速率（理论值）</li>\n</ul>\n<p>带宽： </p>\n<ul>\n<li>原本：信号具有的频带宽度，最高频率和最低频率之差，单位 hz</li>\n<li>网络：数字信道所能传输的最大数据率，单位 b/s</li>\n</ul>\n<p>延迟delay、时延 latency：</p>\n<ul>\n<li>原因： 分组在路由器缓存中排队</li>\n<li>四种类型：<ul>\n<li>处理延迟( nodal processing delay)：<ul>\n<li>差错检测</li>\n<li>确定输出链路</li>\n<li>通常毫秒、微秒级 </li>\n</ul>\n</li>\n<li>排队延迟 (queueing delay)<ul>\n<li>等待输出链路可用</li>\n<li>取决于路由器拥塞程度</li>\n</ul>\n</li>\n<li>传输延迟 (transmission delay) ：路由器到链路<ul>\n<li>取决于分组长度L、链路带宽R， d trans = L/R</li>\n</ul>\n</li>\n<li>传播延迟 (propagation delay)：链路上到下一个路由器<ul>\n<li>取决于链路长度d，信号传播速度s，　d prop = d/s</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>d nodal = d proc + d queue + d trans + d prop</li>\n</ul>\n<p>时延带宽积＝传播时延＊带宽 = 链路上能容纳多少比特</p>\n<p>丢包：</p>\n<ul>\n<li>原因：队列缓存有限</li>\n<li>分组到达已满队列将被丢弃</li>\n<li>丢弃分组可能由前序结点或源重发</li>\n<li>以丢包率衡量</li>\n</ul>\n<p>吞吐量  throughput</p>\n<ul>\n<li>发送端与接收端之间的速率</li>\n<li>分类：<ul>\n<li>即时吞吐量</li>\n<li>平均吞吐量<ul>\n<li>取决于端到端路径上，最小速率的链路</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h4><p>用<strong>分层结构</strong>从<strong>功能上</strong>描述计算机网络体系</p>\n<p>每层完成一个特定功能，每层依赖底层提供的服务</p>\n<p>每层遵循某个协议完成本层功能</p>\n<p>计算机网络体系结构是计算机网络各层及其协议的集合</p>\n<p>分层结构的优点</p>\n<ul>\n<li>结构清晰</li>\n<li>模块化思想，易于系统更新、维护<ul>\n<li>任何一层服务实现上的改变对其它层不影响​</li>\n</ul>\n</li>\n</ul>\n<p>基本概念：</p>\n<ul>\n<li>实体 entity ： 任何可发送或接收信息的硬件或软件进程</li>\n<li>协议 protocol：控制两个对等实体进行通信的规则的集合（同层的，水平的）</li>\n<li>服务是垂直的，任一层实体需要使用下层服务，遵循本层协议，实现本层功能，对上层提供服务</li>\n<li>下层实现对上层是不可见的</li>\n<li>相邻层之间通过接口进行交互，通过服务访问点SAP</li>\n</ul>\n<h5 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h5><p>概念：</p>\n<ul>\n<li>目的： 支持异构网络系统的互联互通</li>\n<li>异构网络系统互连的国际标准</li>\n<li>理解网络通信的最佳学习工具（理论模型，市场失败）</li>\n</ul>\n<p>分层： 7层：</p>\n<ul>\n<li>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>\n<li>主机需要完成7层</li>\n<li>路由器只需要完成3层，物理层、链路层、网络层</li>\n<li>数据纵向流动，协议水平</li>\n<li>端到端层 end-end： 应用层到传输层 四层</li>\n</ul>\n<p>数据封装和通信过程：</p>\n<ol>\n<li>APDU 应用层数据单元</li>\n<li>PPDU 表示层</li>\n<li>SPDU 会话层</li>\n<li>TPDU 传输层</li>\n<li>NPDU 网络层</li>\n<li>DPDU 链路层加头加尾</li>\n<li>物理层对应比特，不加额外信息</li>\n</ol>\n<ul>\n<li>增加控制信息： 最终构造成 PDU 构造协议数据单元</li>\n<li>控制信息包括：<ul>\n<li>地址： 标识发送端、接收端</li>\n<li>差错检测编码：差错检测或纠正</li>\n<li>协议控制：实现协议功能的附加信息</li>\n</ul>\n</li>\n</ul>\n<p>功能：</p>\n<ul>\n<li>物理层功能：   总：实现比特的传输<ul>\n<li>定义、规范接口特性<ul>\n<li>机械特性：接口的几何形状</li>\n<li>电气特性：接口的电平、电压</li>\n<li>功能特性：多少引脚、引脚的功能</li>\n<li>规程特性：接口的使用规则，也叫过程特性</li>\n</ul>\n</li>\n<li>比特编码</li>\n<li>数据率</li>\n<li>比特同步： 时钟同步问题</li>\n<li>传输模式<ul>\n<li>单工模式 simplex ： 单向发信（如电视）</li>\n<li>半双工 half-duplex ： 可双向，但只能交替进行（如对讲机）</li>\n<li>全双工 full-duplex ： 可同时收发</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据链路层功能：<ul>\n<li>负责结点-结点 node-to-node数据传输</li>\n<li>以帧为单位进行传输</li>\n<li>功能：<ul>\n<li>组帧 framing ： 加头加尾 ： 使得接收方能够切分帧病识别控制信息</li>\n<li>物理寻址 physical addressing：包含源和目的物理地址</li>\n<li>流量控制 flow control ： 避免淹没接收端</li>\n<li>差错控制 error control ： 检测并重传损坏或丢失帧，并避免重复帧</li>\n<li>访问（接入）控制 access control：决定哪个设备拥有链路的控制使用权</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络层功能：负责数据分组packet的交付<ul>\n<li>原因：可能穿越多个网络</li>\n<li>逻辑寻址 logical addressing： 全局唯一逻辑地址，确保数据分组被送到目的地，如IP地址</li>\n<li>路由 routing： 选择路径</li>\n<li>分组转发</li>\n</ul>\n</li>\n<li>传输层功能： 负责端-端 完整报文的传输<ul>\n<li>报文的分段和重组</li>\n<li>SAP寻址：确保报文提交给正确进程，如端口号</li>\n<li>连接控制：逻辑连接</li>\n<li>流量控制</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>会话层功能： 插入控制信息<ul>\n<li>对话控制 dialog controlling： 对话的建立与维护</li>\n<li>对话同步 synchronization： 数据流中插入同步点</li>\n<li>最“薄”的一层</li>\n</ul>\n</li>\n<li>表示层功能： 编码、加密、压缩数据<ul>\n<li>数据表示转化<ul>\n<li>转换为主机独立的编码</li>\n</ul>\n</li>\n<li>加密解密</li>\n<li>压缩解压缩</li>\n</ul>\n</li>\n<li>应用层功能：支持用户通过接口使用网络服务<ul>\n<li>典型类型：<ul>\n<li>FTP 文件传输</li>\n<li>HTTP WEB</li>\n<li>SMTP 电子邮件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"TCP-IP模型\"><a href=\"#TCP-IP模型\" class=\"headerlink\" title=\"TCP / IP模型\"></a>TCP / IP模型</h5><p>四层： 应用层、运输层、网际层、网络接口层</p>\n<h5 id=\"五层参考模型\"><a href=\"#五层参考模型\" class=\"headerlink\" title=\"五层参考模型\"></a>五层参考模型</h5><p>综合OSI和TCP/IP模型的优点</p>\n<p>应用层、传输层、网络层、数据链路层、物理层</p>\n<p>层次：</p>\n<ul>\n<li>主机 五层</li>\n<li>路由器 三层</li>\n<li>交换机 两层</li>\n</ul>\n<h4 id=\"网络发展历史\"><a href=\"#网络发展历史\" class=\"headerlink\" title=\"网络发展历史\"></a>网络发展历史</h4><p>1961-1972： 交换分组原理提出与应用</p>\n<p>1972-1980：网络互连，大量新型、私有网络的涌现</p>\n<p>1980-1990：新型网络协议与网络的激增</p>\n<p>1990-2000初： 商业化，web，新应用</p>\n<p>2005-今</p>\n<h3 id=\"网络应用（上）\"><a href=\"#网络应用（上）\" class=\"headerlink\" title=\"网络应用（上）\"></a>网络应用（上）</h3><p>应用层 - 传输层 - 网络层 - 链路层 - 物理层</p>\n<h4 id=\"网络应用层概述\"><a href=\"#网络应用层概述\" class=\"headerlink\" title=\"网络应用层概述\"></a>网络应用层概述</h4><ul>\n<li>网络应用体系结构</li>\n<li>网络应用的服务需求</li>\n<li>Internet传输层服务模型</li>\n<li>特定网络应用与协议</li>\n<li>Socket编程</li>\n</ul>\n<h4 id=\"网络应用的基本原理\"><a href=\"#网络应用的基本原理\" class=\"headerlink\" title=\"网络应用的基本原理\"></a>网络应用的基本原理</h4><h5 id=\"网络应用的体系结构\"><a href=\"#网络应用的体系结构\" class=\"headerlink\" title=\"网络应用的体系结构\"></a>网络应用的体系结构</h5><ul>\n<li>客户机、服务器结构  C/S  Client-Server<ul>\n<li>服务器<ul>\n<li>7*24小时提供服务</li>\n<li>永久性访问地址\\域名</li>\n<li>利用大量服务器实现可扩展性（处理大量并发请求）</li>\n</ul>\n</li>\n<li>客户机<ul>\n<li>与服务器通信，使用服务器提供的服务</li>\n<li>间歇性接入网络</li>\n<li>可能使用动态IP</li>\n<li>不会和其他客户机直接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>点对点结构 P2P Peer-to-peer<ul>\n<li>没有永远在线的服务器</li>\n<li>任意端系统之间可以直接通信</li>\n<li>节点间歇性接入网络</li>\n<li>节点可能改变IP</li>\n<li>优点：高度可伸缩、可扩展</li>\n<li>缺点：难以管理</li>\n</ul>\n</li>\n<li>混合结构 hyrid</li>\n</ul>\n<h5 id=\"网络应用进程通信\"><a href=\"#网络应用进程通信\" class=\"headerlink\" title=\"网络应用进程通信\"></a>网络应用进程通信</h5><p>同一主机上进程通信：</p>\n<ul>\n<li>进程间通信机制</li>\n<li>由操作系统提供</li>\n</ul>\n<p>不同主机进程通信：消息交换</p>\n<p>Socket套接字：进程间利用socket发送和接受消息</p>\n<p>传输基础设施向进程提供API：</p>\n<ul>\n<li>传输协议的选择</li>\n<li>参数的设置</li>\n</ul>\n<p>进程寻址：</p>\n<ul>\n<li>不同主机进程通信，每个进程必须有标识符</li>\n<li>寻址主机：IP地址</li>\n<li>端口号 port number：主机上每个需要通信的进程分配一个端口号</li>\n<li>已经分配的端口： HTTP：80     mail：25</li>\n<li>进程的标识符： IP+端口号</li>\n</ul>\n<p>应用层协议：</p>\n<ul>\n<li>网络应用都应该遵循应用层协议</li>\n<li>公开协议： <ul>\n<li>由 RFC（request for comments）定义</li>\n<li>允许互操作</li>\n<li>例如： HTTP、SMTP</li>\n</ul>\n</li>\n<li>私有协议：<ul>\n<li>多数P2P文件共享应用</li>\n</ul>\n</li>\n<li>内容：<ul>\n<li>消息的类型type：<ul>\n<li>请求消息</li>\n<li>响应消息</li>\n</ul>\n</li>\n<li>消息的语法syntax 、格式<ul>\n<li>消息中由哪些字段 field</li>\n<li>每个字段如何描述</li>\n</ul>\n</li>\n<li>字段的语义 semantics ：信息的含义</li>\n<li>规则 rules： 何时、如何发送、相应消息</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"网络应用的需求与传输层服务\"><a href=\"#网络应用的需求与传输层服务\" class=\"headerlink\" title=\"网络应用的需求与传输层服务\"></a>网络应用的需求与传输层服务</h5><p>需求：</p>\n<ul>\n<li>数据丢失 data loss、 可靠性reliability<ul>\n<li>某些可容忍一定的数据丢失：网络电话</li>\n<li>某些要求100%可靠的数据传输</li>\n</ul>\n</li>\n<li>时间timing 、 延迟 delay：<ul>\n<li>延迟低才有效（网络电话、网络游戏）</li>\n</ul>\n</li>\n<li>带宽 bandwidth：<ul>\n<li>带宽达到最低要求才有效：网路视频</li>\n<li>可适应任何带宽——弹性应用：email、文件下载</li>\n</ul>\n</li>\n</ul>\n<p>传输服务：</p>\n<ul>\n<li>TCP服务：<ul>\n<li>面向连接：客户机和服务器需要建立连接</li>\n<li>可靠的传输</li>\n<li>流量控制：发送方不会发送速度过快</li>\n<li>拥塞控制：网络负载过重时能限制发送方发送速度</li>\n<li>不提供时间保障</li>\n<li>不提供最小带宽保障</li>\n</ul>\n</li>\n<li>UDP服务：<ul>\n<li>无连接</li>\n<li>不可靠</li>\n<li>不提供：可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h4><h5 id=\"web与http\"><a href=\"#web与http\" class=\"headerlink\" title=\"web与http\"></a>web与http</h5><p>web：</p>\n<ul>\n<li>网页</li>\n<li>网页互相链接</li>\n</ul>\n<p>网页 webpage 包含多个对象 objects：</p>\n<ul>\n<li>对象：html文件、jpeg图片、视频、动态脚本</li>\n<li>基本html文件：包含对其他对象引用的链接</li>\n</ul>\n<p>对象的寻址 addressing：</p>\n<ul>\n<li>URL（uniform resource locator）：统一资源定位器</li>\n<li>格式：  Scheme:// host:port/path</li>\n</ul>\n<p>HTTP协议 hypertext transfer protocol 超文本传输协议：</p>\n<ul>\n<li>CS结构：<ul>\n<li>客户- browser：请求、接受、展示web对象</li>\n<li>服务器-web server：相应客户请求、发送对象</li>\n</ul>\n</li>\n<li>使用TCP传输服务</li>\n<li>无状态 stateless：服务器不维护任何过去发送请求的信息</li>\n</ul>\n<h5 id=\"HTTP连接\"><a href=\"#HTTP连接\" class=\"headerlink\" title=\"HTTP连接\"></a>HTTP连接</h5><p>非持久性连接 nonpersistent http：</p>\n<ul>\n<li>每个TCP连接最多允许传输一个对象</li>\n<li>在HTTP 1.0版本</li>\n<li>缺点：<ul>\n<li>每个对象需要2个RTT</li>\n<li>操作系统要为每个TCP连接开销资源</li>\n<li>浏览器需要打开多个并行TCP连接获取对象</li>\n</ul>\n</li>\n</ul>\n<p>持久性连接：</p>\n<ul>\n<li>每个TCP连接允许传输多个对象</li>\n<li>HTTP 1.1默认</li>\n<li>发送响应后，服务器保持TCP连接打开以发送后续HTTP消息</li>\n<li>分类：<ul>\n<li>无流水pipelining的持久性连接<ul>\n<li>客户端受到一个响应才发送一个新请求</li>\n<li>每个对象消耗 1RTT</li>\n</ul>\n</li>\n<li>流水机制的持久性连接：<ul>\n<li>HTTP 1.1默认</li>\n<li>客户端遇到一个引用对象就尽快发送请求</li>\n<li>理想情况下收到所有引用对象只需要约 1RTT</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>响应时间 RTT ： round trip time：从客户端发送一个很小数据包到服务器并返回所经历的时间</p>\n<h5 id=\"HTTP请求消息\"><a href=\"#HTTP请求消息\" class=\"headerlink\" title=\"HTTP请求消息\"></a>HTTP请求消息</h5><p>HTTP协议两类信息：</p>\n<ul>\n<li>请求消息 request<ul>\n<li>ASCII：人直接可读</li>\n<li>上传输入的方法：<ul>\n<li>POST方法：在请求消息的消息体中输入</li>\n<li>URL方法：GET方法：输入信息通过request行中的URL段上传</li>\n<li>HEAD：请求服务器不要把所请求对象放入相应消息中（只返回头，一般用作测试）</li>\n<li>PUT：（HTTP  1.1）消息体中的文件上传到URL段所指定的路径（上传文件到服务器）</li>\n<li>DELETE：（HTTP1.1）删除URL字段指定文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>响应消息 response<ul>\n<li>状态响应代码：相应消息的第一行</li>\n<li>如 200 OK， 404 Not Found</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Cookie-方法\"><a href=\"#Cookie-方法\" class=\"headerlink\" title=\"Cookie 方法\"></a>Cookie 方法</h5><p>cookie技术：网站为辨明用户身份、通过session跟踪而存储在用户本地终端的数据</p>\n<p>RFC 6265</p>\n<p>Cookie组件：</p>\n<ul>\n<li>HTTP响应消息的Cookie头部行</li>\n<li>HTTP请求消息的Cookie头部行</li>\n<li>保存在客户端主机的Cookie文件，由浏览器管理</li>\n<li>web服务器端的后台数据库</li>\n</ul>\n<p>Cookie的作用：</p>\n<ul>\n<li>身份认证、购物车、推荐、email</li>\n</ul>\n<p>隐私问题</p>\n<h5 id=\"web缓存、代理服务器技术\"><a href=\"#web缓存、代理服务器技术\" class=\"headerlink\" title=\"web缓存、代理服务器技术\"></a>web缓存、代理服务器技术</h5><p>功能：在不访问服务器的前提下满足客户端的HTTP请求</p>\n<p>原因： 性能优化</p>\n<ul>\n<li>缩短客户请求响应时间</li>\n<li>减少机构、组织流量</li>\n<li>在大范围内实现有效内容分发</li>\n</ul>\n<p>步骤：</p>\n<ul>\n<li>用户设定浏览器通过缓存进行web访问</li>\n<li>浏览器向缓存、代理服务器发送所有HTTP请求<ul>\n<li>若请求对象在缓存中 ，则缓存返回对象</li>\n<li>若不在缓存，则缓存服务器向原始服务器发送HTTP请求，获取对象并返回给客户端、并保存对象</li>\n</ul>\n</li>\n</ul>\n<p>解决对象更新问题： 条件性GET</p>\n<ul>\n<li>若缓存为最新版本，则不需要发送请求对象</li>\n<li>缓存服务器请求信息中声明持有版本的日期 modified 日期</li>\n<li>目标服务器：<ul>\n<li>若缓存版本是最新的，响应消息中不包含对象，返回 304 Not Modified</li>\n<li>若缓存版本不是最新，则返回对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Email-应用\"><a href=\"#Email-应用\" class=\"headerlink\" title=\"Email 应用\"></a>Email 应用</h4><h5 id=\"email应用概述\"><a href=\"#email应用概述\" class=\"headerlink\" title=\"email应用概述\"></a>email应用概述</h5><p>构成组件：</p>\n<ul>\n<li>客户端</li>\n<li>服务器<ul>\n<li>邮箱：存储发给该用户的email</li>\n<li>消息队列 msessage queue：存储等待发送的email</li>\n</ul>\n</li>\n<li>SMTP协议：email消息传输、交换协议<ul>\n<li>邮件服务器之间传递消息所使用的协议</li>\n<li>客户端：发送消息的服务器</li>\n<li>服务器：接受消息的服务器</li>\n<li>端口25</li>\n<li>使用TCP 进行可靠传输、持久性连接</li>\n<li>三个阶段：<ul>\n<li>握手</li>\n<li>消息传输</li>\n<li>关闭</li>\n</ul>\n</li>\n<li>命令、相应交互模式：<ul>\n<li>命令 command：ASCII文本</li>\n<li>响应 response：状态代码和语句</li>\n</ul>\n</li>\n<li>email消息只能包含7位ASCII码</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Email消息格式与POP3协议\"><a href=\"#Email消息格式与POP3协议\" class=\"headerlink\" title=\"Email消息格式与POP3协议\"></a>Email消息格式与POP3协议</h5><p>RFC 822：文本消息格式标准：</p>\n<ul>\n<li>头部行 header<ul>\n<li>To 、 From、 Subject</li>\n</ul>\n</li>\n<li>消息体 body<ul>\n<li>消息本身，只能是ASCII字符</li>\n</ul>\n</li>\n</ul>\n<p>为了支持多媒体： 使用 MIME 多媒体邮件扩展</p>\n<ul>\n<li>在邮件头部增加额外的行声明MIME的内容类型</li>\n</ul>\n<p>邮件访问协议：收件方从服务器获取邮件</p>\n<ul>\n<li>POP：post office protocol 协议：两个阶段：认证/授权和下载<ul>\n<li>模式：<ul>\n<li>下载并删除模式：用户换了客户端软件，则无法重读邮件</li>\n<li>下载并保持模式：不同客户端都可以保存拷贝</li>\n</ul>\n</li>\n<li>POP3是无状态协议（服务器没有记忆功能）</li>\n</ul>\n</li>\n<li>IMAP: internet mail access protocol协议<ul>\n<li>更多功能、更复杂，新于POP3</li>\n<li>可操纵服务器上存储的消息</li>\n<li>所有消息统一保存在服务器</li>\n<li>允许用户利用文件夹组织消息</li>\n<li>支持跨会话Session 的用户状态</li>\n<li>有状态协议</li>\n</ul>\n</li>\n<li>HTTP协议： 163、 qq 、 mail</li>\n</ul>\n<h4 id=\"DNS应用\"><a href=\"#DNS应用\" class=\"headerlink\" title=\"DNS应用\"></a>DNS应用</h4><h5 id=\"DNS概述\"><a href=\"#DNS概述\" class=\"headerlink\" title=\"DNS概述\"></a>DNS概述</h5><p>DNS：domain name system 域名系统：解决Internet上主机、路由器识别问题</p>\n<p>DNS域名解析系统：域名和IP地址的映射</p>\n<ul>\n<li>多层命名服务器构成的分布式数据库</li>\n<li>应用层协议：完成名字的解析<ul>\n<li>Internet核心功能，用应用层协议实现</li>\n<li>网络边界复杂</li>\n</ul>\n</li>\n</ul>\n<p>服务：</p>\n<ul>\n<li>域名向IP地址翻译</li>\n<li>主机别名</li>\n<li>邮件服务器别名</li>\n<li>负载均衡：web服务器</li>\n</ul>\n<p>集中式DNS的问题： 不可伸缩</p>\n<ul>\n<li>单点失败问题：服务器坏掉</li>\n<li>流量问题</li>\n<li>距离问题</li>\n<li>维护性问题</li>\n</ul>\n<p>分布式层次式数据库：</p>\n<ol>\n<li>根服务器 root</li>\n<li>顶级域名服务器  com、org、edu等</li>\n</ol>\n<p>根域名服务器： 本地域名解析服务器无法解析域名时，访问根域名服务器</p>\n<ul>\n<li>不知道映射时，访问权威域名服务器</li>\n</ul>\n<p>顶级域名服务器 TLD top-level domain：负责com、edu等</p>\n<p>权威域名服务器：组织的域名解析服务器，负责解析组织内部服务器的解析服务</p>\n<ul>\n<li>组织负责维护</li>\n<li>服务提供商负责维护</li>\n</ul>\n<p>本地域名解析服务器：</p>\n<ul>\n<li>不严格属于层次体系</li>\n<li>每个ISP都有一个本地域名服务器：默认的服务器</li>\n<li>本地服务器作为代理，把查询转发给域名解析服务器系统</li>\n<li>查询方式：<ul>\n<li>迭代查询：获得下一个服务器地址，本地服务器挨个询问</li>\n<li>递归查询：本地服务器把询问任务交给根服务器</li>\n</ul>\n</li>\n</ul>\n<p>DNS记录缓存与更新：</p>\n<ul>\n<li>本地域名服务器一般会缓存顶级域名服务器的映射<ul>\n<li>因此根域名服务器不经常被访问</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"DNS记录与消息格式\"><a href=\"#DNS记录与消息格式\" class=\"headerlink\" title=\"DNS记录与消息格式\"></a>DNS记录与消息格式</h5><p>资源记录 RR resource records</p>\n<p>格式： name value type ttl</p>\n<p>类型：</p>\n<ul>\n<li>Type = A<ul>\n<li>Name：主机域名</li>\n<li>value：IP地址</li>\n</ul>\n</li>\n<li>Type = NS<ul>\n<li>Name：域</li>\n<li>value：该域的权威域名解析服务器的主机域名</li>\n</ul>\n</li>\n<li>Type = CNAME<ul>\n<li>Name：某一域名的别名</li>\n<li>Value：真实域名</li>\n</ul>\n</li>\n<li>Type = MX<ul>\n<li>Value ：与name对应的邮件服务器</li>\n</ul>\n</li>\n</ul>\n<p>DNS协议：</p>\n<ul>\n<li>查询query 和回复 reply</li>\n<li>消息格式相同<ul>\n<li>头部：<ul>\n<li>identification：16位查询编号，回复使用相同编号</li>\n<li>flags</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网络应用（下）\"><a href=\"#网络应用（下）\" class=\"headerlink\" title=\"网络应用（下）\"></a>网络应用（下）</h3><h4 id=\"P2P应用\"><a href=\"#P2P应用\" class=\"headerlink\" title=\"P2P应用\"></a>P2P应用</h4><h5 id=\"P2P应用：原理与文件分发\"><a href=\"#P2P应用：原理与文件分发\" class=\"headerlink\" title=\"P2P应用：原理与文件分发\"></a>P2P应用：原理与文件分发</h5><p>典型协议：BT BitTorrent：</p>\n<ul>\n<li>torrent：交换同一个文件的文件块的节点组</li>\n<li>tracker：跟踪参与torrent的节点</li>\n</ul>\n<p>获取chunk：</p>\n<ul>\n<li>给定任意时刻，不同节点持有文件的不同chunk集合</li>\n<li>节点定期查询每个邻居持有的chunk列表</li>\n<li>节点发送请求，请求获取缺失的chunk：<ul>\n<li>稀缺优先原则</li>\n</ul>\n</li>\n</ul>\n<p>发送chunk： tit-for-tat：</p>\n<ul>\n<li>向4个邻居发送chunk：正在向其发送chunk且速率最快的四个<ul>\n<li>每10s重新评估top4</li>\n</ul>\n</li>\n<li>每30s随机选择一个其他节点，向其发送chunk</li>\n</ul>\n<h5 id=\"P2P应用；索引技术\"><a href=\"#P2P应用；索引技术\" class=\"headerlink\" title=\"P2P应用；索引技术\"></a>P2P应用；索引技术</h5><p>索引：信息到节点位置（IP地址+端口号）的映射</p>\n<p>文件共享：</p>\n<ul>\n<li>利用索引动态跟踪节点所共享的文件的位置</li>\n<li>节点告诉索引它拥有哪些文件</li>\n<li>节点搜索索引，获知能够得知哪些文件</li>\n</ul>\n<p>即时消息：</p>\n<ul>\n<li>索引把用户名映射到位置</li>\n<li>用户开启IM应用时，需要通知索引它的位置</li>\n<li>节点检索索引，确定用户的IP地址</li>\n</ul>\n<h6 id=\"集中式索引\"><a href=\"#集中式索引\" class=\"headerlink\" title=\"集中式索引\"></a>集中式索引</h6><p>Napster最早采用</p>\n<ol>\n<li>节点加入时，通知中央服务器<ul>\n<li>IP地址</li>\n<li>内容</li>\n</ul>\n</li>\n<li>节点向中央服务器查找文件</li>\n<li>节点向用户请求文件</li>\n</ol>\n<p>缺点： 内容定位高度集中</p>\n<ul>\n<li>单点失效问题</li>\n<li>性能瓶颈</li>\n<li>版权问题</li>\n</ul>\n<h6 id=\"洪泛式查询-query-flooding\"><a href=\"#洪泛式查询-query-flooding\" class=\"headerlink\" title=\"洪泛式查询 query flooding\"></a>洪泛式查询 query flooding</h6><p>完全分布式架构</p>\n<p>每个节点只对自己共享的文件进行索引</p>\n<p>覆盖网络 overlay network：</p>\n<ul>\n<li>节点之间若有TCP连接，则构成一条边</li>\n<li>所有活动节点和边构成网络</li>\n<li>边：虚拟链路</li>\n<li>节点邻居数一般少于10</li>\n</ul>\n<p>查询：</p>\n<ul>\n<li>查询消息通过已有的TCP连接发送</li>\n<li>节点转发查询消息</li>\n<li>查询命中，则利用反向路径发回查询节点</li>\n</ul>\n<p>缺点：消息泛滥、造成网络阻塞</p>\n<h6 id=\"层次式覆盖网络\"><a href=\"#层次式覆盖网络\" class=\"headerlink\" title=\"层次式覆盖网络\"></a>层次式覆盖网络</h6><p>介于集中式索引和洪泛查询之间</p>\n<p>每个节点 要么是超级节点，要么被分配一个超级节点</p>\n<ul>\n<li>节点和超级节点之间维持TCP连接（集中式索引）</li>\n<li>超级节点之间维持TCP连接（洪泛式查询）</li>\n</ul>\n<p>超级节点负责跟踪子节点内容</p>\n<h4 id=\"Socket编程\"><a href=\"#Socket编程\" class=\"headerlink\" title=\"Socket编程\"></a>Socket编程</h4><h6 id=\"应用编程接口API\"><a href=\"#应用编程接口API\" class=\"headerlink\" title=\"应用编程接口API\"></a>应用编程接口API</h6><p>将应用进程的控制权和操作系统的控制权进行转换的系统接口</p>\n<p>典型接口：</p>\n<ul>\n<li>套接字 socket</li>\n<li>winsock：Windows Socket interface，微软的套接字接口</li>\n<li>TLI，transport layer interface 传输层接口</li>\n</ul>\n<h5 id=\"Socket-API概述\"><a href=\"#Socket-API概述\" class=\"headerlink\" title=\"Socket API概述\"></a>Socket API概述</h5><p>最初面向 BSD UNIX-Berkley</p>\n<p>Internet网络应用最典型的API接口</p>\n<p>通信模型： 客户、服务器模型</p>\n<p>应用进程间通信的抽象机制</p>\n<p>标识通信端点（对外）：IP地址+端口号</p>\n<p>对内管理套接字：套接字描述符 Socket descriptor</p>\n<p>Socket抽象：</p>\n<ul>\n<li>类似文件的抽象</li>\n<li>应用程序创建套接字时，操作系统分配一个数据结构存储该套接字相关信息</li>\n<li>返回套接字描述符</li>\n</ul>\n<h5 id=\"Socket-API函数-Winsock：\"><a href=\"#Socket-API函数-Winsock：\" class=\"headerlink\" title=\"Socket API函数 Winsock：\"></a>Socket API函数 Winsock：</h5><p>WSAStartup：初始化api  -&gt;  应用程序  -&gt; WSACleanup</p>\n<p>socket(protofamily , type, proto )：</p>\n<ul>\n<li>创建套接字，返回套接字描述符</li>\n<li>protofamily 协议族  （TCP/IP = PF_INET）</li>\n<li>type：套接字类型</li>\n<li>proto：协议号，0为默认</li>\n</ul>\n<p>面向TCP/IP 服务类型：</p>\n<ul>\n<li>SOCK_DGRAM：传输层UDP协议：不可靠、无连接、数据报传输</li>\n<li>SOCK_STREAM：传输层TCP协议：可靠、面向连接、字节流传输、点对点</li>\n<li>SOCK_RAW：网络层，IP/ICMP/IGMP</li>\n</ul>\n<p>int Closesocket( SOCKET sd);</p>\n<ul>\n<li>关闭一个描述符为sd的套接字</li>\n<li>多个进程共享一个套接字时，调用该函数将套接字引用计数减一，减到0才关闭</li>\n<li>一个进程多线程对一个套接字使用无计数</li>\n<li>返回值：0成功</li>\n</ul>\n<p>int bind(sd, localaddr, addrlen);</p>\n<ul>\n<li>绑定套接字的本地端点地址（IP+端口号）</li>\n<li>参数：<ul>\n<li>套接字描述符 sd</li>\n<li>端点地址 localaddr： 结构 sockaddr_in</li>\n</ul>\n</li>\n<li>客户端程序一般不必调用bind函数</li>\n<li>服务器绑定多IP地址：地址通配符：INADDR_ANY</li>\n</ul>\n<p>int listen(sd, queuesize);</p>\n<ul>\n<li>置服务器端的流套接字处于监听状态<ul>\n<li>仅服务器端调用</li>\n<li>仅用于面向连接的流套接字</li>\n</ul>\n</li>\n<li>设置连接请求队列大小 queuesize</li>\n<li>返回值：成功 0</li>\n</ul>\n<p>connect( sd, addr , saddrlen);</p>\n<ul>\n<li>仅用于客户端，使客户套接字与特定计算机的特定端口saddr的套接字进行连接</li>\n<li>可用于TCP、 UDP<ul>\n<li>TCP：建立连接</li>\n<li>UDP：指定服务器端点地址</li>\n</ul>\n</li>\n</ul>\n<p>newsock = accept( sd, caddr, caddrlen);</p>\n<ul>\n<li>只用于服务器端，只用于TCP套接字</li>\n<li>从客户连接请求队列中取出最前的客户请求，并创建一个新的套接字和客户套接字创建连接通道</li>\n<li>利用新创建的套接字和客户通信（TCP是点对点的）</li>\n</ul>\n<p>send( sd , *buf, len , flags);</p>\n<p>sendto( sd, * buf , len, flags, destaddr, addrlen);</p>\n<ul>\n<li>send函数TCP套接字（客户端或服务器）或调用了connect函数的UDP客户端套接字</li>\n<li>sendto用于UDP服务器端套接字和未调用connect函数的UDP客户端套接字</li>\n</ul>\n<p>recv，recvfrom 类似send，sendto</p>\n<p>setsockopt、 getsockopt 设置或获取套接字设置</p>\n<p>网络字节顺序 network byte order：</p>\n<p>​    TCP/IP定义了标准的用于协议头中的二进制整数表示</p>\n<p>​    某些socket API函数参数需要存储为网络字节顺序（如IP地址、端口号等）</p>\n<h5 id=\"客户端软件设计\"><a href=\"#客户端软件设计\" class=\"headerlink\" title=\"客户端软件设计\"></a>客户端软件设计</h5><p>解析服务器IP地址： 域名或IP地址转换为32位二进制IP地址：</p>\n<ul>\n<li>inet_addr() 点分十进制IP到32位IP地址</li>\n<li>gethostbyname() 域名到32位IP地址： 返回指向结构hostent的指针</li>\n<li>都返回网络字节顺序</li>\n</ul>\n<p>解析端口号： 可能使用服务名（如HTTP）或端口号</p>\n<ul>\n<li>getservbyname() 服务名转为熟知端口号</li>\n</ul>\n<p>解析协议号：可能使用协议名（如TCP）指定协议</p>\n<ul>\n<li>getprotobyname() 协议名到协议号的转换</li>\n</ul>\n<p>TCP客户端软件流程：</p>\n<ol>\n<li>确定服务器IP地址+端口号</li>\n<li>创建客户端套接字</li>\n<li>分配本地端点地址（IP+端口号） （系统自动完成）</li>\n<li>连接服务器套接字</li>\n<li>遵循应用层协议进行通信</li>\n<li>关闭或释放连接</li>\n</ol>\n<p>UDP客户端软件流程：</p>\n<ol>\n<li>确定服务器IP地址+端口号</li>\n<li>创建客户端套接字</li>\n<li>分配本地端点地址（IP+端口号） （系统自动完成）</li>\n<li>指定服务器端点地址，构造UDP数据报</li>\n<li>遵循应用层协议进行通信</li>\n<li>关闭或释放套接字</li>\n</ol>\n<h5 id=\"服务器软件设计\"><a href=\"#服务器软件设计\" class=\"headerlink\" title=\"服务器软件设计\"></a>服务器软件设计</h5><p>基本服务器类型：</p>\n<ol>\n<li>循环无连接 IteratIve connectionless<ul>\n<li>一次只接受一个客户端请求</li>\n<li>无连接：基于UDP</li>\n<li>流程：<ol>\n<li>创建套接字</li>\n<li>绑定端点地址（INADDR_ANY+端口号）</li>\n<li>反复接收来自客户端的请求</li>\n<li>遵循应用层协议，构造响应报文，发送给客户</li>\n</ol>\n</li>\n<li>服务器端不能使用connect函数</li>\n<li>无连接服务器使用 sendto发送数据报</li>\n<li>客户端端点地址在调用recvfrom接收数据时自动提取</li>\n</ul>\n</li>\n<li>循环面向连接 Iterative connection-oriented<ul>\n<li>流程：<ol>\n<li>创建主套接字，绑定熟知端口号</li>\n<li>主套接字设置为被动监听模式</li>\n<li>调用accept接收连接请求，创建新套接字和客户建立连接</li>\n<li>通过新套接字接收请求、构造并发送响应</li>\n<li>完成服务后，关闭连接，返回3</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>并发无连接 Concurrent connectionless<ul>\n<li>流程：<ol>\n<li>主线程1 创建套接字，绑定熟知端口号</li>\n<li>主线程2 反复调用recvfrom函数，接收请求，创建新线程处理响应</li>\n<li>子线程1 接收请求</li>\n<li>子线程2 构造响应报文，调用sendto发送</li>\n<li>子线程3 退出</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>并发面向连接 Concurrent connection-oriented<ul>\n<li>流程：<ol>\n<li>主线程1 创建套接字，绑定熟知端口号</li>\n<li>主线程2 设置主套接字为被动监听模式</li>\n<li>主线程3 反复调用accept接收连接请求，创建新的子线程处理客户响应</li>\n<li>子线程1 接收请求（通过新套接字）</li>\n<li>子线程2 根据协议进行交互</li>\n<li>子线程3 关闭、释放连接并退出（线程终止）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"传输层（上）\"><a href=\"#传输层（上）\" class=\"headerlink\" title=\"传输层（上）\"></a>传输层（上）</h3><h4 id=\"传输层服务概述\"><a href=\"#传输层服务概述\" class=\"headerlink\" title=\"传输层服务概述\"></a>传输层服务概述</h4><p>传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制</p>\n<p>端系统运行传输层协议：</p>\n<ul>\n<li>发送方：把消息分成多个Segment并传给网络层</li>\n<li>接收方：把segment组装成消息，交给应用层</li>\n</ul>\n<p>协议类型：</p>\n<ul>\n<li>TCP、UDP</li>\n</ul>\n<p>与网络层的区别：</p>\n<ul>\n<li>网络层提供主机之间的逻辑通信机制</li>\n<li>位于网络层之上、依赖网络层</li>\n<li>对网络层服务进行（可能的）增强</li>\n</ul>\n<h4 id=\"复用和分用\"><a href=\"#复用和分用\" class=\"headerlink\" title=\"复用和分用\"></a>复用和分用</h4><p>原因：</p>\n<ul>\n<li>接收端（多路分用）：传输层将segment交给正确的socket 即正确的进程</li>\n<li>发送端（多路复用）：从多个socket接收消息，每块数据封装头部消息，生成Segment，交给网络层</li>\n</ul>\n<p>分用工作：</p>\n<ul>\n<li>主机接收到IP数据报 datagram</li>\n<li>每个数据报携带源IP、目的IP，一个传输层的段</li>\n<li>每个段携带源端口号、目的端口号</li>\n<li>传输层协议根据IP地址和端口号，把Segment导向Socket<ul>\n<li>TCP做更多处理</li>\n</ul>\n</li>\n<li>无连接分用：UDP：用二元组标识（目的IP，目的端口号）</li>\n<li>面向连接的分用：TCP：用四元组（源IP，源端口号，目的IP，目的端口号）</li>\n</ul>\n<h4 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h4><p>UDP：user datagram protocol 【RFC 768】</p>\n<p>特点：</p>\n<ul>\n<li>基于 IP协议：<ul>\n<li>多路复用、分用</li>\n<li>简单的错误校验：端到端原则，不能确保所有链路层协议都有错误检测，也不能确保转发时错误不发生</li>\n</ul>\n</li>\n<li>Best effort（尽力而为）服务，UDP可能：<ul>\n<li>丢失</li>\n<li>非按序到达</li>\n</ul>\n</li>\n<li>无连接：<ul>\n<li>发送方接收方不需要握手、不需要建立连接</li>\n<li>每个UDP段处理独立</li>\n</ul>\n</li>\n</ul>\n<p>价值：</p>\n<ul>\n<li>无需建立连接：延迟显著减少（2个RTT）（DNS用UDP）</li>\n<li>实现简单，无需维护连接状态</li>\n<li>头部开销少（8字节 VS  20字节）</li>\n<li>没有拥塞控制，上层控制发送时间和速率</li>\n</ul>\n<p>用途：</p>\n<ul>\n<li>常用于流媒体：容忍丢失、速率敏感</li>\n<li>DNS、SNMP</li>\n<li>在其之上实现可靠数据传输：（应用层开发）<ul>\n<li>在应用层增加可靠性机制</li>\n<li>应用特定的错误恢复机制</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/UDP.png\" alt=\"UDP\"></p>\n<p>UDP校验和 checksum： </p>\n<ul>\n<li>目的：检测UDP段传输过程中是否发生错误</li>\n<li>发送方：<ul>\n<li>段内容视为16-bit证书</li>\n<li>校验和计算：求和，进位加到和后面，按位取反</li>\n<li>校验和填入校验和字段</li>\n</ul>\n</li>\n<li>发送方：<ul>\n<li>计算校验和</li>\n<li>进行比对：<ul>\n<li>不相等：检错</li>\n<li>相等：未检测到错误（可能有错）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"可靠数据传输原理\"><a href=\"#可靠数据传输原理\" class=\"headerlink\" title=\"可靠数据传输原理\"></a>可靠数据传输原理</h4><p>可靠的定义：不错、不丢、不乱</p>\n<p>可靠数据传输协议：</p>\n<ul>\n<li>对应用层、传输层、链路层都重要</li>\n<li>信道的不可靠特性决定了可靠数据传输协议rdt的复杂性</li>\n</ul>\n<p>Rdt 1.0：可靠信道上的可靠数据传输</p>\n<ul>\n<li>底层信道完全可靠</li>\n<li>发送方和接收方 FSM独立</li>\n</ul>\n<p>Rdt 2.0： 产生位错误：</p>\n<ul>\n<li><p>底层信道可能翻转分组中的位</p>\n<ul>\n<li>用校验和检测位错误</li>\n</ul>\n</li>\n<li><p>如何从错误中恢复：</p>\n<ul>\n<li>确认机制 ACK acknowledgements：接收方显式告知发送方分组已经正确接收</li>\n<li>NAK：接收方显式告诉发送方分组有错误</li>\n<li>发送方收到NAK后，重传分组</li>\n</ul>\n</li>\n<li><p>基于重传机制的rdt协议成为ARQ automatic repeat request 协议</p>\n</li>\n<li><p>新机制：</p>\n<ul>\n<li>差错检测</li>\n<li>接收方反馈控制消息： ACK、 NAK</li>\n<li>重传</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt2.0.png\" alt=\"rdt2.0\"></p>\n</li>\n<li><p>缺陷： ACK、NAK消息发生错误或被破坏 corrupted：</p>\n</li>\n<li><p>解决方案： rdt 2.1</p>\n<ol>\n<li>ACK、NAK增加校验和，检错并纠错（代价高）</li>\n<li>添加额外控制消息</li>\n<li>发送方重传：可能产生重复分组<ul>\n<li>解决重复分组： 序列号 sequence number：发送方给每个分组增加序列号</li>\n<li>接收方丢弃重复分组</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt2.1.png\" alt=\"rdt2.1\"></p>\n</li>\n<li><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt2.1rev.png\" alt=\"rdt2.1rev\"></p>\n<p>发送方变化：</p>\n<ul>\n<li>每个分组增加了序列号(0,1序号)</li>\n<li>需要校验ACK、NAK消息是否错误</li>\n<li>状态数量翻倍</li>\n</ul>\n<p>接收方变化：</p>\n<ul>\n<li>需要判断分组是否重复</li>\n</ul>\n</li>\n<li><p>Rdt 2.2 ：只使用ACK：检验和+序列号+ACK+重传</p>\n<ul>\n<li>接收方通过ACK告知最后一个被正确接收的分组</li>\n<li>ACK中显式加入被确认分组的序列号</li>\n<li>发送方收到重复ACK后，重传当前分组</li>\n</ul>\n</li>\n</ul>\n<p>Rdt 3.0：既可能错误，也可能丢失：</p>\n<ul>\n<li>方法：发送方等待 合理 时间：<ul>\n<li>没收到ACK，重传</li>\n<li>分组或ACK只是延迟而不是丢了</li>\n<li>增加定时器</li>\n</ul>\n</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt3.0send.png\" alt=\"rdt3.0send\"></li>\n<li>问题：性能很差：停等操作</li>\n</ul>\n<h4 id=\"流水线与滑动窗口协议\"><a href=\"#流水线与滑动窗口协议\" class=\"headerlink\" title=\"流水线与滑动窗口协议\"></a>流水线与滑动窗口协议</h4><p>流水线机制：</p>\n<ul>\n<li>允许发送方收到ACK之前连续发送多个分组：<ul>\n<li>更大的序列号范围</li>\n<li>发送方、接收方需要更大存储空间缓存分组</li>\n</ul>\n</li>\n</ul>\n<p>滑动窗口协议 sliding-window protocol：</p>\n<ul>\n<li>窗口：<ul>\n<li>允许使用的序列号范围</li>\n<li>窗口尺寸为N：最多由N个等待确认的消息</li>\n</ul>\n</li>\n<li>滑动窗口：<ul>\n<li>随着协议的运行，窗口在序列号空间内向前滑动</li>\n</ul>\n</li>\n<li>滑动窗口协议：GBN，SR</li>\n</ul>\n<p>GBN go-back-N 协议：</p>\n<ul>\n<li>发送方：<ul>\n<li>分组头有k-bit序列号</li>\n<li>窗口尺寸为N，最多允许N个分组未确认</li>\n<li>累计确认机制：ACK(n)：确认到序列号n（包含n）的分组都被正常接收<ul>\n<li>可能收到重复ACK</li>\n</ul>\n</li>\n<li>空中分组设置计时器 timer</li>\n<li>timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组</li>\n</ul>\n</li>\n<li>接收方：<ul>\n<li>ACK机制：发送拥有最高序列号的，已经被正确接收的分组的ACK<ul>\n<li>可能产生重复ACK</li>\n<li>只需记住唯一的expectedseqnum</li>\n</ul>\n</li>\n<li>乱序到达的分组：<ul>\n<li>直接丢弃</li>\n<li>重新确认序列号最大的、按序到达的分组</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>缺陷：<ul>\n<li>重传大量不必要分组</li>\n</ul>\n</li>\n</ul>\n<p>SR selective repeat协议：</p>\n<ul>\n<li>接收方对每个分组单独进行确认<ul>\n<li>设置缓存机制，缓存乱序到达的分组</li>\n</ul>\n</li>\n<li>发送方只重发没收到ACK的分组<ul>\n<li>为每个分组设置定时器</li>\n</ul>\n</li>\n<li>发送方窗口不变化</li>\n<li>新增接收方窗口</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sr.png\" alt=\"sr\"></li>\n<li>SR协议问题： 困境<ul>\n<li>出现原因：序列号少且窗口尺寸大</li>\n<li>解决： $N_S + N_R &lt;= 2^k $</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"传输层（下）\"><a href=\"#传输层（下）\" class=\"headerlink\" title=\"传输层（下）\"></a>传输层（下）</h3><h4 id=\"面向连接传输协议-TCP\"><a href=\"#面向连接传输协议-TCP\" class=\"headerlink\" title=\"面向连接传输协议 TCP\"></a>面向连接传输协议 TCP</h4><p>概述：</p>\n<ul>\n<li>点对点</li>\n<li>可靠的、按序的字节流</li>\n<li>流水线机制： TCP拥塞控制和流量控制机制动态设置窗口尺寸</li>\n<li>发送方、接收方缓存</li>\n<li>全双工：同一连接双向传输数据</li>\n<li>面向连接：<ul>\n<li>通信双方在发送数据前必须建立连接</li>\n<li>连接状态只在两端维护</li>\n<li>TCP连接包括： 两台主机上的缓存、连接状态变量、Socket等</li>\n</ul>\n</li>\n<li>流量控制机制</li>\n</ul>\n<p>序列号：</p>\n<ul>\n<li>序列号指的是Segment第一个字节的编号，而不是Segment的编号</li>\n<li>建立连接时，双方随机选择序列号</li>\n</ul>\n<p>ACK：</p>\n<ul>\n<li>希望接收的下一个字节的序列号</li>\n<li>累计确认：该序列号之前的所有字节都已被正确接收</li>\n</ul>\n<p>乱序到达的Segment：没有规定，由TCP实现者做决策</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/TCP.png\" alt=\"TCP\"></p>\n<h5 id=\"TCP可靠数据传输\"><a href=\"#TCP可靠数据传输\" class=\"headerlink\" title=\"TCP可靠数据传输\"></a>TCP可靠数据传输</h5><p>概述：</p>\n<ul>\n<li>流水线机制</li>\n<li>累计确认</li>\n<li>单一重传计时器</li>\n<li>触发重传事件：<ul>\n<li>超时</li>\n<li>受到重复ACK</li>\n</ul>\n</li>\n</ul>\n<p>RTT与超时时间设置：</p>\n<ul>\n<li>需要大于RTT：但RTT是变化的</li>\n<li>超时时间 = 平均RTT + 4*安全时间</li>\n<li>安全时间 =  0.25*|平均RTT-RTT|+0.75旧安全时间</li>\n</ul>\n<p>发送方事件：</p>\n<ul>\n<li>从应用层收到数据：<ul>\n<li>创建Segment</li>\n<li>开启计时器</li>\n<li>设置超时时间</li>\n</ul>\n</li>\n<li>超时：<ul>\n<li>重传超时的Segment</li>\n<li>重启计时器</li>\n</ul>\n</li>\n<li>收到ACK<ul>\n<li>未确认的Segment：<ul>\n<li>更新sendbase</li>\n<li>窗口若还有未确认的分组，重启计时器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>快速重传机制：</p>\n<ul>\n<li>如果超时，超时时间间隔重新设置，导致其很大</li>\n<li>通过重复ACK检测分组丢失：<ul>\n<li>发送方收到同一分组的3次ACK，则立刻重传</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"TCP-流量控制\"><a href=\"#TCP-流量控制\" class=\"headerlink\" title=\"TCP 流量控制\"></a>TCP 流量控制</h5><p>原因：接收方为TCP设置了buffer，上层应用可能处理buffer的速度太慢</p>\n<p>实现：接受者在Segment的头部信息的revwindow告诉发送方还剩余多少可用空间，发送方限制数据不超过revwindow的大小</p>\n<h5 id=\"TCP连接管理\"><a href=\"#TCP连接管理\" class=\"headerlink\" title=\"TCP连接管理\"></a>TCP连接管理</h5><ul>\n<li>初始化TCP变量：<ul>\n<li>选择序列号</li>\n<li>设置缓存和流量控制信息</li>\n</ul>\n</li>\n<li>client：连接发起者</li>\n<li>server：等待连接请求</li>\n<li>三次握手建立连接：<ol>\n<li>客户端向server发送 SYN段<ul>\n<li>不携带任何数据</li>\n<li>SYN标志位为1</li>\n<li>传递初始序列号</li>\n<li>SYN=1，seq=client_isn</li>\n</ul>\n</li>\n<li>服务器接到SYN，同意后发送 SYNACK段<ul>\n<li>服务器分配缓存</li>\n<li>选择自己的初始序列号</li>\n<li>SYN=1, seq=server_isn，ack=client_isn+1</li>\n</ul>\n</li>\n<li>客户端受到SYNACK，回复ACK报文段，SYN不再置1，可能有数据<ul>\n<li>SYN=0, seq=client_isn+1 , ack=server_isn+1</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>连接关闭：<ol>\n<li>客户端向服务器发送 FIN 控制段</li>\n<li>服务器收到FIN，回复ACK，关闭连接，发送FIN</li>\n<li>客户端收到FIN，回复ACK：进入等待状态，若收到FIN，重发ACK</li>\n<li>服务器收到ACK，真正关闭连接</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"拥塞控制问题\"><a href=\"#拥塞控制问题\" class=\"headerlink\" title=\"拥塞控制问题\"></a>拥塞控制问题</h4><p>拥塞 congestion： 太多主机发送太多数据或速度太快以致网络无法处理</p>\n<p>表现：</p>\n<ul>\n<li>分组丢失（路由器缓存溢出）</li>\n<li>分组延迟过大（在路由器缓存中排队）</li>\n</ul>\n<p>拥塞控制 （网络阻塞） vs 流量控制（接收方处理不过来）</p>\n<p>为什么拥塞控制要在传输层进行</p>\n<p>拥塞控制方法：</p>\n<ul>\n<li>端到端的拥塞控制：<ul>\n<li>网络层不需要显式提供支持</li>\n<li>端系统通过观察loss、delay等网络行为判断是否发生拥塞</li>\n<li>TCP采用这种方法</li>\n</ul>\n</li>\n<li>网络辅助的拥塞控制：<ul>\n<li>路由器向发送方显式反馈网络拥塞信息</li>\n<li>简单的拥塞指示(1-bit)：SNA、DECbit，TCP/IP ECN, ATM</li>\n<li>指示发送方应该采用何种速率</li>\n</ul>\n</li>\n</ul>\n<p>ATM ABR拥塞控制  available bit rate：</p>\n<ul>\n<li>弹性服务</li>\n<li>发送方路径可用：使用可用贷款</li>\n<li>发送方路径堵塞：发送速率降到最低保障速率</li>\n<li>RM resource management cell：<ul>\n<li>发送几个数据段就发送一个RM cell</li>\n<li>发送方发送</li>\n<li>交换机设置 RM cell位（网络辅助）<ul>\n<li>NI bit：rate不许增长</li>\n<li>CI bit：拥塞指示</li>\n</ul>\n</li>\n<li>RM cell由接收方返回给发送方</li>\n<li>RM cell有显式的速率ER 字段：两个字节：<ul>\n<li>拥塞的交换机可以把ER设置为更低的值</li>\n<li>发送方获知路径所能支持的最小速率</li>\n</ul>\n</li>\n<li>数据cell的EFCI位：拥塞的交换机将其设置为1：<ul>\n<li>若RM cell前data cell的EFCI位设置为1，那么发送方在返回的RM cell中置CI位</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>TCP拥塞控制：</p>\n<ul>\n<li><p>如何控制发送速率：</p>\n<ul>\n<li>拥塞窗口 CongWin：<ul>\n<li>LastByteSent-LastByteAcked &lt;= CongWin</li>\n<li>速率 ≈ CongWin / RTT byte/sec</li>\n<li>动态调整以改变发送速率</li>\n<li>反映所感知的网络拥塞</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何感知拥塞状况：</p>\n<ul>\n<li>Loss事件 = timeout 或 3个重复ACK</li>\n<li>发生loss事件后，发送方降低速率</li>\n</ul>\n</li>\n<li><p>如何合理调整发送速率：</p>\n<ul>\n<li>加性增- 乘性减： AIMD<ul>\n<li>原理：谨慎探测可用带宽，逐渐增加速率，直到loss，一旦loss，快速降低速率</li>\n<li>additive increase：每个RTT将CongWin增大一个MSS（拥塞避免）</li>\n<li>multiplicative decrease：发生loss后CongWin减半</li>\n</ul>\n</li>\n<li>慢启动： SS<ul>\n<li>TCP建立时，CongWin=1，可用带宽可能远高于初始速率，希望快速增长</li>\n<li>原理：连接开始时，速率指数增长（收到每个ack时 CongWin+1）</li>\n</ul>\n</li>\n<li>何时从指数增长切换到线性增长：<ul>\n<li>当CongWin达到loss事件前值的一半时</li>\n<li>Threshold记录loss事件前CongWin值的1/2</li>\n</ul>\n</li>\n<li>Loss事件的处理：<ul>\n<li>3个重复ACK：<ul>\n<li>CongWin切到一半</li>\n<li>而后线性增长</li>\n<li>原因：能收到3个ACK说明网络还能传输</li>\n</ul>\n</li>\n<li>timeout：<ul>\n<li>CongWin直接减为1个MSS</li>\n<li>而后指数增长</li>\n<li>达到threshold后再线性增长</li>\n<li>原因：timeout说明网络拥塞更严重</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>TCP的公平性：</p>\n<ul>\n<li>公平性与UDP：<ul>\n<li>多媒体应用通常不适用TCP，以免被拥塞控制机制限制速率</li>\n<li>使用UDP：以恒定速率发送，能容忍丢失</li>\n<li>产生不公平</li>\n</ul>\n</li>\n<li>都使用TCP：<ul>\n<li>可能打开多个并发连接</li>\n<li>如WEB浏览器</li>\n<li>产生公平性问题</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网络层服务（上）\"><a href=\"#网络层服务（上）\" class=\"headerlink\" title=\"网络层服务（上）\"></a>网络层服务（上）</h3><h4 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4><p>源主机向目的主机发送数据报</p>\n<p>每个主机和路由器都运行网络层协议</p>\n<p>路由器检验所有穿越它的IP数据报的头部域：决策如何处理IP数据报</p>\n<p>网络层核心功能：</p>\n<ul>\n<li>转发 forwarding：<ul>\n<li>功能：分组从路由器输入端口转移到合适的输出端口</li>\n<li>路由器维护转发表：确定在该路由器中根据地址信息转发到哪条链路</li>\n</ul>\n</li>\n<li>路由 routing：<ul>\n<li>确定分组从源到目的经过的路径</li>\n<li>根据 路由算法 routing algorithms</li>\n</ul>\n</li>\n<li>连接建立：不是所有网络都需要<ul>\n<li>数据分组传输之前两端主机需要首先建立虚拟连接<ul>\n<li>网络设备（路由器）参与连接的建立</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>网络层服务模型：</p>\n<ul>\n<li>无连接服务 connection-less service：<ul>\n<li>特点：<ul>\n<li>不事先为系列分组的传输确定传输路径</li>\n<li>每个分组独立确定传输路径</li>\n<li>不同分组可能路径不同</li>\n</ul>\n</li>\n<li>典型例子：数据报网络 datagram network</li>\n</ul>\n</li>\n<li>连接服务：<ul>\n<li>特点：<ul>\n<li>首先为系列分组传输确定路径</li>\n<li>沿路径传输系列分组</li>\n<li>系列分组传输路径相同</li>\n<li>传输结束后拆除连接</li>\n</ul>\n</li>\n<li>典型例子：虚电路网络 virtual-circuit network</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"虚电路网络和数据报网络\"><a href=\"#虚电路网络和数据报网络\" class=\"headerlink\" title=\"虚电路网络和数据报网络\"></a>虚电路网络和数据报网络</h4><h5 id=\"虚电路网络\"><a href=\"#虚电路网络\" class=\"headerlink\" title=\"虚电路网络\"></a>虚电路网络</h5><p>提供网络层连接服务</p>\n<p>一条从源主机到目的主机，类似电路的路径：</p>\n<ul>\n<li>分组交换</li>\n<li>每个分组的传输利用链路的全部带宽</li>\n<li>源到目的主机经过网络层设备共同完成虚电路建设</li>\n</ul>\n<p>通信过程： 呼叫建立 call setup -&gt; 数据传输 -&gt; 拆除呼叫</p>\n<p>每个分组携带虚电路标识 VCID，而不是目标主机地址</p>\n<p>每个网络设备都需要维护经过它的虚电路连接状态</p>\n<p>可以面向虚电路VC 进行预分配资源：</p>\n<ul>\n<li>如ATM的电路仿真 CBR</li>\n</ul>\n<p>具体实现：</p>\n<ul>\n<li>每条虚电路包括：<ol>\n<li>从源主机到目的主机的一条路径</li>\n<li>虚电路号 VCID，沿路每段链路一个编号（不可能统一编号，因为每段链路负载不一样）</li>\n<li>沿途每个网络设备，利用转发表记录经过的每条虚电路</li>\n</ol>\n</li>\n<li>路由器转发分组时根据转发表改写、替换VCID</li>\n<li>转发表包括： 输入接口+输入VC+输出接口+输出VC</li>\n</ul>\n<p>虚电路信令协议 signaling protocols：</p>\n<ul>\n<li>用于虚电路的建立、维护及拆除<ul>\n<li>路径选择</li>\n</ul>\n</li>\n<li>应用于虚电路网络，如ATM，帧中继 frame-relay网络等</li>\n<li>目前的Internet不采用</li>\n</ul>\n<h5 id=\"数据报网络\"><a href=\"#数据报网络\" class=\"headerlink\" title=\"数据报网络\"></a>数据报网络</h5><p>提供网络层无连接服务</p>\n<p>每个分组携带目的地址</p>\n<p>路由器根据目的地址转发分组：</p>\n<ul>\n<li>根据路由协议、路由算法构建转发表</li>\n<li>检索转发表</li>\n<li>每个分组独立选路</li>\n</ul>\n<p>数据报转发表：</p>\n<ul>\n<li>转发表中目的地址针对地址范围</li>\n<li>最长前缀匹配优先：优先选择匹配前缀最长的入口</li>\n</ul>\n<p>数据报网络和VC网络的对比：</p>\n<ul>\n<li>数据报网络 Internet：<ul>\n<li>计算机之间数据交换：<ul>\n<li>时间要求不严格</li>\n</ul>\n</li>\n<li>链路类型众多：<ul>\n<li>特点、性能各异</li>\n<li>统一服务困难</li>\n</ul>\n</li>\n<li>智能端系统（计算机）</li>\n<li>简化网络，复杂边缘</li>\n</ul>\n</li>\n<li>VC网络 ATM：<ul>\n<li>电话网络演化而来</li>\n<li>核心业务是实时对话：<ul>\n<li>严格时间、可靠性</li>\n</ul>\n</li>\n<li>非智能端系统（电话机、传真机）</li>\n<li>简化边缘，复杂网络</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h4><p>ICMP协议（IP协议的伴随协议）：</p>\n<ul>\n<li>差错报告</li>\n<li>路由器信令</li>\n</ul>\n<p>IP数据报：</p>\n<ul>\n<li>格式：<ul>\n<li>头部<ul>\n<li>固定部分：20字节</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/IP.png\" alt=\"IP\"><ul>\n<li>版本号： 4-bit，IP协议的版本： 4：ipv4, 6：ipv6</li>\n<li>首部长度：4-bit：IP分组首部长度，以4字节为单位</li>\n<li>服务类型 TOS，占 8-bit：指示期望获得哪种类型的服务<ul>\n<li>98年改名为区分服务，只有在网络提供区分服务diffserv时使用</li>\n<li>一般不使用，通常为00H</li>\n</ul>\n</li>\n<li>总长度： 16-bit， IP分组的总字节数（首部+数据），最多可以放65535-20 Byte</li>\n<li>生存时间 TTL，8-bit：IP分组在网络中可以通过的路由器数，路由器转发一次分组，TTL-1，TTL==0时路由器丢弃该分组</li>\n<li>协议，8-bit：指示IP分组封装的是哪个协议的数据报，实现复用、分解， 6：TCP， 17：UDP</li>\n<li>首部校验和 16-bit：对IP首部差错检测，计算校验和时该字段置0，逐跳计算，逐跳检验</li>\n<li>源IP地址、目的IP地址，各32-bit</li>\n</ul>\n</li>\n<li>可变部分： 0字节&lt;=长度&lt;=40字节，携带安全、源选路径、时间戳和路由记录等内容，实际很少被使用</li>\n<li>填充部分：长度可变， 0&lt;=长度&lt;=3B，目的是补齐首部符合32位对齐</li>\n</ul>\n</li>\n<li>数据</li>\n</ul>\n</li>\n</ul>\n<p>IP分片：</p>\n<ul>\n<li>最大传输单元 MTU：链路层 数据帧可封装数据的上限，不同链路MTU不同</li>\n<li>当大IP分组向小MTU链路转发时，<strong>可以</strong>被分片 fragmented，若不允许分片且放不下，则将分组扔掉</li>\n<li>一个大IP分组分成多个小IP分片，IP分片到达目的主机进行重装 reassembled</li>\n<li>IP首部的相关字段用于标识分片以及确定分片的相对顺序</li>\n<li>涉及字段：<ul>\n<li>总长度</li>\n<li>标识 16-bit：用于标识一个IP分组，每产生一个IP分组计时器加1，作为该IP分组的标识</li>\n<li>标志位 3-bit：保留，DF don’t fragment ， MF more fragment：<ul>\n<li>DF=1：禁止分片   DF=0：允许分片</li>\n<li>MF=1：非最后一片， MF=0：最后一片（或未分片）</li>\n</ul>\n</li>\n<li>片偏移 13-bit：一个IP分组分片封装原数据的相对偏移量（未分片则为0），以8字节为单位</li>\n</ul>\n</li>\n</ul>\n<p>分片过程：</p>\n<ul>\n<li>若 总长度&gt;MTU且 DF=0，则分片</li>\n<li>每个分片标识复制原IP分组的标识</li>\n<li>除最后一片，其他分片均分为MUT最大允许分片</li>\n<li>一个最大分片可封装的数据应该是8的倍数，可封装数据为 d = [ (M-20) / 8]*8（向下取整）（20字节头部）</li>\n<li>需要总的片数  n = [(L-20)/d] (向上取整)</li>\n<li>每片的片偏移字段取值为  F = d/8 * (i-1)  1&lt;=i&lt;=n</li>\n<li>每片总字段长度   Li = d+20 （非最后一片）  Li= L-(n-1)d （最后一片）</li>\n</ul>\n<h4 id=\"IP编址-addressing\"><a href=\"#IP编址-addressing\" class=\"headerlink\" title=\"IP编址 addressing\"></a>IP编址 addressing</h4><p>接口 interface：主机、路由器与物理链路的连接：</p>\n<ul>\n<li>实现网络层功能</li>\n<li>路由器通常有多个接口</li>\n<li>主机通常只有一个或两个接口</li>\n</ul>\n<p>IP地址：32-bit  IPv4：</p>\n<ul>\n<li>编号标识主机、路由器的接口</li>\n<li>32-bit =》  4个8bit的点分十进制地址</li>\n<li>IP地址与每个接口关联</li>\n<li>如何为接口分配IP地址：<ul>\n<li>IP地址分为两部分：网络号netID （高位）+ 主机号hostID（低位）：</li>\n<li>IP子网 subnet：<ul>\n<li>IP地址具有相同网络号的设备接口</li>\n<li>不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"有类IP地址\"><a href=\"#有类IP地址\" class=\"headerlink\" title=\"有类IP地址\"></a>有类IP地址</h5><p>有类编址：</p>\n<ul>\n<li><p>A类地址 （50%） （第一位为0）  netID 8-bit，hostID 24-bit  0.0.0.0~127.255.255.255</p>\n</li>\n<li><p>B类地址 （25%）（1\\2位为10） netID 16-bit  hostID 16-bit   128.0.0.0~191.255.255.255</p>\n</li>\n<li><p>C类地址（12.5%）（11） netID 24-bit， hostID 8-bit   192.0.0.0~223.255.255.255</p>\n</li>\n<li><p>D、E不再区分netID和hostID</p>\n<ul>\n<li>D类地址（6.25%）（1110） ：多播地址<ul>\n<li>用作特殊目的：命名或标识一组主机，理论上可分布在任何地方，只能向其发送数据</li>\n</ul>\n</li>\n<li>E类地址（6.25%）（1111）：研究所用</li>\n</ul>\n</li>\n<li><p>特殊IP地址</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/specialIP.png\" alt=\"特殊IP\"></p>\n</li>\n<li><p>私有地址：只用于内部网络，在公共环境无效</p>\n<ul>\n<li>A类： netID 10 ，1个</li>\n<li>B类： netID 172.16到172.31      16个</li>\n<li>C类： netID 192.168.0 到 192.168.255      255个 </li>\n</ul>\n</li>\n</ul>\n<h5 id=\"IP子网及子网掩码\"><a href=\"#IP子网及子网掩码\" class=\"headerlink\" title=\"IP子网及子网掩码\"></a>IP子网及子网掩码</h5><p>子网划分：</p>\n<ul>\n<li>IP地址：<ul>\n<li>网络号 netID：高位比特</li>\n<li>子网号 subid ：原网络主机号部分比特</li>\n<li>主机号 hostID：低位比特</li>\n</ul>\n</li>\n<li>子网掩码：<ul>\n<li>确定是否划分了子网，利用多少位划分子网</li>\n<li>形式和IP地址相同， 32-bit，点分十进制形式</li>\n<li>取值： netID、subID全取1，hostID位全取0</li>\n<li>默认子网掩码：<ul>\n<li>A类默认子网掩码：255.0.0.0</li>\n<li>B类默认子网掩码：255.255.0.0</li>\n<li>C类默认子网掩码：255.255.255.0</li>\n<li>借用3比特划分子网的B类子网掩码 255.255.224.0</li>\n</ul>\n</li>\n<li>子网地址 + 子网掩码 ：准确确定子网大小</li>\n<li>应用：<ul>\n<li>IP分组的目标IP地址与子网掩码按位与运算提取子网地址</li>\n<li>子网地址，地址范围 -&gt; 去除不可用地址 -&gt; 可分配地址范围</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网络层（中）\"><a href=\"#网络层（中）\" class=\"headerlink\" title=\"网络层（中）\"></a>网络层（中）</h3><h4 id=\"CIDR与路由聚合\"><a href=\"#CIDR与路由聚合\" class=\"headerlink\" title=\"CIDR与路由聚合\"></a>CIDR与路由聚合</h4><p>无类域间路由 classless interdomain routing：</p>\n<ul>\n<li>消除ABC类地址界限<ul>\n<li>netID + subID -&gt; 网络前缀 prefix  任意长度</li>\n</ul>\n</li>\n<li>融合子网地址和子网掩码，方便子网划分<ul>\n<li>无类地址格式： a.b.c.d/x  x为前缀长度</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>提高IPV4地址空间分配效率</li>\n<li>提高路由效率：<ul>\n<li>将多个子网聚合成一个大网</li>\n<li>构造超网（supernetting）</li>\n<li>路由聚合（route aggregation）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"DHCP协议\"><a href=\"#DHCP协议\" class=\"headerlink\" title=\"DHCP协议\"></a>DHCP协议</h4><p>主机如何获得IP地址：</p>\n<ul>\n<li>硬编码：<ul>\n<li>静态配置（自行填写）<ul>\n<li>默认网关：数据报转发到的路由器默认接口的IP地址</li>\n</ul>\n</li>\n<li>动态配置协议 DHCP dynamic host configuration protocol：<ul>\n<li>从服务器动态获取<ul>\n<li>IP地址</li>\n<li>子网掩码</li>\n<li>默认网关</li>\n<li>DNS服务器名称及IP</li>\n</ul>\n</li>\n<li>在应用层实现，封装在UDP数据报</li>\n<li>即插即用的协议</li>\n<li>允许地址重用</li>\n<li>支持在用地址续租</li>\n<li>支持移动用户加入网络</li>\n<li>与DHCP服务器交换报文：<ul>\n<li>发现报文DHCP discover：客户端进行广播，确认服务器的地址</li>\n<li>提供报文DHCP offer：DHCP服务器利用提供报文进行广播响应并发送IP地址</li>\n<li>请求报文DHCP request：主机广播发送以请求IP地址，并通知其它可能的DHCP服务器回收资源</li>\n<li>确认报文DHCP ack：服务器向主机发送确认消息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"NAT-网络地址转换\"><a href=\"#NAT-网络地址转换\" class=\"headerlink\" title=\"NAT 网络地址转换\"></a>NAT 网络地址转换</h4><p>所有离开内网的源IP需要替换成相同NAT的IP地址及不同端口号</p>\n<p>动机：</p>\n<ul>\n<li>只需/只能从ISP申请到一个IP地址<ul>\n<li>IPV4耗尽</li>\n</ul>\n</li>\n<li>本地网络设备IP地址变更，无需通告外界网络</li>\n<li>变更ISP时无需修改内网IP</li>\n<li>内网设备对外网不可见，不能直接寻址（安全）</li>\n</ul>\n<p>实现：</p>\n<ul>\n<li>替换：（内到外）<ul>\n<li>离开内网的IP数据报的源IP地址及源端口号替换NAT的IP地址及新端口号</li>\n</ul>\n</li>\n<li>记录：<ul>\n<li>每对（NAT IP地址及新端口号）与（源IP地址及端口号）替换信息存储到NAT转换表</li>\n</ul>\n</li>\n<li>替换：（外到内）<ul>\n<li>发回的数据报，利用NAT转换表替换IP地址和端口号</li>\n</ul>\n</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>16-bit端口号字段（0-65535），可以同时支持6万多并行连接</li>\n<li>争议：<ul>\n<li>路由器应只处理第三层功能（NAT修改了第四层数据段的内容）</li>\n<li>违背了端到端通信原则<ul>\n<li>应用开发者必须考虑到NAT的存在，如P2P应用</li>\n</ul>\n</li>\n<li>地址短缺问题应该由IPv6解决</li>\n</ul>\n</li>\n</ul>\n<p>NAT穿透方案：</p>\n<ul>\n<li>静态配置NAT：特定端口总是与特定内部IP及端口连接</li>\n<li>利用UPnP universal plug and play 互联网网关设备协议IGD internet gateway device自动配置:<ul>\n<li>内网主机自动学习到NAT公共IP地址</li>\n<li>在NAT转换表中，增删端口映射</li>\n</ul>\n</li>\n<li>中继 （如 Skype）：<ul>\n<li>NAT内部客户与中继服务器建立连接</li>\n<li>外部客户也和中继服务器建立连接</li>\n<li>中继服务器桥接两个连接的分组</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ICMP互联网控制报文协议\"><a href=\"#ICMP互联网控制报文协议\" class=\"headerlink\" title=\"ICMP互联网控制报文协议\"></a>ICMP互联网控制报文协议</h4><p>internet control message protocol 互联网控制报文协议支持主机和路由器：</p>\n<ul>\n<li>差错或异常报告（反馈）</li>\n<li>网络探询（主动发送）</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li>差错报告报文（5种）：<ul>\n<li>目的不可达</li>\n<li>源抑制 source quench：拥塞控制，路由器向源主机发送，让其降低发送分组速度</li>\n<li>超时、超期（如TTL 可以跨越的路由器数目）</li>\n<li>参数问题：路由器认为IP数据报头部数据有问题</li>\n<li>重定向 redirect：路由器认定路径不对</li>\n</ul>\n</li>\n<li>网络探询（2组）：<ul>\n<li>回声（Echo）请求与应答报文（Reply）：探测到目标主机的网络是否通达，如 ping</li>\n<li>时间戳请求与应答报文</li>\n</ul>\n</li>\n</ul>\n<p>不发送ICMP的特殊情况：</p>\n<ul>\n<li>对ICMP差错报文不再发送ICMP</li>\n<li>除对第一个分片外，后续分片都不发送ICMP</li>\n<li>所有多播IP数据报都不发送</li>\n<li>对特殊地址的IP数据报不发送ICMP</li>\n</ul>\n<p>不再使用的ICMP报文：</p>\n<ul>\n<li>信息请求与应答</li>\n<li>子网掩码请求与应答</li>\n<li>路由器询问和通告</li>\n</ul>\n<p>报文格式：</p>\n<ul>\n<li>ICMP报文封装到IP数据报的数据部分传输</li>\n<li>ICMP头部：类型、代码、校验和</li>\n</ul>\n<p>ICMP的应用：Traceroute</p>\n<h4 id=\"IPv6\"><a href=\"#IPv6\" class=\"headerlink\" title=\"IPv6\"></a>IPv6</h4><p>动机：</p>\n<ul>\n<li>32位ipv4地址空间分配殆尽</li>\n<li>改进首部格式：<ul>\n<li>快速处理、转发数据报</li>\n<li>支持QoS</li>\n</ul>\n</li>\n</ul>\n<p>数据报格式：</p>\n<ul>\n<li>固定长度的40字节基本首部</li>\n<li>路由器不允许分片（若要分片，源主机分）</li>\n<li>基本首部+扩展首部（路由器一般不处理）+数据部分</li>\n<li>扩展首部+数据 = 载荷（0至64KB）</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ipv6.png\" alt=\"ipv6\"></li>\n<li>流标签 flow label：标识同一流中的数据报</li>\n<li>下一个首部 next header：标识下一个选项首部或上层协议首部</li>\n<li>跳步限制：TTL：允许经过的路由器数目</li>\n</ul>\n<p>与IPV4的对比：</p>\n<ul>\n<li>无校验和：以减少每跳处理时间</li>\n<li>通过多个选项首部 支持 选项</li>\n<li>ICMPv6：新版ICMP：<ul>\n<li>附加报文类型： packet too big</li>\n<li>多播组管理功能</li>\n</ul>\n</li>\n</ul>\n<p>地址表示：</p>\n<ul>\n<li>一般形式：冒号分割的8组16进制数，每组4个数字</li>\n<li>压缩：用两个连续冒号省略中间的0</li>\n<li>兼容ipv4：前8个bit都为0:0:0:0:0：FFFF：ipv4地址 或 ::FFFF:ipv4</li>\n<li>地址前缀：ipv6不再使用掩码</li>\n</ul>\n<p>基本地址类型：</p>\n<ul>\n<li>单播unicast： 一对一通信</li>\n<li>多播multicast：一对多通信</li>\n<li>任意播 anycast：一对一组之一（最近一个）通信</li>\n</ul>\n<p>IPV4向IPV6过渡：</p>\n<ul>\n<li>隧道 tunneling：IPV6数据报作为ipv4数据报的载荷进行封装穿越ipv4的网络</li>\n</ul>\n<h3 id=\"网络层（下）\"><a href=\"#网络层（下）\" class=\"headerlink\" title=\"网络层（下）\"></a>网络层（下）</h3><h4 id=\"路由算法\"><a href=\"#路由算法\" class=\"headerlink\" title=\"路由算法\"></a>路由算法</h4><p>概念：寻找最小费用路径的算法</p>\n<p>静态路由 vs 动态路由：</p>\n<ul>\n<li>静态路由：<ul>\n<li>手工配置的路由</li>\n<li>路由更新慢</li>\n<li>优先级高</li>\n</ul>\n</li>\n<li>动态路由：<ul>\n<li>计算得来的路由</li>\n<li>更新快<ul>\n<li>定期更新</li>\n<li>及时响应连路费用或网络拓扑变化</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>全局信息 vs 分散信息：</p>\n<ul>\n<li>全局信息：<ul>\n<li>所有路由器掌握完整网络拓扑和链路费用</li>\n<li>典型算法：链路状态LS路由算法</li>\n</ul>\n</li>\n<li>分散decentralized信息：<ul>\n<li>只掌握物理相连的邻居及链路费用</li>\n<li>通过邻居间信息交换及迭代运算</li>\n<li>典型算法：距离向量DV路由算法</li>\n</ul>\n</li>\n</ul>\n<p>链路状态路由算法：</p>\n<ul>\n<li>所有路由器掌握网络拓扑和链路费用</li>\n<li>通过链路状态广播</li>\n<li>采用 dijkstra算法在每个路由器计算单源最短路</li>\n<li>存在 震荡oscillations 可能</li>\n</ul>\n<p>距离向量（Distance Vector）路由算法：</p>\n<ul>\n<li>每个路由器只掌握物理相连的邻居及链路费用</li>\n<li>Bellman-Ford方程（动态规划）</li>\n<li>步骤：<ul>\n<li>每个结点不定时将自己的DV估计发送给邻居</li>\n<li>结点接收到邻居的新的DV估计时，依据BF更新其自身估计，若估计变化了，则传播给邻居</li>\n<li>距离最终收敛于实际的最小费用</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>异步迭代<ul>\n<li>引发局部迭代的因素：<ul>\n<li>局部链路费用改变</li>\n<li>邻居的DV更新</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>分布式：结点只当自己DV变化时才告诉邻居</li>\n<li>好消息（高费降低费）传播快，坏消息（低费升高费）传播慢</li>\n<li>可能有 无穷计数 count to infinite 问题，解决方案：<ul>\n<li>毒性逆转技术 poisoned reverse：<ul>\n<li>若Z到X的最小路径是通过Y，则y收到Z到X的费用是正无穷</li>\n</ul>\n</li>\n<li>定义最大度量 maximum metric：<ul>\n<li>定义一个最大的有效费用值，超过最大费用的记为无穷</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>层次路由：</p>\n<ul>\n<li>提出原因：把网络抽象为一个图计算路由过于理想化，网络规模过大，管理自治</li>\n<li>聚合路由器为一个区域：自治系统AS autonomous system</li>\n<li>同一AS内路由器运行相同路由协议算法<ul>\n<li>自治系统内部路由协议</li>\n<li>不同自治系统内的路由器可以运行不同的AS内部路由协议</li>\n</ul>\n</li>\n<li>网关路由器 gateway router：<ul>\n<li>位于AS边缘</li>\n<li>通过链路连接其他AS的网关路由器</li>\n</ul>\n</li>\n<li>转发表由AS内部路由算法和AS间路由算法共同配置</li>\n<li>热土豆路由：将分组发给最近的网关路由器</li>\n</ul>\n<h4 id=\"Internet-路由\"><a href=\"#Internet-路由\" class=\"headerlink\" title=\"Internet 路由\"></a>Internet 路由</h4><p>路由协议：</p>\n<ul>\n<li>AS内部路由： 内部网关协议 IGP interior gateway protocols<ul>\n<li>路由信息协议  RIP routing information protocol：<ul>\n<li>距离向量路由算法</li>\n<li>距离用跳步数度量（最大有效为15跳步）</li>\n<li>通告advertisement ：每30s，邻居交换一次DV</li>\n<li>每次通告：最多25个目的子网</li>\n<li>链路失效、恢复：<ul>\n<li>180s没有收到通告 -&gt; 邻居、链路失效 -&gt; 重新计算路由 -&gt; 向邻居发送新的通告 -&gt; 邻居可能向外发送通告</li>\n</ul>\n</li>\n<li>RIP路由表处理：利用一个称作route-d的应用层进程进行管理</li>\n<li>通告报文周期性通过UDP数据报发送</li>\n</ul>\n</li>\n<li>开放最短路径优先 OSPF open shortest path first：<ul>\n<li>链路状态路由算法：所有路由器对整个网络已知，dijkstra求解：<ul>\n<li>LS分组扩散（通告）</li>\n<li>每个路由器构造完整的网络AS拓扑图</li>\n<li>利用dijkstra计算</li>\n</ul>\n</li>\n<li>每个入口对应一个邻居</li>\n<li>通告在整个AS中泛洪</li>\n<li>通告报文直接封装到IP数据报中</li>\n<li>优点：<ul>\n<li>安全：所有OSPF报文可以被认证（预防恶意入侵）</li>\n<li>允许使用多条到同一目的的相同费用的路径（RIP只能从中选一条）</li>\n<li>对同一链路针对不同TOS设置不同费用度量</li>\n<li>集成单播与多播路由：<ul>\n<li>多播OSPF协议（MOSPF）与OSPF利用相同的拓扑数据</li>\n</ul>\n</li>\n<li>支持大规模AS分层 hierarchical：<ul>\n<li>区边界路由器：同时在主干区和分支区的路由器</li>\n<li>主干路由器：只在主干区</li>\n<li>AS边界路由器：连接其它AS</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内部网关路由协议 IGRP interior gateway routing protocol（思科的私有协议）</li>\n</ul>\n</li>\n<li>AS间路由协议：BGP border gateway protocol：<ul>\n<li>事实上的标准域间路由协议</li>\n<li>为每个AS提供了一种手段：<ul>\n<li>eBGP：从邻居AS获取子网可传达性信息（外部会话）</li>\n<li>iBGP：向所有AS内部路由器传播子网可达性信息（内部会话）</li>\n</ul>\n</li>\n<li>基础：<ul>\n<li>BGP会话session：两个路由器交换BGP报文<ul>\n<li>通告去往不同目的前缀（子网）的路径</li>\n<li>报文交换基于半永久的TCP连接</li>\n</ul>\n</li>\n<li>BGP报文：<ul>\n<li>OPEN：建立TCP连接并认证发送方</li>\n<li>UPDATE：通告新路径（或撤销原路径）</li>\n<li>KEEPALIVE：无UPDATE时保活连接，也用于对OPEN的确认</li>\n<li>NOTIFICATION：报告先前报文的差错，也用于关闭连接</li>\n</ul>\n</li>\n<li>路径信息与BGP路由：<ul>\n<li>通告的前缀信息包括BGP属性<ul>\n<li>前缀+属性 = “路由”</li>\n</ul>\n</li>\n<li>两个重要属性：<ul>\n<li>AS-PATH  AS路径：包含前缀通告所经过的AS路径</li>\n<li>NEXT-HOP下一跳：开始一个AS-PATH的路由器的接口，指向下一跳AS</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>路由选择：网关路由器收到路由通告后，利用输入策略import policy决策接收或拒绝路由：</li>\n<li>多条路径的挑选准则：<ol>\n<li>本地偏好preference值策略</li>\n<li>最短AS-PATH</li>\n<li>最近NEXT-HOP路由器：热土豆路由</li>\n<li>附加准则</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>采用不同的AS内、AS间路由协议原因：<ul>\n<li>策略：<ul>\n<li>AS间inter-AS：希望能够管理控制流量如何被路由，谁路由经过网络</li>\n<li>intra-AS 内部：单一管理，无需策略决策</li>\n</ul>\n</li>\n<li>规模：<ul>\n<li>层次路由节省路由表大小，减少更新流量</li>\n<li>适应大规模互联网</li>\n</ul>\n</li>\n<li>性能：<ul>\n<li>inter-AS间：策略主导</li>\n<li>intra-AS内：侧重性能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><h4 id=\"链路层服务\"><a href=\"#链路层服务\" class=\"headerlink\" title=\"链路层服务\"></a>链路层服务</h4><p>术语：</p>\n<ul>\n<li>结点 nodes：主机和路由器</li>\n<li>链路 links：连接相邻结点的通信信道：<ul>\n<li>有线链路 wired links</li>\n<li>无线链路 wireless links</li>\n<li>局域网 LANS</li>\n</ul>\n</li>\n<li>帧 frame：链路层的数据分组，封装网络层的数据报</li>\n</ul>\n<p>功能：负责通过链路在相邻结点间传输数据报</p>\n<p>服务：</p>\n<ul>\n<li>组帧 framing：<ul>\n<li>封装数据报构成数据帧，加头加尾</li>\n<li>帧同步</li>\n</ul>\n</li>\n<li>链路接入 link access：<ul>\n<li>若是共享介质时，需要解决信道接入 channel access</li>\n<li>帧首部的MAC地址 ( 物理地址 )，用于标识帧的源和目的</li>\n</ul>\n</li>\n<li>相邻结点间的可靠交付<ul>\n<li>低误码率的有线链路很少采用（如光纤，某些双绞线）</li>\n<li>无线链路：误码率高，需要可靠交付</li>\n</ul>\n</li>\n<li>流量控制 flow control：<ul>\n<li>协调pacing相邻发送结点与接收</li>\n</ul>\n</li>\n<li>差错检测 error detection：<ul>\n<li>应对信号衰减和噪声</li>\n<li>接收端检测到差错：重传或丢弃</li>\n</ul>\n</li>\n<li>差错纠正 error correction （个别协议）：<ul>\n<li>纠错编码：接收端可以直接纠正比特差错</li>\n</ul>\n</li>\n<li>全双工和半双工的通信控制</li>\n</ul>\n<p>具体实现：</p>\n<ul>\n<li>链路层在网络接口卡实现</li>\n<li>由硬件、软件和固件组成</li>\n<li>链接主机的系统总线</li>\n</ul>\n<h4 id=\"差错编码\"><a href=\"#差错编码\" class=\"headerlink\" title=\"差错编码\"></a>差错编码</h4><p>原理：</p>\n<ul>\n<li>在数据上增加冗余信息 R 称为监督位或冗余比特</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li>分组码<ul>\n<li>线性码</li>\n<li>非线性码</li>\n</ul>\n</li>\n<li>卷积码</li>\n</ul>\n<p>差错编码的检错能力：</p>\n<ul>\n<li>差错编码分为 检错码 和 纠错码</li>\n<li>对于检错码，若编码集的汉明距离d = r+1 ， 则该差错编码可以100%检测 r位差错<ul>\n<li>汉明距离：编码集中任意两个字符编码不同比特数目的最小值</li>\n</ul>\n</li>\n<li>对于纠错码，汉明距离 d=2r+1，则该差错编码可以100%纠正r位差错（纠成与之距离最近的码字）</li>\n</ul>\n<p>常见差错编码：</p>\n<ul>\n<li>奇偶校验码：0的个数或1的个数加上冗余位为奇数或偶数<ul>\n<li>1比特校验位：检测奇数位差错，冗余位少</li>\n<li>二维奇偶校验：<ul>\n<li>检测所有奇数位差错、部分偶数位差错</li>\n<li>可以检测同一行或同一列差错</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Internet校验和  checksum：<ul>\n<li>数据划分为16位二进制整数序列</li>\n<li>求和后取反码</li>\n</ul>\n</li>\n<li>循环冗余校验码 CRC<ul>\n<li>数据 D 看成一个二进制数</li>\n<li>选择一个 r+1 位的生成比特模式 G</li>\n<li>目标：选择 r 位CRC比特 R 满足 &lt; D,R &gt;刚好可以被G整除</li>\n<li>R计算方法： <ul>\n<li>$ D<em>2^{r} (XOR)  R = n</em>G$</li>\n<li>$ R =( D*2^r ) mod G $</li>\n</ul>\n</li>\n<li>可以检测所有突发长度小于r+1位差错</li>\n<li>广泛应用于实际网络</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多路访问控制-MAC-协议\"><a href=\"#多路访问控制-MAC-协议\" class=\"headerlink\" title=\"多路访问控制 MAC 协议\"></a>多路访问控制 MAC 协议</h4><p>两类链路：</p>\n<ul>\n<li>点对点链路：<ul>\n<li>拨号接入的PPP</li>\n<li>以太网交换机和主机间的点对点链路</li>\n</ul>\n</li>\n<li>广播链路（共享介质）<ul>\n<li>单一共享广播信道</li>\n<li>两个或两个以上结点同时传输：干扰 interference<ul>\n<li>冲突 collision：结点同时接收多个信号</li>\n</ul>\n</li>\n<li>多路访问控制协议 MAC multiple access control protocol：<ul>\n<li>采用分布式算法决定结点如何共享信道</li>\n<li>基于信道本身进行协调<ul>\n<li>无带外信道进行协调</li>\n</ul>\n</li>\n<li>理想的MAC协议：<ul>\n<li>完全分散控制：<ul>\n<li>无需特定结点协调</li>\n<li>无需时钟、时隙同步</li>\n</ul>\n</li>\n<li>需要发送数据的结点平分链路带宽</li>\n<li>简单</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>信道划分 channel partitioning MAC协议：<ul>\n<li>多路复用技术 TDMA、FDMA、CDMA、WDMA等</li>\n<li>网络负载重时公平、效率高</li>\n<li>负载轻时效率低</li>\n</ul>\n</li>\n<li>随机访问 random access MAC协议：<ul>\n<li>信道不划分，允许冲突</li>\n<li>采用冲突恢复机制</li>\n<li>结点要发送数据时<ul>\n<li>用信道的全部速率发送分组</li>\n<li>没有事先的节点间协调</li>\n</ul>\n</li>\n<li>需要定义：<ul>\n<li>如何检测冲突</li>\n<li>如何从冲突中恢复（通常是延迟重传）</li>\n</ul>\n</li>\n<li>负载重时冲突大、效率低</li>\n<li>负载低时效率高</li>\n<li>典型随机访问MAC协议：<ul>\n<li>时隙soted ALOHA：<ul>\n<li>假定：<ul>\n<li>假设所有帧大小相等</li>\n<li>时间划分成等长时隙（每个时隙可以传1个帧）</li>\n<li>结点只能在时隙开始时发送帧</li>\n<li>结点间时钟同步</li>\n</ul>\n</li>\n<li>运行：<ul>\n<li>有帧时，在下一个时隙发送：<ul>\n<li>无冲突：在下一个时隙发新的帧</li>\n<li>有冲突：在下一个时隙以概率p重发，直至成功</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>单个结点活动时用整个信道速率</li>\n<li>高度分散化：只需要同步时隙</li>\n<li>简单</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>容易冲突，浪费时隙</li>\n<li>空闲时隙</li>\n<li>时钟同步</li>\n<li>效率低，最好情况 37%</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ALOHA：<ul>\n<li>无时隙划分，纯ALOHA，更简单，无需同步</li>\n<li>有新的帧生成时：立即发送</li>\n<li>冲突可能性大</li>\n<li>比时隙ALOHA协议效率更低，18%</li>\n</ul>\n</li>\n<li>CSMA、CSMA/CD、CSMA/CA<ul>\n<li>CSMA 载波监听多路访问协议 carrier sense multiple access：发送帧之前监听信道：<ul>\n<li>信道空闲：发送完整帧</li>\n<li>信道忙：推迟发送：<ul>\n<li>1-坚持CSMA：以概率p=1监听信道</li>\n<li>非坚持CSMA：随机等待一段时间后再监听</li>\n<li>P-坚持CSMA：以概率p坚持监听，1-p非坚持</li>\n</ul>\n</li>\n<li>冲突仍然可能发送：信号传播延迟</li>\n<li>继续发送冲突帧：浪费信道资源</li>\n</ul>\n</li>\n<li>CSMA/CD CSMA with Collision Detection 带冲突检测的CSMA协议：短时间内可以检测冲突<ul>\n<li>广泛用于以太网</li>\n<li>检测到冲突后，立刻停止传输</li>\n<li>冲突检测：<ul>\n<li>有线局域网易实现：测量信号强度</li>\n<li>无线局域网难实现：接收信号强度淹没在本地发射信号强度下</li>\n</ul>\n</li>\n<li>边发边听，不发不听</li>\n<li>Lmin / R = RTTmax （Lmin：数据帧最小长度，R：网络带宽，RTT：消息来回的时间），发送数据时能够检测到冲突的最小长度，防止数据在冲突时已经发完，因不发不听而不知道有冲突</li>\n</ul>\n</li>\n<li>CSMA/CA 应用于802.11无线局域网</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>轮转 taking turns MAC协议：<ul>\n<li>结点轮流使用信道</li>\n<li>综合信道划分和随机访问的优点</li>\n<li>类型：<ul>\n<li>轮询 polling：<ul>\n<li>主结点轮流邀请从属结点发送数据</li>\n<li>典型应用： 哑dump（非智能、蓝牙）从属设备</li>\n<li>问题：<ul>\n<li>轮询开销，数据占用带宽</li>\n<li>等待延迟</li>\n<li>单点故障，主结点故障问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>令牌传递 token passing：<ul>\n<li>控制令牌依次从一个结点传递到下一个结点</li>\n<li>令牌：特殊帧，网络中有且只有一个令牌</li>\n<li>网络可能构成环形网络</li>\n<li>问题：<ul>\n<li>令牌开销，带宽开销</li>\n<li>等待延迟</li>\n<li>单点故障：令牌丢失</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"局域网\"><a href=\"#局域网\" class=\"headerlink\" title=\"局域网\"></a>局域网</h3><h4 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h4><p>MAC地址：物理地址、LAN地址、以太网地址</p>\n<ul>\n<li>作用：在局域网中标识一个帧从哪个接口发出，到达哪个物理相连的其它接口</li>\n<li>48位（16进制6字节）MAC地址，固化在网卡的ROM中，有时可以软件设置</li>\n<li>局域网中每块网卡都有唯一的MAC地址</li>\n<li>由IEEE统一管理与分配</li>\n<li>网卡厂商在IEEE购买前24比特MAC地址空间</li>\n<li>与IP地址区别：<ul>\n<li>MAC地址是“平面地址”，可以从一个LAN移到另一个LAN，用于标识帧</li>\n<li>IP地址是层次地址，依赖结点连接到哪个子网，用于标识数据报</li>\n</ul>\n</li>\n</ul>\n<p>ARP：地址解析协议</p>\n<ul>\n<li>已知目的接口的IP地址下确定MAC地址</li>\n<li>ARP表：LAN中每个IP结点维护一个表，存储某些LAN结点IP/MAC地址映射关系：&lt; IP; MAC ; TTL&gt;(TTL time to live:经过这个时间后该映射关系会丢弃，一般为20min)</li>\n<li>ARP是“即插即用”协议：结点无需干预，自主创建ARP表</li>\n<li>获取目标主机的MAC地址：<ul>\n<li>同一局域网内：<ul>\n<li>若A的ARP表不包含B的MAC地址，则A广播ARP查询分组，其中包含B的IP地址，只有B向A利用单播帧响应B的MAC地址，A缓存B的地址对直至超时</li>\n</ul>\n</li>\n<li>不同局域网内：<ul>\n<li>A发数据帧至网关路由器（源IP为A，目标IP为B，源MAC为A，目的MAC为网关路由器的一端口），网关路由器转发数据报，更改源MAC地址为发出端口的MAC地址，若双方都在公网，则不需要更改IP地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"以太网-Ethernet\"><a href=\"#以太网-Ethernet\" class=\"headerlink\" title=\"以太网 Ethernet\"></a>以太网 Ethernet</h4><p>有线LAN技术、应用最广泛的LAN技术</p>\n<p>物理拓扑：</p>\n<ul>\n<li>总线 bus：同轴电缆，上世纪90年代中期流行<ul>\n<li>所有结点在同一冲突域 collision domain ，可能彼此冲突</li>\n</ul>\n</li>\n<li>星型 star：目前主流网络拓扑<ul>\n<li>利用中心交换机 switch</li>\n<li>每个结点一个单独冲突域，结点间彼此不冲突</li>\n</ul>\n</li>\n</ul>\n<p>特点:</p>\n<ul>\n<li>无连接 connectionless：发送帧的网卡和接收帧的网卡没有握手过程</li>\n<li>不可靠 unreliable：接收网卡不向发送网卡进行确认<ul>\n<li>出错可能性低，差错帧直接丢弃，依靠高层协议恢复数据</li>\n</ul>\n</li>\n<li>采用二进制指数退避算法CSMA/CD的 MAC协议：<ol>\n<li>网卡从网络层接收数据报，创建数据帧</li>\n<li>监听信道：<ol>\n<li>监听到信道空闲，则发送帧</li>\n<li>信道忙，一直等待到信道空闲，然后发送</li>\n</ol>\n</li>\n<li>发送完整个帧没有检测到其他结点数据发送，则确认发送成功</li>\n<li>若检测到其他结点传输数据，终止发送并发送阻塞信号 jam signal</li>\n<li>网卡进入二进制指数退避：<ul>\n<li>第m次连续冲突后：<ul>\n<li>取n=Max(m,10)</li>\n<li>网卡从 0到 $2^n-1$随机取一个数K</li>\n<li>等待 K * 512bit的传输延迟时间，再返回第2步</li>\n</ul>\n</li>\n<li>连续16次冲突后，报告差错</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>帧结构：</p>\n<ul>\n<li>把IP数据报封装到以太网帧中</li>\n<li>前导码 preamble   8B：<ul>\n<li>前7个字节为10101010，第八字节为10101011</li>\n<li>用于发送端和接收端的时钟一致</li>\n</ul>\n</li>\n<li>目的MAC和源MAC地址（各6B）</li>\n<li>类型 Type  2B：指示帧中封装哪种高层协议的分组</li>\n<li>数据 Data 46-1500B：上层协议载荷 （CSMA/CD发送数据时能够检测到冲突的最小长度）</li>\n<li>CRC 4B：循环冗余校验码</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述（上）\"><a href=\"#概述（上）\" class=\"headerlink\" title=\"概述（上）\"></a>概述（上）</h3><p>计算机网络学习笔记，包括：</p>\n<ol>\n<li>基本概念：网络结构、体系结构</li>\n<li>网络层：web、Email、DNS、P2P、Socket</li>\n<li>传输层：TCP、UDP</li>\n<li>网络层：IP、CIDR、DHCP、NAT、ICMP、路由</li>\n<li>数据链路层：差错编码、MAC</li>\n<li>局域网：ARP、以太网</li>\n</ol>","more":"<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>计算机网络 = 通信技术 + 计算机技术</p>\n<p>定义： 计算机网络是互连的、自治的计算机集合</p>\n<p>网络结构：</p>\n<ul>\n<li>网络边缘： 主机、网络应用<ul>\n<li>主机（端系统）：运行网络应用程序</li>\n<li>模型：<ul>\n<li>client、server 客户 服务器模型：客户发送请求，服务器响应</li>\n<li>p2p模型：无专用服务器，通信在对等实体间直接进行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>接入网络，物理介质： 有线或无线通信链路<ul>\n<li>DSL 数字用户线路：用电话线连接，FDM分频</li>\n</ul>\n</li>\n<li>网络核心（核心网络）：互联的路由器、网络的网络<ul>\n<li>核心功能：路由routing + 转发 forwarding<ul>\n<li>路由：确定分组从源到目的传输路径</li>\n<li>转发：分组从路由器输入端口转发至正确的输出端口</li>\n</ul>\n</li>\n<li><strong>数据交换</strong></li>\n</ul>\n</li>\n</ul>\n<p>端系统通过 接入ISP 连接到Internet， 接入ISP互连</p>\n<h4 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h4><p>数据交换：数据通过网络核心从源主机到达目的主机的手段</p>\n<p>数据交换分类：</p>\n<ol>\n<li>电路交换</li>\n<li>报文交换</li>\n<li>分组交换</li>\n</ol>\n<h5 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h5><p>最典型的电路交换网络：电话网络</p>\n<p>三个阶段：</p>\n<ul>\n<li>建立连接</li>\n<li>通信</li>\n<li>释放连接</li>\n</ul>\n<p>特点：资源<strong>独占</strong></p>\n<p>如何共享中继线： 多路复用（Multiplexing）</p>\n<p>多路复用： 链路、网络资源划分资源片，每路独占分配的资源片，资源片可能闲置</p>\n<p>典型多路复用方法：</p>\n<ul>\n<li>频分多路复用 FDM<ul>\n<li>各用户占用不同频率带宽</li>\n<li>通信过程中始终使用一个频带</li>\n</ul>\n</li>\n<li>时分多路复用 TDM<ul>\n<li>将时间划分为等长的帧，帧划分为时隙，每个用户使用固定序号的时隙</li>\n<li>每个用户的时隙周期性出现（周期为帧长度）</li>\n<li>所有用户使用所有频带宽度</li>\n</ul>\n</li>\n<li>波分多路复用 WDM<ul>\n<li>光的频分复用</li>\n</ul>\n</li>\n<li>码分多路复用 CDM<ul>\n<li>广泛应用于无线链路共享</li>\n<li>每个用户有唯一的码片序列，码片序列之间正交</li>\n<li>用户用码片序列编码自己的数据</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"报文交换-message-switching\"><a href=\"#报文交换-message-switching\" class=\"headerlink\" title=\"报文交换 message switching\"></a>报文交换 message switching</h5><p>一次发送信息整体</p>\n<h5 id=\"分组交换-package-switching\"><a href=\"#分组交换-package-switching\" class=\"headerlink\" title=\"分组交换 package switching\"></a>分组交换 package switching</h5><p>分组： 报文拆分出的一系列较小的数据包</p>\n<p>需要报文的拆分和重组</p>\n<p>每个分组需要额外的分组头</p>\n<p><strong>统计多路复用 statistical multiplexing</strong>： 按需共享（传输数据多的速度快，数据少的速度慢）</p>\n<p>交换方式： <strong>存储-转发</strong>：</p>\n<p>​    一次存储整个分组，而后转发</p>\n<p>分组交换和电路交换：</p>\n<p>分组交换适用于突发数据传输：</p>\n<ul>\n<li>优点<ul>\n<li>资源充分共享<ul>\n<li>简单、无需建立呼叫电路</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>可能产生拥塞 congestion： 分组延迟和丢包</li>\n<li>需要协议处理可靠数据传输和拥塞控制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概述（下）\"><a href=\"#概述（下）\" class=\"headerlink\" title=\"概述（下）\"></a>概述（下）</h3><h4 id=\"计算机网络性能\"><a href=\"#计算机网络性能\" class=\"headerlink\" title=\"计算机网络性能\"></a>计算机网络性能</h4><p>速率：</p>\n<ul>\n<li>速率、数据率、比特率： 单位时间(秒)内传输信息（比特）量， b/s ,bps, kb/s</li>\n<li>速率往往指的是额定速率、标称速率（理论值）</li>\n</ul>\n<p>带宽： </p>\n<ul>\n<li>原本：信号具有的频带宽度，最高频率和最低频率之差，单位 hz</li>\n<li>网络：数字信道所能传输的最大数据率，单位 b/s</li>\n</ul>\n<p>延迟delay、时延 latency：</p>\n<ul>\n<li>原因： 分组在路由器缓存中排队</li>\n<li>四种类型：<ul>\n<li>处理延迟( nodal processing delay)：<ul>\n<li>差错检测</li>\n<li>确定输出链路</li>\n<li>通常毫秒、微秒级 </li>\n</ul>\n</li>\n<li>排队延迟 (queueing delay)<ul>\n<li>等待输出链路可用</li>\n<li>取决于路由器拥塞程度</li>\n</ul>\n</li>\n<li>传输延迟 (transmission delay) ：路由器到链路<ul>\n<li>取决于分组长度L、链路带宽R， d trans = L/R</li>\n</ul>\n</li>\n<li>传播延迟 (propagation delay)：链路上到下一个路由器<ul>\n<li>取决于链路长度d，信号传播速度s，　d prop = d/s</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>d nodal = d proc + d queue + d trans + d prop</li>\n</ul>\n<p>时延带宽积＝传播时延＊带宽 = 链路上能容纳多少比特</p>\n<p>丢包：</p>\n<ul>\n<li>原因：队列缓存有限</li>\n<li>分组到达已满队列将被丢弃</li>\n<li>丢弃分组可能由前序结点或源重发</li>\n<li>以丢包率衡量</li>\n</ul>\n<p>吞吐量  throughput</p>\n<ul>\n<li>发送端与接收端之间的速率</li>\n<li>分类：<ul>\n<li>即时吞吐量</li>\n<li>平均吞吐量<ul>\n<li>取决于端到端路径上，最小速率的链路</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h4><p>用<strong>分层结构</strong>从<strong>功能上</strong>描述计算机网络体系</p>\n<p>每层完成一个特定功能，每层依赖底层提供的服务</p>\n<p>每层遵循某个协议完成本层功能</p>\n<p>计算机网络体系结构是计算机网络各层及其协议的集合</p>\n<p>分层结构的优点</p>\n<ul>\n<li>结构清晰</li>\n<li>模块化思想，易于系统更新、维护<ul>\n<li>任何一层服务实现上的改变对其它层不影响​</li>\n</ul>\n</li>\n</ul>\n<p>基本概念：</p>\n<ul>\n<li>实体 entity ： 任何可发送或接收信息的硬件或软件进程</li>\n<li>协议 protocol：控制两个对等实体进行通信的规则的集合（同层的，水平的）</li>\n<li>服务是垂直的，任一层实体需要使用下层服务，遵循本层协议，实现本层功能，对上层提供服务</li>\n<li>下层实现对上层是不可见的</li>\n<li>相邻层之间通过接口进行交互，通过服务访问点SAP</li>\n</ul>\n<h5 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h5><p>概念：</p>\n<ul>\n<li>目的： 支持异构网络系统的互联互通</li>\n<li>异构网络系统互连的国际标准</li>\n<li>理解网络通信的最佳学习工具（理论模型，市场失败）</li>\n</ul>\n<p>分层： 7层：</p>\n<ul>\n<li>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>\n<li>主机需要完成7层</li>\n<li>路由器只需要完成3层，物理层、链路层、网络层</li>\n<li>数据纵向流动，协议水平</li>\n<li>端到端层 end-end： 应用层到传输层 四层</li>\n</ul>\n<p>数据封装和通信过程：</p>\n<ol>\n<li>APDU 应用层数据单元</li>\n<li>PPDU 表示层</li>\n<li>SPDU 会话层</li>\n<li>TPDU 传输层</li>\n<li>NPDU 网络层</li>\n<li>DPDU 链路层加头加尾</li>\n<li>物理层对应比特，不加额外信息</li>\n</ol>\n<ul>\n<li>增加控制信息： 最终构造成 PDU 构造协议数据单元</li>\n<li>控制信息包括：<ul>\n<li>地址： 标识发送端、接收端</li>\n<li>差错检测编码：差错检测或纠正</li>\n<li>协议控制：实现协议功能的附加信息</li>\n</ul>\n</li>\n</ul>\n<p>功能：</p>\n<ul>\n<li>物理层功能：   总：实现比特的传输<ul>\n<li>定义、规范接口特性<ul>\n<li>机械特性：接口的几何形状</li>\n<li>电气特性：接口的电平、电压</li>\n<li>功能特性：多少引脚、引脚的功能</li>\n<li>规程特性：接口的使用规则，也叫过程特性</li>\n</ul>\n</li>\n<li>比特编码</li>\n<li>数据率</li>\n<li>比特同步： 时钟同步问题</li>\n<li>传输模式<ul>\n<li>单工模式 simplex ： 单向发信（如电视）</li>\n<li>半双工 half-duplex ： 可双向，但只能交替进行（如对讲机）</li>\n<li>全双工 full-duplex ： 可同时收发</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据链路层功能：<ul>\n<li>负责结点-结点 node-to-node数据传输</li>\n<li>以帧为单位进行传输</li>\n<li>功能：<ul>\n<li>组帧 framing ： 加头加尾 ： 使得接收方能够切分帧病识别控制信息</li>\n<li>物理寻址 physical addressing：包含源和目的物理地址</li>\n<li>流量控制 flow control ： 避免淹没接收端</li>\n<li>差错控制 error control ： 检测并重传损坏或丢失帧，并避免重复帧</li>\n<li>访问（接入）控制 access control：决定哪个设备拥有链路的控制使用权</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络层功能：负责数据分组packet的交付<ul>\n<li>原因：可能穿越多个网络</li>\n<li>逻辑寻址 logical addressing： 全局唯一逻辑地址，确保数据分组被送到目的地，如IP地址</li>\n<li>路由 routing： 选择路径</li>\n<li>分组转发</li>\n</ul>\n</li>\n<li>传输层功能： 负责端-端 完整报文的传输<ul>\n<li>报文的分段和重组</li>\n<li>SAP寻址：确保报文提交给正确进程，如端口号</li>\n<li>连接控制：逻辑连接</li>\n<li>流量控制</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>会话层功能： 插入控制信息<ul>\n<li>对话控制 dialog controlling： 对话的建立与维护</li>\n<li>对话同步 synchronization： 数据流中插入同步点</li>\n<li>最“薄”的一层</li>\n</ul>\n</li>\n<li>表示层功能： 编码、加密、压缩数据<ul>\n<li>数据表示转化<ul>\n<li>转换为主机独立的编码</li>\n</ul>\n</li>\n<li>加密解密</li>\n<li>压缩解压缩</li>\n</ul>\n</li>\n<li>应用层功能：支持用户通过接口使用网络服务<ul>\n<li>典型类型：<ul>\n<li>FTP 文件传输</li>\n<li>HTTP WEB</li>\n<li>SMTP 电子邮件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"TCP-IP模型\"><a href=\"#TCP-IP模型\" class=\"headerlink\" title=\"TCP / IP模型\"></a>TCP / IP模型</h5><p>四层： 应用层、运输层、网际层、网络接口层</p>\n<h5 id=\"五层参考模型\"><a href=\"#五层参考模型\" class=\"headerlink\" title=\"五层参考模型\"></a>五层参考模型</h5><p>综合OSI和TCP/IP模型的优点</p>\n<p>应用层、传输层、网络层、数据链路层、物理层</p>\n<p>层次：</p>\n<ul>\n<li>主机 五层</li>\n<li>路由器 三层</li>\n<li>交换机 两层</li>\n</ul>\n<h4 id=\"网络发展历史\"><a href=\"#网络发展历史\" class=\"headerlink\" title=\"网络发展历史\"></a>网络发展历史</h4><p>1961-1972： 交换分组原理提出与应用</p>\n<p>1972-1980：网络互连，大量新型、私有网络的涌现</p>\n<p>1980-1990：新型网络协议与网络的激增</p>\n<p>1990-2000初： 商业化，web，新应用</p>\n<p>2005-今</p>\n<h3 id=\"网络应用（上）\"><a href=\"#网络应用（上）\" class=\"headerlink\" title=\"网络应用（上）\"></a>网络应用（上）</h3><p>应用层 - 传输层 - 网络层 - 链路层 - 物理层</p>\n<h4 id=\"网络应用层概述\"><a href=\"#网络应用层概述\" class=\"headerlink\" title=\"网络应用层概述\"></a>网络应用层概述</h4><ul>\n<li>网络应用体系结构</li>\n<li>网络应用的服务需求</li>\n<li>Internet传输层服务模型</li>\n<li>特定网络应用与协议</li>\n<li>Socket编程</li>\n</ul>\n<h4 id=\"网络应用的基本原理\"><a href=\"#网络应用的基本原理\" class=\"headerlink\" title=\"网络应用的基本原理\"></a>网络应用的基本原理</h4><h5 id=\"网络应用的体系结构\"><a href=\"#网络应用的体系结构\" class=\"headerlink\" title=\"网络应用的体系结构\"></a>网络应用的体系结构</h5><ul>\n<li>客户机、服务器结构  C/S  Client-Server<ul>\n<li>服务器<ul>\n<li>7*24小时提供服务</li>\n<li>永久性访问地址\\域名</li>\n<li>利用大量服务器实现可扩展性（处理大量并发请求）</li>\n</ul>\n</li>\n<li>客户机<ul>\n<li>与服务器通信，使用服务器提供的服务</li>\n<li>间歇性接入网络</li>\n<li>可能使用动态IP</li>\n<li>不会和其他客户机直接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>点对点结构 P2P Peer-to-peer<ul>\n<li>没有永远在线的服务器</li>\n<li>任意端系统之间可以直接通信</li>\n<li>节点间歇性接入网络</li>\n<li>节点可能改变IP</li>\n<li>优点：高度可伸缩、可扩展</li>\n<li>缺点：难以管理</li>\n</ul>\n</li>\n<li>混合结构 hyrid</li>\n</ul>\n<h5 id=\"网络应用进程通信\"><a href=\"#网络应用进程通信\" class=\"headerlink\" title=\"网络应用进程通信\"></a>网络应用进程通信</h5><p>同一主机上进程通信：</p>\n<ul>\n<li>进程间通信机制</li>\n<li>由操作系统提供</li>\n</ul>\n<p>不同主机进程通信：消息交换</p>\n<p>Socket套接字：进程间利用socket发送和接受消息</p>\n<p>传输基础设施向进程提供API：</p>\n<ul>\n<li>传输协议的选择</li>\n<li>参数的设置</li>\n</ul>\n<p>进程寻址：</p>\n<ul>\n<li>不同主机进程通信，每个进程必须有标识符</li>\n<li>寻址主机：IP地址</li>\n<li>端口号 port number：主机上每个需要通信的进程分配一个端口号</li>\n<li>已经分配的端口： HTTP：80     mail：25</li>\n<li>进程的标识符： IP+端口号</li>\n</ul>\n<p>应用层协议：</p>\n<ul>\n<li>网络应用都应该遵循应用层协议</li>\n<li>公开协议： <ul>\n<li>由 RFC（request for comments）定义</li>\n<li>允许互操作</li>\n<li>例如： HTTP、SMTP</li>\n</ul>\n</li>\n<li>私有协议：<ul>\n<li>多数P2P文件共享应用</li>\n</ul>\n</li>\n<li>内容：<ul>\n<li>消息的类型type：<ul>\n<li>请求消息</li>\n<li>响应消息</li>\n</ul>\n</li>\n<li>消息的语法syntax 、格式<ul>\n<li>消息中由哪些字段 field</li>\n<li>每个字段如何描述</li>\n</ul>\n</li>\n<li>字段的语义 semantics ：信息的含义</li>\n<li>规则 rules： 何时、如何发送、相应消息</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"网络应用的需求与传输层服务\"><a href=\"#网络应用的需求与传输层服务\" class=\"headerlink\" title=\"网络应用的需求与传输层服务\"></a>网络应用的需求与传输层服务</h5><p>需求：</p>\n<ul>\n<li>数据丢失 data loss、 可靠性reliability<ul>\n<li>某些可容忍一定的数据丢失：网络电话</li>\n<li>某些要求100%可靠的数据传输</li>\n</ul>\n</li>\n<li>时间timing 、 延迟 delay：<ul>\n<li>延迟低才有效（网络电话、网络游戏）</li>\n</ul>\n</li>\n<li>带宽 bandwidth：<ul>\n<li>带宽达到最低要求才有效：网路视频</li>\n<li>可适应任何带宽——弹性应用：email、文件下载</li>\n</ul>\n</li>\n</ul>\n<p>传输服务：</p>\n<ul>\n<li>TCP服务：<ul>\n<li>面向连接：客户机和服务器需要建立连接</li>\n<li>可靠的传输</li>\n<li>流量控制：发送方不会发送速度过快</li>\n<li>拥塞控制：网络负载过重时能限制发送方发送速度</li>\n<li>不提供时间保障</li>\n<li>不提供最小带宽保障</li>\n</ul>\n</li>\n<li>UDP服务：<ul>\n<li>无连接</li>\n<li>不可靠</li>\n<li>不提供：可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h4><h5 id=\"web与http\"><a href=\"#web与http\" class=\"headerlink\" title=\"web与http\"></a>web与http</h5><p>web：</p>\n<ul>\n<li>网页</li>\n<li>网页互相链接</li>\n</ul>\n<p>网页 webpage 包含多个对象 objects：</p>\n<ul>\n<li>对象：html文件、jpeg图片、视频、动态脚本</li>\n<li>基本html文件：包含对其他对象引用的链接</li>\n</ul>\n<p>对象的寻址 addressing：</p>\n<ul>\n<li>URL（uniform resource locator）：统一资源定位器</li>\n<li>格式：  Scheme:// host:port/path</li>\n</ul>\n<p>HTTP协议 hypertext transfer protocol 超文本传输协议：</p>\n<ul>\n<li>CS结构：<ul>\n<li>客户- browser：请求、接受、展示web对象</li>\n<li>服务器-web server：相应客户请求、发送对象</li>\n</ul>\n</li>\n<li>使用TCP传输服务</li>\n<li>无状态 stateless：服务器不维护任何过去发送请求的信息</li>\n</ul>\n<h5 id=\"HTTP连接\"><a href=\"#HTTP连接\" class=\"headerlink\" title=\"HTTP连接\"></a>HTTP连接</h5><p>非持久性连接 nonpersistent http：</p>\n<ul>\n<li>每个TCP连接最多允许传输一个对象</li>\n<li>在HTTP 1.0版本</li>\n<li>缺点：<ul>\n<li>每个对象需要2个RTT</li>\n<li>操作系统要为每个TCP连接开销资源</li>\n<li>浏览器需要打开多个并行TCP连接获取对象</li>\n</ul>\n</li>\n</ul>\n<p>持久性连接：</p>\n<ul>\n<li>每个TCP连接允许传输多个对象</li>\n<li>HTTP 1.1默认</li>\n<li>发送响应后，服务器保持TCP连接打开以发送后续HTTP消息</li>\n<li>分类：<ul>\n<li>无流水pipelining的持久性连接<ul>\n<li>客户端受到一个响应才发送一个新请求</li>\n<li>每个对象消耗 1RTT</li>\n</ul>\n</li>\n<li>流水机制的持久性连接：<ul>\n<li>HTTP 1.1默认</li>\n<li>客户端遇到一个引用对象就尽快发送请求</li>\n<li>理想情况下收到所有引用对象只需要约 1RTT</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>响应时间 RTT ： round trip time：从客户端发送一个很小数据包到服务器并返回所经历的时间</p>\n<h5 id=\"HTTP请求消息\"><a href=\"#HTTP请求消息\" class=\"headerlink\" title=\"HTTP请求消息\"></a>HTTP请求消息</h5><p>HTTP协议两类信息：</p>\n<ul>\n<li>请求消息 request<ul>\n<li>ASCII：人直接可读</li>\n<li>上传输入的方法：<ul>\n<li>POST方法：在请求消息的消息体中输入</li>\n<li>URL方法：GET方法：输入信息通过request行中的URL段上传</li>\n<li>HEAD：请求服务器不要把所请求对象放入相应消息中（只返回头，一般用作测试）</li>\n<li>PUT：（HTTP  1.1）消息体中的文件上传到URL段所指定的路径（上传文件到服务器）</li>\n<li>DELETE：（HTTP1.1）删除URL字段指定文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>响应消息 response<ul>\n<li>状态响应代码：相应消息的第一行</li>\n<li>如 200 OK， 404 Not Found</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Cookie-方法\"><a href=\"#Cookie-方法\" class=\"headerlink\" title=\"Cookie 方法\"></a>Cookie 方法</h5><p>cookie技术：网站为辨明用户身份、通过session跟踪而存储在用户本地终端的数据</p>\n<p>RFC 6265</p>\n<p>Cookie组件：</p>\n<ul>\n<li>HTTP响应消息的Cookie头部行</li>\n<li>HTTP请求消息的Cookie头部行</li>\n<li>保存在客户端主机的Cookie文件，由浏览器管理</li>\n<li>web服务器端的后台数据库</li>\n</ul>\n<p>Cookie的作用：</p>\n<ul>\n<li>身份认证、购物车、推荐、email</li>\n</ul>\n<p>隐私问题</p>\n<h5 id=\"web缓存、代理服务器技术\"><a href=\"#web缓存、代理服务器技术\" class=\"headerlink\" title=\"web缓存、代理服务器技术\"></a>web缓存、代理服务器技术</h5><p>功能：在不访问服务器的前提下满足客户端的HTTP请求</p>\n<p>原因： 性能优化</p>\n<ul>\n<li>缩短客户请求响应时间</li>\n<li>减少机构、组织流量</li>\n<li>在大范围内实现有效内容分发</li>\n</ul>\n<p>步骤：</p>\n<ul>\n<li>用户设定浏览器通过缓存进行web访问</li>\n<li>浏览器向缓存、代理服务器发送所有HTTP请求<ul>\n<li>若请求对象在缓存中 ，则缓存返回对象</li>\n<li>若不在缓存，则缓存服务器向原始服务器发送HTTP请求，获取对象并返回给客户端、并保存对象</li>\n</ul>\n</li>\n</ul>\n<p>解决对象更新问题： 条件性GET</p>\n<ul>\n<li>若缓存为最新版本，则不需要发送请求对象</li>\n<li>缓存服务器请求信息中声明持有版本的日期 modified 日期</li>\n<li>目标服务器：<ul>\n<li>若缓存版本是最新的，响应消息中不包含对象，返回 304 Not Modified</li>\n<li>若缓存版本不是最新，则返回对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Email-应用\"><a href=\"#Email-应用\" class=\"headerlink\" title=\"Email 应用\"></a>Email 应用</h4><h5 id=\"email应用概述\"><a href=\"#email应用概述\" class=\"headerlink\" title=\"email应用概述\"></a>email应用概述</h5><p>构成组件：</p>\n<ul>\n<li>客户端</li>\n<li>服务器<ul>\n<li>邮箱：存储发给该用户的email</li>\n<li>消息队列 msessage queue：存储等待发送的email</li>\n</ul>\n</li>\n<li>SMTP协议：email消息传输、交换协议<ul>\n<li>邮件服务器之间传递消息所使用的协议</li>\n<li>客户端：发送消息的服务器</li>\n<li>服务器：接受消息的服务器</li>\n<li>端口25</li>\n<li>使用TCP 进行可靠传输、持久性连接</li>\n<li>三个阶段：<ul>\n<li>握手</li>\n<li>消息传输</li>\n<li>关闭</li>\n</ul>\n</li>\n<li>命令、相应交互模式：<ul>\n<li>命令 command：ASCII文本</li>\n<li>响应 response：状态代码和语句</li>\n</ul>\n</li>\n<li>email消息只能包含7位ASCII码</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Email消息格式与POP3协议\"><a href=\"#Email消息格式与POP3协议\" class=\"headerlink\" title=\"Email消息格式与POP3协议\"></a>Email消息格式与POP3协议</h5><p>RFC 822：文本消息格式标准：</p>\n<ul>\n<li>头部行 header<ul>\n<li>To 、 From、 Subject</li>\n</ul>\n</li>\n<li>消息体 body<ul>\n<li>消息本身，只能是ASCII字符</li>\n</ul>\n</li>\n</ul>\n<p>为了支持多媒体： 使用 MIME 多媒体邮件扩展</p>\n<ul>\n<li>在邮件头部增加额外的行声明MIME的内容类型</li>\n</ul>\n<p>邮件访问协议：收件方从服务器获取邮件</p>\n<ul>\n<li>POP：post office protocol 协议：两个阶段：认证/授权和下载<ul>\n<li>模式：<ul>\n<li>下载并删除模式：用户换了客户端软件，则无法重读邮件</li>\n<li>下载并保持模式：不同客户端都可以保存拷贝</li>\n</ul>\n</li>\n<li>POP3是无状态协议（服务器没有记忆功能）</li>\n</ul>\n</li>\n<li>IMAP: internet mail access protocol协议<ul>\n<li>更多功能、更复杂，新于POP3</li>\n<li>可操纵服务器上存储的消息</li>\n<li>所有消息统一保存在服务器</li>\n<li>允许用户利用文件夹组织消息</li>\n<li>支持跨会话Session 的用户状态</li>\n<li>有状态协议</li>\n</ul>\n</li>\n<li>HTTP协议： 163、 qq 、 mail</li>\n</ul>\n<h4 id=\"DNS应用\"><a href=\"#DNS应用\" class=\"headerlink\" title=\"DNS应用\"></a>DNS应用</h4><h5 id=\"DNS概述\"><a href=\"#DNS概述\" class=\"headerlink\" title=\"DNS概述\"></a>DNS概述</h5><p>DNS：domain name system 域名系统：解决Internet上主机、路由器识别问题</p>\n<p>DNS域名解析系统：域名和IP地址的映射</p>\n<ul>\n<li>多层命名服务器构成的分布式数据库</li>\n<li>应用层协议：完成名字的解析<ul>\n<li>Internet核心功能，用应用层协议实现</li>\n<li>网络边界复杂</li>\n</ul>\n</li>\n</ul>\n<p>服务：</p>\n<ul>\n<li>域名向IP地址翻译</li>\n<li>主机别名</li>\n<li>邮件服务器别名</li>\n<li>负载均衡：web服务器</li>\n</ul>\n<p>集中式DNS的问题： 不可伸缩</p>\n<ul>\n<li>单点失败问题：服务器坏掉</li>\n<li>流量问题</li>\n<li>距离问题</li>\n<li>维护性问题</li>\n</ul>\n<p>分布式层次式数据库：</p>\n<ol>\n<li>根服务器 root</li>\n<li>顶级域名服务器  com、org、edu等</li>\n</ol>\n<p>根域名服务器： 本地域名解析服务器无法解析域名时，访问根域名服务器</p>\n<ul>\n<li>不知道映射时，访问权威域名服务器</li>\n</ul>\n<p>顶级域名服务器 TLD top-level domain：负责com、edu等</p>\n<p>权威域名服务器：组织的域名解析服务器，负责解析组织内部服务器的解析服务</p>\n<ul>\n<li>组织负责维护</li>\n<li>服务提供商负责维护</li>\n</ul>\n<p>本地域名解析服务器：</p>\n<ul>\n<li>不严格属于层次体系</li>\n<li>每个ISP都有一个本地域名服务器：默认的服务器</li>\n<li>本地服务器作为代理，把查询转发给域名解析服务器系统</li>\n<li>查询方式：<ul>\n<li>迭代查询：获得下一个服务器地址，本地服务器挨个询问</li>\n<li>递归查询：本地服务器把询问任务交给根服务器</li>\n</ul>\n</li>\n</ul>\n<p>DNS记录缓存与更新：</p>\n<ul>\n<li>本地域名服务器一般会缓存顶级域名服务器的映射<ul>\n<li>因此根域名服务器不经常被访问</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"DNS记录与消息格式\"><a href=\"#DNS记录与消息格式\" class=\"headerlink\" title=\"DNS记录与消息格式\"></a>DNS记录与消息格式</h5><p>资源记录 RR resource records</p>\n<p>格式： name value type ttl</p>\n<p>类型：</p>\n<ul>\n<li>Type = A<ul>\n<li>Name：主机域名</li>\n<li>value：IP地址</li>\n</ul>\n</li>\n<li>Type = NS<ul>\n<li>Name：域</li>\n<li>value：该域的权威域名解析服务器的主机域名</li>\n</ul>\n</li>\n<li>Type = CNAME<ul>\n<li>Name：某一域名的别名</li>\n<li>Value：真实域名</li>\n</ul>\n</li>\n<li>Type = MX<ul>\n<li>Value ：与name对应的邮件服务器</li>\n</ul>\n</li>\n</ul>\n<p>DNS协议：</p>\n<ul>\n<li>查询query 和回复 reply</li>\n<li>消息格式相同<ul>\n<li>头部：<ul>\n<li>identification：16位查询编号，回复使用相同编号</li>\n<li>flags</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网络应用（下）\"><a href=\"#网络应用（下）\" class=\"headerlink\" title=\"网络应用（下）\"></a>网络应用（下）</h3><h4 id=\"P2P应用\"><a href=\"#P2P应用\" class=\"headerlink\" title=\"P2P应用\"></a>P2P应用</h4><h5 id=\"P2P应用：原理与文件分发\"><a href=\"#P2P应用：原理与文件分发\" class=\"headerlink\" title=\"P2P应用：原理与文件分发\"></a>P2P应用：原理与文件分发</h5><p>典型协议：BT BitTorrent：</p>\n<ul>\n<li>torrent：交换同一个文件的文件块的节点组</li>\n<li>tracker：跟踪参与torrent的节点</li>\n</ul>\n<p>获取chunk：</p>\n<ul>\n<li>给定任意时刻，不同节点持有文件的不同chunk集合</li>\n<li>节点定期查询每个邻居持有的chunk列表</li>\n<li>节点发送请求，请求获取缺失的chunk：<ul>\n<li>稀缺优先原则</li>\n</ul>\n</li>\n</ul>\n<p>发送chunk： tit-for-tat：</p>\n<ul>\n<li>向4个邻居发送chunk：正在向其发送chunk且速率最快的四个<ul>\n<li>每10s重新评估top4</li>\n</ul>\n</li>\n<li>每30s随机选择一个其他节点，向其发送chunk</li>\n</ul>\n<h5 id=\"P2P应用；索引技术\"><a href=\"#P2P应用；索引技术\" class=\"headerlink\" title=\"P2P应用；索引技术\"></a>P2P应用；索引技术</h5><p>索引：信息到节点位置（IP地址+端口号）的映射</p>\n<p>文件共享：</p>\n<ul>\n<li>利用索引动态跟踪节点所共享的文件的位置</li>\n<li>节点告诉索引它拥有哪些文件</li>\n<li>节点搜索索引，获知能够得知哪些文件</li>\n</ul>\n<p>即时消息：</p>\n<ul>\n<li>索引把用户名映射到位置</li>\n<li>用户开启IM应用时，需要通知索引它的位置</li>\n<li>节点检索索引，确定用户的IP地址</li>\n</ul>\n<h6 id=\"集中式索引\"><a href=\"#集中式索引\" class=\"headerlink\" title=\"集中式索引\"></a>集中式索引</h6><p>Napster最早采用</p>\n<ol>\n<li>节点加入时，通知中央服务器<ul>\n<li>IP地址</li>\n<li>内容</li>\n</ul>\n</li>\n<li>节点向中央服务器查找文件</li>\n<li>节点向用户请求文件</li>\n</ol>\n<p>缺点： 内容定位高度集中</p>\n<ul>\n<li>单点失效问题</li>\n<li>性能瓶颈</li>\n<li>版权问题</li>\n</ul>\n<h6 id=\"洪泛式查询-query-flooding\"><a href=\"#洪泛式查询-query-flooding\" class=\"headerlink\" title=\"洪泛式查询 query flooding\"></a>洪泛式查询 query flooding</h6><p>完全分布式架构</p>\n<p>每个节点只对自己共享的文件进行索引</p>\n<p>覆盖网络 overlay network：</p>\n<ul>\n<li>节点之间若有TCP连接，则构成一条边</li>\n<li>所有活动节点和边构成网络</li>\n<li>边：虚拟链路</li>\n<li>节点邻居数一般少于10</li>\n</ul>\n<p>查询：</p>\n<ul>\n<li>查询消息通过已有的TCP连接发送</li>\n<li>节点转发查询消息</li>\n<li>查询命中，则利用反向路径发回查询节点</li>\n</ul>\n<p>缺点：消息泛滥、造成网络阻塞</p>\n<h6 id=\"层次式覆盖网络\"><a href=\"#层次式覆盖网络\" class=\"headerlink\" title=\"层次式覆盖网络\"></a>层次式覆盖网络</h6><p>介于集中式索引和洪泛查询之间</p>\n<p>每个节点 要么是超级节点，要么被分配一个超级节点</p>\n<ul>\n<li>节点和超级节点之间维持TCP连接（集中式索引）</li>\n<li>超级节点之间维持TCP连接（洪泛式查询）</li>\n</ul>\n<p>超级节点负责跟踪子节点内容</p>\n<h4 id=\"Socket编程\"><a href=\"#Socket编程\" class=\"headerlink\" title=\"Socket编程\"></a>Socket编程</h4><h6 id=\"应用编程接口API\"><a href=\"#应用编程接口API\" class=\"headerlink\" title=\"应用编程接口API\"></a>应用编程接口API</h6><p>将应用进程的控制权和操作系统的控制权进行转换的系统接口</p>\n<p>典型接口：</p>\n<ul>\n<li>套接字 socket</li>\n<li>winsock：Windows Socket interface，微软的套接字接口</li>\n<li>TLI，transport layer interface 传输层接口</li>\n</ul>\n<h5 id=\"Socket-API概述\"><a href=\"#Socket-API概述\" class=\"headerlink\" title=\"Socket API概述\"></a>Socket API概述</h5><p>最初面向 BSD UNIX-Berkley</p>\n<p>Internet网络应用最典型的API接口</p>\n<p>通信模型： 客户、服务器模型</p>\n<p>应用进程间通信的抽象机制</p>\n<p>标识通信端点（对外）：IP地址+端口号</p>\n<p>对内管理套接字：套接字描述符 Socket descriptor</p>\n<p>Socket抽象：</p>\n<ul>\n<li>类似文件的抽象</li>\n<li>应用程序创建套接字时，操作系统分配一个数据结构存储该套接字相关信息</li>\n<li>返回套接字描述符</li>\n</ul>\n<h5 id=\"Socket-API函数-Winsock：\"><a href=\"#Socket-API函数-Winsock：\" class=\"headerlink\" title=\"Socket API函数 Winsock：\"></a>Socket API函数 Winsock：</h5><p>WSAStartup：初始化api  -&gt;  应用程序  -&gt; WSACleanup</p>\n<p>socket(protofamily , type, proto )：</p>\n<ul>\n<li>创建套接字，返回套接字描述符</li>\n<li>protofamily 协议族  （TCP/IP = PF_INET）</li>\n<li>type：套接字类型</li>\n<li>proto：协议号，0为默认</li>\n</ul>\n<p>面向TCP/IP 服务类型：</p>\n<ul>\n<li>SOCK_DGRAM：传输层UDP协议：不可靠、无连接、数据报传输</li>\n<li>SOCK_STREAM：传输层TCP协议：可靠、面向连接、字节流传输、点对点</li>\n<li>SOCK_RAW：网络层，IP/ICMP/IGMP</li>\n</ul>\n<p>int Closesocket( SOCKET sd);</p>\n<ul>\n<li>关闭一个描述符为sd的套接字</li>\n<li>多个进程共享一个套接字时，调用该函数将套接字引用计数减一，减到0才关闭</li>\n<li>一个进程多线程对一个套接字使用无计数</li>\n<li>返回值：0成功</li>\n</ul>\n<p>int bind(sd, localaddr, addrlen);</p>\n<ul>\n<li>绑定套接字的本地端点地址（IP+端口号）</li>\n<li>参数：<ul>\n<li>套接字描述符 sd</li>\n<li>端点地址 localaddr： 结构 sockaddr_in</li>\n</ul>\n</li>\n<li>客户端程序一般不必调用bind函数</li>\n<li>服务器绑定多IP地址：地址通配符：INADDR_ANY</li>\n</ul>\n<p>int listen(sd, queuesize);</p>\n<ul>\n<li>置服务器端的流套接字处于监听状态<ul>\n<li>仅服务器端调用</li>\n<li>仅用于面向连接的流套接字</li>\n</ul>\n</li>\n<li>设置连接请求队列大小 queuesize</li>\n<li>返回值：成功 0</li>\n</ul>\n<p>connect( sd, addr , saddrlen);</p>\n<ul>\n<li>仅用于客户端，使客户套接字与特定计算机的特定端口saddr的套接字进行连接</li>\n<li>可用于TCP、 UDP<ul>\n<li>TCP：建立连接</li>\n<li>UDP：指定服务器端点地址</li>\n</ul>\n</li>\n</ul>\n<p>newsock = accept( sd, caddr, caddrlen);</p>\n<ul>\n<li>只用于服务器端，只用于TCP套接字</li>\n<li>从客户连接请求队列中取出最前的客户请求，并创建一个新的套接字和客户套接字创建连接通道</li>\n<li>利用新创建的套接字和客户通信（TCP是点对点的）</li>\n</ul>\n<p>send( sd , *buf, len , flags);</p>\n<p>sendto( sd, * buf , len, flags, destaddr, addrlen);</p>\n<ul>\n<li>send函数TCP套接字（客户端或服务器）或调用了connect函数的UDP客户端套接字</li>\n<li>sendto用于UDP服务器端套接字和未调用connect函数的UDP客户端套接字</li>\n</ul>\n<p>recv，recvfrom 类似send，sendto</p>\n<p>setsockopt、 getsockopt 设置或获取套接字设置</p>\n<p>网络字节顺序 network byte order：</p>\n<p>​    TCP/IP定义了标准的用于协议头中的二进制整数表示</p>\n<p>​    某些socket API函数参数需要存储为网络字节顺序（如IP地址、端口号等）</p>\n<h5 id=\"客户端软件设计\"><a href=\"#客户端软件设计\" class=\"headerlink\" title=\"客户端软件设计\"></a>客户端软件设计</h5><p>解析服务器IP地址： 域名或IP地址转换为32位二进制IP地址：</p>\n<ul>\n<li>inet_addr() 点分十进制IP到32位IP地址</li>\n<li>gethostbyname() 域名到32位IP地址： 返回指向结构hostent的指针</li>\n<li>都返回网络字节顺序</li>\n</ul>\n<p>解析端口号： 可能使用服务名（如HTTP）或端口号</p>\n<ul>\n<li>getservbyname() 服务名转为熟知端口号</li>\n</ul>\n<p>解析协议号：可能使用协议名（如TCP）指定协议</p>\n<ul>\n<li>getprotobyname() 协议名到协议号的转换</li>\n</ul>\n<p>TCP客户端软件流程：</p>\n<ol>\n<li>确定服务器IP地址+端口号</li>\n<li>创建客户端套接字</li>\n<li>分配本地端点地址（IP+端口号） （系统自动完成）</li>\n<li>连接服务器套接字</li>\n<li>遵循应用层协议进行通信</li>\n<li>关闭或释放连接</li>\n</ol>\n<p>UDP客户端软件流程：</p>\n<ol>\n<li>确定服务器IP地址+端口号</li>\n<li>创建客户端套接字</li>\n<li>分配本地端点地址（IP+端口号） （系统自动完成）</li>\n<li>指定服务器端点地址，构造UDP数据报</li>\n<li>遵循应用层协议进行通信</li>\n<li>关闭或释放套接字</li>\n</ol>\n<h5 id=\"服务器软件设计\"><a href=\"#服务器软件设计\" class=\"headerlink\" title=\"服务器软件设计\"></a>服务器软件设计</h5><p>基本服务器类型：</p>\n<ol>\n<li>循环无连接 IteratIve connectionless<ul>\n<li>一次只接受一个客户端请求</li>\n<li>无连接：基于UDP</li>\n<li>流程：<ol>\n<li>创建套接字</li>\n<li>绑定端点地址（INADDR_ANY+端口号）</li>\n<li>反复接收来自客户端的请求</li>\n<li>遵循应用层协议，构造响应报文，发送给客户</li>\n</ol>\n</li>\n<li>服务器端不能使用connect函数</li>\n<li>无连接服务器使用 sendto发送数据报</li>\n<li>客户端端点地址在调用recvfrom接收数据时自动提取</li>\n</ul>\n</li>\n<li>循环面向连接 Iterative connection-oriented<ul>\n<li>流程：<ol>\n<li>创建主套接字，绑定熟知端口号</li>\n<li>主套接字设置为被动监听模式</li>\n<li>调用accept接收连接请求，创建新套接字和客户建立连接</li>\n<li>通过新套接字接收请求、构造并发送响应</li>\n<li>完成服务后，关闭连接，返回3</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>并发无连接 Concurrent connectionless<ul>\n<li>流程：<ol>\n<li>主线程1 创建套接字，绑定熟知端口号</li>\n<li>主线程2 反复调用recvfrom函数，接收请求，创建新线程处理响应</li>\n<li>子线程1 接收请求</li>\n<li>子线程2 构造响应报文，调用sendto发送</li>\n<li>子线程3 退出</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>并发面向连接 Concurrent connection-oriented<ul>\n<li>流程：<ol>\n<li>主线程1 创建套接字，绑定熟知端口号</li>\n<li>主线程2 设置主套接字为被动监听模式</li>\n<li>主线程3 反复调用accept接收连接请求，创建新的子线程处理客户响应</li>\n<li>子线程1 接收请求（通过新套接字）</li>\n<li>子线程2 根据协议进行交互</li>\n<li>子线程3 关闭、释放连接并退出（线程终止）</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"传输层（上）\"><a href=\"#传输层（上）\" class=\"headerlink\" title=\"传输层（上）\"></a>传输层（上）</h3><h4 id=\"传输层服务概述\"><a href=\"#传输层服务概述\" class=\"headerlink\" title=\"传输层服务概述\"></a>传输层服务概述</h4><p>传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制</p>\n<p>端系统运行传输层协议：</p>\n<ul>\n<li>发送方：把消息分成多个Segment并传给网络层</li>\n<li>接收方：把segment组装成消息，交给应用层</li>\n</ul>\n<p>协议类型：</p>\n<ul>\n<li>TCP、UDP</li>\n</ul>\n<p>与网络层的区别：</p>\n<ul>\n<li>网络层提供主机之间的逻辑通信机制</li>\n<li>位于网络层之上、依赖网络层</li>\n<li>对网络层服务进行（可能的）增强</li>\n</ul>\n<h4 id=\"复用和分用\"><a href=\"#复用和分用\" class=\"headerlink\" title=\"复用和分用\"></a>复用和分用</h4><p>原因：</p>\n<ul>\n<li>接收端（多路分用）：传输层将segment交给正确的socket 即正确的进程</li>\n<li>发送端（多路复用）：从多个socket接收消息，每块数据封装头部消息，生成Segment，交给网络层</li>\n</ul>\n<p>分用工作：</p>\n<ul>\n<li>主机接收到IP数据报 datagram</li>\n<li>每个数据报携带源IP、目的IP，一个传输层的段</li>\n<li>每个段携带源端口号、目的端口号</li>\n<li>传输层协议根据IP地址和端口号，把Segment导向Socket<ul>\n<li>TCP做更多处理</li>\n</ul>\n</li>\n<li>无连接分用：UDP：用二元组标识（目的IP，目的端口号）</li>\n<li>面向连接的分用：TCP：用四元组（源IP，源端口号，目的IP，目的端口号）</li>\n</ul>\n<h4 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h4><p>UDP：user datagram protocol 【RFC 768】</p>\n<p>特点：</p>\n<ul>\n<li>基于 IP协议：<ul>\n<li>多路复用、分用</li>\n<li>简单的错误校验：端到端原则，不能确保所有链路层协议都有错误检测，也不能确保转发时错误不发生</li>\n</ul>\n</li>\n<li>Best effort（尽力而为）服务，UDP可能：<ul>\n<li>丢失</li>\n<li>非按序到达</li>\n</ul>\n</li>\n<li>无连接：<ul>\n<li>发送方接收方不需要握手、不需要建立连接</li>\n<li>每个UDP段处理独立</li>\n</ul>\n</li>\n</ul>\n<p>价值：</p>\n<ul>\n<li>无需建立连接：延迟显著减少（2个RTT）（DNS用UDP）</li>\n<li>实现简单，无需维护连接状态</li>\n<li>头部开销少（8字节 VS  20字节）</li>\n<li>没有拥塞控制，上层控制发送时间和速率</li>\n</ul>\n<p>用途：</p>\n<ul>\n<li>常用于流媒体：容忍丢失、速率敏感</li>\n<li>DNS、SNMP</li>\n<li>在其之上实现可靠数据传输：（应用层开发）<ul>\n<li>在应用层增加可靠性机制</li>\n<li>应用特定的错误恢复机制</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/UDP.png\" alt=\"UDP\"></p>\n<p>UDP校验和 checksum： </p>\n<ul>\n<li>目的：检测UDP段传输过程中是否发生错误</li>\n<li>发送方：<ul>\n<li>段内容视为16-bit证书</li>\n<li>校验和计算：求和，进位加到和后面，按位取反</li>\n<li>校验和填入校验和字段</li>\n</ul>\n</li>\n<li>发送方：<ul>\n<li>计算校验和</li>\n<li>进行比对：<ul>\n<li>不相等：检错</li>\n<li>相等：未检测到错误（可能有错）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"可靠数据传输原理\"><a href=\"#可靠数据传输原理\" class=\"headerlink\" title=\"可靠数据传输原理\"></a>可靠数据传输原理</h4><p>可靠的定义：不错、不丢、不乱</p>\n<p>可靠数据传输协议：</p>\n<ul>\n<li>对应用层、传输层、链路层都重要</li>\n<li>信道的不可靠特性决定了可靠数据传输协议rdt的复杂性</li>\n</ul>\n<p>Rdt 1.0：可靠信道上的可靠数据传输</p>\n<ul>\n<li>底层信道完全可靠</li>\n<li>发送方和接收方 FSM独立</li>\n</ul>\n<p>Rdt 2.0： 产生位错误：</p>\n<ul>\n<li><p>底层信道可能翻转分组中的位</p>\n<ul>\n<li>用校验和检测位错误</li>\n</ul>\n</li>\n<li><p>如何从错误中恢复：</p>\n<ul>\n<li>确认机制 ACK acknowledgements：接收方显式告知发送方分组已经正确接收</li>\n<li>NAK：接收方显式告诉发送方分组有错误</li>\n<li>发送方收到NAK后，重传分组</li>\n</ul>\n</li>\n<li><p>基于重传机制的rdt协议成为ARQ automatic repeat request 协议</p>\n</li>\n<li><p>新机制：</p>\n<ul>\n<li>差错检测</li>\n<li>接收方反馈控制消息： ACK、 NAK</li>\n<li>重传</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt2.0.png\" alt=\"rdt2.0\"></p>\n</li>\n<li><p>缺陷： ACK、NAK消息发生错误或被破坏 corrupted：</p>\n</li>\n<li><p>解决方案： rdt 2.1</p>\n<ol>\n<li>ACK、NAK增加校验和，检错并纠错（代价高）</li>\n<li>添加额外控制消息</li>\n<li>发送方重传：可能产生重复分组<ul>\n<li>解决重复分组： 序列号 sequence number：发送方给每个分组增加序列号</li>\n<li>接收方丢弃重复分组</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt2.1.png\" alt=\"rdt2.1\"></p>\n</li>\n<li><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt2.1rev.png\" alt=\"rdt2.1rev\"></p>\n<p>发送方变化：</p>\n<ul>\n<li>每个分组增加了序列号(0,1序号)</li>\n<li>需要校验ACK、NAK消息是否错误</li>\n<li>状态数量翻倍</li>\n</ul>\n<p>接收方变化：</p>\n<ul>\n<li>需要判断分组是否重复</li>\n</ul>\n</li>\n<li><p>Rdt 2.2 ：只使用ACK：检验和+序列号+ACK+重传</p>\n<ul>\n<li>接收方通过ACK告知最后一个被正确接收的分组</li>\n<li>ACK中显式加入被确认分组的序列号</li>\n<li>发送方收到重复ACK后，重传当前分组</li>\n</ul>\n</li>\n</ul>\n<p>Rdt 3.0：既可能错误，也可能丢失：</p>\n<ul>\n<li>方法：发送方等待 合理 时间：<ul>\n<li>没收到ACK，重传</li>\n<li>分组或ACK只是延迟而不是丢了</li>\n<li>增加定时器</li>\n</ul>\n</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rdt3.0send.png\" alt=\"rdt3.0send\"></li>\n<li>问题：性能很差：停等操作</li>\n</ul>\n<h4 id=\"流水线与滑动窗口协议\"><a href=\"#流水线与滑动窗口协议\" class=\"headerlink\" title=\"流水线与滑动窗口协议\"></a>流水线与滑动窗口协议</h4><p>流水线机制：</p>\n<ul>\n<li>允许发送方收到ACK之前连续发送多个分组：<ul>\n<li>更大的序列号范围</li>\n<li>发送方、接收方需要更大存储空间缓存分组</li>\n</ul>\n</li>\n</ul>\n<p>滑动窗口协议 sliding-window protocol：</p>\n<ul>\n<li>窗口：<ul>\n<li>允许使用的序列号范围</li>\n<li>窗口尺寸为N：最多由N个等待确认的消息</li>\n</ul>\n</li>\n<li>滑动窗口：<ul>\n<li>随着协议的运行，窗口在序列号空间内向前滑动</li>\n</ul>\n</li>\n<li>滑动窗口协议：GBN，SR</li>\n</ul>\n<p>GBN go-back-N 协议：</p>\n<ul>\n<li>发送方：<ul>\n<li>分组头有k-bit序列号</li>\n<li>窗口尺寸为N，最多允许N个分组未确认</li>\n<li>累计确认机制：ACK(n)：确认到序列号n（包含n）的分组都被正常接收<ul>\n<li>可能收到重复ACK</li>\n</ul>\n</li>\n<li>空中分组设置计时器 timer</li>\n<li>timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组</li>\n</ul>\n</li>\n<li>接收方：<ul>\n<li>ACK机制：发送拥有最高序列号的，已经被正确接收的分组的ACK<ul>\n<li>可能产生重复ACK</li>\n<li>只需记住唯一的expectedseqnum</li>\n</ul>\n</li>\n<li>乱序到达的分组：<ul>\n<li>直接丢弃</li>\n<li>重新确认序列号最大的、按序到达的分组</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>缺陷：<ul>\n<li>重传大量不必要分组</li>\n</ul>\n</li>\n</ul>\n<p>SR selective repeat协议：</p>\n<ul>\n<li>接收方对每个分组单独进行确认<ul>\n<li>设置缓存机制，缓存乱序到达的分组</li>\n</ul>\n</li>\n<li>发送方只重发没收到ACK的分组<ul>\n<li>为每个分组设置定时器</li>\n</ul>\n</li>\n<li>发送方窗口不变化</li>\n<li>新增接收方窗口</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sr.png\" alt=\"sr\"></li>\n<li>SR协议问题： 困境<ul>\n<li>出现原因：序列号少且窗口尺寸大</li>\n<li>解决： $N_S + N_R &lt;= 2^k $</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"传输层（下）\"><a href=\"#传输层（下）\" class=\"headerlink\" title=\"传输层（下）\"></a>传输层（下）</h3><h4 id=\"面向连接传输协议-TCP\"><a href=\"#面向连接传输协议-TCP\" class=\"headerlink\" title=\"面向连接传输协议 TCP\"></a>面向连接传输协议 TCP</h4><p>概述：</p>\n<ul>\n<li>点对点</li>\n<li>可靠的、按序的字节流</li>\n<li>流水线机制： TCP拥塞控制和流量控制机制动态设置窗口尺寸</li>\n<li>发送方、接收方缓存</li>\n<li>全双工：同一连接双向传输数据</li>\n<li>面向连接：<ul>\n<li>通信双方在发送数据前必须建立连接</li>\n<li>连接状态只在两端维护</li>\n<li>TCP连接包括： 两台主机上的缓存、连接状态变量、Socket等</li>\n</ul>\n</li>\n<li>流量控制机制</li>\n</ul>\n<p>序列号：</p>\n<ul>\n<li>序列号指的是Segment第一个字节的编号，而不是Segment的编号</li>\n<li>建立连接时，双方随机选择序列号</li>\n</ul>\n<p>ACK：</p>\n<ul>\n<li>希望接收的下一个字节的序列号</li>\n<li>累计确认：该序列号之前的所有字节都已被正确接收</li>\n</ul>\n<p>乱序到达的Segment：没有规定，由TCP实现者做决策</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/TCP.png\" alt=\"TCP\"></p>\n<h5 id=\"TCP可靠数据传输\"><a href=\"#TCP可靠数据传输\" class=\"headerlink\" title=\"TCP可靠数据传输\"></a>TCP可靠数据传输</h5><p>概述：</p>\n<ul>\n<li>流水线机制</li>\n<li>累计确认</li>\n<li>单一重传计时器</li>\n<li>触发重传事件：<ul>\n<li>超时</li>\n<li>受到重复ACK</li>\n</ul>\n</li>\n</ul>\n<p>RTT与超时时间设置：</p>\n<ul>\n<li>需要大于RTT：但RTT是变化的</li>\n<li>超时时间 = 平均RTT + 4*安全时间</li>\n<li>安全时间 =  0.25*|平均RTT-RTT|+0.75旧安全时间</li>\n</ul>\n<p>发送方事件：</p>\n<ul>\n<li>从应用层收到数据：<ul>\n<li>创建Segment</li>\n<li>开启计时器</li>\n<li>设置超时时间</li>\n</ul>\n</li>\n<li>超时：<ul>\n<li>重传超时的Segment</li>\n<li>重启计时器</li>\n</ul>\n</li>\n<li>收到ACK<ul>\n<li>未确认的Segment：<ul>\n<li>更新sendbase</li>\n<li>窗口若还有未确认的分组，重启计时器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>快速重传机制：</p>\n<ul>\n<li>如果超时，超时时间间隔重新设置，导致其很大</li>\n<li>通过重复ACK检测分组丢失：<ul>\n<li>发送方收到同一分组的3次ACK，则立刻重传</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"TCP-流量控制\"><a href=\"#TCP-流量控制\" class=\"headerlink\" title=\"TCP 流量控制\"></a>TCP 流量控制</h5><p>原因：接收方为TCP设置了buffer，上层应用可能处理buffer的速度太慢</p>\n<p>实现：接受者在Segment的头部信息的revwindow告诉发送方还剩余多少可用空间，发送方限制数据不超过revwindow的大小</p>\n<h5 id=\"TCP连接管理\"><a href=\"#TCP连接管理\" class=\"headerlink\" title=\"TCP连接管理\"></a>TCP连接管理</h5><ul>\n<li>初始化TCP变量：<ul>\n<li>选择序列号</li>\n<li>设置缓存和流量控制信息</li>\n</ul>\n</li>\n<li>client：连接发起者</li>\n<li>server：等待连接请求</li>\n<li>三次握手建立连接：<ol>\n<li>客户端向server发送 SYN段<ul>\n<li>不携带任何数据</li>\n<li>SYN标志位为1</li>\n<li>传递初始序列号</li>\n<li>SYN=1，seq=client_isn</li>\n</ul>\n</li>\n<li>服务器接到SYN，同意后发送 SYNACK段<ul>\n<li>服务器分配缓存</li>\n<li>选择自己的初始序列号</li>\n<li>SYN=1, seq=server_isn，ack=client_isn+1</li>\n</ul>\n</li>\n<li>客户端受到SYNACK，回复ACK报文段，SYN不再置1，可能有数据<ul>\n<li>SYN=0, seq=client_isn+1 , ack=server_isn+1</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>连接关闭：<ol>\n<li>客户端向服务器发送 FIN 控制段</li>\n<li>服务器收到FIN，回复ACK，关闭连接，发送FIN</li>\n<li>客户端收到FIN，回复ACK：进入等待状态，若收到FIN，重发ACK</li>\n<li>服务器收到ACK，真正关闭连接</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"拥塞控制问题\"><a href=\"#拥塞控制问题\" class=\"headerlink\" title=\"拥塞控制问题\"></a>拥塞控制问题</h4><p>拥塞 congestion： 太多主机发送太多数据或速度太快以致网络无法处理</p>\n<p>表现：</p>\n<ul>\n<li>分组丢失（路由器缓存溢出）</li>\n<li>分组延迟过大（在路由器缓存中排队）</li>\n</ul>\n<p>拥塞控制 （网络阻塞） vs 流量控制（接收方处理不过来）</p>\n<p>为什么拥塞控制要在传输层进行</p>\n<p>拥塞控制方法：</p>\n<ul>\n<li>端到端的拥塞控制：<ul>\n<li>网络层不需要显式提供支持</li>\n<li>端系统通过观察loss、delay等网络行为判断是否发生拥塞</li>\n<li>TCP采用这种方法</li>\n</ul>\n</li>\n<li>网络辅助的拥塞控制：<ul>\n<li>路由器向发送方显式反馈网络拥塞信息</li>\n<li>简单的拥塞指示(1-bit)：SNA、DECbit，TCP/IP ECN, ATM</li>\n<li>指示发送方应该采用何种速率</li>\n</ul>\n</li>\n</ul>\n<p>ATM ABR拥塞控制  available bit rate：</p>\n<ul>\n<li>弹性服务</li>\n<li>发送方路径可用：使用可用贷款</li>\n<li>发送方路径堵塞：发送速率降到最低保障速率</li>\n<li>RM resource management cell：<ul>\n<li>发送几个数据段就发送一个RM cell</li>\n<li>发送方发送</li>\n<li>交换机设置 RM cell位（网络辅助）<ul>\n<li>NI bit：rate不许增长</li>\n<li>CI bit：拥塞指示</li>\n</ul>\n</li>\n<li>RM cell由接收方返回给发送方</li>\n<li>RM cell有显式的速率ER 字段：两个字节：<ul>\n<li>拥塞的交换机可以把ER设置为更低的值</li>\n<li>发送方获知路径所能支持的最小速率</li>\n</ul>\n</li>\n<li>数据cell的EFCI位：拥塞的交换机将其设置为1：<ul>\n<li>若RM cell前data cell的EFCI位设置为1，那么发送方在返回的RM cell中置CI位</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>TCP拥塞控制：</p>\n<ul>\n<li><p>如何控制发送速率：</p>\n<ul>\n<li>拥塞窗口 CongWin：<ul>\n<li>LastByteSent-LastByteAcked &lt;= CongWin</li>\n<li>速率 ≈ CongWin / RTT byte/sec</li>\n<li>动态调整以改变发送速率</li>\n<li>反映所感知的网络拥塞</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何感知拥塞状况：</p>\n<ul>\n<li>Loss事件 = timeout 或 3个重复ACK</li>\n<li>发生loss事件后，发送方降低速率</li>\n</ul>\n</li>\n<li><p>如何合理调整发送速率：</p>\n<ul>\n<li>加性增- 乘性减： AIMD<ul>\n<li>原理：谨慎探测可用带宽，逐渐增加速率，直到loss，一旦loss，快速降低速率</li>\n<li>additive increase：每个RTT将CongWin增大一个MSS（拥塞避免）</li>\n<li>multiplicative decrease：发生loss后CongWin减半</li>\n</ul>\n</li>\n<li>慢启动： SS<ul>\n<li>TCP建立时，CongWin=1，可用带宽可能远高于初始速率，希望快速增长</li>\n<li>原理：连接开始时，速率指数增长（收到每个ack时 CongWin+1）</li>\n</ul>\n</li>\n<li>何时从指数增长切换到线性增长：<ul>\n<li>当CongWin达到loss事件前值的一半时</li>\n<li>Threshold记录loss事件前CongWin值的1/2</li>\n</ul>\n</li>\n<li>Loss事件的处理：<ul>\n<li>3个重复ACK：<ul>\n<li>CongWin切到一半</li>\n<li>而后线性增长</li>\n<li>原因：能收到3个ACK说明网络还能传输</li>\n</ul>\n</li>\n<li>timeout：<ul>\n<li>CongWin直接减为1个MSS</li>\n<li>而后指数增长</li>\n<li>达到threshold后再线性增长</li>\n<li>原因：timeout说明网络拥塞更严重</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>TCP的公平性：</p>\n<ul>\n<li>公平性与UDP：<ul>\n<li>多媒体应用通常不适用TCP，以免被拥塞控制机制限制速率</li>\n<li>使用UDP：以恒定速率发送，能容忍丢失</li>\n<li>产生不公平</li>\n</ul>\n</li>\n<li>都使用TCP：<ul>\n<li>可能打开多个并发连接</li>\n<li>如WEB浏览器</li>\n<li>产生公平性问题</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网络层服务（上）\"><a href=\"#网络层服务（上）\" class=\"headerlink\" title=\"网络层服务（上）\"></a>网络层服务（上）</h3><h4 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4><p>源主机向目的主机发送数据报</p>\n<p>每个主机和路由器都运行网络层协议</p>\n<p>路由器检验所有穿越它的IP数据报的头部域：决策如何处理IP数据报</p>\n<p>网络层核心功能：</p>\n<ul>\n<li>转发 forwarding：<ul>\n<li>功能：分组从路由器输入端口转移到合适的输出端口</li>\n<li>路由器维护转发表：确定在该路由器中根据地址信息转发到哪条链路</li>\n</ul>\n</li>\n<li>路由 routing：<ul>\n<li>确定分组从源到目的经过的路径</li>\n<li>根据 路由算法 routing algorithms</li>\n</ul>\n</li>\n<li>连接建立：不是所有网络都需要<ul>\n<li>数据分组传输之前两端主机需要首先建立虚拟连接<ul>\n<li>网络设备（路由器）参与连接的建立</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>网络层服务模型：</p>\n<ul>\n<li>无连接服务 connection-less service：<ul>\n<li>特点：<ul>\n<li>不事先为系列分组的传输确定传输路径</li>\n<li>每个分组独立确定传输路径</li>\n<li>不同分组可能路径不同</li>\n</ul>\n</li>\n<li>典型例子：数据报网络 datagram network</li>\n</ul>\n</li>\n<li>连接服务：<ul>\n<li>特点：<ul>\n<li>首先为系列分组传输确定路径</li>\n<li>沿路径传输系列分组</li>\n<li>系列分组传输路径相同</li>\n<li>传输结束后拆除连接</li>\n</ul>\n</li>\n<li>典型例子：虚电路网络 virtual-circuit network</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"虚电路网络和数据报网络\"><a href=\"#虚电路网络和数据报网络\" class=\"headerlink\" title=\"虚电路网络和数据报网络\"></a>虚电路网络和数据报网络</h4><h5 id=\"虚电路网络\"><a href=\"#虚电路网络\" class=\"headerlink\" title=\"虚电路网络\"></a>虚电路网络</h5><p>提供网络层连接服务</p>\n<p>一条从源主机到目的主机，类似电路的路径：</p>\n<ul>\n<li>分组交换</li>\n<li>每个分组的传输利用链路的全部带宽</li>\n<li>源到目的主机经过网络层设备共同完成虚电路建设</li>\n</ul>\n<p>通信过程： 呼叫建立 call setup -&gt; 数据传输 -&gt; 拆除呼叫</p>\n<p>每个分组携带虚电路标识 VCID，而不是目标主机地址</p>\n<p>每个网络设备都需要维护经过它的虚电路连接状态</p>\n<p>可以面向虚电路VC 进行预分配资源：</p>\n<ul>\n<li>如ATM的电路仿真 CBR</li>\n</ul>\n<p>具体实现：</p>\n<ul>\n<li>每条虚电路包括：<ol>\n<li>从源主机到目的主机的一条路径</li>\n<li>虚电路号 VCID，沿路每段链路一个编号（不可能统一编号，因为每段链路负载不一样）</li>\n<li>沿途每个网络设备，利用转发表记录经过的每条虚电路</li>\n</ol>\n</li>\n<li>路由器转发分组时根据转发表改写、替换VCID</li>\n<li>转发表包括： 输入接口+输入VC+输出接口+输出VC</li>\n</ul>\n<p>虚电路信令协议 signaling protocols：</p>\n<ul>\n<li>用于虚电路的建立、维护及拆除<ul>\n<li>路径选择</li>\n</ul>\n</li>\n<li>应用于虚电路网络，如ATM，帧中继 frame-relay网络等</li>\n<li>目前的Internet不采用</li>\n</ul>\n<h5 id=\"数据报网络\"><a href=\"#数据报网络\" class=\"headerlink\" title=\"数据报网络\"></a>数据报网络</h5><p>提供网络层无连接服务</p>\n<p>每个分组携带目的地址</p>\n<p>路由器根据目的地址转发分组：</p>\n<ul>\n<li>根据路由协议、路由算法构建转发表</li>\n<li>检索转发表</li>\n<li>每个分组独立选路</li>\n</ul>\n<p>数据报转发表：</p>\n<ul>\n<li>转发表中目的地址针对地址范围</li>\n<li>最长前缀匹配优先：优先选择匹配前缀最长的入口</li>\n</ul>\n<p>数据报网络和VC网络的对比：</p>\n<ul>\n<li>数据报网络 Internet：<ul>\n<li>计算机之间数据交换：<ul>\n<li>时间要求不严格</li>\n</ul>\n</li>\n<li>链路类型众多：<ul>\n<li>特点、性能各异</li>\n<li>统一服务困难</li>\n</ul>\n</li>\n<li>智能端系统（计算机）</li>\n<li>简化网络，复杂边缘</li>\n</ul>\n</li>\n<li>VC网络 ATM：<ul>\n<li>电话网络演化而来</li>\n<li>核心业务是实时对话：<ul>\n<li>严格时间、可靠性</li>\n</ul>\n</li>\n<li>非智能端系统（电话机、传真机）</li>\n<li>简化边缘，复杂网络</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h4><p>ICMP协议（IP协议的伴随协议）：</p>\n<ul>\n<li>差错报告</li>\n<li>路由器信令</li>\n</ul>\n<p>IP数据报：</p>\n<ul>\n<li>格式：<ul>\n<li>头部<ul>\n<li>固定部分：20字节</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/IP.png\" alt=\"IP\"><ul>\n<li>版本号： 4-bit，IP协议的版本： 4：ipv4, 6：ipv6</li>\n<li>首部长度：4-bit：IP分组首部长度，以4字节为单位</li>\n<li>服务类型 TOS，占 8-bit：指示期望获得哪种类型的服务<ul>\n<li>98年改名为区分服务，只有在网络提供区分服务diffserv时使用</li>\n<li>一般不使用，通常为00H</li>\n</ul>\n</li>\n<li>总长度： 16-bit， IP分组的总字节数（首部+数据），最多可以放65535-20 Byte</li>\n<li>生存时间 TTL，8-bit：IP分组在网络中可以通过的路由器数，路由器转发一次分组，TTL-1，TTL==0时路由器丢弃该分组</li>\n<li>协议，8-bit：指示IP分组封装的是哪个协议的数据报，实现复用、分解， 6：TCP， 17：UDP</li>\n<li>首部校验和 16-bit：对IP首部差错检测，计算校验和时该字段置0，逐跳计算，逐跳检验</li>\n<li>源IP地址、目的IP地址，各32-bit</li>\n</ul>\n</li>\n<li>可变部分： 0字节&lt;=长度&lt;=40字节，携带安全、源选路径、时间戳和路由记录等内容，实际很少被使用</li>\n<li>填充部分：长度可变， 0&lt;=长度&lt;=3B，目的是补齐首部符合32位对齐</li>\n</ul>\n</li>\n<li>数据</li>\n</ul>\n</li>\n</ul>\n<p>IP分片：</p>\n<ul>\n<li>最大传输单元 MTU：链路层 数据帧可封装数据的上限，不同链路MTU不同</li>\n<li>当大IP分组向小MTU链路转发时，<strong>可以</strong>被分片 fragmented，若不允许分片且放不下，则将分组扔掉</li>\n<li>一个大IP分组分成多个小IP分片，IP分片到达目的主机进行重装 reassembled</li>\n<li>IP首部的相关字段用于标识分片以及确定分片的相对顺序</li>\n<li>涉及字段：<ul>\n<li>总长度</li>\n<li>标识 16-bit：用于标识一个IP分组，每产生一个IP分组计时器加1，作为该IP分组的标识</li>\n<li>标志位 3-bit：保留，DF don’t fragment ， MF more fragment：<ul>\n<li>DF=1：禁止分片   DF=0：允许分片</li>\n<li>MF=1：非最后一片， MF=0：最后一片（或未分片）</li>\n</ul>\n</li>\n<li>片偏移 13-bit：一个IP分组分片封装原数据的相对偏移量（未分片则为0），以8字节为单位</li>\n</ul>\n</li>\n</ul>\n<p>分片过程：</p>\n<ul>\n<li>若 总长度&gt;MTU且 DF=0，则分片</li>\n<li>每个分片标识复制原IP分组的标识</li>\n<li>除最后一片，其他分片均分为MUT最大允许分片</li>\n<li>一个最大分片可封装的数据应该是8的倍数，可封装数据为 d = [ (M-20) / 8]*8（向下取整）（20字节头部）</li>\n<li>需要总的片数  n = [(L-20)/d] (向上取整)</li>\n<li>每片的片偏移字段取值为  F = d/8 * (i-1)  1&lt;=i&lt;=n</li>\n<li>每片总字段长度   Li = d+20 （非最后一片）  Li= L-(n-1)d （最后一片）</li>\n</ul>\n<h4 id=\"IP编址-addressing\"><a href=\"#IP编址-addressing\" class=\"headerlink\" title=\"IP编址 addressing\"></a>IP编址 addressing</h4><p>接口 interface：主机、路由器与物理链路的连接：</p>\n<ul>\n<li>实现网络层功能</li>\n<li>路由器通常有多个接口</li>\n<li>主机通常只有一个或两个接口</li>\n</ul>\n<p>IP地址：32-bit  IPv4：</p>\n<ul>\n<li>编号标识主机、路由器的接口</li>\n<li>32-bit =》  4个8bit的点分十进制地址</li>\n<li>IP地址与每个接口关联</li>\n<li>如何为接口分配IP地址：<ul>\n<li>IP地址分为两部分：网络号netID （高位）+ 主机号hostID（低位）：</li>\n<li>IP子网 subnet：<ul>\n<li>IP地址具有相同网络号的设备接口</li>\n<li>不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"有类IP地址\"><a href=\"#有类IP地址\" class=\"headerlink\" title=\"有类IP地址\"></a>有类IP地址</h5><p>有类编址：</p>\n<ul>\n<li><p>A类地址 （50%） （第一位为0）  netID 8-bit，hostID 24-bit  0.0.0.0~127.255.255.255</p>\n</li>\n<li><p>B类地址 （25%）（1\\2位为10） netID 16-bit  hostID 16-bit   128.0.0.0~191.255.255.255</p>\n</li>\n<li><p>C类地址（12.5%）（11） netID 24-bit， hostID 8-bit   192.0.0.0~223.255.255.255</p>\n</li>\n<li><p>D、E不再区分netID和hostID</p>\n<ul>\n<li>D类地址（6.25%）（1110） ：多播地址<ul>\n<li>用作特殊目的：命名或标识一组主机，理论上可分布在任何地方，只能向其发送数据</li>\n</ul>\n</li>\n<li>E类地址（6.25%）（1111）：研究所用</li>\n</ul>\n</li>\n<li><p>特殊IP地址</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/specialIP.png\" alt=\"特殊IP\"></p>\n</li>\n<li><p>私有地址：只用于内部网络，在公共环境无效</p>\n<ul>\n<li>A类： netID 10 ，1个</li>\n<li>B类： netID 172.16到172.31      16个</li>\n<li>C类： netID 192.168.0 到 192.168.255      255个 </li>\n</ul>\n</li>\n</ul>\n<h5 id=\"IP子网及子网掩码\"><a href=\"#IP子网及子网掩码\" class=\"headerlink\" title=\"IP子网及子网掩码\"></a>IP子网及子网掩码</h5><p>子网划分：</p>\n<ul>\n<li>IP地址：<ul>\n<li>网络号 netID：高位比特</li>\n<li>子网号 subid ：原网络主机号部分比特</li>\n<li>主机号 hostID：低位比特</li>\n</ul>\n</li>\n<li>子网掩码：<ul>\n<li>确定是否划分了子网，利用多少位划分子网</li>\n<li>形式和IP地址相同， 32-bit，点分十进制形式</li>\n<li>取值： netID、subID全取1，hostID位全取0</li>\n<li>默认子网掩码：<ul>\n<li>A类默认子网掩码：255.0.0.0</li>\n<li>B类默认子网掩码：255.255.0.0</li>\n<li>C类默认子网掩码：255.255.255.0</li>\n<li>借用3比特划分子网的B类子网掩码 255.255.224.0</li>\n</ul>\n</li>\n<li>子网地址 + 子网掩码 ：准确确定子网大小</li>\n<li>应用：<ul>\n<li>IP分组的目标IP地址与子网掩码按位与运算提取子网地址</li>\n<li>子网地址，地址范围 -&gt; 去除不可用地址 -&gt; 可分配地址范围</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网络层（中）\"><a href=\"#网络层（中）\" class=\"headerlink\" title=\"网络层（中）\"></a>网络层（中）</h3><h4 id=\"CIDR与路由聚合\"><a href=\"#CIDR与路由聚合\" class=\"headerlink\" title=\"CIDR与路由聚合\"></a>CIDR与路由聚合</h4><p>无类域间路由 classless interdomain routing：</p>\n<ul>\n<li>消除ABC类地址界限<ul>\n<li>netID + subID -&gt; 网络前缀 prefix  任意长度</li>\n</ul>\n</li>\n<li>融合子网地址和子网掩码，方便子网划分<ul>\n<li>无类地址格式： a.b.c.d/x  x为前缀长度</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>提高IPV4地址空间分配效率</li>\n<li>提高路由效率：<ul>\n<li>将多个子网聚合成一个大网</li>\n<li>构造超网（supernetting）</li>\n<li>路由聚合（route aggregation）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"DHCP协议\"><a href=\"#DHCP协议\" class=\"headerlink\" title=\"DHCP协议\"></a>DHCP协议</h4><p>主机如何获得IP地址：</p>\n<ul>\n<li>硬编码：<ul>\n<li>静态配置（自行填写）<ul>\n<li>默认网关：数据报转发到的路由器默认接口的IP地址</li>\n</ul>\n</li>\n<li>动态配置协议 DHCP dynamic host configuration protocol：<ul>\n<li>从服务器动态获取<ul>\n<li>IP地址</li>\n<li>子网掩码</li>\n<li>默认网关</li>\n<li>DNS服务器名称及IP</li>\n</ul>\n</li>\n<li>在应用层实现，封装在UDP数据报</li>\n<li>即插即用的协议</li>\n<li>允许地址重用</li>\n<li>支持在用地址续租</li>\n<li>支持移动用户加入网络</li>\n<li>与DHCP服务器交换报文：<ul>\n<li>发现报文DHCP discover：客户端进行广播，确认服务器的地址</li>\n<li>提供报文DHCP offer：DHCP服务器利用提供报文进行广播响应并发送IP地址</li>\n<li>请求报文DHCP request：主机广播发送以请求IP地址，并通知其它可能的DHCP服务器回收资源</li>\n<li>确认报文DHCP ack：服务器向主机发送确认消息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"NAT-网络地址转换\"><a href=\"#NAT-网络地址转换\" class=\"headerlink\" title=\"NAT 网络地址转换\"></a>NAT 网络地址转换</h4><p>所有离开内网的源IP需要替换成相同NAT的IP地址及不同端口号</p>\n<p>动机：</p>\n<ul>\n<li>只需/只能从ISP申请到一个IP地址<ul>\n<li>IPV4耗尽</li>\n</ul>\n</li>\n<li>本地网络设备IP地址变更，无需通告外界网络</li>\n<li>变更ISP时无需修改内网IP</li>\n<li>内网设备对外网不可见，不能直接寻址（安全）</li>\n</ul>\n<p>实现：</p>\n<ul>\n<li>替换：（内到外）<ul>\n<li>离开内网的IP数据报的源IP地址及源端口号替换NAT的IP地址及新端口号</li>\n</ul>\n</li>\n<li>记录：<ul>\n<li>每对（NAT IP地址及新端口号）与（源IP地址及端口号）替换信息存储到NAT转换表</li>\n</ul>\n</li>\n<li>替换：（外到内）<ul>\n<li>发回的数据报，利用NAT转换表替换IP地址和端口号</li>\n</ul>\n</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>16-bit端口号字段（0-65535），可以同时支持6万多并行连接</li>\n<li>争议：<ul>\n<li>路由器应只处理第三层功能（NAT修改了第四层数据段的内容）</li>\n<li>违背了端到端通信原则<ul>\n<li>应用开发者必须考虑到NAT的存在，如P2P应用</li>\n</ul>\n</li>\n<li>地址短缺问题应该由IPv6解决</li>\n</ul>\n</li>\n</ul>\n<p>NAT穿透方案：</p>\n<ul>\n<li>静态配置NAT：特定端口总是与特定内部IP及端口连接</li>\n<li>利用UPnP universal plug and play 互联网网关设备协议IGD internet gateway device自动配置:<ul>\n<li>内网主机自动学习到NAT公共IP地址</li>\n<li>在NAT转换表中，增删端口映射</li>\n</ul>\n</li>\n<li>中继 （如 Skype）：<ul>\n<li>NAT内部客户与中继服务器建立连接</li>\n<li>外部客户也和中继服务器建立连接</li>\n<li>中继服务器桥接两个连接的分组</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ICMP互联网控制报文协议\"><a href=\"#ICMP互联网控制报文协议\" class=\"headerlink\" title=\"ICMP互联网控制报文协议\"></a>ICMP互联网控制报文协议</h4><p>internet control message protocol 互联网控制报文协议支持主机和路由器：</p>\n<ul>\n<li>差错或异常报告（反馈）</li>\n<li>网络探询（主动发送）</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li>差错报告报文（5种）：<ul>\n<li>目的不可达</li>\n<li>源抑制 source quench：拥塞控制，路由器向源主机发送，让其降低发送分组速度</li>\n<li>超时、超期（如TTL 可以跨越的路由器数目）</li>\n<li>参数问题：路由器认为IP数据报头部数据有问题</li>\n<li>重定向 redirect：路由器认定路径不对</li>\n</ul>\n</li>\n<li>网络探询（2组）：<ul>\n<li>回声（Echo）请求与应答报文（Reply）：探测到目标主机的网络是否通达，如 ping</li>\n<li>时间戳请求与应答报文</li>\n</ul>\n</li>\n</ul>\n<p>不发送ICMP的特殊情况：</p>\n<ul>\n<li>对ICMP差错报文不再发送ICMP</li>\n<li>除对第一个分片外，后续分片都不发送ICMP</li>\n<li>所有多播IP数据报都不发送</li>\n<li>对特殊地址的IP数据报不发送ICMP</li>\n</ul>\n<p>不再使用的ICMP报文：</p>\n<ul>\n<li>信息请求与应答</li>\n<li>子网掩码请求与应答</li>\n<li>路由器询问和通告</li>\n</ul>\n<p>报文格式：</p>\n<ul>\n<li>ICMP报文封装到IP数据报的数据部分传输</li>\n<li>ICMP头部：类型、代码、校验和</li>\n</ul>\n<p>ICMP的应用：Traceroute</p>\n<h4 id=\"IPv6\"><a href=\"#IPv6\" class=\"headerlink\" title=\"IPv6\"></a>IPv6</h4><p>动机：</p>\n<ul>\n<li>32位ipv4地址空间分配殆尽</li>\n<li>改进首部格式：<ul>\n<li>快速处理、转发数据报</li>\n<li>支持QoS</li>\n</ul>\n</li>\n</ul>\n<p>数据报格式：</p>\n<ul>\n<li>固定长度的40字节基本首部</li>\n<li>路由器不允许分片（若要分片，源主机分）</li>\n<li>基本首部+扩展首部（路由器一般不处理）+数据部分</li>\n<li>扩展首部+数据 = 载荷（0至64KB）</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ipv6.png\" alt=\"ipv6\"></li>\n<li>流标签 flow label：标识同一流中的数据报</li>\n<li>下一个首部 next header：标识下一个选项首部或上层协议首部</li>\n<li>跳步限制：TTL：允许经过的路由器数目</li>\n</ul>\n<p>与IPV4的对比：</p>\n<ul>\n<li>无校验和：以减少每跳处理时间</li>\n<li>通过多个选项首部 支持 选项</li>\n<li>ICMPv6：新版ICMP：<ul>\n<li>附加报文类型： packet too big</li>\n<li>多播组管理功能</li>\n</ul>\n</li>\n</ul>\n<p>地址表示：</p>\n<ul>\n<li>一般形式：冒号分割的8组16进制数，每组4个数字</li>\n<li>压缩：用两个连续冒号省略中间的0</li>\n<li>兼容ipv4：前8个bit都为0:0:0:0:0：FFFF：ipv4地址 或 ::FFFF:ipv4</li>\n<li>地址前缀：ipv6不再使用掩码</li>\n</ul>\n<p>基本地址类型：</p>\n<ul>\n<li>单播unicast： 一对一通信</li>\n<li>多播multicast：一对多通信</li>\n<li>任意播 anycast：一对一组之一（最近一个）通信</li>\n</ul>\n<p>IPV4向IPV6过渡：</p>\n<ul>\n<li>隧道 tunneling：IPV6数据报作为ipv4数据报的载荷进行封装穿越ipv4的网络</li>\n</ul>\n<h3 id=\"网络层（下）\"><a href=\"#网络层（下）\" class=\"headerlink\" title=\"网络层（下）\"></a>网络层（下）</h3><h4 id=\"路由算法\"><a href=\"#路由算法\" class=\"headerlink\" title=\"路由算法\"></a>路由算法</h4><p>概念：寻找最小费用路径的算法</p>\n<p>静态路由 vs 动态路由：</p>\n<ul>\n<li>静态路由：<ul>\n<li>手工配置的路由</li>\n<li>路由更新慢</li>\n<li>优先级高</li>\n</ul>\n</li>\n<li>动态路由：<ul>\n<li>计算得来的路由</li>\n<li>更新快<ul>\n<li>定期更新</li>\n<li>及时响应连路费用或网络拓扑变化</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>全局信息 vs 分散信息：</p>\n<ul>\n<li>全局信息：<ul>\n<li>所有路由器掌握完整网络拓扑和链路费用</li>\n<li>典型算法：链路状态LS路由算法</li>\n</ul>\n</li>\n<li>分散decentralized信息：<ul>\n<li>只掌握物理相连的邻居及链路费用</li>\n<li>通过邻居间信息交换及迭代运算</li>\n<li>典型算法：距离向量DV路由算法</li>\n</ul>\n</li>\n</ul>\n<p>链路状态路由算法：</p>\n<ul>\n<li>所有路由器掌握网络拓扑和链路费用</li>\n<li>通过链路状态广播</li>\n<li>采用 dijkstra算法在每个路由器计算单源最短路</li>\n<li>存在 震荡oscillations 可能</li>\n</ul>\n<p>距离向量（Distance Vector）路由算法：</p>\n<ul>\n<li>每个路由器只掌握物理相连的邻居及链路费用</li>\n<li>Bellman-Ford方程（动态规划）</li>\n<li>步骤：<ul>\n<li>每个结点不定时将自己的DV估计发送给邻居</li>\n<li>结点接收到邻居的新的DV估计时，依据BF更新其自身估计，若估计变化了，则传播给邻居</li>\n<li>距离最终收敛于实际的最小费用</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>异步迭代<ul>\n<li>引发局部迭代的因素：<ul>\n<li>局部链路费用改变</li>\n<li>邻居的DV更新</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>分布式：结点只当自己DV变化时才告诉邻居</li>\n<li>好消息（高费降低费）传播快，坏消息（低费升高费）传播慢</li>\n<li>可能有 无穷计数 count to infinite 问题，解决方案：<ul>\n<li>毒性逆转技术 poisoned reverse：<ul>\n<li>若Z到X的最小路径是通过Y，则y收到Z到X的费用是正无穷</li>\n</ul>\n</li>\n<li>定义最大度量 maximum metric：<ul>\n<li>定义一个最大的有效费用值，超过最大费用的记为无穷</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>层次路由：</p>\n<ul>\n<li>提出原因：把网络抽象为一个图计算路由过于理想化，网络规模过大，管理自治</li>\n<li>聚合路由器为一个区域：自治系统AS autonomous system</li>\n<li>同一AS内路由器运行相同路由协议算法<ul>\n<li>自治系统内部路由协议</li>\n<li>不同自治系统内的路由器可以运行不同的AS内部路由协议</li>\n</ul>\n</li>\n<li>网关路由器 gateway router：<ul>\n<li>位于AS边缘</li>\n<li>通过链路连接其他AS的网关路由器</li>\n</ul>\n</li>\n<li>转发表由AS内部路由算法和AS间路由算法共同配置</li>\n<li>热土豆路由：将分组发给最近的网关路由器</li>\n</ul>\n<h4 id=\"Internet-路由\"><a href=\"#Internet-路由\" class=\"headerlink\" title=\"Internet 路由\"></a>Internet 路由</h4><p>路由协议：</p>\n<ul>\n<li>AS内部路由： 内部网关协议 IGP interior gateway protocols<ul>\n<li>路由信息协议  RIP routing information protocol：<ul>\n<li>距离向量路由算法</li>\n<li>距离用跳步数度量（最大有效为15跳步）</li>\n<li>通告advertisement ：每30s，邻居交换一次DV</li>\n<li>每次通告：最多25个目的子网</li>\n<li>链路失效、恢复：<ul>\n<li>180s没有收到通告 -&gt; 邻居、链路失效 -&gt; 重新计算路由 -&gt; 向邻居发送新的通告 -&gt; 邻居可能向外发送通告</li>\n</ul>\n</li>\n<li>RIP路由表处理：利用一个称作route-d的应用层进程进行管理</li>\n<li>通告报文周期性通过UDP数据报发送</li>\n</ul>\n</li>\n<li>开放最短路径优先 OSPF open shortest path first：<ul>\n<li>链路状态路由算法：所有路由器对整个网络已知，dijkstra求解：<ul>\n<li>LS分组扩散（通告）</li>\n<li>每个路由器构造完整的网络AS拓扑图</li>\n<li>利用dijkstra计算</li>\n</ul>\n</li>\n<li>每个入口对应一个邻居</li>\n<li>通告在整个AS中泛洪</li>\n<li>通告报文直接封装到IP数据报中</li>\n<li>优点：<ul>\n<li>安全：所有OSPF报文可以被认证（预防恶意入侵）</li>\n<li>允许使用多条到同一目的的相同费用的路径（RIP只能从中选一条）</li>\n<li>对同一链路针对不同TOS设置不同费用度量</li>\n<li>集成单播与多播路由：<ul>\n<li>多播OSPF协议（MOSPF）与OSPF利用相同的拓扑数据</li>\n</ul>\n</li>\n<li>支持大规模AS分层 hierarchical：<ul>\n<li>区边界路由器：同时在主干区和分支区的路由器</li>\n<li>主干路由器：只在主干区</li>\n<li>AS边界路由器：连接其它AS</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内部网关路由协议 IGRP interior gateway routing protocol（思科的私有协议）</li>\n</ul>\n</li>\n<li>AS间路由协议：BGP border gateway protocol：<ul>\n<li>事实上的标准域间路由协议</li>\n<li>为每个AS提供了一种手段：<ul>\n<li>eBGP：从邻居AS获取子网可传达性信息（外部会话）</li>\n<li>iBGP：向所有AS内部路由器传播子网可达性信息（内部会话）</li>\n</ul>\n</li>\n<li>基础：<ul>\n<li>BGP会话session：两个路由器交换BGP报文<ul>\n<li>通告去往不同目的前缀（子网）的路径</li>\n<li>报文交换基于半永久的TCP连接</li>\n</ul>\n</li>\n<li>BGP报文：<ul>\n<li>OPEN：建立TCP连接并认证发送方</li>\n<li>UPDATE：通告新路径（或撤销原路径）</li>\n<li>KEEPALIVE：无UPDATE时保活连接，也用于对OPEN的确认</li>\n<li>NOTIFICATION：报告先前报文的差错，也用于关闭连接</li>\n</ul>\n</li>\n<li>路径信息与BGP路由：<ul>\n<li>通告的前缀信息包括BGP属性<ul>\n<li>前缀+属性 = “路由”</li>\n</ul>\n</li>\n<li>两个重要属性：<ul>\n<li>AS-PATH  AS路径：包含前缀通告所经过的AS路径</li>\n<li>NEXT-HOP下一跳：开始一个AS-PATH的路由器的接口，指向下一跳AS</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>路由选择：网关路由器收到路由通告后，利用输入策略import policy决策接收或拒绝路由：</li>\n<li>多条路径的挑选准则：<ol>\n<li>本地偏好preference值策略</li>\n<li>最短AS-PATH</li>\n<li>最近NEXT-HOP路由器：热土豆路由</li>\n<li>附加准则</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>采用不同的AS内、AS间路由协议原因：<ul>\n<li>策略：<ul>\n<li>AS间inter-AS：希望能够管理控制流量如何被路由，谁路由经过网络</li>\n<li>intra-AS 内部：单一管理，无需策略决策</li>\n</ul>\n</li>\n<li>规模：<ul>\n<li>层次路由节省路由表大小，减少更新流量</li>\n<li>适应大规模互联网</li>\n</ul>\n</li>\n<li>性能：<ul>\n<li>inter-AS间：策略主导</li>\n<li>intra-AS内：侧重性能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><h4 id=\"链路层服务\"><a href=\"#链路层服务\" class=\"headerlink\" title=\"链路层服务\"></a>链路层服务</h4><p>术语：</p>\n<ul>\n<li>结点 nodes：主机和路由器</li>\n<li>链路 links：连接相邻结点的通信信道：<ul>\n<li>有线链路 wired links</li>\n<li>无线链路 wireless links</li>\n<li>局域网 LANS</li>\n</ul>\n</li>\n<li>帧 frame：链路层的数据分组，封装网络层的数据报</li>\n</ul>\n<p>功能：负责通过链路在相邻结点间传输数据报</p>\n<p>服务：</p>\n<ul>\n<li>组帧 framing：<ul>\n<li>封装数据报构成数据帧，加头加尾</li>\n<li>帧同步</li>\n</ul>\n</li>\n<li>链路接入 link access：<ul>\n<li>若是共享介质时，需要解决信道接入 channel access</li>\n<li>帧首部的MAC地址 ( 物理地址 )，用于标识帧的源和目的</li>\n</ul>\n</li>\n<li>相邻结点间的可靠交付<ul>\n<li>低误码率的有线链路很少采用（如光纤，某些双绞线）</li>\n<li>无线链路：误码率高，需要可靠交付</li>\n</ul>\n</li>\n<li>流量控制 flow control：<ul>\n<li>协调pacing相邻发送结点与接收</li>\n</ul>\n</li>\n<li>差错检测 error detection：<ul>\n<li>应对信号衰减和噪声</li>\n<li>接收端检测到差错：重传或丢弃</li>\n</ul>\n</li>\n<li>差错纠正 error correction （个别协议）：<ul>\n<li>纠错编码：接收端可以直接纠正比特差错</li>\n</ul>\n</li>\n<li>全双工和半双工的通信控制</li>\n</ul>\n<p>具体实现：</p>\n<ul>\n<li>链路层在网络接口卡实现</li>\n<li>由硬件、软件和固件组成</li>\n<li>链接主机的系统总线</li>\n</ul>\n<h4 id=\"差错编码\"><a href=\"#差错编码\" class=\"headerlink\" title=\"差错编码\"></a>差错编码</h4><p>原理：</p>\n<ul>\n<li>在数据上增加冗余信息 R 称为监督位或冗余比特</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li>分组码<ul>\n<li>线性码</li>\n<li>非线性码</li>\n</ul>\n</li>\n<li>卷积码</li>\n</ul>\n<p>差错编码的检错能力：</p>\n<ul>\n<li>差错编码分为 检错码 和 纠错码</li>\n<li>对于检错码，若编码集的汉明距离d = r+1 ， 则该差错编码可以100%检测 r位差错<ul>\n<li>汉明距离：编码集中任意两个字符编码不同比特数目的最小值</li>\n</ul>\n</li>\n<li>对于纠错码，汉明距离 d=2r+1，则该差错编码可以100%纠正r位差错（纠成与之距离最近的码字）</li>\n</ul>\n<p>常见差错编码：</p>\n<ul>\n<li>奇偶校验码：0的个数或1的个数加上冗余位为奇数或偶数<ul>\n<li>1比特校验位：检测奇数位差错，冗余位少</li>\n<li>二维奇偶校验：<ul>\n<li>检测所有奇数位差错、部分偶数位差错</li>\n<li>可以检测同一行或同一列差错</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Internet校验和  checksum：<ul>\n<li>数据划分为16位二进制整数序列</li>\n<li>求和后取反码</li>\n</ul>\n</li>\n<li>循环冗余校验码 CRC<ul>\n<li>数据 D 看成一个二进制数</li>\n<li>选择一个 r+1 位的生成比特模式 G</li>\n<li>目标：选择 r 位CRC比特 R 满足 &lt; D,R &gt;刚好可以被G整除</li>\n<li>R计算方法： <ul>\n<li>$ D<em>2^{r} (XOR)  R = n</em>G$</li>\n<li>$ R =( D*2^r ) mod G $</li>\n</ul>\n</li>\n<li>可以检测所有突发长度小于r+1位差错</li>\n<li>广泛应用于实际网络</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多路访问控制-MAC-协议\"><a href=\"#多路访问控制-MAC-协议\" class=\"headerlink\" title=\"多路访问控制 MAC 协议\"></a>多路访问控制 MAC 协议</h4><p>两类链路：</p>\n<ul>\n<li>点对点链路：<ul>\n<li>拨号接入的PPP</li>\n<li>以太网交换机和主机间的点对点链路</li>\n</ul>\n</li>\n<li>广播链路（共享介质）<ul>\n<li>单一共享广播信道</li>\n<li>两个或两个以上结点同时传输：干扰 interference<ul>\n<li>冲突 collision：结点同时接收多个信号</li>\n</ul>\n</li>\n<li>多路访问控制协议 MAC multiple access control protocol：<ul>\n<li>采用分布式算法决定结点如何共享信道</li>\n<li>基于信道本身进行协调<ul>\n<li>无带外信道进行协调</li>\n</ul>\n</li>\n<li>理想的MAC协议：<ul>\n<li>完全分散控制：<ul>\n<li>无需特定结点协调</li>\n<li>无需时钟、时隙同步</li>\n</ul>\n</li>\n<li>需要发送数据的结点平分链路带宽</li>\n<li>简单</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>信道划分 channel partitioning MAC协议：<ul>\n<li>多路复用技术 TDMA、FDMA、CDMA、WDMA等</li>\n<li>网络负载重时公平、效率高</li>\n<li>负载轻时效率低</li>\n</ul>\n</li>\n<li>随机访问 random access MAC协议：<ul>\n<li>信道不划分，允许冲突</li>\n<li>采用冲突恢复机制</li>\n<li>结点要发送数据时<ul>\n<li>用信道的全部速率发送分组</li>\n<li>没有事先的节点间协调</li>\n</ul>\n</li>\n<li>需要定义：<ul>\n<li>如何检测冲突</li>\n<li>如何从冲突中恢复（通常是延迟重传）</li>\n</ul>\n</li>\n<li>负载重时冲突大、效率低</li>\n<li>负载低时效率高</li>\n<li>典型随机访问MAC协议：<ul>\n<li>时隙soted ALOHA：<ul>\n<li>假定：<ul>\n<li>假设所有帧大小相等</li>\n<li>时间划分成等长时隙（每个时隙可以传1个帧）</li>\n<li>结点只能在时隙开始时发送帧</li>\n<li>结点间时钟同步</li>\n</ul>\n</li>\n<li>运行：<ul>\n<li>有帧时，在下一个时隙发送：<ul>\n<li>无冲突：在下一个时隙发新的帧</li>\n<li>有冲突：在下一个时隙以概率p重发，直至成功</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>单个结点活动时用整个信道速率</li>\n<li>高度分散化：只需要同步时隙</li>\n<li>简单</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>容易冲突，浪费时隙</li>\n<li>空闲时隙</li>\n<li>时钟同步</li>\n<li>效率低，最好情况 37%</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ALOHA：<ul>\n<li>无时隙划分，纯ALOHA，更简单，无需同步</li>\n<li>有新的帧生成时：立即发送</li>\n<li>冲突可能性大</li>\n<li>比时隙ALOHA协议效率更低，18%</li>\n</ul>\n</li>\n<li>CSMA、CSMA/CD、CSMA/CA<ul>\n<li>CSMA 载波监听多路访问协议 carrier sense multiple access：发送帧之前监听信道：<ul>\n<li>信道空闲：发送完整帧</li>\n<li>信道忙：推迟发送：<ul>\n<li>1-坚持CSMA：以概率p=1监听信道</li>\n<li>非坚持CSMA：随机等待一段时间后再监听</li>\n<li>P-坚持CSMA：以概率p坚持监听，1-p非坚持</li>\n</ul>\n</li>\n<li>冲突仍然可能发送：信号传播延迟</li>\n<li>继续发送冲突帧：浪费信道资源</li>\n</ul>\n</li>\n<li>CSMA/CD CSMA with Collision Detection 带冲突检测的CSMA协议：短时间内可以检测冲突<ul>\n<li>广泛用于以太网</li>\n<li>检测到冲突后，立刻停止传输</li>\n<li>冲突检测：<ul>\n<li>有线局域网易实现：测量信号强度</li>\n<li>无线局域网难实现：接收信号强度淹没在本地发射信号强度下</li>\n</ul>\n</li>\n<li>边发边听，不发不听</li>\n<li>Lmin / R = RTTmax （Lmin：数据帧最小长度，R：网络带宽，RTT：消息来回的时间），发送数据时能够检测到冲突的最小长度，防止数据在冲突时已经发完，因不发不听而不知道有冲突</li>\n</ul>\n</li>\n<li>CSMA/CA 应用于802.11无线局域网</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>轮转 taking turns MAC协议：<ul>\n<li>结点轮流使用信道</li>\n<li>综合信道划分和随机访问的优点</li>\n<li>类型：<ul>\n<li>轮询 polling：<ul>\n<li>主结点轮流邀请从属结点发送数据</li>\n<li>典型应用： 哑dump（非智能、蓝牙）从属设备</li>\n<li>问题：<ul>\n<li>轮询开销，数据占用带宽</li>\n<li>等待延迟</li>\n<li>单点故障，主结点故障问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>令牌传递 token passing：<ul>\n<li>控制令牌依次从一个结点传递到下一个结点</li>\n<li>令牌：特殊帧，网络中有且只有一个令牌</li>\n<li>网络可能构成环形网络</li>\n<li>问题：<ul>\n<li>令牌开销，带宽开销</li>\n<li>等待延迟</li>\n<li>单点故障：令牌丢失</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"局域网\"><a href=\"#局域网\" class=\"headerlink\" title=\"局域网\"></a>局域网</h3><h4 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h4><p>MAC地址：物理地址、LAN地址、以太网地址</p>\n<ul>\n<li>作用：在局域网中标识一个帧从哪个接口发出，到达哪个物理相连的其它接口</li>\n<li>48位（16进制6字节）MAC地址，固化在网卡的ROM中，有时可以软件设置</li>\n<li>局域网中每块网卡都有唯一的MAC地址</li>\n<li>由IEEE统一管理与分配</li>\n<li>网卡厂商在IEEE购买前24比特MAC地址空间</li>\n<li>与IP地址区别：<ul>\n<li>MAC地址是“平面地址”，可以从一个LAN移到另一个LAN，用于标识帧</li>\n<li>IP地址是层次地址，依赖结点连接到哪个子网，用于标识数据报</li>\n</ul>\n</li>\n</ul>\n<p>ARP：地址解析协议</p>\n<ul>\n<li>已知目的接口的IP地址下确定MAC地址</li>\n<li>ARP表：LAN中每个IP结点维护一个表，存储某些LAN结点IP/MAC地址映射关系：&lt; IP; MAC ; TTL&gt;(TTL time to live:经过这个时间后该映射关系会丢弃，一般为20min)</li>\n<li>ARP是“即插即用”协议：结点无需干预，自主创建ARP表</li>\n<li>获取目标主机的MAC地址：<ul>\n<li>同一局域网内：<ul>\n<li>若A的ARP表不包含B的MAC地址，则A广播ARP查询分组，其中包含B的IP地址，只有B向A利用单播帧响应B的MAC地址，A缓存B的地址对直至超时</li>\n</ul>\n</li>\n<li>不同局域网内：<ul>\n<li>A发数据帧至网关路由器（源IP为A，目标IP为B，源MAC为A，目的MAC为网关路由器的一端口），网关路由器转发数据报，更改源MAC地址为发出端口的MAC地址，若双方都在公网，则不需要更改IP地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"以太网-Ethernet\"><a href=\"#以太网-Ethernet\" class=\"headerlink\" title=\"以太网 Ethernet\"></a>以太网 Ethernet</h4><p>有线LAN技术、应用最广泛的LAN技术</p>\n<p>物理拓扑：</p>\n<ul>\n<li>总线 bus：同轴电缆，上世纪90年代中期流行<ul>\n<li>所有结点在同一冲突域 collision domain ，可能彼此冲突</li>\n</ul>\n</li>\n<li>星型 star：目前主流网络拓扑<ul>\n<li>利用中心交换机 switch</li>\n<li>每个结点一个单独冲突域，结点间彼此不冲突</li>\n</ul>\n</li>\n</ul>\n<p>特点:</p>\n<ul>\n<li>无连接 connectionless：发送帧的网卡和接收帧的网卡没有握手过程</li>\n<li>不可靠 unreliable：接收网卡不向发送网卡进行确认<ul>\n<li>出错可能性低，差错帧直接丢弃，依靠高层协议恢复数据</li>\n</ul>\n</li>\n<li>采用二进制指数退避算法CSMA/CD的 MAC协议：<ol>\n<li>网卡从网络层接收数据报，创建数据帧</li>\n<li>监听信道：<ol>\n<li>监听到信道空闲，则发送帧</li>\n<li>信道忙，一直等待到信道空闲，然后发送</li>\n</ol>\n</li>\n<li>发送完整个帧没有检测到其他结点数据发送，则确认发送成功</li>\n<li>若检测到其他结点传输数据，终止发送并发送阻塞信号 jam signal</li>\n<li>网卡进入二进制指数退避：<ul>\n<li>第m次连续冲突后：<ul>\n<li>取n=Max(m,10)</li>\n<li>网卡从 0到 $2^n-1$随机取一个数K</li>\n<li>等待 K * 512bit的传输延迟时间，再返回第2步</li>\n</ul>\n</li>\n<li>连续16次冲突后，报告差错</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>帧结构：</p>\n<ul>\n<li>把IP数据报封装到以太网帧中</li>\n<li>前导码 preamble   8B：<ul>\n<li>前7个字节为10101010，第八字节为10101011</li>\n<li>用于发送端和接收端的时钟一致</li>\n</ul>\n</li>\n<li>目的MAC和源MAC地址（各6B）</li>\n<li>类型 Type  2B：指示帧中封装哪种高层协议的分组</li>\n<li>数据 Data 46-1500B：上层协议载荷 （CSMA/CD发送数据时能够检测到冲突的最小长度）</li>\n<li>CRC 4B：循环冗余校验码</li>\n</ul>"},{"layout":"post","title":"操作系统笔记","date":"2018-02-19T16:00:00.000Z","comments":1,"_content":"\n\n\n### 概述\n\n操作系统学习笔记，包括：\n\n1. 操作系统基本概念\n2. 进程、线程\n3. 处理器调度\n4. 同步机制\n5. 存储模型\n6. 文件系统\n7. IO\n8. 死锁\n\n<!-- more -->\n\n重点：\n\n《现代操作系统》(第三版)\n\n* 教材：\n  * 第一章： 1.1 、1.2 、 1.4\n  * 第10章： 10.2.5 linux\n  * 第11章： 11.3.1 \n* 重点概念：\n  * 操作系统定义\n  * 操作系统三个作用\n  * 操作系统四个特点\n  * SPOOLING技术\n  * windows、linux、unix架构及主要功能\n\n#### 操作系统的定义与作用\n\n1. 有效管理资源\n\n> 1. 静态分配：在进程执行前准备好需要的所有资源，会造成资源浪费\n> 2. 动态分配：进程需要时进行申请\n\n2. 通过命令接口、编程接口为用户提供服务\n\n3. 对硬件机器的扩展\n\n   > 对硬件进行抽象，硬件之上的虚拟机器\n\n#### 操作系统的特征\n\n1. 并发 concurrency: 指处理多个同时性活动的能力\n\n   > 引发问题： 活动切换、保护、相互依赖的活动的同步\n   >\n   > 并行parallel： 不同程序同时在多个硬件上执行\n\n2. 共享 sharing：操作系统与用户的程序共享系统中的资源\n\n   > 操作系统要对资源进行合理分配和使用\n   >\n   > 1. 互斥共享（打印机）\n   > 2. 同时共享（代码、文件）\n\n3. 虚拟 virtual：物理实体映射为若干个对应的逻辑实体（分时、分空间）\n\n   > 目的：提高资源利用率\n   >\n   > CPU：每个进程 “虚处理器”\n   >\n   > 存储器：虚拟地址空间\n   >\n   > 显示器：多窗口\n\n4. 随机：随时对不可预测的次序发生的事件进行响应并处理\n\n   > * 进程运行速度不可预知\n   > * 难以重现系统在某个时刻的状态\n\n#### 操作系统的架构\n\nWindows 、 Unix 、 Linux\n\n#### 操作系统的分类\n\n发展： 硬件发展、应用需求发展、软件技术发展\n\n目的：充分利用硬件，提供更好服务\n\n掌握各种操作系统的目标和不同点\n\n* 批处理操作系统\n\n  1. 方式\n\n     > 系统操作员从用户处收集作业并输入系统，而后启动操作系统，操作系统自动处理作业并输出，系统操作员从输出处获取作业\n\n  2. 目的： 提高资源利用率，增加吞吐量\n\n  3. 概念：\n\n     * 作业：程序、数据、作业说明素\n     * 成批：由若干作业组成\n     * 批作业处理：对每个作业做相同处理\n\n  4. 问题：\n\n     * 输入输出慢，由主机完成，CPU处于等待状态\n     * 解决：用卫星机：完成输入输出，暂存输入输出结果，流程：用户->卫星机->系统操作员->计算机->系统操作员->卫星机->用户\n\n  5. 分类：\n\n     * 单道批处理：一次处理一个作业\n     * 多道批处理：一次选中多个作业进行处理\n\n  6. 技术： Spooling 同时外围设备联机操作，假脱机技术\n\n     > 用磁盘作缓冲，输入输出和计算并行在一台机器上进行\n     >\n     > 现代打印过程通常用spooling技术\n\n* 分时系统：time-sharing ，最早的交互式系统\n\n  1. 方式：\n\n     * 一台主机对多个终端，用户在终端输入命令等待结果\n\n  2. 概念：时间片 （time slice）\n\n     操作系统将CPU时间划分成若干片段，以时间片为单位轮流为终端服务，每次一个时间片\n\n  3. 特点：利用人的错觉，使得人感觉系统只在为自己服务（每个用户在一个虚拟机上运行）\n\n  4. 目标：及时响应\n\n通用操作系统：分时和批处理结合，原则：以分时优先，批处理在后\n\n* 实时操作系统\n  1. 概念：计算机能及时响应外部事件的请求，在严格时间内完成处理\n  2. 分类：\n     1. 实施过程控制（军事控制、航空）\n     2. 实时通信处理（订票）\n  3. 目标：\n     * 严格时间范围内响应\n     * 高可靠性\n  4. 特征：\n     1. 硬实时系统：某个动作必须在规定时间内或规定时刻完成（焊接）\n     2. 软实时系统：接受偶尔违反时限（播放音乐、视频等）\n* PC操作系统\n  1. 目标：\n     * 界面友好、使用方便\n     * 丰富的应用软件\n* 网络操作系统\n  1. 概念：按网络体系结构协议标准开发的软件\n  2. 功能：网络管理，通信，安全，资源共享和网络应用\n  3. 追求目标：相互通信，资源共享\n* 分布式操作系统\n  1. 概念：以计算机网络或多处理器为基础，特征是处理分布在不同计算机上\n* 嵌入式操作系统\n  1. 概念：\n     * 在各种设备、装置中完成特定功能的软硬件系统（汽车、手机、播放器等）\n     * 大设备、装置中的一部分\n     * 对反应时间、处理时间有严格要求\n\n### 操作系统运行环境\n\n重点：\n\n* 理解计算机系统的保护机制\n  * 掌握处理器状态\n  * 掌握特权指令与非特权指令\n* 掌握中断、异常机制\n  * 掌握中断、异常的基本概念\n  * 理解中断、异常机制的工作原理\n* 掌握系统调用机制\n  * 掌握系统调用的设计原理\n  * 掌握系统调用的执行过程\n\n重点阅读：\n\n* 第一章： 1.3、 1.6\n* 第二章： P52 图2-5\n\n重点概念：\n\n​\tCPU状态、内核态 用户态、特权指令 非特权指令、中断、异常、中断响应、中断向量、中断处理程序、系统调用、陷入指令、系统调用号、系统调用表\n\n#### 处理器状态\n\n中断与异常机制\n\nCPU由运算器、控制器、寄存器及高速缓存组成\n\n* 两类寄存器：\n  * 用户可见寄存器：高级语言编译器通过优化算法分配寄存器并使用，减少访问内存次数\n  * 控制和状态寄存器：用于控制处理器操作，只能由操作系统代码使用，\n    * 程序计数器 PC\n    * 指令寄存器 IR\n    * 程序字寄存器 PSW\n\n并发和共享 -> 要求保护： 用户程序不对操作系统干扰\n\n要求硬件提供基本运行机制：\n\n* CPU具有特权级别，不同特权级下运行不同指令集合\n* 将OS与用户程序隔离\n\ncpu状态通常为两种、三种或四种：\n\n​\t在程序状态字寄存器PSW专门设置一位，根据程序的使用权限设置不同的CPU状态\n\n操作系统需要两种CPU状态：\n\n       \t1. 内核态 ： 运行操作系统程序\n     \t2. 用户态： 运行用户程序\n\n指令分类：\n\n1. 特权指令：只能由操作系统使用，用户程序不能使用（启动IO、内存清零）\n2. 非特权指令：操作系统和用户程序都可以使用（控制转移）\n\nCPU状态的转换：\n\n* 用户态 -> 内核态： 唯一途径：中断、异常、陷入机制（提供给用户程序的接口，用于调用操作系统功能）\n* 内核态 -> 用户态：设置程序状态字PSW\n\n#### 中断与异常机制\n\n操作系统是由 中断驱动的 或是 事件驱动的\n\n概念：CPU对系统发生的某个事件的反应\n\n事件的发生改变了CPU的控制流\n\n主要作用：\n\n* 及时处理外部设备中断请求\n* 捕获用户程序提出的服务请求\n* 防止用户程序执行过程中的破坏活动\n\n特点：\n\n* 随机发生\n* 自动处理 (硬件自动完成的)\n* 可恢复\n\n中断的引入原因：支持CPU与设备之间的并行操作\n\n异常的引入原因：CPU执行指令时本身出错\n\n事件：\n\n* 中断（外中断）：\n  * IO中断（按键、外部设备）\n  * 时钟中断（定时器，CPU时间片到了）\n  * 硬件故障（充电）\n* 异常（内中断）：\n  * 系统调用\n  * 页故障、页错误（缺页）\n  * 保护性异常（只读文件和写操作）\n  * 断点指令（debug）\n  * 其他程序性异常（算术溢出）\n\n异常类别：\n\n* 陷入 Trap ： 有意识安排的      同步   返回到下一条指令\n* 故障 Fault： 可恢复的错误     同步    返回到当前指令\n* 终止 Abort： 不可恢复的错误   同步   不会返回\n\n#### 中断、异常机制的工作原理\n\n**硬件和软件相互配合**\n\n硬件：响应异常\n\n​\t捕获请求，以一定方式相应，把CPU的控制权交给处理程序\n\n软件：处理异常\n\n​\t识别类型并完成处理\n\n中断响应：硬件\n\n​\t每条指令执行最后扫描中断寄存器查看是否有中断信号，若有，则中断硬件将中断触发器内容按编码送入PSW，并查询中断向量表引出处理程序\n\n​\t中断向量：一个内存单元，存放中断处理程序入口地址和程序运行时需要的处理机状态字\n\n​\t流程： 设备发出中断信号 -> 硬件保存现场(PSW,PC) -> 根据中断码查表 -> 中断处理程序入口地址送入相应寄存器 -> 执行处理程序\t\n\n中断处理：软件\n\n* 保存相关寄存器信息（硬件只保存关键寄存器）\n* 分析具体原因\n* 执行处理功能\n* 恢复现场，返回被打断的程序\n\n#### 系统调用机制\n\n操作系统给用户提供的接口，在编程时可调用的操作系统功能\n\n使CPU状态从用户态陷入内核态\n\n区分： 系统调用、库函数、API、内核函数\n\n​\t应用程序通常借函数库、API接口间接进行系统调用\n\n​\t内核函数包含系统调用，大部分不开放给用户\n\n设计系统调用机制：\n\n       \t1. 利用中断异常机制\n     \t2. 选择一条特殊指令：陷入指令，从用户态切换到内核态\n     \t3. 每个系统调用给定一个编号\n     \t4. 存放系统调用服务例程的入口地址\n\n用户的参数传递给内核：（从用户栈到内核栈）\n\n1. 陷入指令自带参数（长度有限）\n2. 通用寄存器传递参数（寄存器个数有限） （主要方法）\n3. 内存中开辟专用堆栈区传递参数\n\n系统调用执行过程：\n\n1. 中断异常机制：硬件保护现场，查询中断向量表，控制权交给系统调用总入口程序\n2. 系统调用总入口程序：保存现场，把参数保存到内核栈，查系统调用表把控制权转给相应的系统调用例程或内核函数\n3. 执行系统调用例程\n4. 恢复现场，返回用户程序\n\n\n### 进程、线程模型\n\n重点：\n\n​\t第2章： 2.1、 2.2(除 2.2.8 - 2.2.10外)\n\n重点概念：\n​\t进程、进程状态及切换、进程控制、PCB、进程地址空间、进程上下文环境、线程、线程属性、用户级线程、核心级线程、Pthreads、可再入程序、原语、web服务器\n\n#### 进程的基本概念\n\n多道程序设计： 允许多个程序同时进入内存并运行\n\n并发环境：一段时间间隔内，单处理器由两个或以上程序同时处于开始运行但尚未结束的状态且次序不是事先确定的\n\n进程 process： 具有独立功能的程序关于某个数据集合上的一次运行活动，是资源分配和调度的单位，又称任务\n\n  * 程序一次执行过程\n  * 正在运行程序的抽象\n  * 一个CPU变换成多个虚拟的CPU\n  * 系统资源以进程为单位分配，如内存、文件\n  * 每个进程有独立的地址空间\n  * 操作系统把CPU调度给需要的进程\n\n进程控制块 PCB\n\n* 又称 进程描述符、进程属性\n* 操作系统用于管理控制进程的一个专门数据结构\n* 记录进程的各种属性，并描述进程的动态变化过程\n* 是系统感知进程的唯一标识，与进程一一对应\n* 包含：\n  * 进程描述信息\n    * 进程标识符 ID，唯一\n    * 进程名，不唯一\n    * 用户ID\n    * 进程组关系（子进程、父进程等）\n  * 进程控制信息\n    * 当前状态、优先级、代码执行入口地址、磁盘地址、队列指针等\n  * 所拥有资源和使用情况\n    * 虚拟空间空间状况\n    * 打开文件列表\n  * CPU现场信息\n    * 寄存器值\n    * 指向该进程页表的指针\n\n进程表： 所有进程的PCB的集合（大小固定）\n\n#### 进程状态及状态转换\n\n进程三种基本状态：运行态、就绪态、等待态\n\n运行态 running：\n\n​\t占有CPU并在CPU上运行\n\n就绪态 ready：\n\n​\t已具备运行条件，但没有空闲CPU\n\n等待态、阻塞态、封锁态、睡眠态：\n\n​\t因等待某一事件而暂停（如读盘）\n\n状态转换：\n\n1. 就绪 -> 运行：调度程序选中\n2. 运行 -> 就绪：运行进程用完时间片，或高优先级进程进入就绪态\n3. 运行 -> 等待：进程等待事件（请求OS服务，资源尚未访问，等待IO，等待另一进程等） \n4. 等待 -> 就绪：所等待的事件发生\n\n其它状态：\n\n*  创建态 new：已完成创建进程必备工作（PID、PCB），但未被同意执行（资源有限）\n*  终止态 terminated：执行后，完成数据统计工作，回收资源\n*  挂起态 suspend：进行负载调节，进程不占用内存空间，进程映像交换到磁盘\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sevenlevel.png)\n\n进程队列：\n\n* 每一类进程建立一个或多个队列\n* 队列元素为PCB\n* 进程状态改变，其PCB从一个队列进入另一队列\n\n#### 进程控制\n\n完成进程状态之间的转换，由具有特定功能的原语完成\n\n原语 primitive：完成某特定功能的程序，不可分割、不可中断\n\n1. 进程创建\n   1. 新进程分配唯一标识ID以及进程控制块PCB\n   2. 分配地址空间\n   3. 初始化PCB：设置默认值\n   4. 设置相应的队列指针\n2. 进程的撤销：结束进程\n   1. 回收进程占用的资源（关闭文件、断开网络、回收内存）\n   2. 收回PCB\n3. 进程阻塞：由**进程自己**执行阻塞原语，使自己由运行态变为阻塞态\n\nUNIX下进程控制： 系统调用\n\n* fork 通过复制调用进程建立新进程\n* exec 用新代码覆盖原来的地址空间，建立新进程\n* wait 进程进入阻塞态 \n* exit 终止进程运行 \n\n#### 进程相关概念\n\n进程的分类：\n\n1.  \n   * 系统进程：优先级较高\n   * 用户进程\n2.  \n   * 前台进程\n   * 后台进程\n3.  \n   * CPU密集型进程\n   * IO密集型进程\n\n进程的层次结构：\n\n* Unix进程家族树：init为根\n* Windows：地位相同\n\n进程和程序的区别：\n\n* 进程更准确刻画并发\n* 程序是静态的，进程是动态的\n* 进程由生命周期，程序相对长久\n* 一个程序可以对应多个进程\n* 进程可以创建其它进程，程序不行\n\n进程映像 image： 进程执行活动全过程的静态描述，程序+数据+栈（用户栈+内核栈）+PCB\n\n上下文context 切换： CPU硬件状态从一个进程切换到另一个进程的过程\n\n> 进程运行时硬件状态保存在CPU的寄存器，当进程不运行时，寄存器的值要保存到PCB中\n\n#### 线程的引入\n\n引入原因：\n\n* 应用需要 （打字与排版与存盘、web服务器）\n* 开销考虑\n  * 线程开销小\n    * 创建新线程花费时间少\n    * 线程切换花费时间少\n    * 线程通信无需调用内核，直接共享资源\n* 性能考虑：多处理器处理多线程\n\n线程的基本概念\n\n线程集成了CPU调度单位\n\n进程还是资源拥有者\n\n线程 thread：进程中的一个运行实体，是CPU的调度单位，也称轻量级进程\n\n属性：\n\n* 有标识符ID\n* 有状态及状态切换\n* 不运行时需要保存上下文\n* 有自己的栈和栈指针\n* 共享所在进程的地址空间和其他资源\n* 可以创建、撤销另一个线程，程序一开始是单线程执行\n\n#### 线程机制的实现\n\n* 用户级线程 （unix）\n  * 在用户空间建立线程库\n  * 通过 运行时系统（run-time system）完成管理工作\n  * 内核管理、进程都不知道线程的存在\n  * 线程切换不需要内核态特权，不需要操作系统干预\n  * 优点：\n    * 线程切换快\n    * 调度算法是应用程序特定的\n    * 可运行在任何操作系统上\n  * 缺点：\n    * 内核只分配处理器给进程，同一进程两线程不能同时运行于两个处理器\n    * 系统调用大多是阻塞的，内核阻塞进程时所有线程也被阻塞\n* 核心级线程 （windows）\n  * 内核管理所有线程，向应用程序提供API\n  * 内核维护线程和进程\n  * 线程切换需要内核\n  * 以线程为单位进行调度\n* 混合模型：\n  * 线程在用户空间创建\n  * 线程调度在核心态完成\n\n### 处理器调度\n\n教材重点：\n\n* 第二章： 2.4\n* 第11章： 11.4.3\n\n重点：\n\n* 掌握处理器调度的相关概念：\n  * 调度时机、进程切换\n  * 调度标准：吞吐量、周转时间、响应时间\n  * 优先级/优先数、 抢占/非抢占、 IO型与CPU型\n* 掌握主要的调度算法：\n  * 先来先服务、短作业有限、最高响应比优先\n  * 时间片轮转、最高优先级\n  * 多级反馈队列\n* 了解Windows、多处理器调度的基本思想\n\n#### 处理器调度的相关概念\n\nCPU调度：控制、协调进程对CPU的竞争，按一定调度算法从就绪队列中选一个进程把CPU使用权交给被选中进程\n\n若没有就绪进程，系统会安排系统空闲进程或idle进程\n\n三个问题：\n\n* 按什么原则选择下一个进程：调度算法\n* 何时选择：调度时机\n* 如何让被选中进程上CPU运行：调度过程（进程上下文切换）\n\n调度时机： 内核对中断、异常、系统调用处理后返回用户态时\n\n * 进程正常终止或因错误终止\n * 新进程创建、等待进程变成就绪\n * 进程从运行态进入阻塞态\n * 进程从运行态进入就绪态\n\n调度过程：\n\n* 进程切换：一个进程让出CPU，另一个进程使用CPU\n  * 包括对原进程状态的保存，和对新进程状态的恢复\n  * 过程\n    * 切换全局页目录以加载新的地址空间\n    * 切换内核栈和硬件上下文\n  * 开销：\n    * 直接开销：内核完成切换所用的CPU时间\n      * 保存、恢复寄存器\n      * 切换地址空间\n    * 间接开销\n      * 高速缓存、缓冲区缓存、TLB失效\n\n调度算法的设计：\n\n* 衡量指标：\n  * 吞吐量 throughput： 单位时间完成的进程数目\n  * 周转时间 TT turnaround time：进程从提出请求到运行完成的时间\n  * 响应时间 RT response time：提出请求到第一次回应的事件\n  * CPU利用率：CPU有效工作的时间\n  * 等待时间：进程在就绪队列中等待的时间\n\n![调度算法设计](http://ot1c7ttzm.bkt.clouddn.com/schedulalgo.png)\n\n#### 调度算法的设计\n\n优先级：\n\n * 优先级与优先数\n * 静态与动态\n\n占用CPU的方式：\n\n* 抢占式 preemptive：\n  * 有优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU\n* 不可抢占式 non-preemptive：\n  * 除非因自身原因不能运行，否则进程会一直运行下去\n\n进程按执行过程行为划分：\n\n* IO密集型 IO-bound\n* CPU密集型 CPU-bound\n\n时间片： time slice 或 quantum：\n\n * 分配给调度上CPU的进程的时间段\n\n#### 批处理中的调度算法\n\n* 先来先服务 FCFS  first come first serve：\n  * 按进程就绪先后顺序使用CPU\n  * 非抢占式\n  * 优点： 公平、实现简单\n  * 缺点：短进程需要等长时间\n* 最短作业优先 SJF shortest job first：\n  * 最短完成时间的进程优先\n  * 非抢占式\n  * 改善短作业的周转时间\n  * 优点：最短平均周转时间（所有进程同时可运行时）\n  * 缺点：不公平，长任务饥饿现象 starvation\n* 最短剩余时间优先 SRTN  shortest remaining time next：\n  * 最短作业优先的抢占版本\n* 最高响应比优先 HRRN  highest response ratio next\n  * 调度时，先计算每个进程的响应比R，总选择R最高的进程\n  * R = $\\frac{周转时间}{处理时间}$ =  $1+\\frac{等待时间}{处理时间}$ \n\n#### 交互式系统采用的调度算法\n\n* 轮转调度 RR round robin\n  * 目标：为短任务改善平均响应时间\n  * 思路：\n    * 周期性切换\n    * 每个进程一个时间片\n    * 时钟中断 -> 轮换\n  * 时间片选择：\n    * 太长：短进程响应时间长\n    * 太短：切换开销大\n  * 优点：公平、利于交互式计算\n  * 缺点：进程切换使得轮转开销大、对大小相近的进程不利、对IO型进程不利\n* 最高优先级调度 HPF highest priority first：\n  * 通常： 系统进程优先于用户进程、前台进程优先于后台，偏向于IO型进程\n  * 优先级反转问题 priority inversion（基于优先级的抢占式时）：低优先级进程占有高优先级进程需要的资源\n    * 影响： \n      * 系统错误\n      * 高优先级进程停滞不前\n    * 解决方案：\n      * 设置优先级上限（临界区的进程优先级最高）\n      * 优先级继承（低优先级继承高优先级）\n      * 使用中断禁止（临界区进程不响应中断）\n* 多级反馈队列 Multiple feedback queue：\n  * 设置多个就绪队列，第一级队列优先级最高\n  * 时间片长度不同，级别越低，时间片越大\n  * 每个队列用时间片轮转方式调度\n  * 新进程创建就绪后，进入第一级\n  * 进程用完时间片并放弃CPU，进入下一级就绪队列\n  * 因阻塞放弃CPU的进程从等待队列出来时回到原来就绪队列\n* 最短进程优先 Shortest process next\n\n![调度算法总结](http://ot1c7ttzm.bkt.clouddn.com/schedulalgo1.png)\n\n多处理器调度算法设计：\n\n* 不仅选择哪个进程，还要选择在哪个CPU\n* 考虑进程在多个CPU迁移的开销\n* 负载均衡问题\n\n#### Windows 线程调度\n\n调度单位是线程\n\n采用基于动态优先级、抢占式调度，结合时间配额的调整\n\n引发线程调度的条件：\n\n* 线程优先级改变\n* 线程改变了亲和affinity处理机集合\n* 正常调度条件（4条）\n\n32个优先级，分三类：\n\n* 实时优先级：不改变优先级\n* 可变优先级：在一定范围内可变\n* 系统线程\n\n时间配额：配额单位的整数，不是时间长度值\n\n调度策略：\n\n* 主动切换\n* 抢占： \n  * 被抢占线程：\n    * 实时优先级：时间配额重置\n    * 可变优先级：时间配额不变\n* 时间配额用完\n  * A优先级未降低：A进入原就绪队列末尾\n  * A优先级降低\n\n### 同步机制\n\n重点：\n\n* 基本概念：\n  * 竞争条件、临界区\n  * 进程同步、互斥\n  * 自旋锁（忙等待）\n* 信号量，PV操作\n* 经典问题模型及解决方案\n  * 生产者消费者问题，读者写者问题\n\n教材：\n\n* 第2章： 2.3.1~2.3.5， 2.5.2\n\n#### 进程互斥\n\n竞争条件 race condition： 两个或多个进程读写某些共享数据，最后结果取决于进程的精确时序\n\n进程互斥 mutual exclusive：共享资源需要排他性使用，各进程之间竞争使用这些资源\n\n临界资源、共享资源、互斥资源 critical resource： 某些资源一次只允许一个进程使用\n\n临界区（互斥区）：critical section：各个进程中对临界资源实时操作的程序片断\n\n临界区的使用原则：\n\n* 没有进程在临界区时，想进入的可以进入\n* 不允许两个进程同时处于临界区\n* 临界区外的进程不得阻塞其他进程进入临界区\n* 不得使进程在临界区外无限等待\n\n解决方案：\n\n* 软件：\n  * dekker解法\n  * peterson解法\n* 硬件：\n  * 屏蔽中断\n  * TSL（XCHG）指令\n\n忙等待 busy waiting：进程得到临界区访问权之前，持续测试\n\n* 自旋锁 spin lock （多处理器）\n* 为什么不直接切换进程： 临界区使用时间一般很短，切换进程的开销更大\n\n优先级反转（倒置）：由于临界区保护带来的问题\n\n#### 软件解法\n\n解法1：\n\n* 用free作为标志：临界区是否空闲\n  * true：有进程在临界区\n  * false：无进程在临界区\n  * 初始值：false\n* 使用 lock(),unlock()作为原语\n\ndekker算法：\n\n* 引入turn变量，判断是否轮到自己\n\npeterson算法：\n\n* 解决了互斥访问的问题，而且克服了强制轮流的缺点\n* 通过 enter_region()  和 leave_region()函数\n* while( turn==process && interested[other]==TURE );\n\n#### 硬件解法\n\n通过指令完成\n\n解法1：中断屏蔽方法\n\n* 使用  开关中断 指令 （特权指令）\n* 入临界区： 执行 关中断 指令\n* 出临界区： 执行 开中断 指令\n* 优点：简单高效\n* 缺点：\n  * 代价高，限制CPU并发能力\n  * 不适用于多处理器\n  * 适合操作系统，不适合用户进程\n\n解法2：测试并加锁 指令：\n\n* TSL指令：TEST AND SET LOCK\n* 复制 锁 到寄存器 并把锁置为1（上锁）\n* 判断寄存器是不是0\n  * 若不是0，跳转到enter_region（反复循环）\n  * 若是0，返回，进入临界区\n\n解法3： 交换 指令：\n\n* XCHG指令：EXCHANGE\n* 寄存器设置为1，交换寄存器和锁的内容，判断寄存器是否是0（与TSL类似）\n\n#### 进程同步\n\n进程同步 synchronization：多个进程中发生的事件存在某种时序关系，需要合作\n\n生产者、消费者问题（有界缓冲区）：\n\n* 一个或多个生产者生产某种数据放在缓冲区\n* 有消费者从缓冲区中取数据，每次取一项\n* 只能有一个生产者或一个消费者对缓冲区进行操作\n* 问题：\n  * 缓冲区满时，生产者不添加数据\n  * 缓冲区空时，消费者不移走数据\n* 避免忙等待\n  * 睡眠 与 唤醒 操作（原语）\n\n\n#### 信号量及P、V操作\n\n典型的进程同步机制\n\n信号量：特殊的变量，用于进程间传递信息的整数值 （count、queue）\n\n可执行的操作： 初始化、 P（test） 、 V（increment）\n\nP操作： 测试\n\n* 把信号量的值减一\n* 判断信号量是否 < 0 ：\n  * <0：该进程状态为阻塞态，插入等待队列 s.queue末尾，重新调度\n  * false：执行进程\n\nV操作：\n\n* 信号量的值+1\n* 判断信号量是否<=0:\n  * true ：唤醒s.queue的一个进程，插入就绪队列\n\nP、 V操作是原语操作 primitive or atomic action\n\n最初提出：二元信号量（解决互斥）\n\n推广：一般信号量（解决同步）\n\n用PV解决互斥问题：\n\n* 分析并发进程关键活动，划定临界区\n* 设置信号量 mutex，初始值为1\n* 临界区前实施 P\n* 临界区后实施 V\n\n用PV解决生产者消费者问题：\n\n* 用full、empty两个变量记录满缓冲区和空缓冲区数目\n* 分别用P、V操作维护full和empty\n* 用 mutex 维护互斥，防止同时读写buffer![PV](http://ot1c7ttzm.bkt.clouddn.com/PV.png)\n* 两边的P操作顺序不可逆，必须先判断empty或full才能判断mutex（因为P操作可能使进程进入阻塞态）\n* 两边的V操作顺序可逆\n* 位置：尽可能缩小临界区\n\nPV操作解决读者、写者问题：\n\n* 多个进程共享一个数据区，分为两组：\n\n  * 读者进程：只读数据区数据\n  * 写者进程：只写数据区数据\n\n* 条件：\n\n  * 允许多个读者同时读\n  * 不允许多个写者同时操作\n  * 不允许读写同时\n  * （读写互斥，写者之间互斥）\n\n* Linux提供的读写锁：\n\n* 第一类读者写者问题：读者优先：\n\n  * 若有写者在等，有其他读者在读，则新读者可以读\n  * 有读者在读，写者等待\n  * 解法：\n    * 第一个读者做P操作，最后一个读者做V操作\n\n  ​\n\n\n### 同步机制（2）\n\n重点：\n\n* 管程：\n  * 如何保证互斥\n  * 如何保证同步：条件变量及wait、signal\n  * HOARE管程\n  * MESA管程\n* 进程间通信：\n  * 消息传递、共享内存、管道\n* Pthread中的同步机制\n* Linux的IPC机制\n\n教材：\n\n* 第二章： 2.3.6～ 2.3.9\n\n#### 管程 monitor\n\n出现原因： 信息量机制不足：程序编写困难、易出错（PV操作的位置）\n\n解决：在程序设计语言中引入管程成分：高级同步机制\n\n定义：\n\n* 一个特殊的模块\n* 每个管程有一个名字\n* 管理共享资源的数据结构及其上操作的一组过程组成\n\n进程与管程： 进程只能通过调用管程中的过程来间接访问管程的数据结构\n\n管程解决的问题：\n\n* 互斥：\n  * 管程是互斥进入的：为了保证管程中数据结构的数据完整性\n  * 互斥性由编译器负责保证\n* 同步：\n  * 管程中设置条件变量及等待、唤醒操作以解决同步问题\n  * 可以使一个进程或线程在条件变量上等待或唤醒\n\n使用管程的问题：\n\n* 进入管程的操作执行唤醒操作（P唤醒Q）：\n  * 规定唤醒操作为管程中最后一个可执行的操作\n  * P等待，Q执行 （HOARE管程）\n  * Q等待，P继续执行（MESA管程）\n\nHOARE管程：\n\n* 管程内增加紧急等待队列，P唤醒Q后P进入紧急等待队列（优先级高于入口等待队列）\n* 管程外有入口等待队列\n* 条件变量：在管程内部说明和使用的一种特殊类型的变量\n  * wait操作：紧急队列非空，则唤醒第一个等待者，否则释放管程互斥权，执行该操作的进程进入c链末尾\n  * signal：c链为空则相当于空操作，否则唤醒第一个等待者，执行该操作的进程进入紧急等待队列\n* 缺点：\n  * 两次额外的进程切换\n\n管程的实现：\n\n* 直接构造：效率高\n* 间接构造：用某种已经实现的同步机制构造（如信号量及PV操作）\n\n\nMESA管程：（P唤醒Q，P继续执行）\n\n* signal -> notify： notif(x)使得x条件队列得到通知，发信号的进程继续执行\n* notify的结果：条件队列头的进程在将来合适的时候恢复执行\n* 不能保证在它之前没有其他进程进入管程，因此进程必须重新检查条件：用while循环取代if语句检查条件\n* 导致对条件变量至少多一次额外检测，对等待进程什么时候执行没有限制\n* 对notify的改进：\n  1. 每个条件原语关联计时器，超过一定等待时间的进程直接进入就绪态\n  2. broadcast：所有在该条件上等待的进程都被释放且进入就绪序列\n\nHOARE和MESA的比较：\n\n* MESA一般优于HOARE：MESA错误较少\n* MESA：每个过程收到信号后重新检查管程变量，且使用while\n\n#### PTHREAD中的同步机制\n\n通过互斥量保护临界区： Pthread_mutex\n\n解决同步问题：条件变量： wait \\ signal \\ broadcast\n\n#### 进程间通信机制\n\n原因：\n\n* 信号量和管程的不足\n* 不适合多处理器的情况\n\n进程通信机制：消息传递：send & receive 原语\n\n适用于： 分布式系统、单处理器系统、共享内存的多处理器系统\n\n通信方式：\n\n* 消息传递\n  * 操作系统空间设置消息缓冲区：\n    * 消息头（消息类型，进程ID：发送、接收，消息长度，控制信息）\n    * 消息体\n  * 发送原语，由操作系统完成\n  * 过程：陷入内核、复制消息、消息入队（接收进程的PCB消息队列指针）、复制消息\n  * 通过PV操作实现\n* 共享内存\n  * 需要解决两个问题：\n    * 物理内存中建立共享空间，并建立两个进程的地址空间到内存的映射\n    * 读者写者问题\n* 管道 pipe：\n  * 利用缓冲传输介质：内存或文件连接两个进程\n  * 问题：\n    * 字符流方式写入读出\n    * 先入先出顺序\n    * 管道通信必须提供协调能力：互斥、同步、判断对方进程是否存在\n* 套接字\n* 远程过程调用\n\n#### 典型操作系统的IPC机制\n\nlinux的进程通信机制：\n\n* 用户程序：管道、消息队列、共享内存、信号、套接字\n* 内核同步机制：原子操作、自旋锁、读写锁、信号量、屏障\n\n原子操作：\n\n* 不可分割，不会被打断\n* 常用于资源计数\n\n屏障 barrier：\n\n* 同步机制\n* 用于对一组线程进行协调，要求所有线程到达一个汇合点后一起向前\n\n\n### 存储模型（1）\n\n重点：\n\n* 地址重定位\n* 基本内存管理方案\n* 物理内存管理技术\n* 交换技术\n\n教材：\n\n* 第3章 3.1、 3.2\n\n#### 地址重定位\n\n进程中的地址不是最终的物理地址\n\n进程运行前无法计算出物理地址\n\n地址重定位：\n\n* 逻辑地址（相对地址、虚拟地址）：\n  * 用户程序经过编译汇编后形成目标代码，首地址为0，其它地址相对于首地址编址\n  * 不能用逻辑地址在内存中读取信息\n* 物理地址（绝对地址，实地址）：\n  * 内存存储单元的地址，可直接寻址\n* 概念：需要将用户程序的逻辑地址转换为可由其直接寻址的物理地址\n* 分类：\n  * 静态重定位：\n    * 用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换\n    * 一般由软件完成\n  * 动态重定位：（常用）\n    * 进程执行过程中进行地址变换：逐条指令执行时完成地址转换\n    * 需要硬件部件支持（部件：内存管理单元MMU memory management unit）\n\n#### 物理内存划分\n\n空闲内存管理：\n\n* 等长划分：\n  * bitmap 位图：每个分配单元对应一位\n* 不等长划分：\n  * 空闲区表、已分配区表：表中每一项记录起始地址、长度、标志\n  * 空闲块链表：每个表项用链相连\n\n内存分配算法：\n\n* 首次适配 first fit：空闲区表第一个满足进程要求的空闲区\n* 下次适配 next fit：从上次找到的空闲区接着找\n* 最佳适配 best fit：查找整个表，找到满足要求的最小空闲区\n* 最差适配 worst fit：总分配满足进程要求的最大空闲区\n\n空闲区划分：一部分供进程使用，一部分作为新的空闲区\n\n回收问题：\n\n* 内存回收算法：\n  * 某一块归还后，空闲空间合并，修改空闲区表\n  * 四种情况：\n    * 上相邻、下相邻、上下都相邻、上下都不相邻\n\n伙伴系统：\n\n* linux底层内存管理采用\n* 经典的内存分配方案\n* 主要思想： 内存按2的幂划分，组成空闲块链表，查找最佳匹配\n* 算法：\n  * 首先将整个空间看做一块 $2^U$\n  * 假设进程申请空间大小为s，若满足 $ 2^{U-1}<s<=2^U $则分配整个块\n  * 否则把块划分成两个大小相等的伙伴 $2^{U-1}$\n  * 一直划分直到产生大于等于s的块\n* 进程使用完后归还空间，空间进行可能的合并\n\n#### 基本内存管理方案（1）\n\n整个进程进入内存连续区域\n\n以进程为单位装载\n\n方案：\n\n* 单一连续区：\n  * 特点：一段时间内只有一个进程在内存\n  * 简单，但内存利用率低\n* 固定分区：\n  * 分区：内存空间分割\n  * 分区固定不变，大小可以相同也可以不同\n  * 一个分区装一个进程\n* 可变分区：\n  * 根据进程需要把空闲空间分割，分配进程，剩余部分成为新的空闲区\n  * 缺点：有外碎片(进程之间的小空闲空间无法分配)，导致内存利用率下降\n  * 碎片：很小的，不易利用的空闲区\n  * 问题解决：紧缩技术 memory compaction：\n    * 在内存移动程序把小空闲区合并：\n    * 需要考虑：\n      * 系统开销\n      * 移动时机\n\n#### 基本内存管理方案（2）\n\n一个进程进入内存中若干不连续区域\n\n方案：\n\n* 页式存储管理：\n  * 用户进程被划分为大小相等的部分称 页 page 或页面\n  * 内存空间按同样大小分区域，称页框 page frame\n  * 内存分配：\n    * 以页为单位分配，按进程需要的页数分配\n    * 逻辑相邻的页，物理上不一定相邻\n  * 典型页面尺寸： 4K或4M\n  * 逻辑地址： 页号+页内地址\n  * 页表：\n    * 页表项：记录逻辑地址和物理地址的映射关系\n    * 每个进程一个页表，一般放在内存\n  * 空闲内存管理：bitmap\n  * 地址转换：硬件支持：\n    * 逻辑地址，CPU自动划分为页号和页内地址，用页号查页表得到页框号，再与页内偏移拼接成物理地址\n  * 内碎片：页框内浪费空间\n* 段式存储方案：\n  * 按程序逻辑划分若干程序段，每个段一个段名\n  * 内存空间被动态划分为长度不同的区域，称为物理段\n  * 以段为单位进行划分，每段占连续空间，段之间可以不相邻\n  * 逻辑地址 = 段号+段内地址 ， 无法自动划分\n  * 段表： 记录每段长度和段起始地址，存放在内存\n  * 物理内存管理：空闲区表\n  * 地址转换：硬件支持：\n    * 逻辑地址，用段号查段表，得到起始地址，与段内偏移地址计算出地址\n* 段页式存储方案：\n  * 综合页式，段式优点\n  * 先按段划分，每个段按页划分\n  * 逻辑地址：段号+页号+页内地址\n  * 内存划分：同页式存储方案\n  * 内存分配：以页为单位分配\n  * 段表： 记录每一段页表起始地址和长度\n  * 页表：逻辑页号和页框的对应关系\n  * 一个进程一个段表多个页表，一个段表一个页表\n  * 空闲区同页式管理\n\n#### 交换技术 swapping\n\n内存不足时的解决方案，当大的地址空间装不进小的内存空间\n\n内存”扩充“技术\n\n* 内存紧缩技术（可变分区）\n* 覆盖技术 overlaying：（早期操作系统）\n  * 程序大小超过物理内存总和\n  * 程序不同部分在内存中相互替代，把不会同时执行的程序段共享同一内存区域\n  * 要求程序各模块有明确的调用结构\n  * 程序员声明覆盖结构，操作系统完成自动覆盖\n  * 缺点：用户不透明，增加用户负担\n* 交换技术 swapping：\n  * 系统把内存中某些进程暂时移到外存，把外存某些进程换入内存\n  * 问题：\n    * 进程哪些内容要交换：运行中创建或修改的内容：栈和堆\n    * 磁盘什么位置保存：交换区swap space：一块特殊的区域，包含连续的磁道，操作系统通过底层的磁盘读写操作对其高效访问\n    * 交换时机：只要不用就换出； 内存空间不足或即将不足时\n    * 如何选择被换出的进程：不应换出处于等待IO状态的进程\n    * 如何处理进程空间增长：预留空间给数据段、栈增长\n* 虚拟存储技术 virtual memory\n\n\n### 存储模型（2） 虚拟存储\n\n重点：\n\n* 虚拟存储技术\n* 虚拟页式存储方案的实现：\n  * 多级页表、翻转页表、页表项、地址转换、MMU、快表TLB、页错误、缺页异常处理\n* 软件策略：\n  * 驻留集、置换范围、清除策略\n  * 置换算法：OPT、FIFO、第二次机会、时钟算法、LRU、老化、工作集\n* 虚存相关的软件技术：内存映射文件、写时复制\n\n教材：\n\n* 第三章：3.3、 3.4、 3.5.1、 3.5.7、 3.5.8、 3.6.1\n\n#### 虚拟存储技术\n\n定义： 进程运行时，一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成从磁盘调入内存的工作\n\n虚拟地址空间：分配给进程的虚拟内存\n\n虚拟地址：虚拟内存中指令或数据的位置\n\n虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用\n\n大小限制：寻址空间和磁盘大小\n\n地址保护：（硬件）\n\n* 确保每个进程都有独立的地址空间\n* 确保进程访问合法的地址范围： 基地址寄存器+界限寄存器\n* 确保进程的操作是合法的\n\n虚拟页式paging：\n\n* 虚拟存储技术+页式存储方案\n* 基本思想：\n  * 进程开始前装入一个或0个页面\n  * 根据进程需要动态装入其他页面\n  * 当内存空间满，又需要装入新的页面，则根据置换算法置换某个页面，以装入新的页面\n* 方式：\n  * 请求调页 demand paging\n  * 预先调页 prepaging\n* 用CPU时间和磁盘空间换内存空间\n\n#### 页表和页表项的设计\n\n页表由页表项组成：\n\n* 页框号：内存块号、物理页面号\n* 有效位：表示该页在内存还是在磁盘\n* 访问位R：引用位，表示这个页被访问过\n* 修改位M：表示该页在内存中是否被修改过\n* 保护位：读 / 可读写\n\n通常页表项是硬件设计的\n\n页表在内存不应该连续存放，因此需要引入页表页的地址索引表：页目录 page directory\n\n二级页表：\n\n* 虚拟地址： 页目录偏移+页表偏移+页内偏移\n* 可以表示4G的虚拟地址\n* 从页目录地址寄存器得到页目录首地址，加上页目录偏移得到页表首地址，加上页表偏移得到在第i个页表的页框号，页框号+页内偏移得到物理地址\n* ![虚存页表](http://ot1c7ttzm.bkt.clouddn.com/virtualpage.png)\n\n反转页表（倒排页表）：\n\n* 每个进程一张页表过于庞大\n* 从物理地址空间出发，系统建立一张页表\n* 页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系\n* 解决从虚拟地址到物理地址的映射：虚拟地址页号部分映射到散列值，散列值指向一个反转页表\n\n#### 地址转换过程和TLB引入\n\n虚拟地址到物理地址映射： MMU 内存管理单元\n\n快表 TLB translation look-aside buffers的引入：\n\n* 原因：\n  * 页表需要进行多次内存访问\n  * CPU指令处理速度和内存指令访问速度差异大\n* 程序访问的局部性原理\n* CPU中引入的高速缓存（cache），随机存取型存储器组成\n* 有特殊的接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较\n* 相联存储器 associative memory：特点：按内容并行查找\n* 保存正在运行进程的页表的子集\n\n\n页错误：page fault\n\n* 地址转换过程中硬件产生的异常\n* 具体原因：\n  * 缺页异常：所访问的虚拟页面没调入物理内存\n  * 违反权限：读/写、用户/内核\n  * 错误的访问地址\n* 处理缺页异常：\n  * 地址映射过程中，硬件检查页表发现所要页面不在内存\n  * 操作系统执行缺页异常处理程序：获得磁盘地址、启动磁盘、将该页调入内存：\n    * 内存中有空闲页框，修改页表中相应页表项的有效位和页框号\n    * 内存中没有空闲页框，置换某一页，若该页修改过，还需要写回磁盘\n\n#### 软件相关策略\n\n驻留集：\n\n* 操作系统给每个进程分配页框数目\n* 策略：\n  * 固定分配策略：\n    * 进程创建时确定\n    * 可以根据进程类型或程序员或系统管理员需要确定\n  * 可变分配策略：\n    * 根据缺页率评估进程局部性表现\n    * 带来额外系统开销\n\n页框锁定：\n\n* 为什么要锁定页面：虚存技术使得进程运行时间不确定\n* 给每一页框增加一个锁定位\n* 不让操作系统将进程换出内存\n* 如：操作系统核心代码，关键数据结构，IO缓冲区\n\n置换问题：\n\n* 置换范围：\n  * 置换集合是局限于产生缺页中断的进程，还是所有进程的页框\n  * 策略：\n    * 局部置换：只在产生本次缺页的进程的驻留集中选择\n    * 全局置换：将内存中所有未锁定的页框都作为置换的候选\n* 置换策略：\n  * 选择换出哪个页框\n  * 目标：置换最近最不可能访问的页\n  * 局部性原理：基于过去行为来预测将来行为\n  * 但策略设置越复杂，实现时软硬件开销越大\n  * 约束：不能置换锁定的页框\n\n清除策略：\n\n* 清除：从进程驻留集中集中回收页框（进程运行过程中回收）\n* 需要在系统中保持一定数目空闲页框，使得系统在最佳状态工作\n* 分页守护进程 paging daemon：\n  * 大部分时间睡眠，定期唤醒检查内存状态\n  * 若空闲页框数过少，该进程通过页面置换算法换出内存\n  * 若页面被修改过，则写回磁盘，以保证所有空闲页框是干净的\n* 页缓冲技术：\n  * 不丢弃置换出的页，放入两个表之一：空闲链表和修改链表\n  * 修改链表定期写回磁盘\n  * 被置换的页仍在内存，一旦进程又要访问，则可以迅速将它加入进程的驻留集合\n\n#### 置换算法 replacement\n\n颠簸 thrashing：页面在内存和磁盘间调度的事件多于实际运行的时间\n\n影响缺页次数的因素：\n\n* 置换算法\n* 页面大小：\n  * 内部碎片\n  * 页表长度\n  * 辅存的物理特性\n* 程序编制问题\n* 分配给进程的页框数目\n\n最佳页面置换算法 OPT：\n\n* 置换以后不再需要或最远的将来才会用到的页面\n* 无法实现\n* 作用：作为一种标准来衡量其他算法性能\n\n先进先出 FIFO：\n\n* 选择在内存中驻留时间最长的页并置换\n* 实现：页面链表法\n\n第二次机会算法 SCR second chance：\n\n* 按先进先出选择页面，检查其访问位R，若为0，则置换，若为1，则给第二次机会并把R置位0\n\n时钟算法 CLOCK：\n\n* SCR的改进，把链表改成环，用指针指向当前要置换的页\n\n最近未使用算法 NRU：\n\n* 最近未使用的一页\n* 实现：根据页表项的两位：访问位R，修改位M（若硬件没有这两位，则用软件模拟）\n* R位定期清零\n* 优先级：\n  * 1 最低：R=0，M=0，无使用，未修改\n  * 2： R=0，M=1\n  * 3： R=1，M=0\n  * 4： R=1，M=1\n* 时钟算法实现：\n  * 环状链表，选中遇到第一个R=0，M=0,用于置换\n  * 若没有，则扫描第一个 R=0，M=1，对每个跳过的页框，把R置为0\n  * 若仍没有，重新扫描R=0，M=0\n  * 若仍没有，则扫描 R=0，M=1\n\n最近最少使用 LRU：\n\n* 置换未使用时间最长的一页\n* 性能最接近 OPT 最佳算法，使用最多\n* 实现： 开销大，需要维护时间戳或访问页的栈\n\n最不经常使用 NFU：\n\n* LRU的一种软件解决方案（自说）\n* 选择访问次数最少的页面置换\n* 实现：\n  * 软件计数器，每一个页一个，初值为0\n  * 每次事件中断，计数器加该页的R\n  * 缺页中断时，选择计数器最小的置换\n\n老化算法 AGING：\n\n* 对NFU的改进（模拟LRU）：\n* 计数器在加R前先右移一位（除以2），R加到计数器最左端\n\nBELADY现象：\n\n* 页框数目多，缺页次数反而多\n\n工作集working set 算法：\n\n* 程序局部性： 活跃页面：进程一段时间中集中访问的页面\n* 为进程提供和活跃页面数相等的物理页面数，则可以减少中断次数\n* 工作集：当前正在使用的页框集合， W(t, delta)=该进程在时刻 t 过去 delta 事件单位中访问的页面的集合\n* 核心思想：找出一个不在工作集的页面并置换它\n* 思路：\n  * 每个页表项记录该页面最后一次被访问的时间\n  * 设置时间T\n  * 判断：根据一个页面访问时间在 当前时间-T 之前或之中决定其在工作集之内还是之外\n* 实现：扫描所有页表项：\n  * 若 R=1，则把其最后一次访问时间设置为当前时间，R清零\n  * R=0，则检查访问时间是否在 当前时间-T 之前（不在工作集）\n    * 若是，则置换\n    * 若不是，则记录最后访问时间的最小值\n\n![置换算法](http://ot1c7ttzm.bkt.clouddn.com/replacement.png)\n\n#### 其他技术\n\n内存映射文件：\n\n* 进程通过系统调用 mmap 将文件或部分 映射到虚拟地址空间的一部分，访问该文件就像访问内存中的大数组，而不是对文件进行读写\n* 不会实际读入页面，在访问页面时才会被读入内存\n* 进程退出或显示解除文件映射时，修改写回磁盘\n\n写时复制技术：\n\n* 多个进程共享页面，页标志为写时复制\n* 进程试图改变页面数据时，操作系统复制一个页面，对执行写操作的进程是私有的\n\n\n### 文件系统（1）\n\n重点：\n\n* 文件系统相关概念：文件、文件分类、文件逻辑结构和物理结构\n* 文件目录的实现：文件控制块FCB、目录项、目录文件\n* 文件系统的实现：磁盘布局、内存树结构\n* 磁盘空间的管理：存储介质、扇区、物理块block、簇cluster\n\n教材：\n\n* 第四章：4.1、 4.2、 4.3、 4.5.3\n\n#### 文件与文件系统\n\n文件 是 对磁盘的抽象\n\n文件：一组带标识的、在逻辑上有完整意义的信息项的序列\n\n信息项：构成文件内容的基本单位（单个字节或多个字节），各信息项之间有顺序关系\n\n文件内容的意义：由文件建立者和使用者解释\n\n文件系统：操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供共享和保护手段：\n\n* 统一管理磁盘空间，实施磁盘空间分配和回收\n* 实现文件按名存取（名字空间 -> 映射 -> 磁盘空间）\n* 实现文件信息的共享\n* 向用户提供方便使用和维护的接口\n* 提高文件系统性能\n* 提供与IO系统的统一接口\n\n文件分类：（UNIX）：按文件性质和用途\n\n* 普通文件\n* 目录文件\n* 特殊文件（设备文件）：设备作为文件处理，分为字符设备或块设备\n* 管道文件\n* 套接字\n\n文件的逻辑结构：\n\n* 由用户的访问方式决定\n* 典型文件逻辑结构：\n  * 流式文件：文件是有逻辑意义、无结构的一串字符的集合\n  * 记录式文件：文件由若干记录组成，可以按记录读写查找等\n* 文件存取：\n  * 顺序存取（访问）\n  * 随机存取（访问）：提供读写位置\n\n#### 文件的存储介质\n\n典型存储介质：磁盘、磁带、光盘、U盘\n\n物理块：\n\n* 信息存储、传输、分配的独立单位\n* 存储设备划分为大小相等的物理块，统一编号\n\n典型磁盘结构：\n\n* 任何时刻只有一个磁头处于活动状态：输入输出数据流以位串形式出现\n* 物理地址形式：磁头号、磁道号、扇区号\n\n磁盘访问：\n\n* 寻道：磁头移动到指定磁道\n* 旋转延迟：等待指定扇区\n* 数据传输：数据在磁盘和内存之间实际传输\n\n磁盘空间管理：\n\n* 数据结构：\n  * 位图：用二进制位反应块的分配情况，0为已经分配，1为空闲\n  * 空闲块表：所有空闲块记录在一张表\n  * 空闲块链表：**成组链接法**\n  * ![成组链接法](http://ot1c7ttzm.bkt.clouddn.com/grouplink.png)\n\n#### 文件属性\n\n文件控制块 file control block：为了管理文件而设置的数据结构，保存所需要等待有关信息\n\n文件目录：\n\n*  统一管理每个文件的元数据，以支持文件名到文件物理地址的转换\n*  将所有文件的管理信息组织在一起\n\n目录文件：文件目录以文件的形式存放在磁盘上\n\n目录项：\n\n* 构成文件目录的基本单元\n* 目录项可以是FCB，目录是文件控制块的有序集合\n\n#### 文件的物理结构\n\n文件在存储介质的存放方式\n\n结构：\n\n* 连续（顺序）结构：\n  * 文件的信息在若干连续的物理块中\n  * 优点：\n    * 简单\n    * 支持顺序存取、随机存取\n    * 需要的磁盘寻道次数和寻道时间最少\n    * 可以同时读入多个块，检索一个块也容易\n  * 缺点：\n    * 文件不能动态增长\n    * 不利于文件插入和删除\n    * 会产生外部碎片：紧缩技术\n* 链接结构：\n  * 一个文件的信息存放在若干不连续物理块中，各块用指针相连，前一个物理块指向下一个物理块\n  * 优点：\n    * 提高磁盘空间利用率，不存在外部碎片问题\n    * 利于文件插入、删除\n    * 利于文件动态扩充\n  * 缺点：\n    * 存取速度慢，不利于随机存取\n    * 可靠性问题，如指针出错\n    * 更多寻道时间和寻道次数\n    * 链接指针占用空间\n  * 变形：文件分配表 FAT：记录每个物理块的下一块的索引\n* 索引结构：\n  * 信息存放在若干不连续的物理块中\n  * 系统为每个文件建立一个索引表，块号放在索引表\n  * 索引表就是磁盘块地址数组\n  * FCB放索引表的起始地址\n  * 优点：\n    * 保持链接结构优点，又解决其缺点：\n      * 能顺序和随机存取\n      * 满足文件动态增长、插入删除要求\n  * 缺点：\n    * 寻道次数和寻道时间多\n    * 索引表需要额外空间\n  * 组织方式：\n    * 当索引表很大，需要多个物理块存放时：\n      * 链接方式：一个盘块存一个表\n      * 多级索引\n      * 综合索引：直接索引加间接索引：部分直接索引，指向一个物理块，一部分间接寻址，指向索引表\n  * UNIX 三级索引结构（综合模式）：\n    * 每个文件主索引表放FCB中，有15项，每项2字节\n    * 前12个直接寻址\n    * 第13项指向一级索引表\n    * 第14项作为二级索引表\n    * 第15项作为三级索引表\n    * 最大总文件大小 = 12 + 256 + 256*256 + 256^3 个block\n\n#### 文件系统的实现\n\n需要考虑： 磁盘上 和 内存中 内容布局\n\n磁盘分区 partition：把一个物理磁盘存储空间划分为几个相互独立部分\n\n文件卷 volume：磁盘上的逻辑分区，由一个或多个物理块组成：\n\n* 一个文件卷可以使一个盘或部分盘或跨盘 RAID\n* 同一个文件卷使用同一份管理数据\n* 文件卷上：文件系统信息、一组文件（用户文件+目录文件）、未分配空间\n* 块 block 或 簇cluster：\n\n格式化 format：在一个文件卷上建立文件系统，建立并初始化元数据\n\nUNIX：\n\n * FCB = 目录项 + i节点\n * 目录项 = 文件名+i节点号\n * i节点 = 保存描述文件的相关信息\n\n\n\n\n### 文件系统（2）\n\n重点：\n\n* 文件操作的实现流程\n* 文件系统的可靠性、一致性、写入策略、安全性\n* 提高文件系统性能\n* FAT文件系统的实现\n\n#### 文件操作的实现\n\n创建文件：\n\n* 建立系统和文件的联系，实质是建立文件的FCB\n* 在目录中为新文件建立一个目录项，填写参数\n* 分配必要的存储空间\n* 流程：\n  1. 检查参数合法性（命名规则、重名文件等）\n  2. 申请空闲目录项，填写相关信息\n  3. 为文件申请磁盘块\n\n打开文件：\n\n* 根据文件名在文件目录中检索，找到目录项或FCB\n* 将目录项读入内存，建立相应的数据结构（文件描述符或文件句柄），为后续操作做好准备\n* 流程：\n  1. 给出路径名查目录，找到目录项或i节点号\n  2. 根据文件号查系统打开文件表\n     1. 是 则共享计数加1\n     2. 否 将信息填入系统打开文件表，共享计数为1\n  3. 根据打开方式、共享说明和用户身份检查访问合法性\n  4. 在用户打开文件表获取一个空表项，填写参数，返回文件句柄\n* 指针定位：\n  * 每个进程打开的每个文件维护一个读写指针\n  * 在用户打开文件表中\n\n读文件：\n\n1. 根据打开文件时的文件描述符，找到FCB，确定操作合法性\n2. 把文件的逻辑块号转换成物理块号\n3. 申请缓冲区\n4. 启动磁盘IO操作，把磁盘块内容送到缓冲区，而后送到内存\n\n#### 文件系统的管理\n\n可靠性：\n\n* 抵御和预防各种物理性破坏和人为性破坏的能力\n* 坏块问题\n* 备份：通过转储操作，形成文件或文件系统的多个副本\n\n转储：\n\n* 全量转储：定期拷贝所有文件\n* 增量转储：只转储修改过的文件，两次备份之间的修改\n* 物理转储：从磁盘第0块开始，将所有磁盘块按序输出到磁带\n* 逻辑转储：从指定目录开始，递归转储给定日期后所有更改的文件或目录\n\n文件系统一致性：\n\n* 问题的产生：磁盘块 -> 内存 -> 写回磁盘块，若在写回之前系统崩溃，则文件系统不一致（FCB、目录文件已经更新）\n* 解决方案：设计程序，当系统再次启动时检查磁盘块和目录系统\n* 磁盘块的一致性检查：\n  * 用两张表，每个表项对应一个磁盘块，第一张表记录每个块在文件中出现的次数，第二张表记录在空闲块表中出现的次数\n  * 情况1： 使用块和空闲块相反：正常\n  * 情况2： 使用块和空闲块均为0：把空闲块置1\n  * 情况3： 使用块和空闲块均为1：空闲块置0\n  * 情况4： 使用块为2，空闲为0： 在空闲中寻找一个把多出的文件写入\n\n写入策略：\n\n* write-through：直写：内存中修改立刻返回磁盘：FAT\n* lazy-write：延迟写：利用回写write back缓存的方法增加速度\n* transaction log：可恢复写：利用事务日志实现文件系统写入 ： NTFS，EXT3\n\n访问控制：\n\n1. 主动控制：访问控制表：\n   * 每个文件一张表\n   * 记录用户id和访问权限\n   * 用户可以是一组用户\n   * 文件可以是一组文件\n2. 能力表（权限表）\n   * 每个用户一个\n   * 记录文件名及访问权限\n   * 用户可以是一组用户\n   * 文件可以是一组文件\n\nUNIX文件访问控制：\n\n* 采用文件二级存取控制\n* 第一级：对访问者的识别：\n  * 对用户分类：\n    * 文件主\n    * 文件主的同组用户\n    * 其他用户\n* 第二级：对操作权限的识别：\n  * 对操作分类：\n    * 读 r\n    * 写 w\n    * 执行 x\n    * 不能执行任何操作 -\n\n#### 文件系统的性能\n\n设计文件系统应该尽可能减少磁盘访问次数\n\n方法：\n\n* 目录项FCB分解、当前目录、磁盘碎片整理\n* 块高速缓存 block cache：\n  * 在内存中为磁盘块设置一个缓冲区，保存磁盘某些块的副本\n  * 检查所有读请求，看是否在块高速缓存中\n    * 若在，则直接读\n    * 若不再，先将块拷入块高速缓存，再拷入所需地方\n  * 组织：用hash\n  * 置换：LRU\n  * 写入策略（文件系统一致性）：定期写回磁盘\n* 合理分配磁盘空间：\n  * 分配磁盘块时，有可能顺序存取的块放在一起\n  * 尽可能分配在同一柱面上，从而减少磁盘臂移动次数和距离\n* 磁盘调度：\n  * 有多个访盘请求时，采用一定策略调整顺序\n  * 降低平均磁盘服务时间\n  * 调度算法：\n    * 先来先服务 FCFS\n    * 最短寻道时间优先：优先选择离当前磁头最近的访问请求\n      * 优点：改善平均服务请求\n      * 缺点：饥饿现象\n    * 扫描算法 SCAN （电梯算法）：按一个方向移动，若该方向没有请求，则改变方向\n    * 单向扫描算法 C-SCAN：SCAN的改进：总从0号柱面向里扫描，到达最后一个柱面时，立即返回0号，返回时不服务，返回后再次扫描\n    * N-step-SCAN策略：磁盘请求划分为长度为N的子队列，每一次用SCAN处理一个子队列\n    * FSCAN策略：使用两个子队列，开始时请求在一个队列，扫描时请求加入另一个队列\n    * 旋转调度：根据延迟时间决定执行次序的调度\n* 信息的优化分布：\n  * 记录在磁盘的排列方式\n* 记录的成组与分解：\n  * 若干逻辑记录合成一组存放\n  * 成组操作必须用内存缓冲区，缓存区长度 = 记录长度 * 块因子\n  * 目的：提高空间利用率和工作效率\n* RAID 独立磁盘冗余阵列 技术：\n  * 多块磁盘按一定要求构成一个独立存储设备\n  * 目标：提高可靠性和性能\n  * 组织：\n    * 多个磁盘组织，作为一个逻辑卷\n    * 数据分成多个数据块，并行写入、读出多个磁盘\n    * 通过镜像或校验，提供容错能力（冗余）\n  * 分类：\n    * RAID 0-条带化，数据分布在所有磁盘上，无冗余，性能最佳\n    * RAID 1 - 镜像：利用率 50%，所有数据同时保存在两块盘相同位置，安全性最好\n    * RAID 4 -交错块奇偶校验：带奇偶校验，以数据块为单位 \n\nWindows的文件访问方式：\n\n* 不使用文件缓存\n* 使用文件缓存：\n  * Windows的cache manager实现对缓存的控制：\n    * 读取数据时预取\n    * 在cache满时，根据LRU清除缓存内容\n    * 定期更新磁盘内容使其与cache一致\n  * write-back机制：只更改cache内容，由cache manager定期写回\n* 异步模式：\n  * 不等待磁盘操作的完成\n  * 使CPU和IO并发工作\n\n\n### IO系统\n\n重点：\n\n* IO系统的概念：\n  * IO设备的特点及分类\n  * IO管理的任务\n* IO管理的解决方案\n  * IO硬件组成\n  * IO控制方式\n  * IO软件层次及功能\n* IO相关技术\n* IO性能提高的解决方案\n\n教材：第五章：5.1、 5.2、 5.4\n\n#### IO管理概述\n\nIO设备管理：\n\n* 逻辑IO：统一的操作，与具体设备无关\n* 设备驱动程序\n* 中断服务程序\n\n![IO](http://ot1c7ttzm.bkt.clouddn.com/IO.png)\n\nIO的特点：\n\n* IO性能经常成为系统性能的瓶颈\n* 操作系统庞大复杂的原因之一：IO资源多而杂，并发\n  * 速度差异大\n  * 应用\n  * 控制接口的复杂性\n  * 传送单位\n  * 数据表示\n  * 错误条件\n* 与其他功能密切相关，尤其是文件系统\n\n设备分类：\n\n* 按数据组织分：\n  * 块设备：\n    * 以数据块为单位\n    * 传输速度块，可寻址\n  * 字符设备：\n    * 以字符为单位\n    * 速率低、不可寻址\n* 从资源分配角度：\n  * 独占设备：一段时间只能有一个进程使用，一般低速，如打印机\n  * 共享设备：一段时间可有多个进程共同使用，以交叉方式使用\n  * 虚设备：\n    * 在一类设备上模拟另一类，常用 共享模拟独占、高速模拟低速\n    * 实例：SPOOLing技术，用硬盘模拟输入输出\n\n目标：\n\n* 按用户请求，控制设备的各种操作，完成设备和内存的数据交换\n  * 设备的分配和回收\n    * 记录设备的状态\n    * 根据用户请求和设备类型，采用一定分配算法，选择设备到内存的数据通路\n  * 执行设备驱动程序\n  * 设备中断处理\n  * 缓冲区管理：管理IO缓冲区\n* 建立方便统一的独立于设备的接口：通用性\n  * 方便性：用户编程时不考虑设备的物理特性\n  * 统一性：用户程序使用的是逻辑设备，以屏蔽硬件细节\n* 利用各种技术提高CPU与设备、设备之间的并行工作能力，充分利用资源\n  * 并行性\n  * 均衡性\n* ​\n\n#### IO设备组成\n\n一般由机械和电子部分组成：\n\n* 机械部分是设备本身（物理装置）\n* 电子部分又称设备控制器（适配器）\n  * 地址译码\n  * 接受计算机发来或向计算机发送数据和状态信号\n  * 把计算机数字信号转换成机械能识别的模拟信号，或反过来\n  * 设备内部硬件缓冲或数据加工等提升性能\n\n机械部分：设备接口——控制器：\n\n* 操作系统将命令写入控制器的接口寄存器，并从中读取状态信息或结果信息\n* 控制器接受命令后独立于CPU执行，命令完成后产生中断，操作系统通过读控制寄存器的信息获取操作结果和状态\n* 控制器和设备的接口通常是低级借口\n* 控制器的任务：串行位流转换成字节块，并进行必要的错误修正\n\nIO端口地址：\n\n* 每个寄存器都有的唯一的地址\n* 所有端口地址形成IO端口空间\n* IO指令形式和IO地址关联：\n  * 内存映像编址（内存映像IO模式）：内存一部分用作IO端口\n    * 把IO端口看作一个存储单元\n    * 优点：\n      * 凡是可对内存的操作均可对IO操作\n      * 不需要专门IO指令\n      * IO端口空间大\n      * 不需要专门机制阻止用户操作IO\n    * 缺点：\n      * 占用内存空间\n      * 不能对控制寄存器进行高速缓存\n  * IO独立编址（IO专用指令）：IO空间独立于内存\n    * 使用专门的IO指令对端口操作\n    * 优点：\n      * 外设不占内存\n      * 编程时可以区分对内存还是对IO\n    * 缺点：IO操作指令类型少，操作不灵活\n\nIO控制方式：\n\n1. 可编程IO（轮询、查询）\n   * CPU不断询问IO模块\n   * 设置控制寄存器后不断查询状态寄存器，完成后把数据寄存器中数据读取\n2. 中断驱动IO\n   * IO结束后，由设备控制器主动通知设备驱动程序\n3. DMA\n   * 直接内存存取\n\n#### IO软件组成\n\n设计思想：\n\n* IO软件组织成多层次\n* 每层执行所需要功能的子集，依赖于低一层实现的功能\n* 低层考虑硬件特性，向高层提供接口\n* 高层不考虑硬件细节，提供良好接口\n\n软件层次：\n\n* 用户级IO\n* 与设备无关的OS软件：\n  * 驱动程序统一接口\n  * 缓存\n  * 错误报告\n  * 分配与释放设备\n  * 提供与设备无关的尺寸大小\n* 设备驱动程序\n* 中断处理程序\n\n设备无关性：用户程序可以访问任意IO设备，无需事先指定设备\n\n* 好处：易实现IO重定向，设备分配灵活\n\n#### IO相关技术\n\n缓冲技术：\n\n* 凡是数据到达和离去速度不匹配的地方均可用缓冲技术\n* 实现：\n  * 硬缓冲：由硬件寄存器实现\n  * 软缓存：内存中开辟空间作缓冲区\n* 缓冲区管理：\n  * 单缓冲\n  * 双缓冲\n  * 缓冲池（多缓存）：统一管理多个缓冲区，缓冲区循环使用\n* UNIX缓冲技术：\n  * 结合提前读和延迟写技术\n  * 充分利用从磁盘读入，已传入用户区但仍在缓冲区的数据\n  * 缓冲区组成：缓冲控制块+数据区\n  * 空闲缓冲区对联 av链\n  * 设备缓冲队列 b链：链接所有分配给设备使用的缓冲区，按散列方式组织\n\n#### IO设备管理\n\n独占设备的分配：\n\n* 静态分配：\n  * 运行前完成设备分配，结束时收回设备\n  * 缺点：利用率低\n* 动态分配：\n  * 运行过程中，用户提出设备要求时进行分配，一旦停止使用立刻收回\n  * 优点：效率高\n  * 缺点：可能死锁\n\n分时式共享设备：\n\n* 以一次IO为单位分时使用设备，不同IO请求排队使用\n\n设备驱动程序：\n\n* 每个设备驱动程序管理一类设备\n* 接收来自与设备无关的上层软件抽象请求，并执行请求\n* 每个控制器有一个或多个设备寄存器用于存命令和参数，设备驱动程序负责释放命令并监督执行\n* 与外界的接口：\n  * 与操作系统的接口\n  * 与系统引导的接口\n  * 与设备的接口\n* 接口函数\n* IO进程：专门处理系统IO请求与IO中断\n\n#### IO性能问题\n\n核心：\n\n* 使CPU利用率尽可能不被IO降低\n* 使CPU尽可能摆脱IO\n\n解决方案：\n\n* 减少或缓解速度差距：缓冲技术\n* 使CPU不等待IO：异步IO：用其他操作填充IO操作间等待的CPU时间\n* 使CPU摆脱IO：DMA、通道\n\n\n### 死锁\n\n重点：\n\n* 死锁的基本概念\n  * 死锁的四个必要条件\n  * 死锁和活锁、饥饿的区别\n* 死锁的解决方案：\n  * 死锁预防：资源的有序分配法\n  * 死锁避免：银行家算法、安全/不安全状态\n  * 死锁检测与解除\n* 资源分配图和在解决死锁问题的应用\n* 哲学家就餐问题\n\n\n\n#### 基本概念\n\n死锁：\n\n * 一组进程中每个进程都无限等待被该组另一进程占用的资源\n * 参与死锁的所有进程都在等待资源\n * 参与死锁的进程是当前系统中所有进程的子集\n\n死锁的原因：\n\n * 资源数目有限、锁和信号量错误使用\n * 资源的使用方式： 申请 -- 分配 -- 使用 -- 释放\n * 资源分类：\n    * 可重用资源：可被多个资源多次使用\n       * 可抢占资源：CPU\n       * 不可抢占资源：打印机\n   * 可消耗资源：只使用一次、可创建和销毁的资源：如信号、中断、消息\n\n活锁和饥饿：\n\n* 活锁：得不到资源，但能够运行，既无进展也无阻塞\n* 饥饿：资源分配策略决定\n\n死锁的产生条件：\n\n* 互斥使用（资源独占）：一个资源一次一个进程使用\n* 占有且等待：在申请新资源的同时保持对原资源的占有\n* 不可抢占、不可剥夺：资源只能由占有者自愿释放\n* 循环等待\n\n#### 资源分配图\n\n用有向图描述系统资源和进程的状态\n\n结点V：分为P 进程 ， R 资源\n\n有向边E：有向边的集合，资源 R 指向 进程 P （资源分配）或 进程P 指向资源R（申请资源）\n\n死锁定理：\n\n* 资源分配图中没有环路，则没有死锁\n* 图中存在环路，系统可能有死锁\n* 若每个资源类只有一个资源实例，则 环路存在  <=> 死锁存在\n\n#### 死锁预防\n\n解决死锁的方法：\n\n* 鸵鸟算法：不考虑死锁问题\n* 不让死锁发生\n  * 死锁预防：静态策略：设计合适的资源分配算法\n  * 死锁避免：动态策略：以不让死锁发生为目标，跟踪和评估资源分配过程，根据评估结果决策是否分配\n* 死锁检测与解除\n\n死锁预防：\n\n* 防止产生死锁的四个必要条件之一\n* 破坏 互斥使用、资源独占 条件：\n  * 资源转换技术：把独占资源变为共享资源\n* 破坏 占有且等待 条件：\n  * 方案1：每个进程运行前必须一次性申请所有资源，仅当进程需要的资源都可满足才一次性分配\n    * 资源利用率低，饥饿现象\n  * 方案2：申请新资源得不到满足而变为等待状态前，必须释放已经占有的所有资源\n* 破坏 不可抢占 条件：\n  * 申请的资源被其他进程占用时，可通过操作系统抢占资源（进程优先级不同）\n    * 局限性：适用于状态易于保存和恢复的资源\n* 破坏 循环等待 条件：\n  * 资源有序分配法：进程申请资源时必须按资源编号的递增次序进行，否则操作系统不予分配\n\n死锁避免：\n\n* 对进程发出的资源申请进行动态检查，根据分配后是否会发送死锁或是否可能导致死锁决定是否分配资源\n\n* 安全状态：系统中存在一个由所有进程构成的安全序列，对每个进程 Pi 以后所需要资源量不超过 （系统当前剩余资源+所有进程Pj( j<i )当前所占有的资源）\n\n* 安全状态一定不死锁，不安全状态一定导致死锁（哪怕当前未死锁）\n\n* 银行家算法 banker's algorithm：仿照银行发放贷款采取的控制方式\n\n  * 应用条件：\n\n    * 固定数目进程 共享 固定数目资源\n    * 每个进程预先指定所需要的最大资源数\n    * 进程不能申请大于系统可用资源总数的资源\n    * 进程等待资源的时间有限\n    * 系统满足进程的最大需求后，进程应在有限时间内尽快使用并归还\n\n  * 变量：\n\n    * n：进程数目\n    * m：资源类数目\n    * available   【1.m】系统每类资源剩余数目\n    * max  【1.n 1.m】每个进程对每类资源要求的最大数目\n    * allocation 【1.n 1.m】每个进程已经分配的每类资源数目\n    * need 【1.n 1.m】每个进程还需要的每类资源的数目\n    * request 【1.n 1.m】 这次每个进程申请的每类资源数目\n\n  * 步骤：\n\n    1. 若 request[i] <= need[i] 继续，否则报错\n\n    2. 若 request[i] <= available 继续，否则等待\n\n    3. 假设系统分配了资源：\n\n        available -= request[i]\n\n        allocation[i] += request[i] \n\n        need[i] -= request[i]\n\n    4. 若系统新状态安全，则分配完成，若不安全，则恢复分配\n\n  * 安全性检查：\n\n    1. work = available，finish=false\n    2. 检查每个i 有 finish[i]==false && need[i]<=work\n    3. 而后 work += allocation[i];  finish[i]=true, 转2\n    4. 若对所有i都有 finish[i]==true 则系统安全\n\n#### 死锁检测与解除\n\n死锁检测：\n\n* 允许死锁发生，但操作系统不断监视系统，判断死锁是否发生\n* 一旦发生死锁则解除死锁并以最小代价恢复系统运行\n* 检测时机：\n  * 当进程由于资源请求不满足而等待时\n  * 定时检测\n  * 系统资源利用率下降时\n\n死锁解除：\n\n1. 撤销所有死锁进程\n2. 进程回退roll back ，再启动\n3. 按某原则逐一撤销死锁进程\n4. 按某种原则逐一抢占资源\n","source":"_posts/os_note.md","raw":"---\nlayout: post\ntitle: \"操作系统笔记\"\ndate: 2018-02-20\ncomments: true\ntags: \n  - 学习笔记\n  - OS\n---\n\n\n\n### 概述\n\n操作系统学习笔记，包括：\n\n1. 操作系统基本概念\n2. 进程、线程\n3. 处理器调度\n4. 同步机制\n5. 存储模型\n6. 文件系统\n7. IO\n8. 死锁\n\n<!-- more -->\n\n重点：\n\n《现代操作系统》(第三版)\n\n* 教材：\n  * 第一章： 1.1 、1.2 、 1.4\n  * 第10章： 10.2.5 linux\n  * 第11章： 11.3.1 \n* 重点概念：\n  * 操作系统定义\n  * 操作系统三个作用\n  * 操作系统四个特点\n  * SPOOLING技术\n  * windows、linux、unix架构及主要功能\n\n#### 操作系统的定义与作用\n\n1. 有效管理资源\n\n> 1. 静态分配：在进程执行前准备好需要的所有资源，会造成资源浪费\n> 2. 动态分配：进程需要时进行申请\n\n2. 通过命令接口、编程接口为用户提供服务\n\n3. 对硬件机器的扩展\n\n   > 对硬件进行抽象，硬件之上的虚拟机器\n\n#### 操作系统的特征\n\n1. 并发 concurrency: 指处理多个同时性活动的能力\n\n   > 引发问题： 活动切换、保护、相互依赖的活动的同步\n   >\n   > 并行parallel： 不同程序同时在多个硬件上执行\n\n2. 共享 sharing：操作系统与用户的程序共享系统中的资源\n\n   > 操作系统要对资源进行合理分配和使用\n   >\n   > 1. 互斥共享（打印机）\n   > 2. 同时共享（代码、文件）\n\n3. 虚拟 virtual：物理实体映射为若干个对应的逻辑实体（分时、分空间）\n\n   > 目的：提高资源利用率\n   >\n   > CPU：每个进程 “虚处理器”\n   >\n   > 存储器：虚拟地址空间\n   >\n   > 显示器：多窗口\n\n4. 随机：随时对不可预测的次序发生的事件进行响应并处理\n\n   > * 进程运行速度不可预知\n   > * 难以重现系统在某个时刻的状态\n\n#### 操作系统的架构\n\nWindows 、 Unix 、 Linux\n\n#### 操作系统的分类\n\n发展： 硬件发展、应用需求发展、软件技术发展\n\n目的：充分利用硬件，提供更好服务\n\n掌握各种操作系统的目标和不同点\n\n* 批处理操作系统\n\n  1. 方式\n\n     > 系统操作员从用户处收集作业并输入系统，而后启动操作系统，操作系统自动处理作业并输出，系统操作员从输出处获取作业\n\n  2. 目的： 提高资源利用率，增加吞吐量\n\n  3. 概念：\n\n     * 作业：程序、数据、作业说明素\n     * 成批：由若干作业组成\n     * 批作业处理：对每个作业做相同处理\n\n  4. 问题：\n\n     * 输入输出慢，由主机完成，CPU处于等待状态\n     * 解决：用卫星机：完成输入输出，暂存输入输出结果，流程：用户->卫星机->系统操作员->计算机->系统操作员->卫星机->用户\n\n  5. 分类：\n\n     * 单道批处理：一次处理一个作业\n     * 多道批处理：一次选中多个作业进行处理\n\n  6. 技术： Spooling 同时外围设备联机操作，假脱机技术\n\n     > 用磁盘作缓冲，输入输出和计算并行在一台机器上进行\n     >\n     > 现代打印过程通常用spooling技术\n\n* 分时系统：time-sharing ，最早的交互式系统\n\n  1. 方式：\n\n     * 一台主机对多个终端，用户在终端输入命令等待结果\n\n  2. 概念：时间片 （time slice）\n\n     操作系统将CPU时间划分成若干片段，以时间片为单位轮流为终端服务，每次一个时间片\n\n  3. 特点：利用人的错觉，使得人感觉系统只在为自己服务（每个用户在一个虚拟机上运行）\n\n  4. 目标：及时响应\n\n通用操作系统：分时和批处理结合，原则：以分时优先，批处理在后\n\n* 实时操作系统\n  1. 概念：计算机能及时响应外部事件的请求，在严格时间内完成处理\n  2. 分类：\n     1. 实施过程控制（军事控制、航空）\n     2. 实时通信处理（订票）\n  3. 目标：\n     * 严格时间范围内响应\n     * 高可靠性\n  4. 特征：\n     1. 硬实时系统：某个动作必须在规定时间内或规定时刻完成（焊接）\n     2. 软实时系统：接受偶尔违反时限（播放音乐、视频等）\n* PC操作系统\n  1. 目标：\n     * 界面友好、使用方便\n     * 丰富的应用软件\n* 网络操作系统\n  1. 概念：按网络体系结构协议标准开发的软件\n  2. 功能：网络管理，通信，安全，资源共享和网络应用\n  3. 追求目标：相互通信，资源共享\n* 分布式操作系统\n  1. 概念：以计算机网络或多处理器为基础，特征是处理分布在不同计算机上\n* 嵌入式操作系统\n  1. 概念：\n     * 在各种设备、装置中完成特定功能的软硬件系统（汽车、手机、播放器等）\n     * 大设备、装置中的一部分\n     * 对反应时间、处理时间有严格要求\n\n### 操作系统运行环境\n\n重点：\n\n* 理解计算机系统的保护机制\n  * 掌握处理器状态\n  * 掌握特权指令与非特权指令\n* 掌握中断、异常机制\n  * 掌握中断、异常的基本概念\n  * 理解中断、异常机制的工作原理\n* 掌握系统调用机制\n  * 掌握系统调用的设计原理\n  * 掌握系统调用的执行过程\n\n重点阅读：\n\n* 第一章： 1.3、 1.6\n* 第二章： P52 图2-5\n\n重点概念：\n\n​\tCPU状态、内核态 用户态、特权指令 非特权指令、中断、异常、中断响应、中断向量、中断处理程序、系统调用、陷入指令、系统调用号、系统调用表\n\n#### 处理器状态\n\n中断与异常机制\n\nCPU由运算器、控制器、寄存器及高速缓存组成\n\n* 两类寄存器：\n  * 用户可见寄存器：高级语言编译器通过优化算法分配寄存器并使用，减少访问内存次数\n  * 控制和状态寄存器：用于控制处理器操作，只能由操作系统代码使用，\n    * 程序计数器 PC\n    * 指令寄存器 IR\n    * 程序字寄存器 PSW\n\n并发和共享 -> 要求保护： 用户程序不对操作系统干扰\n\n要求硬件提供基本运行机制：\n\n* CPU具有特权级别，不同特权级下运行不同指令集合\n* 将OS与用户程序隔离\n\ncpu状态通常为两种、三种或四种：\n\n​\t在程序状态字寄存器PSW专门设置一位，根据程序的使用权限设置不同的CPU状态\n\n操作系统需要两种CPU状态：\n\n       \t1. 内核态 ： 运行操作系统程序\n     \t2. 用户态： 运行用户程序\n\n指令分类：\n\n1. 特权指令：只能由操作系统使用，用户程序不能使用（启动IO、内存清零）\n2. 非特权指令：操作系统和用户程序都可以使用（控制转移）\n\nCPU状态的转换：\n\n* 用户态 -> 内核态： 唯一途径：中断、异常、陷入机制（提供给用户程序的接口，用于调用操作系统功能）\n* 内核态 -> 用户态：设置程序状态字PSW\n\n#### 中断与异常机制\n\n操作系统是由 中断驱动的 或是 事件驱动的\n\n概念：CPU对系统发生的某个事件的反应\n\n事件的发生改变了CPU的控制流\n\n主要作用：\n\n* 及时处理外部设备中断请求\n* 捕获用户程序提出的服务请求\n* 防止用户程序执行过程中的破坏活动\n\n特点：\n\n* 随机发生\n* 自动处理 (硬件自动完成的)\n* 可恢复\n\n中断的引入原因：支持CPU与设备之间的并行操作\n\n异常的引入原因：CPU执行指令时本身出错\n\n事件：\n\n* 中断（外中断）：\n  * IO中断（按键、外部设备）\n  * 时钟中断（定时器，CPU时间片到了）\n  * 硬件故障（充电）\n* 异常（内中断）：\n  * 系统调用\n  * 页故障、页错误（缺页）\n  * 保护性异常（只读文件和写操作）\n  * 断点指令（debug）\n  * 其他程序性异常（算术溢出）\n\n异常类别：\n\n* 陷入 Trap ： 有意识安排的      同步   返回到下一条指令\n* 故障 Fault： 可恢复的错误     同步    返回到当前指令\n* 终止 Abort： 不可恢复的错误   同步   不会返回\n\n#### 中断、异常机制的工作原理\n\n**硬件和软件相互配合**\n\n硬件：响应异常\n\n​\t捕获请求，以一定方式相应，把CPU的控制权交给处理程序\n\n软件：处理异常\n\n​\t识别类型并完成处理\n\n中断响应：硬件\n\n​\t每条指令执行最后扫描中断寄存器查看是否有中断信号，若有，则中断硬件将中断触发器内容按编码送入PSW，并查询中断向量表引出处理程序\n\n​\t中断向量：一个内存单元，存放中断处理程序入口地址和程序运行时需要的处理机状态字\n\n​\t流程： 设备发出中断信号 -> 硬件保存现场(PSW,PC) -> 根据中断码查表 -> 中断处理程序入口地址送入相应寄存器 -> 执行处理程序\t\n\n中断处理：软件\n\n* 保存相关寄存器信息（硬件只保存关键寄存器）\n* 分析具体原因\n* 执行处理功能\n* 恢复现场，返回被打断的程序\n\n#### 系统调用机制\n\n操作系统给用户提供的接口，在编程时可调用的操作系统功能\n\n使CPU状态从用户态陷入内核态\n\n区分： 系统调用、库函数、API、内核函数\n\n​\t应用程序通常借函数库、API接口间接进行系统调用\n\n​\t内核函数包含系统调用，大部分不开放给用户\n\n设计系统调用机制：\n\n       \t1. 利用中断异常机制\n     \t2. 选择一条特殊指令：陷入指令，从用户态切换到内核态\n     \t3. 每个系统调用给定一个编号\n     \t4. 存放系统调用服务例程的入口地址\n\n用户的参数传递给内核：（从用户栈到内核栈）\n\n1. 陷入指令自带参数（长度有限）\n2. 通用寄存器传递参数（寄存器个数有限） （主要方法）\n3. 内存中开辟专用堆栈区传递参数\n\n系统调用执行过程：\n\n1. 中断异常机制：硬件保护现场，查询中断向量表，控制权交给系统调用总入口程序\n2. 系统调用总入口程序：保存现场，把参数保存到内核栈，查系统调用表把控制权转给相应的系统调用例程或内核函数\n3. 执行系统调用例程\n4. 恢复现场，返回用户程序\n\n\n### 进程、线程模型\n\n重点：\n\n​\t第2章： 2.1、 2.2(除 2.2.8 - 2.2.10外)\n\n重点概念：\n​\t进程、进程状态及切换、进程控制、PCB、进程地址空间、进程上下文环境、线程、线程属性、用户级线程、核心级线程、Pthreads、可再入程序、原语、web服务器\n\n#### 进程的基本概念\n\n多道程序设计： 允许多个程序同时进入内存并运行\n\n并发环境：一段时间间隔内，单处理器由两个或以上程序同时处于开始运行但尚未结束的状态且次序不是事先确定的\n\n进程 process： 具有独立功能的程序关于某个数据集合上的一次运行活动，是资源分配和调度的单位，又称任务\n\n  * 程序一次执行过程\n  * 正在运行程序的抽象\n  * 一个CPU变换成多个虚拟的CPU\n  * 系统资源以进程为单位分配，如内存、文件\n  * 每个进程有独立的地址空间\n  * 操作系统把CPU调度给需要的进程\n\n进程控制块 PCB\n\n* 又称 进程描述符、进程属性\n* 操作系统用于管理控制进程的一个专门数据结构\n* 记录进程的各种属性，并描述进程的动态变化过程\n* 是系统感知进程的唯一标识，与进程一一对应\n* 包含：\n  * 进程描述信息\n    * 进程标识符 ID，唯一\n    * 进程名，不唯一\n    * 用户ID\n    * 进程组关系（子进程、父进程等）\n  * 进程控制信息\n    * 当前状态、优先级、代码执行入口地址、磁盘地址、队列指针等\n  * 所拥有资源和使用情况\n    * 虚拟空间空间状况\n    * 打开文件列表\n  * CPU现场信息\n    * 寄存器值\n    * 指向该进程页表的指针\n\n进程表： 所有进程的PCB的集合（大小固定）\n\n#### 进程状态及状态转换\n\n进程三种基本状态：运行态、就绪态、等待态\n\n运行态 running：\n\n​\t占有CPU并在CPU上运行\n\n就绪态 ready：\n\n​\t已具备运行条件，但没有空闲CPU\n\n等待态、阻塞态、封锁态、睡眠态：\n\n​\t因等待某一事件而暂停（如读盘）\n\n状态转换：\n\n1. 就绪 -> 运行：调度程序选中\n2. 运行 -> 就绪：运行进程用完时间片，或高优先级进程进入就绪态\n3. 运行 -> 等待：进程等待事件（请求OS服务，资源尚未访问，等待IO，等待另一进程等） \n4. 等待 -> 就绪：所等待的事件发生\n\n其它状态：\n\n*  创建态 new：已完成创建进程必备工作（PID、PCB），但未被同意执行（资源有限）\n*  终止态 terminated：执行后，完成数据统计工作，回收资源\n*  挂起态 suspend：进行负载调节，进程不占用内存空间，进程映像交换到磁盘\n\n![](http://ot1c7ttzm.bkt.clouddn.com/sevenlevel.png)\n\n进程队列：\n\n* 每一类进程建立一个或多个队列\n* 队列元素为PCB\n* 进程状态改变，其PCB从一个队列进入另一队列\n\n#### 进程控制\n\n完成进程状态之间的转换，由具有特定功能的原语完成\n\n原语 primitive：完成某特定功能的程序，不可分割、不可中断\n\n1. 进程创建\n   1. 新进程分配唯一标识ID以及进程控制块PCB\n   2. 分配地址空间\n   3. 初始化PCB：设置默认值\n   4. 设置相应的队列指针\n2. 进程的撤销：结束进程\n   1. 回收进程占用的资源（关闭文件、断开网络、回收内存）\n   2. 收回PCB\n3. 进程阻塞：由**进程自己**执行阻塞原语，使自己由运行态变为阻塞态\n\nUNIX下进程控制： 系统调用\n\n* fork 通过复制调用进程建立新进程\n* exec 用新代码覆盖原来的地址空间，建立新进程\n* wait 进程进入阻塞态 \n* exit 终止进程运行 \n\n#### 进程相关概念\n\n进程的分类：\n\n1.  \n   * 系统进程：优先级较高\n   * 用户进程\n2.  \n   * 前台进程\n   * 后台进程\n3.  \n   * CPU密集型进程\n   * IO密集型进程\n\n进程的层次结构：\n\n* Unix进程家族树：init为根\n* Windows：地位相同\n\n进程和程序的区别：\n\n* 进程更准确刻画并发\n* 程序是静态的，进程是动态的\n* 进程由生命周期，程序相对长久\n* 一个程序可以对应多个进程\n* 进程可以创建其它进程，程序不行\n\n进程映像 image： 进程执行活动全过程的静态描述，程序+数据+栈（用户栈+内核栈）+PCB\n\n上下文context 切换： CPU硬件状态从一个进程切换到另一个进程的过程\n\n> 进程运行时硬件状态保存在CPU的寄存器，当进程不运行时，寄存器的值要保存到PCB中\n\n#### 线程的引入\n\n引入原因：\n\n* 应用需要 （打字与排版与存盘、web服务器）\n* 开销考虑\n  * 线程开销小\n    * 创建新线程花费时间少\n    * 线程切换花费时间少\n    * 线程通信无需调用内核，直接共享资源\n* 性能考虑：多处理器处理多线程\n\n线程的基本概念\n\n线程集成了CPU调度单位\n\n进程还是资源拥有者\n\n线程 thread：进程中的一个运行实体，是CPU的调度单位，也称轻量级进程\n\n属性：\n\n* 有标识符ID\n* 有状态及状态切换\n* 不运行时需要保存上下文\n* 有自己的栈和栈指针\n* 共享所在进程的地址空间和其他资源\n* 可以创建、撤销另一个线程，程序一开始是单线程执行\n\n#### 线程机制的实现\n\n* 用户级线程 （unix）\n  * 在用户空间建立线程库\n  * 通过 运行时系统（run-time system）完成管理工作\n  * 内核管理、进程都不知道线程的存在\n  * 线程切换不需要内核态特权，不需要操作系统干预\n  * 优点：\n    * 线程切换快\n    * 调度算法是应用程序特定的\n    * 可运行在任何操作系统上\n  * 缺点：\n    * 内核只分配处理器给进程，同一进程两线程不能同时运行于两个处理器\n    * 系统调用大多是阻塞的，内核阻塞进程时所有线程也被阻塞\n* 核心级线程 （windows）\n  * 内核管理所有线程，向应用程序提供API\n  * 内核维护线程和进程\n  * 线程切换需要内核\n  * 以线程为单位进行调度\n* 混合模型：\n  * 线程在用户空间创建\n  * 线程调度在核心态完成\n\n### 处理器调度\n\n教材重点：\n\n* 第二章： 2.4\n* 第11章： 11.4.3\n\n重点：\n\n* 掌握处理器调度的相关概念：\n  * 调度时机、进程切换\n  * 调度标准：吞吐量、周转时间、响应时间\n  * 优先级/优先数、 抢占/非抢占、 IO型与CPU型\n* 掌握主要的调度算法：\n  * 先来先服务、短作业有限、最高响应比优先\n  * 时间片轮转、最高优先级\n  * 多级反馈队列\n* 了解Windows、多处理器调度的基本思想\n\n#### 处理器调度的相关概念\n\nCPU调度：控制、协调进程对CPU的竞争，按一定调度算法从就绪队列中选一个进程把CPU使用权交给被选中进程\n\n若没有就绪进程，系统会安排系统空闲进程或idle进程\n\n三个问题：\n\n* 按什么原则选择下一个进程：调度算法\n* 何时选择：调度时机\n* 如何让被选中进程上CPU运行：调度过程（进程上下文切换）\n\n调度时机： 内核对中断、异常、系统调用处理后返回用户态时\n\n * 进程正常终止或因错误终止\n * 新进程创建、等待进程变成就绪\n * 进程从运行态进入阻塞态\n * 进程从运行态进入就绪态\n\n调度过程：\n\n* 进程切换：一个进程让出CPU，另一个进程使用CPU\n  * 包括对原进程状态的保存，和对新进程状态的恢复\n  * 过程\n    * 切换全局页目录以加载新的地址空间\n    * 切换内核栈和硬件上下文\n  * 开销：\n    * 直接开销：内核完成切换所用的CPU时间\n      * 保存、恢复寄存器\n      * 切换地址空间\n    * 间接开销\n      * 高速缓存、缓冲区缓存、TLB失效\n\n调度算法的设计：\n\n* 衡量指标：\n  * 吞吐量 throughput： 单位时间完成的进程数目\n  * 周转时间 TT turnaround time：进程从提出请求到运行完成的时间\n  * 响应时间 RT response time：提出请求到第一次回应的事件\n  * CPU利用率：CPU有效工作的时间\n  * 等待时间：进程在就绪队列中等待的时间\n\n![调度算法设计](http://ot1c7ttzm.bkt.clouddn.com/schedulalgo.png)\n\n#### 调度算法的设计\n\n优先级：\n\n * 优先级与优先数\n * 静态与动态\n\n占用CPU的方式：\n\n* 抢占式 preemptive：\n  * 有优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU\n* 不可抢占式 non-preemptive：\n  * 除非因自身原因不能运行，否则进程会一直运行下去\n\n进程按执行过程行为划分：\n\n* IO密集型 IO-bound\n* CPU密集型 CPU-bound\n\n时间片： time slice 或 quantum：\n\n * 分配给调度上CPU的进程的时间段\n\n#### 批处理中的调度算法\n\n* 先来先服务 FCFS  first come first serve：\n  * 按进程就绪先后顺序使用CPU\n  * 非抢占式\n  * 优点： 公平、实现简单\n  * 缺点：短进程需要等长时间\n* 最短作业优先 SJF shortest job first：\n  * 最短完成时间的进程优先\n  * 非抢占式\n  * 改善短作业的周转时间\n  * 优点：最短平均周转时间（所有进程同时可运行时）\n  * 缺点：不公平，长任务饥饿现象 starvation\n* 最短剩余时间优先 SRTN  shortest remaining time next：\n  * 最短作业优先的抢占版本\n* 最高响应比优先 HRRN  highest response ratio next\n  * 调度时，先计算每个进程的响应比R，总选择R最高的进程\n  * R = $\\frac{周转时间}{处理时间}$ =  $1+\\frac{等待时间}{处理时间}$ \n\n#### 交互式系统采用的调度算法\n\n* 轮转调度 RR round robin\n  * 目标：为短任务改善平均响应时间\n  * 思路：\n    * 周期性切换\n    * 每个进程一个时间片\n    * 时钟中断 -> 轮换\n  * 时间片选择：\n    * 太长：短进程响应时间长\n    * 太短：切换开销大\n  * 优点：公平、利于交互式计算\n  * 缺点：进程切换使得轮转开销大、对大小相近的进程不利、对IO型进程不利\n* 最高优先级调度 HPF highest priority first：\n  * 通常： 系统进程优先于用户进程、前台进程优先于后台，偏向于IO型进程\n  * 优先级反转问题 priority inversion（基于优先级的抢占式时）：低优先级进程占有高优先级进程需要的资源\n    * 影响： \n      * 系统错误\n      * 高优先级进程停滞不前\n    * 解决方案：\n      * 设置优先级上限（临界区的进程优先级最高）\n      * 优先级继承（低优先级继承高优先级）\n      * 使用中断禁止（临界区进程不响应中断）\n* 多级反馈队列 Multiple feedback queue：\n  * 设置多个就绪队列，第一级队列优先级最高\n  * 时间片长度不同，级别越低，时间片越大\n  * 每个队列用时间片轮转方式调度\n  * 新进程创建就绪后，进入第一级\n  * 进程用完时间片并放弃CPU，进入下一级就绪队列\n  * 因阻塞放弃CPU的进程从等待队列出来时回到原来就绪队列\n* 最短进程优先 Shortest process next\n\n![调度算法总结](http://ot1c7ttzm.bkt.clouddn.com/schedulalgo1.png)\n\n多处理器调度算法设计：\n\n* 不仅选择哪个进程，还要选择在哪个CPU\n* 考虑进程在多个CPU迁移的开销\n* 负载均衡问题\n\n#### Windows 线程调度\n\n调度单位是线程\n\n采用基于动态优先级、抢占式调度，结合时间配额的调整\n\n引发线程调度的条件：\n\n* 线程优先级改变\n* 线程改变了亲和affinity处理机集合\n* 正常调度条件（4条）\n\n32个优先级，分三类：\n\n* 实时优先级：不改变优先级\n* 可变优先级：在一定范围内可变\n* 系统线程\n\n时间配额：配额单位的整数，不是时间长度值\n\n调度策略：\n\n* 主动切换\n* 抢占： \n  * 被抢占线程：\n    * 实时优先级：时间配额重置\n    * 可变优先级：时间配额不变\n* 时间配额用完\n  * A优先级未降低：A进入原就绪队列末尾\n  * A优先级降低\n\n### 同步机制\n\n重点：\n\n* 基本概念：\n  * 竞争条件、临界区\n  * 进程同步、互斥\n  * 自旋锁（忙等待）\n* 信号量，PV操作\n* 经典问题模型及解决方案\n  * 生产者消费者问题，读者写者问题\n\n教材：\n\n* 第2章： 2.3.1~2.3.5， 2.5.2\n\n#### 进程互斥\n\n竞争条件 race condition： 两个或多个进程读写某些共享数据，最后结果取决于进程的精确时序\n\n进程互斥 mutual exclusive：共享资源需要排他性使用，各进程之间竞争使用这些资源\n\n临界资源、共享资源、互斥资源 critical resource： 某些资源一次只允许一个进程使用\n\n临界区（互斥区）：critical section：各个进程中对临界资源实时操作的程序片断\n\n临界区的使用原则：\n\n* 没有进程在临界区时，想进入的可以进入\n* 不允许两个进程同时处于临界区\n* 临界区外的进程不得阻塞其他进程进入临界区\n* 不得使进程在临界区外无限等待\n\n解决方案：\n\n* 软件：\n  * dekker解法\n  * peterson解法\n* 硬件：\n  * 屏蔽中断\n  * TSL（XCHG）指令\n\n忙等待 busy waiting：进程得到临界区访问权之前，持续测试\n\n* 自旋锁 spin lock （多处理器）\n* 为什么不直接切换进程： 临界区使用时间一般很短，切换进程的开销更大\n\n优先级反转（倒置）：由于临界区保护带来的问题\n\n#### 软件解法\n\n解法1：\n\n* 用free作为标志：临界区是否空闲\n  * true：有进程在临界区\n  * false：无进程在临界区\n  * 初始值：false\n* 使用 lock(),unlock()作为原语\n\ndekker算法：\n\n* 引入turn变量，判断是否轮到自己\n\npeterson算法：\n\n* 解决了互斥访问的问题，而且克服了强制轮流的缺点\n* 通过 enter_region()  和 leave_region()函数\n* while( turn==process && interested[other]==TURE );\n\n#### 硬件解法\n\n通过指令完成\n\n解法1：中断屏蔽方法\n\n* 使用  开关中断 指令 （特权指令）\n* 入临界区： 执行 关中断 指令\n* 出临界区： 执行 开中断 指令\n* 优点：简单高效\n* 缺点：\n  * 代价高，限制CPU并发能力\n  * 不适用于多处理器\n  * 适合操作系统，不适合用户进程\n\n解法2：测试并加锁 指令：\n\n* TSL指令：TEST AND SET LOCK\n* 复制 锁 到寄存器 并把锁置为1（上锁）\n* 判断寄存器是不是0\n  * 若不是0，跳转到enter_region（反复循环）\n  * 若是0，返回，进入临界区\n\n解法3： 交换 指令：\n\n* XCHG指令：EXCHANGE\n* 寄存器设置为1，交换寄存器和锁的内容，判断寄存器是否是0（与TSL类似）\n\n#### 进程同步\n\n进程同步 synchronization：多个进程中发生的事件存在某种时序关系，需要合作\n\n生产者、消费者问题（有界缓冲区）：\n\n* 一个或多个生产者生产某种数据放在缓冲区\n* 有消费者从缓冲区中取数据，每次取一项\n* 只能有一个生产者或一个消费者对缓冲区进行操作\n* 问题：\n  * 缓冲区满时，生产者不添加数据\n  * 缓冲区空时，消费者不移走数据\n* 避免忙等待\n  * 睡眠 与 唤醒 操作（原语）\n\n\n#### 信号量及P、V操作\n\n典型的进程同步机制\n\n信号量：特殊的变量，用于进程间传递信息的整数值 （count、queue）\n\n可执行的操作： 初始化、 P（test） 、 V（increment）\n\nP操作： 测试\n\n* 把信号量的值减一\n* 判断信号量是否 < 0 ：\n  * <0：该进程状态为阻塞态，插入等待队列 s.queue末尾，重新调度\n  * false：执行进程\n\nV操作：\n\n* 信号量的值+1\n* 判断信号量是否<=0:\n  * true ：唤醒s.queue的一个进程，插入就绪队列\n\nP、 V操作是原语操作 primitive or atomic action\n\n最初提出：二元信号量（解决互斥）\n\n推广：一般信号量（解决同步）\n\n用PV解决互斥问题：\n\n* 分析并发进程关键活动，划定临界区\n* 设置信号量 mutex，初始值为1\n* 临界区前实施 P\n* 临界区后实施 V\n\n用PV解决生产者消费者问题：\n\n* 用full、empty两个变量记录满缓冲区和空缓冲区数目\n* 分别用P、V操作维护full和empty\n* 用 mutex 维护互斥，防止同时读写buffer![PV](http://ot1c7ttzm.bkt.clouddn.com/PV.png)\n* 两边的P操作顺序不可逆，必须先判断empty或full才能判断mutex（因为P操作可能使进程进入阻塞态）\n* 两边的V操作顺序可逆\n* 位置：尽可能缩小临界区\n\nPV操作解决读者、写者问题：\n\n* 多个进程共享一个数据区，分为两组：\n\n  * 读者进程：只读数据区数据\n  * 写者进程：只写数据区数据\n\n* 条件：\n\n  * 允许多个读者同时读\n  * 不允许多个写者同时操作\n  * 不允许读写同时\n  * （读写互斥，写者之间互斥）\n\n* Linux提供的读写锁：\n\n* 第一类读者写者问题：读者优先：\n\n  * 若有写者在等，有其他读者在读，则新读者可以读\n  * 有读者在读，写者等待\n  * 解法：\n    * 第一个读者做P操作，最后一个读者做V操作\n\n  ​\n\n\n### 同步机制（2）\n\n重点：\n\n* 管程：\n  * 如何保证互斥\n  * 如何保证同步：条件变量及wait、signal\n  * HOARE管程\n  * MESA管程\n* 进程间通信：\n  * 消息传递、共享内存、管道\n* Pthread中的同步机制\n* Linux的IPC机制\n\n教材：\n\n* 第二章： 2.3.6～ 2.3.9\n\n#### 管程 monitor\n\n出现原因： 信息量机制不足：程序编写困难、易出错（PV操作的位置）\n\n解决：在程序设计语言中引入管程成分：高级同步机制\n\n定义：\n\n* 一个特殊的模块\n* 每个管程有一个名字\n* 管理共享资源的数据结构及其上操作的一组过程组成\n\n进程与管程： 进程只能通过调用管程中的过程来间接访问管程的数据结构\n\n管程解决的问题：\n\n* 互斥：\n  * 管程是互斥进入的：为了保证管程中数据结构的数据完整性\n  * 互斥性由编译器负责保证\n* 同步：\n  * 管程中设置条件变量及等待、唤醒操作以解决同步问题\n  * 可以使一个进程或线程在条件变量上等待或唤醒\n\n使用管程的问题：\n\n* 进入管程的操作执行唤醒操作（P唤醒Q）：\n  * 规定唤醒操作为管程中最后一个可执行的操作\n  * P等待，Q执行 （HOARE管程）\n  * Q等待，P继续执行（MESA管程）\n\nHOARE管程：\n\n* 管程内增加紧急等待队列，P唤醒Q后P进入紧急等待队列（优先级高于入口等待队列）\n* 管程外有入口等待队列\n* 条件变量：在管程内部说明和使用的一种特殊类型的变量\n  * wait操作：紧急队列非空，则唤醒第一个等待者，否则释放管程互斥权，执行该操作的进程进入c链末尾\n  * signal：c链为空则相当于空操作，否则唤醒第一个等待者，执行该操作的进程进入紧急等待队列\n* 缺点：\n  * 两次额外的进程切换\n\n管程的实现：\n\n* 直接构造：效率高\n* 间接构造：用某种已经实现的同步机制构造（如信号量及PV操作）\n\n\nMESA管程：（P唤醒Q，P继续执行）\n\n* signal -> notify： notif(x)使得x条件队列得到通知，发信号的进程继续执行\n* notify的结果：条件队列头的进程在将来合适的时候恢复执行\n* 不能保证在它之前没有其他进程进入管程，因此进程必须重新检查条件：用while循环取代if语句检查条件\n* 导致对条件变量至少多一次额外检测，对等待进程什么时候执行没有限制\n* 对notify的改进：\n  1. 每个条件原语关联计时器，超过一定等待时间的进程直接进入就绪态\n  2. broadcast：所有在该条件上等待的进程都被释放且进入就绪序列\n\nHOARE和MESA的比较：\n\n* MESA一般优于HOARE：MESA错误较少\n* MESA：每个过程收到信号后重新检查管程变量，且使用while\n\n#### PTHREAD中的同步机制\n\n通过互斥量保护临界区： Pthread_mutex\n\n解决同步问题：条件变量： wait \\ signal \\ broadcast\n\n#### 进程间通信机制\n\n原因：\n\n* 信号量和管程的不足\n* 不适合多处理器的情况\n\n进程通信机制：消息传递：send & receive 原语\n\n适用于： 分布式系统、单处理器系统、共享内存的多处理器系统\n\n通信方式：\n\n* 消息传递\n  * 操作系统空间设置消息缓冲区：\n    * 消息头（消息类型，进程ID：发送、接收，消息长度，控制信息）\n    * 消息体\n  * 发送原语，由操作系统完成\n  * 过程：陷入内核、复制消息、消息入队（接收进程的PCB消息队列指针）、复制消息\n  * 通过PV操作实现\n* 共享内存\n  * 需要解决两个问题：\n    * 物理内存中建立共享空间，并建立两个进程的地址空间到内存的映射\n    * 读者写者问题\n* 管道 pipe：\n  * 利用缓冲传输介质：内存或文件连接两个进程\n  * 问题：\n    * 字符流方式写入读出\n    * 先入先出顺序\n    * 管道通信必须提供协调能力：互斥、同步、判断对方进程是否存在\n* 套接字\n* 远程过程调用\n\n#### 典型操作系统的IPC机制\n\nlinux的进程通信机制：\n\n* 用户程序：管道、消息队列、共享内存、信号、套接字\n* 内核同步机制：原子操作、自旋锁、读写锁、信号量、屏障\n\n原子操作：\n\n* 不可分割，不会被打断\n* 常用于资源计数\n\n屏障 barrier：\n\n* 同步机制\n* 用于对一组线程进行协调，要求所有线程到达一个汇合点后一起向前\n\n\n### 存储模型（1）\n\n重点：\n\n* 地址重定位\n* 基本内存管理方案\n* 物理内存管理技术\n* 交换技术\n\n教材：\n\n* 第3章 3.1、 3.2\n\n#### 地址重定位\n\n进程中的地址不是最终的物理地址\n\n进程运行前无法计算出物理地址\n\n地址重定位：\n\n* 逻辑地址（相对地址、虚拟地址）：\n  * 用户程序经过编译汇编后形成目标代码，首地址为0，其它地址相对于首地址编址\n  * 不能用逻辑地址在内存中读取信息\n* 物理地址（绝对地址，实地址）：\n  * 内存存储单元的地址，可直接寻址\n* 概念：需要将用户程序的逻辑地址转换为可由其直接寻址的物理地址\n* 分类：\n  * 静态重定位：\n    * 用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换\n    * 一般由软件完成\n  * 动态重定位：（常用）\n    * 进程执行过程中进行地址变换：逐条指令执行时完成地址转换\n    * 需要硬件部件支持（部件：内存管理单元MMU memory management unit）\n\n#### 物理内存划分\n\n空闲内存管理：\n\n* 等长划分：\n  * bitmap 位图：每个分配单元对应一位\n* 不等长划分：\n  * 空闲区表、已分配区表：表中每一项记录起始地址、长度、标志\n  * 空闲块链表：每个表项用链相连\n\n内存分配算法：\n\n* 首次适配 first fit：空闲区表第一个满足进程要求的空闲区\n* 下次适配 next fit：从上次找到的空闲区接着找\n* 最佳适配 best fit：查找整个表，找到满足要求的最小空闲区\n* 最差适配 worst fit：总分配满足进程要求的最大空闲区\n\n空闲区划分：一部分供进程使用，一部分作为新的空闲区\n\n回收问题：\n\n* 内存回收算法：\n  * 某一块归还后，空闲空间合并，修改空闲区表\n  * 四种情况：\n    * 上相邻、下相邻、上下都相邻、上下都不相邻\n\n伙伴系统：\n\n* linux底层内存管理采用\n* 经典的内存分配方案\n* 主要思想： 内存按2的幂划分，组成空闲块链表，查找最佳匹配\n* 算法：\n  * 首先将整个空间看做一块 $2^U$\n  * 假设进程申请空间大小为s，若满足 $ 2^{U-1}<s<=2^U $则分配整个块\n  * 否则把块划分成两个大小相等的伙伴 $2^{U-1}$\n  * 一直划分直到产生大于等于s的块\n* 进程使用完后归还空间，空间进行可能的合并\n\n#### 基本内存管理方案（1）\n\n整个进程进入内存连续区域\n\n以进程为单位装载\n\n方案：\n\n* 单一连续区：\n  * 特点：一段时间内只有一个进程在内存\n  * 简单，但内存利用率低\n* 固定分区：\n  * 分区：内存空间分割\n  * 分区固定不变，大小可以相同也可以不同\n  * 一个分区装一个进程\n* 可变分区：\n  * 根据进程需要把空闲空间分割，分配进程，剩余部分成为新的空闲区\n  * 缺点：有外碎片(进程之间的小空闲空间无法分配)，导致内存利用率下降\n  * 碎片：很小的，不易利用的空闲区\n  * 问题解决：紧缩技术 memory compaction：\n    * 在内存移动程序把小空闲区合并：\n    * 需要考虑：\n      * 系统开销\n      * 移动时机\n\n#### 基本内存管理方案（2）\n\n一个进程进入内存中若干不连续区域\n\n方案：\n\n* 页式存储管理：\n  * 用户进程被划分为大小相等的部分称 页 page 或页面\n  * 内存空间按同样大小分区域，称页框 page frame\n  * 内存分配：\n    * 以页为单位分配，按进程需要的页数分配\n    * 逻辑相邻的页，物理上不一定相邻\n  * 典型页面尺寸： 4K或4M\n  * 逻辑地址： 页号+页内地址\n  * 页表：\n    * 页表项：记录逻辑地址和物理地址的映射关系\n    * 每个进程一个页表，一般放在内存\n  * 空闲内存管理：bitmap\n  * 地址转换：硬件支持：\n    * 逻辑地址，CPU自动划分为页号和页内地址，用页号查页表得到页框号，再与页内偏移拼接成物理地址\n  * 内碎片：页框内浪费空间\n* 段式存储方案：\n  * 按程序逻辑划分若干程序段，每个段一个段名\n  * 内存空间被动态划分为长度不同的区域，称为物理段\n  * 以段为单位进行划分，每段占连续空间，段之间可以不相邻\n  * 逻辑地址 = 段号+段内地址 ， 无法自动划分\n  * 段表： 记录每段长度和段起始地址，存放在内存\n  * 物理内存管理：空闲区表\n  * 地址转换：硬件支持：\n    * 逻辑地址，用段号查段表，得到起始地址，与段内偏移地址计算出地址\n* 段页式存储方案：\n  * 综合页式，段式优点\n  * 先按段划分，每个段按页划分\n  * 逻辑地址：段号+页号+页内地址\n  * 内存划分：同页式存储方案\n  * 内存分配：以页为单位分配\n  * 段表： 记录每一段页表起始地址和长度\n  * 页表：逻辑页号和页框的对应关系\n  * 一个进程一个段表多个页表，一个段表一个页表\n  * 空闲区同页式管理\n\n#### 交换技术 swapping\n\n内存不足时的解决方案，当大的地址空间装不进小的内存空间\n\n内存”扩充“技术\n\n* 内存紧缩技术（可变分区）\n* 覆盖技术 overlaying：（早期操作系统）\n  * 程序大小超过物理内存总和\n  * 程序不同部分在内存中相互替代，把不会同时执行的程序段共享同一内存区域\n  * 要求程序各模块有明确的调用结构\n  * 程序员声明覆盖结构，操作系统完成自动覆盖\n  * 缺点：用户不透明，增加用户负担\n* 交换技术 swapping：\n  * 系统把内存中某些进程暂时移到外存，把外存某些进程换入内存\n  * 问题：\n    * 进程哪些内容要交换：运行中创建或修改的内容：栈和堆\n    * 磁盘什么位置保存：交换区swap space：一块特殊的区域，包含连续的磁道，操作系统通过底层的磁盘读写操作对其高效访问\n    * 交换时机：只要不用就换出； 内存空间不足或即将不足时\n    * 如何选择被换出的进程：不应换出处于等待IO状态的进程\n    * 如何处理进程空间增长：预留空间给数据段、栈增长\n* 虚拟存储技术 virtual memory\n\n\n### 存储模型（2） 虚拟存储\n\n重点：\n\n* 虚拟存储技术\n* 虚拟页式存储方案的实现：\n  * 多级页表、翻转页表、页表项、地址转换、MMU、快表TLB、页错误、缺页异常处理\n* 软件策略：\n  * 驻留集、置换范围、清除策略\n  * 置换算法：OPT、FIFO、第二次机会、时钟算法、LRU、老化、工作集\n* 虚存相关的软件技术：内存映射文件、写时复制\n\n教材：\n\n* 第三章：3.3、 3.4、 3.5.1、 3.5.7、 3.5.8、 3.6.1\n\n#### 虚拟存储技术\n\n定义： 进程运行时，一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成从磁盘调入内存的工作\n\n虚拟地址空间：分配给进程的虚拟内存\n\n虚拟地址：虚拟内存中指令或数据的位置\n\n虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用\n\n大小限制：寻址空间和磁盘大小\n\n地址保护：（硬件）\n\n* 确保每个进程都有独立的地址空间\n* 确保进程访问合法的地址范围： 基地址寄存器+界限寄存器\n* 确保进程的操作是合法的\n\n虚拟页式paging：\n\n* 虚拟存储技术+页式存储方案\n* 基本思想：\n  * 进程开始前装入一个或0个页面\n  * 根据进程需要动态装入其他页面\n  * 当内存空间满，又需要装入新的页面，则根据置换算法置换某个页面，以装入新的页面\n* 方式：\n  * 请求调页 demand paging\n  * 预先调页 prepaging\n* 用CPU时间和磁盘空间换内存空间\n\n#### 页表和页表项的设计\n\n页表由页表项组成：\n\n* 页框号：内存块号、物理页面号\n* 有效位：表示该页在内存还是在磁盘\n* 访问位R：引用位，表示这个页被访问过\n* 修改位M：表示该页在内存中是否被修改过\n* 保护位：读 / 可读写\n\n通常页表项是硬件设计的\n\n页表在内存不应该连续存放，因此需要引入页表页的地址索引表：页目录 page directory\n\n二级页表：\n\n* 虚拟地址： 页目录偏移+页表偏移+页内偏移\n* 可以表示4G的虚拟地址\n* 从页目录地址寄存器得到页目录首地址，加上页目录偏移得到页表首地址，加上页表偏移得到在第i个页表的页框号，页框号+页内偏移得到物理地址\n* ![虚存页表](http://ot1c7ttzm.bkt.clouddn.com/virtualpage.png)\n\n反转页表（倒排页表）：\n\n* 每个进程一张页表过于庞大\n* 从物理地址空间出发，系统建立一张页表\n* 页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系\n* 解决从虚拟地址到物理地址的映射：虚拟地址页号部分映射到散列值，散列值指向一个反转页表\n\n#### 地址转换过程和TLB引入\n\n虚拟地址到物理地址映射： MMU 内存管理单元\n\n快表 TLB translation look-aside buffers的引入：\n\n* 原因：\n  * 页表需要进行多次内存访问\n  * CPU指令处理速度和内存指令访问速度差异大\n* 程序访问的局部性原理\n* CPU中引入的高速缓存（cache），随机存取型存储器组成\n* 有特殊的接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较\n* 相联存储器 associative memory：特点：按内容并行查找\n* 保存正在运行进程的页表的子集\n\n\n页错误：page fault\n\n* 地址转换过程中硬件产生的异常\n* 具体原因：\n  * 缺页异常：所访问的虚拟页面没调入物理内存\n  * 违反权限：读/写、用户/内核\n  * 错误的访问地址\n* 处理缺页异常：\n  * 地址映射过程中，硬件检查页表发现所要页面不在内存\n  * 操作系统执行缺页异常处理程序：获得磁盘地址、启动磁盘、将该页调入内存：\n    * 内存中有空闲页框，修改页表中相应页表项的有效位和页框号\n    * 内存中没有空闲页框，置换某一页，若该页修改过，还需要写回磁盘\n\n#### 软件相关策略\n\n驻留集：\n\n* 操作系统给每个进程分配页框数目\n* 策略：\n  * 固定分配策略：\n    * 进程创建时确定\n    * 可以根据进程类型或程序员或系统管理员需要确定\n  * 可变分配策略：\n    * 根据缺页率评估进程局部性表现\n    * 带来额外系统开销\n\n页框锁定：\n\n* 为什么要锁定页面：虚存技术使得进程运行时间不确定\n* 给每一页框增加一个锁定位\n* 不让操作系统将进程换出内存\n* 如：操作系统核心代码，关键数据结构，IO缓冲区\n\n置换问题：\n\n* 置换范围：\n  * 置换集合是局限于产生缺页中断的进程，还是所有进程的页框\n  * 策略：\n    * 局部置换：只在产生本次缺页的进程的驻留集中选择\n    * 全局置换：将内存中所有未锁定的页框都作为置换的候选\n* 置换策略：\n  * 选择换出哪个页框\n  * 目标：置换最近最不可能访问的页\n  * 局部性原理：基于过去行为来预测将来行为\n  * 但策略设置越复杂，实现时软硬件开销越大\n  * 约束：不能置换锁定的页框\n\n清除策略：\n\n* 清除：从进程驻留集中集中回收页框（进程运行过程中回收）\n* 需要在系统中保持一定数目空闲页框，使得系统在最佳状态工作\n* 分页守护进程 paging daemon：\n  * 大部分时间睡眠，定期唤醒检查内存状态\n  * 若空闲页框数过少，该进程通过页面置换算法换出内存\n  * 若页面被修改过，则写回磁盘，以保证所有空闲页框是干净的\n* 页缓冲技术：\n  * 不丢弃置换出的页，放入两个表之一：空闲链表和修改链表\n  * 修改链表定期写回磁盘\n  * 被置换的页仍在内存，一旦进程又要访问，则可以迅速将它加入进程的驻留集合\n\n#### 置换算法 replacement\n\n颠簸 thrashing：页面在内存和磁盘间调度的事件多于实际运行的时间\n\n影响缺页次数的因素：\n\n* 置换算法\n* 页面大小：\n  * 内部碎片\n  * 页表长度\n  * 辅存的物理特性\n* 程序编制问题\n* 分配给进程的页框数目\n\n最佳页面置换算法 OPT：\n\n* 置换以后不再需要或最远的将来才会用到的页面\n* 无法实现\n* 作用：作为一种标准来衡量其他算法性能\n\n先进先出 FIFO：\n\n* 选择在内存中驻留时间最长的页并置换\n* 实现：页面链表法\n\n第二次机会算法 SCR second chance：\n\n* 按先进先出选择页面，检查其访问位R，若为0，则置换，若为1，则给第二次机会并把R置位0\n\n时钟算法 CLOCK：\n\n* SCR的改进，把链表改成环，用指针指向当前要置换的页\n\n最近未使用算法 NRU：\n\n* 最近未使用的一页\n* 实现：根据页表项的两位：访问位R，修改位M（若硬件没有这两位，则用软件模拟）\n* R位定期清零\n* 优先级：\n  * 1 最低：R=0，M=0，无使用，未修改\n  * 2： R=0，M=1\n  * 3： R=1，M=0\n  * 4： R=1，M=1\n* 时钟算法实现：\n  * 环状链表，选中遇到第一个R=0，M=0,用于置换\n  * 若没有，则扫描第一个 R=0，M=1，对每个跳过的页框，把R置为0\n  * 若仍没有，重新扫描R=0，M=0\n  * 若仍没有，则扫描 R=0，M=1\n\n最近最少使用 LRU：\n\n* 置换未使用时间最长的一页\n* 性能最接近 OPT 最佳算法，使用最多\n* 实现： 开销大，需要维护时间戳或访问页的栈\n\n最不经常使用 NFU：\n\n* LRU的一种软件解决方案（自说）\n* 选择访问次数最少的页面置换\n* 实现：\n  * 软件计数器，每一个页一个，初值为0\n  * 每次事件中断，计数器加该页的R\n  * 缺页中断时，选择计数器最小的置换\n\n老化算法 AGING：\n\n* 对NFU的改进（模拟LRU）：\n* 计数器在加R前先右移一位（除以2），R加到计数器最左端\n\nBELADY现象：\n\n* 页框数目多，缺页次数反而多\n\n工作集working set 算法：\n\n* 程序局部性： 活跃页面：进程一段时间中集中访问的页面\n* 为进程提供和活跃页面数相等的物理页面数，则可以减少中断次数\n* 工作集：当前正在使用的页框集合， W(t, delta)=该进程在时刻 t 过去 delta 事件单位中访问的页面的集合\n* 核心思想：找出一个不在工作集的页面并置换它\n* 思路：\n  * 每个页表项记录该页面最后一次被访问的时间\n  * 设置时间T\n  * 判断：根据一个页面访问时间在 当前时间-T 之前或之中决定其在工作集之内还是之外\n* 实现：扫描所有页表项：\n  * 若 R=1，则把其最后一次访问时间设置为当前时间，R清零\n  * R=0，则检查访问时间是否在 当前时间-T 之前（不在工作集）\n    * 若是，则置换\n    * 若不是，则记录最后访问时间的最小值\n\n![置换算法](http://ot1c7ttzm.bkt.clouddn.com/replacement.png)\n\n#### 其他技术\n\n内存映射文件：\n\n* 进程通过系统调用 mmap 将文件或部分 映射到虚拟地址空间的一部分，访问该文件就像访问内存中的大数组，而不是对文件进行读写\n* 不会实际读入页面，在访问页面时才会被读入内存\n* 进程退出或显示解除文件映射时，修改写回磁盘\n\n写时复制技术：\n\n* 多个进程共享页面，页标志为写时复制\n* 进程试图改变页面数据时，操作系统复制一个页面，对执行写操作的进程是私有的\n\n\n### 文件系统（1）\n\n重点：\n\n* 文件系统相关概念：文件、文件分类、文件逻辑结构和物理结构\n* 文件目录的实现：文件控制块FCB、目录项、目录文件\n* 文件系统的实现：磁盘布局、内存树结构\n* 磁盘空间的管理：存储介质、扇区、物理块block、簇cluster\n\n教材：\n\n* 第四章：4.1、 4.2、 4.3、 4.5.3\n\n#### 文件与文件系统\n\n文件 是 对磁盘的抽象\n\n文件：一组带标识的、在逻辑上有完整意义的信息项的序列\n\n信息项：构成文件内容的基本单位（单个字节或多个字节），各信息项之间有顺序关系\n\n文件内容的意义：由文件建立者和使用者解释\n\n文件系统：操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供共享和保护手段：\n\n* 统一管理磁盘空间，实施磁盘空间分配和回收\n* 实现文件按名存取（名字空间 -> 映射 -> 磁盘空间）\n* 实现文件信息的共享\n* 向用户提供方便使用和维护的接口\n* 提高文件系统性能\n* 提供与IO系统的统一接口\n\n文件分类：（UNIX）：按文件性质和用途\n\n* 普通文件\n* 目录文件\n* 特殊文件（设备文件）：设备作为文件处理，分为字符设备或块设备\n* 管道文件\n* 套接字\n\n文件的逻辑结构：\n\n* 由用户的访问方式决定\n* 典型文件逻辑结构：\n  * 流式文件：文件是有逻辑意义、无结构的一串字符的集合\n  * 记录式文件：文件由若干记录组成，可以按记录读写查找等\n* 文件存取：\n  * 顺序存取（访问）\n  * 随机存取（访问）：提供读写位置\n\n#### 文件的存储介质\n\n典型存储介质：磁盘、磁带、光盘、U盘\n\n物理块：\n\n* 信息存储、传输、分配的独立单位\n* 存储设备划分为大小相等的物理块，统一编号\n\n典型磁盘结构：\n\n* 任何时刻只有一个磁头处于活动状态：输入输出数据流以位串形式出现\n* 物理地址形式：磁头号、磁道号、扇区号\n\n磁盘访问：\n\n* 寻道：磁头移动到指定磁道\n* 旋转延迟：等待指定扇区\n* 数据传输：数据在磁盘和内存之间实际传输\n\n磁盘空间管理：\n\n* 数据结构：\n  * 位图：用二进制位反应块的分配情况，0为已经分配，1为空闲\n  * 空闲块表：所有空闲块记录在一张表\n  * 空闲块链表：**成组链接法**\n  * ![成组链接法](http://ot1c7ttzm.bkt.clouddn.com/grouplink.png)\n\n#### 文件属性\n\n文件控制块 file control block：为了管理文件而设置的数据结构，保存所需要等待有关信息\n\n文件目录：\n\n*  统一管理每个文件的元数据，以支持文件名到文件物理地址的转换\n*  将所有文件的管理信息组织在一起\n\n目录文件：文件目录以文件的形式存放在磁盘上\n\n目录项：\n\n* 构成文件目录的基本单元\n* 目录项可以是FCB，目录是文件控制块的有序集合\n\n#### 文件的物理结构\n\n文件在存储介质的存放方式\n\n结构：\n\n* 连续（顺序）结构：\n  * 文件的信息在若干连续的物理块中\n  * 优点：\n    * 简单\n    * 支持顺序存取、随机存取\n    * 需要的磁盘寻道次数和寻道时间最少\n    * 可以同时读入多个块，检索一个块也容易\n  * 缺点：\n    * 文件不能动态增长\n    * 不利于文件插入和删除\n    * 会产生外部碎片：紧缩技术\n* 链接结构：\n  * 一个文件的信息存放在若干不连续物理块中，各块用指针相连，前一个物理块指向下一个物理块\n  * 优点：\n    * 提高磁盘空间利用率，不存在外部碎片问题\n    * 利于文件插入、删除\n    * 利于文件动态扩充\n  * 缺点：\n    * 存取速度慢，不利于随机存取\n    * 可靠性问题，如指针出错\n    * 更多寻道时间和寻道次数\n    * 链接指针占用空间\n  * 变形：文件分配表 FAT：记录每个物理块的下一块的索引\n* 索引结构：\n  * 信息存放在若干不连续的物理块中\n  * 系统为每个文件建立一个索引表，块号放在索引表\n  * 索引表就是磁盘块地址数组\n  * FCB放索引表的起始地址\n  * 优点：\n    * 保持链接结构优点，又解决其缺点：\n      * 能顺序和随机存取\n      * 满足文件动态增长、插入删除要求\n  * 缺点：\n    * 寻道次数和寻道时间多\n    * 索引表需要额外空间\n  * 组织方式：\n    * 当索引表很大，需要多个物理块存放时：\n      * 链接方式：一个盘块存一个表\n      * 多级索引\n      * 综合索引：直接索引加间接索引：部分直接索引，指向一个物理块，一部分间接寻址，指向索引表\n  * UNIX 三级索引结构（综合模式）：\n    * 每个文件主索引表放FCB中，有15项，每项2字节\n    * 前12个直接寻址\n    * 第13项指向一级索引表\n    * 第14项作为二级索引表\n    * 第15项作为三级索引表\n    * 最大总文件大小 = 12 + 256 + 256*256 + 256^3 个block\n\n#### 文件系统的实现\n\n需要考虑： 磁盘上 和 内存中 内容布局\n\n磁盘分区 partition：把一个物理磁盘存储空间划分为几个相互独立部分\n\n文件卷 volume：磁盘上的逻辑分区，由一个或多个物理块组成：\n\n* 一个文件卷可以使一个盘或部分盘或跨盘 RAID\n* 同一个文件卷使用同一份管理数据\n* 文件卷上：文件系统信息、一组文件（用户文件+目录文件）、未分配空间\n* 块 block 或 簇cluster：\n\n格式化 format：在一个文件卷上建立文件系统，建立并初始化元数据\n\nUNIX：\n\n * FCB = 目录项 + i节点\n * 目录项 = 文件名+i节点号\n * i节点 = 保存描述文件的相关信息\n\n\n\n\n### 文件系统（2）\n\n重点：\n\n* 文件操作的实现流程\n* 文件系统的可靠性、一致性、写入策略、安全性\n* 提高文件系统性能\n* FAT文件系统的实现\n\n#### 文件操作的实现\n\n创建文件：\n\n* 建立系统和文件的联系，实质是建立文件的FCB\n* 在目录中为新文件建立一个目录项，填写参数\n* 分配必要的存储空间\n* 流程：\n  1. 检查参数合法性（命名规则、重名文件等）\n  2. 申请空闲目录项，填写相关信息\n  3. 为文件申请磁盘块\n\n打开文件：\n\n* 根据文件名在文件目录中检索，找到目录项或FCB\n* 将目录项读入内存，建立相应的数据结构（文件描述符或文件句柄），为后续操作做好准备\n* 流程：\n  1. 给出路径名查目录，找到目录项或i节点号\n  2. 根据文件号查系统打开文件表\n     1. 是 则共享计数加1\n     2. 否 将信息填入系统打开文件表，共享计数为1\n  3. 根据打开方式、共享说明和用户身份检查访问合法性\n  4. 在用户打开文件表获取一个空表项，填写参数，返回文件句柄\n* 指针定位：\n  * 每个进程打开的每个文件维护一个读写指针\n  * 在用户打开文件表中\n\n读文件：\n\n1. 根据打开文件时的文件描述符，找到FCB，确定操作合法性\n2. 把文件的逻辑块号转换成物理块号\n3. 申请缓冲区\n4. 启动磁盘IO操作，把磁盘块内容送到缓冲区，而后送到内存\n\n#### 文件系统的管理\n\n可靠性：\n\n* 抵御和预防各种物理性破坏和人为性破坏的能力\n* 坏块问题\n* 备份：通过转储操作，形成文件或文件系统的多个副本\n\n转储：\n\n* 全量转储：定期拷贝所有文件\n* 增量转储：只转储修改过的文件，两次备份之间的修改\n* 物理转储：从磁盘第0块开始，将所有磁盘块按序输出到磁带\n* 逻辑转储：从指定目录开始，递归转储给定日期后所有更改的文件或目录\n\n文件系统一致性：\n\n* 问题的产生：磁盘块 -> 内存 -> 写回磁盘块，若在写回之前系统崩溃，则文件系统不一致（FCB、目录文件已经更新）\n* 解决方案：设计程序，当系统再次启动时检查磁盘块和目录系统\n* 磁盘块的一致性检查：\n  * 用两张表，每个表项对应一个磁盘块，第一张表记录每个块在文件中出现的次数，第二张表记录在空闲块表中出现的次数\n  * 情况1： 使用块和空闲块相反：正常\n  * 情况2： 使用块和空闲块均为0：把空闲块置1\n  * 情况3： 使用块和空闲块均为1：空闲块置0\n  * 情况4： 使用块为2，空闲为0： 在空闲中寻找一个把多出的文件写入\n\n写入策略：\n\n* write-through：直写：内存中修改立刻返回磁盘：FAT\n* lazy-write：延迟写：利用回写write back缓存的方法增加速度\n* transaction log：可恢复写：利用事务日志实现文件系统写入 ： NTFS，EXT3\n\n访问控制：\n\n1. 主动控制：访问控制表：\n   * 每个文件一张表\n   * 记录用户id和访问权限\n   * 用户可以是一组用户\n   * 文件可以是一组文件\n2. 能力表（权限表）\n   * 每个用户一个\n   * 记录文件名及访问权限\n   * 用户可以是一组用户\n   * 文件可以是一组文件\n\nUNIX文件访问控制：\n\n* 采用文件二级存取控制\n* 第一级：对访问者的识别：\n  * 对用户分类：\n    * 文件主\n    * 文件主的同组用户\n    * 其他用户\n* 第二级：对操作权限的识别：\n  * 对操作分类：\n    * 读 r\n    * 写 w\n    * 执行 x\n    * 不能执行任何操作 -\n\n#### 文件系统的性能\n\n设计文件系统应该尽可能减少磁盘访问次数\n\n方法：\n\n* 目录项FCB分解、当前目录、磁盘碎片整理\n* 块高速缓存 block cache：\n  * 在内存中为磁盘块设置一个缓冲区，保存磁盘某些块的副本\n  * 检查所有读请求，看是否在块高速缓存中\n    * 若在，则直接读\n    * 若不再，先将块拷入块高速缓存，再拷入所需地方\n  * 组织：用hash\n  * 置换：LRU\n  * 写入策略（文件系统一致性）：定期写回磁盘\n* 合理分配磁盘空间：\n  * 分配磁盘块时，有可能顺序存取的块放在一起\n  * 尽可能分配在同一柱面上，从而减少磁盘臂移动次数和距离\n* 磁盘调度：\n  * 有多个访盘请求时，采用一定策略调整顺序\n  * 降低平均磁盘服务时间\n  * 调度算法：\n    * 先来先服务 FCFS\n    * 最短寻道时间优先：优先选择离当前磁头最近的访问请求\n      * 优点：改善平均服务请求\n      * 缺点：饥饿现象\n    * 扫描算法 SCAN （电梯算法）：按一个方向移动，若该方向没有请求，则改变方向\n    * 单向扫描算法 C-SCAN：SCAN的改进：总从0号柱面向里扫描，到达最后一个柱面时，立即返回0号，返回时不服务，返回后再次扫描\n    * N-step-SCAN策略：磁盘请求划分为长度为N的子队列，每一次用SCAN处理一个子队列\n    * FSCAN策略：使用两个子队列，开始时请求在一个队列，扫描时请求加入另一个队列\n    * 旋转调度：根据延迟时间决定执行次序的调度\n* 信息的优化分布：\n  * 记录在磁盘的排列方式\n* 记录的成组与分解：\n  * 若干逻辑记录合成一组存放\n  * 成组操作必须用内存缓冲区，缓存区长度 = 记录长度 * 块因子\n  * 目的：提高空间利用率和工作效率\n* RAID 独立磁盘冗余阵列 技术：\n  * 多块磁盘按一定要求构成一个独立存储设备\n  * 目标：提高可靠性和性能\n  * 组织：\n    * 多个磁盘组织，作为一个逻辑卷\n    * 数据分成多个数据块，并行写入、读出多个磁盘\n    * 通过镜像或校验，提供容错能力（冗余）\n  * 分类：\n    * RAID 0-条带化，数据分布在所有磁盘上，无冗余，性能最佳\n    * RAID 1 - 镜像：利用率 50%，所有数据同时保存在两块盘相同位置，安全性最好\n    * RAID 4 -交错块奇偶校验：带奇偶校验，以数据块为单位 \n\nWindows的文件访问方式：\n\n* 不使用文件缓存\n* 使用文件缓存：\n  * Windows的cache manager实现对缓存的控制：\n    * 读取数据时预取\n    * 在cache满时，根据LRU清除缓存内容\n    * 定期更新磁盘内容使其与cache一致\n  * write-back机制：只更改cache内容，由cache manager定期写回\n* 异步模式：\n  * 不等待磁盘操作的完成\n  * 使CPU和IO并发工作\n\n\n### IO系统\n\n重点：\n\n* IO系统的概念：\n  * IO设备的特点及分类\n  * IO管理的任务\n* IO管理的解决方案\n  * IO硬件组成\n  * IO控制方式\n  * IO软件层次及功能\n* IO相关技术\n* IO性能提高的解决方案\n\n教材：第五章：5.1、 5.2、 5.4\n\n#### IO管理概述\n\nIO设备管理：\n\n* 逻辑IO：统一的操作，与具体设备无关\n* 设备驱动程序\n* 中断服务程序\n\n![IO](http://ot1c7ttzm.bkt.clouddn.com/IO.png)\n\nIO的特点：\n\n* IO性能经常成为系统性能的瓶颈\n* 操作系统庞大复杂的原因之一：IO资源多而杂，并发\n  * 速度差异大\n  * 应用\n  * 控制接口的复杂性\n  * 传送单位\n  * 数据表示\n  * 错误条件\n* 与其他功能密切相关，尤其是文件系统\n\n设备分类：\n\n* 按数据组织分：\n  * 块设备：\n    * 以数据块为单位\n    * 传输速度块，可寻址\n  * 字符设备：\n    * 以字符为单位\n    * 速率低、不可寻址\n* 从资源分配角度：\n  * 独占设备：一段时间只能有一个进程使用，一般低速，如打印机\n  * 共享设备：一段时间可有多个进程共同使用，以交叉方式使用\n  * 虚设备：\n    * 在一类设备上模拟另一类，常用 共享模拟独占、高速模拟低速\n    * 实例：SPOOLing技术，用硬盘模拟输入输出\n\n目标：\n\n* 按用户请求，控制设备的各种操作，完成设备和内存的数据交换\n  * 设备的分配和回收\n    * 记录设备的状态\n    * 根据用户请求和设备类型，采用一定分配算法，选择设备到内存的数据通路\n  * 执行设备驱动程序\n  * 设备中断处理\n  * 缓冲区管理：管理IO缓冲区\n* 建立方便统一的独立于设备的接口：通用性\n  * 方便性：用户编程时不考虑设备的物理特性\n  * 统一性：用户程序使用的是逻辑设备，以屏蔽硬件细节\n* 利用各种技术提高CPU与设备、设备之间的并行工作能力，充分利用资源\n  * 并行性\n  * 均衡性\n* ​\n\n#### IO设备组成\n\n一般由机械和电子部分组成：\n\n* 机械部分是设备本身（物理装置）\n* 电子部分又称设备控制器（适配器）\n  * 地址译码\n  * 接受计算机发来或向计算机发送数据和状态信号\n  * 把计算机数字信号转换成机械能识别的模拟信号，或反过来\n  * 设备内部硬件缓冲或数据加工等提升性能\n\n机械部分：设备接口——控制器：\n\n* 操作系统将命令写入控制器的接口寄存器，并从中读取状态信息或结果信息\n* 控制器接受命令后独立于CPU执行，命令完成后产生中断，操作系统通过读控制寄存器的信息获取操作结果和状态\n* 控制器和设备的接口通常是低级借口\n* 控制器的任务：串行位流转换成字节块，并进行必要的错误修正\n\nIO端口地址：\n\n* 每个寄存器都有的唯一的地址\n* 所有端口地址形成IO端口空间\n* IO指令形式和IO地址关联：\n  * 内存映像编址（内存映像IO模式）：内存一部分用作IO端口\n    * 把IO端口看作一个存储单元\n    * 优点：\n      * 凡是可对内存的操作均可对IO操作\n      * 不需要专门IO指令\n      * IO端口空间大\n      * 不需要专门机制阻止用户操作IO\n    * 缺点：\n      * 占用内存空间\n      * 不能对控制寄存器进行高速缓存\n  * IO独立编址（IO专用指令）：IO空间独立于内存\n    * 使用专门的IO指令对端口操作\n    * 优点：\n      * 外设不占内存\n      * 编程时可以区分对内存还是对IO\n    * 缺点：IO操作指令类型少，操作不灵活\n\nIO控制方式：\n\n1. 可编程IO（轮询、查询）\n   * CPU不断询问IO模块\n   * 设置控制寄存器后不断查询状态寄存器，完成后把数据寄存器中数据读取\n2. 中断驱动IO\n   * IO结束后，由设备控制器主动通知设备驱动程序\n3. DMA\n   * 直接内存存取\n\n#### IO软件组成\n\n设计思想：\n\n* IO软件组织成多层次\n* 每层执行所需要功能的子集，依赖于低一层实现的功能\n* 低层考虑硬件特性，向高层提供接口\n* 高层不考虑硬件细节，提供良好接口\n\n软件层次：\n\n* 用户级IO\n* 与设备无关的OS软件：\n  * 驱动程序统一接口\n  * 缓存\n  * 错误报告\n  * 分配与释放设备\n  * 提供与设备无关的尺寸大小\n* 设备驱动程序\n* 中断处理程序\n\n设备无关性：用户程序可以访问任意IO设备，无需事先指定设备\n\n* 好处：易实现IO重定向，设备分配灵活\n\n#### IO相关技术\n\n缓冲技术：\n\n* 凡是数据到达和离去速度不匹配的地方均可用缓冲技术\n* 实现：\n  * 硬缓冲：由硬件寄存器实现\n  * 软缓存：内存中开辟空间作缓冲区\n* 缓冲区管理：\n  * 单缓冲\n  * 双缓冲\n  * 缓冲池（多缓存）：统一管理多个缓冲区，缓冲区循环使用\n* UNIX缓冲技术：\n  * 结合提前读和延迟写技术\n  * 充分利用从磁盘读入，已传入用户区但仍在缓冲区的数据\n  * 缓冲区组成：缓冲控制块+数据区\n  * 空闲缓冲区对联 av链\n  * 设备缓冲队列 b链：链接所有分配给设备使用的缓冲区，按散列方式组织\n\n#### IO设备管理\n\n独占设备的分配：\n\n* 静态分配：\n  * 运行前完成设备分配，结束时收回设备\n  * 缺点：利用率低\n* 动态分配：\n  * 运行过程中，用户提出设备要求时进行分配，一旦停止使用立刻收回\n  * 优点：效率高\n  * 缺点：可能死锁\n\n分时式共享设备：\n\n* 以一次IO为单位分时使用设备，不同IO请求排队使用\n\n设备驱动程序：\n\n* 每个设备驱动程序管理一类设备\n* 接收来自与设备无关的上层软件抽象请求，并执行请求\n* 每个控制器有一个或多个设备寄存器用于存命令和参数，设备驱动程序负责释放命令并监督执行\n* 与外界的接口：\n  * 与操作系统的接口\n  * 与系统引导的接口\n  * 与设备的接口\n* 接口函数\n* IO进程：专门处理系统IO请求与IO中断\n\n#### IO性能问题\n\n核心：\n\n* 使CPU利用率尽可能不被IO降低\n* 使CPU尽可能摆脱IO\n\n解决方案：\n\n* 减少或缓解速度差距：缓冲技术\n* 使CPU不等待IO：异步IO：用其他操作填充IO操作间等待的CPU时间\n* 使CPU摆脱IO：DMA、通道\n\n\n### 死锁\n\n重点：\n\n* 死锁的基本概念\n  * 死锁的四个必要条件\n  * 死锁和活锁、饥饿的区别\n* 死锁的解决方案：\n  * 死锁预防：资源的有序分配法\n  * 死锁避免：银行家算法、安全/不安全状态\n  * 死锁检测与解除\n* 资源分配图和在解决死锁问题的应用\n* 哲学家就餐问题\n\n\n\n#### 基本概念\n\n死锁：\n\n * 一组进程中每个进程都无限等待被该组另一进程占用的资源\n * 参与死锁的所有进程都在等待资源\n * 参与死锁的进程是当前系统中所有进程的子集\n\n死锁的原因：\n\n * 资源数目有限、锁和信号量错误使用\n * 资源的使用方式： 申请 -- 分配 -- 使用 -- 释放\n * 资源分类：\n    * 可重用资源：可被多个资源多次使用\n       * 可抢占资源：CPU\n       * 不可抢占资源：打印机\n   * 可消耗资源：只使用一次、可创建和销毁的资源：如信号、中断、消息\n\n活锁和饥饿：\n\n* 活锁：得不到资源，但能够运行，既无进展也无阻塞\n* 饥饿：资源分配策略决定\n\n死锁的产生条件：\n\n* 互斥使用（资源独占）：一个资源一次一个进程使用\n* 占有且等待：在申请新资源的同时保持对原资源的占有\n* 不可抢占、不可剥夺：资源只能由占有者自愿释放\n* 循环等待\n\n#### 资源分配图\n\n用有向图描述系统资源和进程的状态\n\n结点V：分为P 进程 ， R 资源\n\n有向边E：有向边的集合，资源 R 指向 进程 P （资源分配）或 进程P 指向资源R（申请资源）\n\n死锁定理：\n\n* 资源分配图中没有环路，则没有死锁\n* 图中存在环路，系统可能有死锁\n* 若每个资源类只有一个资源实例，则 环路存在  <=> 死锁存在\n\n#### 死锁预防\n\n解决死锁的方法：\n\n* 鸵鸟算法：不考虑死锁问题\n* 不让死锁发生\n  * 死锁预防：静态策略：设计合适的资源分配算法\n  * 死锁避免：动态策略：以不让死锁发生为目标，跟踪和评估资源分配过程，根据评估结果决策是否分配\n* 死锁检测与解除\n\n死锁预防：\n\n* 防止产生死锁的四个必要条件之一\n* 破坏 互斥使用、资源独占 条件：\n  * 资源转换技术：把独占资源变为共享资源\n* 破坏 占有且等待 条件：\n  * 方案1：每个进程运行前必须一次性申请所有资源，仅当进程需要的资源都可满足才一次性分配\n    * 资源利用率低，饥饿现象\n  * 方案2：申请新资源得不到满足而变为等待状态前，必须释放已经占有的所有资源\n* 破坏 不可抢占 条件：\n  * 申请的资源被其他进程占用时，可通过操作系统抢占资源（进程优先级不同）\n    * 局限性：适用于状态易于保存和恢复的资源\n* 破坏 循环等待 条件：\n  * 资源有序分配法：进程申请资源时必须按资源编号的递增次序进行，否则操作系统不予分配\n\n死锁避免：\n\n* 对进程发出的资源申请进行动态检查，根据分配后是否会发送死锁或是否可能导致死锁决定是否分配资源\n\n* 安全状态：系统中存在一个由所有进程构成的安全序列，对每个进程 Pi 以后所需要资源量不超过 （系统当前剩余资源+所有进程Pj( j<i )当前所占有的资源）\n\n* 安全状态一定不死锁，不安全状态一定导致死锁（哪怕当前未死锁）\n\n* 银行家算法 banker's algorithm：仿照银行发放贷款采取的控制方式\n\n  * 应用条件：\n\n    * 固定数目进程 共享 固定数目资源\n    * 每个进程预先指定所需要的最大资源数\n    * 进程不能申请大于系统可用资源总数的资源\n    * 进程等待资源的时间有限\n    * 系统满足进程的最大需求后，进程应在有限时间内尽快使用并归还\n\n  * 变量：\n\n    * n：进程数目\n    * m：资源类数目\n    * available   【1.m】系统每类资源剩余数目\n    * max  【1.n 1.m】每个进程对每类资源要求的最大数目\n    * allocation 【1.n 1.m】每个进程已经分配的每类资源数目\n    * need 【1.n 1.m】每个进程还需要的每类资源的数目\n    * request 【1.n 1.m】 这次每个进程申请的每类资源数目\n\n  * 步骤：\n\n    1. 若 request[i] <= need[i] 继续，否则报错\n\n    2. 若 request[i] <= available 继续，否则等待\n\n    3. 假设系统分配了资源：\n\n        available -= request[i]\n\n        allocation[i] += request[i] \n\n        need[i] -= request[i]\n\n    4. 若系统新状态安全，则分配完成，若不安全，则恢复分配\n\n  * 安全性检查：\n\n    1. work = available，finish=false\n    2. 检查每个i 有 finish[i]==false && need[i]<=work\n    3. 而后 work += allocation[i];  finish[i]=true, 转2\n    4. 若对所有i都有 finish[i]==true 则系统安全\n\n#### 死锁检测与解除\n\n死锁检测：\n\n* 允许死锁发生，但操作系统不断监视系统，判断死锁是否发生\n* 一旦发生死锁则解除死锁并以最小代价恢复系统运行\n* 检测时机：\n  * 当进程由于资源请求不满足而等待时\n  * 定时检测\n  * 系统资源利用率下降时\n\n死锁解除：\n\n1. 撤销所有死锁进程\n2. 进程回退roll back ，再启动\n3. 按某原则逐一撤销死锁进程\n4. 按某种原则逐一抢占资源\n","slug":"os_note","published":1,"updated":"2018-06-02T13:02:22.586Z","photos":[],"link":"","_id":"cjleshqko002yryfci3idgfia","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>操作系统学习笔记，包括：</p>\n<ol>\n<li>操作系统基本概念</li>\n<li>进程、线程</li>\n<li>处理器调度</li>\n<li>同步机制</li>\n<li>存储模型</li>\n<li>文件系统</li>\n<li>IO</li>\n<li>死锁</li>\n</ol>\n<a id=\"more\"></a>\n<p>重点：</p>\n<p>《现代操作系统》(第三版)</p>\n<ul>\n<li>教材：<ul>\n<li>第一章： 1.1 、1.2 、 1.4</li>\n<li>第10章： 10.2.5 linux</li>\n<li>第11章： 11.3.1 </li>\n</ul>\n</li>\n<li>重点概念：<ul>\n<li>操作系统定义</li>\n<li>操作系统三个作用</li>\n<li>操作系统四个特点</li>\n<li>SPOOLING技术</li>\n<li>windows、linux、unix架构及主要功能</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"操作系统的定义与作用\"><a href=\"#操作系统的定义与作用\" class=\"headerlink\" title=\"操作系统的定义与作用\"></a>操作系统的定义与作用</h4><ol>\n<li>有效管理资源</li>\n</ol>\n<blockquote>\n<ol>\n<li>静态分配：在进程执行前准备好需要的所有资源，会造成资源浪费</li>\n<li>动态分配：进程需要时进行申请</li>\n</ol>\n</blockquote>\n<ol>\n<li><p>通过命令接口、编程接口为用户提供服务</p>\n</li>\n<li><p>对硬件机器的扩展</p>\n<blockquote>\n<p>对硬件进行抽象，硬件之上的虚拟机器</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"操作系统的特征\"><a href=\"#操作系统的特征\" class=\"headerlink\" title=\"操作系统的特征\"></a>操作系统的特征</h4><ol>\n<li><p>并发 concurrency: 指处理多个同时性活动的能力</p>\n<blockquote>\n<p>引发问题： 活动切换、保护、相互依赖的活动的同步</p>\n<p>并行parallel： 不同程序同时在多个硬件上执行</p>\n</blockquote>\n</li>\n<li><p>共享 sharing：操作系统与用户的程序共享系统中的资源</p>\n<blockquote>\n<p>操作系统要对资源进行合理分配和使用</p>\n<ol>\n<li>互斥共享（打印机）</li>\n<li>同时共享（代码、文件）</li>\n</ol>\n</blockquote>\n</li>\n<li><p>虚拟 virtual：物理实体映射为若干个对应的逻辑实体（分时、分空间）</p>\n<blockquote>\n<p>目的：提高资源利用率</p>\n<p>CPU：每个进程 “虚处理器”</p>\n<p>存储器：虚拟地址空间</p>\n<p>显示器：多窗口</p>\n</blockquote>\n</li>\n<li><p>随机：随时对不可预测的次序发生的事件进行响应并处理</p>\n<blockquote>\n<ul>\n<li>进程运行速度不可预知</li>\n<li>难以重现系统在某个时刻的状态</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"操作系统的架构\"><a href=\"#操作系统的架构\" class=\"headerlink\" title=\"操作系统的架构\"></a>操作系统的架构</h4><p>Windows 、 Unix 、 Linux</p>\n<h4 id=\"操作系统的分类\"><a href=\"#操作系统的分类\" class=\"headerlink\" title=\"操作系统的分类\"></a>操作系统的分类</h4><p>发展： 硬件发展、应用需求发展、软件技术发展</p>\n<p>目的：充分利用硬件，提供更好服务</p>\n<p>掌握各种操作系统的目标和不同点</p>\n<ul>\n<li><p>批处理操作系统</p>\n<ol>\n<li><p>方式</p>\n<blockquote>\n<p>系统操作员从用户处收集作业并输入系统，而后启动操作系统，操作系统自动处理作业并输出，系统操作员从输出处获取作业</p>\n</blockquote>\n</li>\n<li><p>目的： 提高资源利用率，增加吞吐量</p>\n</li>\n<li><p>概念：</p>\n<ul>\n<li>作业：程序、数据、作业说明素</li>\n<li>成批：由若干作业组成</li>\n<li>批作业处理：对每个作业做相同处理</li>\n</ul>\n</li>\n<li><p>问题：</p>\n<ul>\n<li>输入输出慢，由主机完成，CPU处于等待状态</li>\n<li>解决：用卫星机：完成输入输出，暂存输入输出结果，流程：用户-&gt;卫星机-&gt;系统操作员-&gt;计算机-&gt;系统操作员-&gt;卫星机-&gt;用户</li>\n</ul>\n</li>\n<li><p>分类：</p>\n<ul>\n<li>单道批处理：一次处理一个作业</li>\n<li>多道批处理：一次选中多个作业进行处理</li>\n</ul>\n</li>\n<li><p>技术： Spooling 同时外围设备联机操作，假脱机技术</p>\n<blockquote>\n<p>用磁盘作缓冲，输入输出和计算并行在一台机器上进行</p>\n<p>现代打印过程通常用spooling技术</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>分时系统：time-sharing ，最早的交互式系统</p>\n<ol>\n<li><p>方式：</p>\n<ul>\n<li>一台主机对多个终端，用户在终端输入命令等待结果</li>\n</ul>\n</li>\n<li><p>概念：时间片 （time slice）</p>\n<p>操作系统将CPU时间划分成若干片段，以时间片为单位轮流为终端服务，每次一个时间片</p>\n</li>\n<li><p>特点：利用人的错觉，使得人感觉系统只在为自己服务（每个用户在一个虚拟机上运行）</p>\n</li>\n<li><p>目标：及时响应</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>通用操作系统：分时和批处理结合，原则：以分时优先，批处理在后</p>\n<ul>\n<li>实时操作系统<ol>\n<li>概念：计算机能及时响应外部事件的请求，在严格时间内完成处理</li>\n<li>分类：<ol>\n<li>实施过程控制（军事控制、航空）</li>\n<li>实时通信处理（订票）</li>\n</ol>\n</li>\n<li>目标：<ul>\n<li>严格时间范围内响应</li>\n<li>高可靠性</li>\n</ul>\n</li>\n<li>特征：<ol>\n<li>硬实时系统：某个动作必须在规定时间内或规定时刻完成（焊接）</li>\n<li>软实时系统：接受偶尔违反时限（播放音乐、视频等）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>PC操作系统<ol>\n<li>目标：<ul>\n<li>界面友好、使用方便</li>\n<li>丰富的应用软件</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>网络操作系统<ol>\n<li>概念：按网络体系结构协议标准开发的软件</li>\n<li>功能：网络管理，通信，安全，资源共享和网络应用</li>\n<li>追求目标：相互通信，资源共享</li>\n</ol>\n</li>\n<li>分布式操作系统<ol>\n<li>概念：以计算机网络或多处理器为基础，特征是处理分布在不同计算机上</li>\n</ol>\n</li>\n<li>嵌入式操作系统<ol>\n<li>概念：<ul>\n<li>在各种设备、装置中完成特定功能的软硬件系统（汽车、手机、播放器等）</li>\n<li>大设备、装置中的一部分</li>\n<li>对反应时间、处理时间有严格要求</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"操作系统运行环境\"><a href=\"#操作系统运行环境\" class=\"headerlink\" title=\"操作系统运行环境\"></a>操作系统运行环境</h3><p>重点：</p>\n<ul>\n<li>理解计算机系统的保护机制<ul>\n<li>掌握处理器状态</li>\n<li>掌握特权指令与非特权指令</li>\n</ul>\n</li>\n<li>掌握中断、异常机制<ul>\n<li>掌握中断、异常的基本概念</li>\n<li>理解中断、异常机制的工作原理</li>\n</ul>\n</li>\n<li>掌握系统调用机制<ul>\n<li>掌握系统调用的设计原理</li>\n<li>掌握系统调用的执行过程</li>\n</ul>\n</li>\n</ul>\n<p>重点阅读：</p>\n<ul>\n<li>第一章： 1.3、 1.6</li>\n<li>第二章： P52 图2-5</li>\n</ul>\n<p>重点概念：</p>\n<p>​    CPU状态、内核态 用户态、特权指令 非特权指令、中断、异常、中断响应、中断向量、中断处理程序、系统调用、陷入指令、系统调用号、系统调用表</p>\n<h4 id=\"处理器状态\"><a href=\"#处理器状态\" class=\"headerlink\" title=\"处理器状态\"></a>处理器状态</h4><p>中断与异常机制</p>\n<p>CPU由运算器、控制器、寄存器及高速缓存组成</p>\n<ul>\n<li>两类寄存器：<ul>\n<li>用户可见寄存器：高级语言编译器通过优化算法分配寄存器并使用，减少访问内存次数</li>\n<li>控制和状态寄存器：用于控制处理器操作，只能由操作系统代码使用，<ul>\n<li>程序计数器 PC</li>\n<li>指令寄存器 IR</li>\n<li>程序字寄存器 PSW</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>并发和共享 -&gt; 要求保护： 用户程序不对操作系统干扰</p>\n<p>要求硬件提供基本运行机制：</p>\n<ul>\n<li>CPU具有特权级别，不同特权级下运行不同指令集合</li>\n<li>将OS与用户程序隔离</li>\n</ul>\n<p>cpu状态通常为两种、三种或四种：</p>\n<p>​    在程序状态字寄存器PSW专门设置一位，根据程序的使用权限设置不同的CPU状态</p>\n<p>操作系统需要两种CPU状态：</p>\n<pre><code>       1. 内核态 ： 运行操作系统程序\n     2. 用户态： 运行用户程序\n</code></pre><p>指令分类：</p>\n<ol>\n<li>特权指令：只能由操作系统使用，用户程序不能使用（启动IO、内存清零）</li>\n<li>非特权指令：操作系统和用户程序都可以使用（控制转移）</li>\n</ol>\n<p>CPU状态的转换：</p>\n<ul>\n<li>用户态 -&gt; 内核态： 唯一途径：中断、异常、陷入机制（提供给用户程序的接口，用于调用操作系统功能）</li>\n<li>内核态 -&gt; 用户态：设置程序状态字PSW</li>\n</ul>\n<h4 id=\"中断与异常机制\"><a href=\"#中断与异常机制\" class=\"headerlink\" title=\"中断与异常机制\"></a>中断与异常机制</h4><p>操作系统是由 中断驱动的 或是 事件驱动的</p>\n<p>概念：CPU对系统发生的某个事件的反应</p>\n<p>事件的发生改变了CPU的控制流</p>\n<p>主要作用：</p>\n<ul>\n<li>及时处理外部设备中断请求</li>\n<li>捕获用户程序提出的服务请求</li>\n<li>防止用户程序执行过程中的破坏活动</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>随机发生</li>\n<li>自动处理 (硬件自动完成的)</li>\n<li>可恢复</li>\n</ul>\n<p>中断的引入原因：支持CPU与设备之间的并行操作</p>\n<p>异常的引入原因：CPU执行指令时本身出错</p>\n<p>事件：</p>\n<ul>\n<li>中断（外中断）：<ul>\n<li>IO中断（按键、外部设备）</li>\n<li>时钟中断（定时器，CPU时间片到了）</li>\n<li>硬件故障（充电）</li>\n</ul>\n</li>\n<li>异常（内中断）：<ul>\n<li>系统调用</li>\n<li>页故障、页错误（缺页）</li>\n<li>保护性异常（只读文件和写操作）</li>\n<li>断点指令（debug）</li>\n<li>其他程序性异常（算术溢出）</li>\n</ul>\n</li>\n</ul>\n<p>异常类别：</p>\n<ul>\n<li>陷入 Trap ： 有意识安排的      同步   返回到下一条指令</li>\n<li>故障 Fault： 可恢复的错误     同步    返回到当前指令</li>\n<li>终止 Abort： 不可恢复的错误   同步   不会返回</li>\n</ul>\n<h4 id=\"中断、异常机制的工作原理\"><a href=\"#中断、异常机制的工作原理\" class=\"headerlink\" title=\"中断、异常机制的工作原理\"></a>中断、异常机制的工作原理</h4><p><strong>硬件和软件相互配合</strong></p>\n<p>硬件：响应异常</p>\n<p>​    捕获请求，以一定方式相应，把CPU的控制权交给处理程序</p>\n<p>软件：处理异常</p>\n<p>​    识别类型并完成处理</p>\n<p>中断响应：硬件</p>\n<p>​    每条指令执行最后扫描中断寄存器查看是否有中断信号，若有，则中断硬件将中断触发器内容按编码送入PSW，并查询中断向量表引出处理程序</p>\n<p>​    中断向量：一个内存单元，存放中断处理程序入口地址和程序运行时需要的处理机状态字</p>\n<p>​    流程： 设备发出中断信号 -&gt; 硬件保存现场(PSW,PC) -&gt; 根据中断码查表 -&gt; 中断处理程序入口地址送入相应寄存器 -&gt; 执行处理程序    </p>\n<p>中断处理：软件</p>\n<ul>\n<li>保存相关寄存器信息（硬件只保存关键寄存器）</li>\n<li>分析具体原因</li>\n<li>执行处理功能</li>\n<li>恢复现场，返回被打断的程序</li>\n</ul>\n<h4 id=\"系统调用机制\"><a href=\"#系统调用机制\" class=\"headerlink\" title=\"系统调用机制\"></a>系统调用机制</h4><p>操作系统给用户提供的接口，在编程时可调用的操作系统功能</p>\n<p>使CPU状态从用户态陷入内核态</p>\n<p>区分： 系统调用、库函数、API、内核函数</p>\n<p>​    应用程序通常借函数库、API接口间接进行系统调用</p>\n<p>​    内核函数包含系统调用，大部分不开放给用户</p>\n<p>设计系统调用机制：</p>\n<pre><code>       1. 利用中断异常机制\n     2. 选择一条特殊指令：陷入指令，从用户态切换到内核态\n     3. 每个系统调用给定一个编号\n     4. 存放系统调用服务例程的入口地址\n</code></pre><p>用户的参数传递给内核：（从用户栈到内核栈）</p>\n<ol>\n<li>陷入指令自带参数（长度有限）</li>\n<li>通用寄存器传递参数（寄存器个数有限） （主要方法）</li>\n<li>内存中开辟专用堆栈区传递参数</li>\n</ol>\n<p>系统调用执行过程：</p>\n<ol>\n<li>中断异常机制：硬件保护现场，查询中断向量表，控制权交给系统调用总入口程序</li>\n<li>系统调用总入口程序：保存现场，把参数保存到内核栈，查系统调用表把控制权转给相应的系统调用例程或内核函数</li>\n<li>执行系统调用例程</li>\n<li>恢复现场，返回用户程序</li>\n</ol>\n<h3 id=\"进程、线程模型\"><a href=\"#进程、线程模型\" class=\"headerlink\" title=\"进程、线程模型\"></a>进程、线程模型</h3><p>重点：</p>\n<p>​    第2章： 2.1、 2.2(除 2.2.8 - 2.2.10外)</p>\n<p>重点概念：<br>​    进程、进程状态及切换、进程控制、PCB、进程地址空间、进程上下文环境、线程、线程属性、用户级线程、核心级线程、Pthreads、可再入程序、原语、web服务器</p>\n<h4 id=\"进程的基本概念\"><a href=\"#进程的基本概念\" class=\"headerlink\" title=\"进程的基本概念\"></a>进程的基本概念</h4><p>多道程序设计： 允许多个程序同时进入内存并运行</p>\n<p>并发环境：一段时间间隔内，单处理器由两个或以上程序同时处于开始运行但尚未结束的状态且次序不是事先确定的</p>\n<p>进程 process： 具有独立功能的程序关于某个数据集合上的一次运行活动，是资源分配和调度的单位，又称任务</p>\n<ul>\n<li>程序一次执行过程</li>\n<li>正在运行程序的抽象</li>\n<li>一个CPU变换成多个虚拟的CPU</li>\n<li>系统资源以进程为单位分配，如内存、文件</li>\n<li>每个进程有独立的地址空间</li>\n<li>操作系统把CPU调度给需要的进程</li>\n</ul>\n<p>进程控制块 PCB</p>\n<ul>\n<li>又称 进程描述符、进程属性</li>\n<li>操作系统用于管理控制进程的一个专门数据结构</li>\n<li>记录进程的各种属性，并描述进程的动态变化过程</li>\n<li>是系统感知进程的唯一标识，与进程一一对应</li>\n<li>包含：<ul>\n<li>进程描述信息<ul>\n<li>进程标识符 ID，唯一</li>\n<li>进程名，不唯一</li>\n<li>用户ID</li>\n<li>进程组关系（子进程、父进程等）</li>\n</ul>\n</li>\n<li>进程控制信息<ul>\n<li>当前状态、优先级、代码执行入口地址、磁盘地址、队列指针等</li>\n</ul>\n</li>\n<li>所拥有资源和使用情况<ul>\n<li>虚拟空间空间状况</li>\n<li>打开文件列表</li>\n</ul>\n</li>\n<li>CPU现场信息<ul>\n<li>寄存器值</li>\n<li>指向该进程页表的指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>进程表： 所有进程的PCB的集合（大小固定）</p>\n<h4 id=\"进程状态及状态转换\"><a href=\"#进程状态及状态转换\" class=\"headerlink\" title=\"进程状态及状态转换\"></a>进程状态及状态转换</h4><p>进程三种基本状态：运行态、就绪态、等待态</p>\n<p>运行态 running：</p>\n<p>​    占有CPU并在CPU上运行</p>\n<p>就绪态 ready：</p>\n<p>​    已具备运行条件，但没有空闲CPU</p>\n<p>等待态、阻塞态、封锁态、睡眠态：</p>\n<p>​    因等待某一事件而暂停（如读盘）</p>\n<p>状态转换：</p>\n<ol>\n<li>就绪 -&gt; 运行：调度程序选中</li>\n<li>运行 -&gt; 就绪：运行进程用完时间片，或高优先级进程进入就绪态</li>\n<li>运行 -&gt; 等待：进程等待事件（请求OS服务，资源尚未访问，等待IO，等待另一进程等） </li>\n<li>等待 -&gt; 就绪：所等待的事件发生</li>\n</ol>\n<p>其它状态：</p>\n<ul>\n<li>创建态 new：已完成创建进程必备工作（PID、PCB），但未被同意执行（资源有限）</li>\n<li>终止态 terminated：执行后，完成数据统计工作，回收资源</li>\n<li>挂起态 suspend：进行负载调节，进程不占用内存空间，进程映像交换到磁盘</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sevenlevel.png\" alt=\"\"></p>\n<p>进程队列：</p>\n<ul>\n<li>每一类进程建立一个或多个队列</li>\n<li>队列元素为PCB</li>\n<li>进程状态改变，其PCB从一个队列进入另一队列</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><p>完成进程状态之间的转换，由具有特定功能的原语完成</p>\n<p>原语 primitive：完成某特定功能的程序，不可分割、不可中断</p>\n<ol>\n<li>进程创建<ol>\n<li>新进程分配唯一标识ID以及进程控制块PCB</li>\n<li>分配地址空间</li>\n<li>初始化PCB：设置默认值</li>\n<li>设置相应的队列指针</li>\n</ol>\n</li>\n<li>进程的撤销：结束进程<ol>\n<li>回收进程占用的资源（关闭文件、断开网络、回收内存）</li>\n<li>收回PCB</li>\n</ol>\n</li>\n<li>进程阻塞：由<strong>进程自己</strong>执行阻塞原语，使自己由运行态变为阻塞态</li>\n</ol>\n<p>UNIX下进程控制： 系统调用</p>\n<ul>\n<li>fork 通过复制调用进程建立新进程</li>\n<li>exec 用新代码覆盖原来的地址空间，建立新进程</li>\n<li>wait 进程进入阻塞态 </li>\n<li>exit 终止进程运行 </li>\n</ul>\n<h4 id=\"进程相关概念\"><a href=\"#进程相关概念\" class=\"headerlink\" title=\"进程相关概念\"></a>进程相关概念</h4><p>进程的分类：</p>\n<ol>\n<li><ul>\n<li>系统进程：优先级较高</li>\n<li>用户进程</li>\n</ul>\n</li>\n<li><ul>\n<li>前台进程</li>\n<li>后台进程</li>\n</ul>\n</li>\n<li><ul>\n<li>CPU密集型进程</li>\n<li>IO密集型进程</li>\n</ul>\n</li>\n</ol>\n<p>进程的层次结构：</p>\n<ul>\n<li>Unix进程家族树：init为根</li>\n<li>Windows：地位相同</li>\n</ul>\n<p>进程和程序的区别：</p>\n<ul>\n<li>进程更准确刻画并发</li>\n<li>程序是静态的，进程是动态的</li>\n<li>进程由生命周期，程序相对长久</li>\n<li>一个程序可以对应多个进程</li>\n<li>进程可以创建其它进程，程序不行</li>\n</ul>\n<p>进程映像 image： 进程执行活动全过程的静态描述，程序+数据+栈（用户栈+内核栈）+PCB</p>\n<p>上下文context 切换： CPU硬件状态从一个进程切换到另一个进程的过程</p>\n<blockquote>\n<p>进程运行时硬件状态保存在CPU的寄存器，当进程不运行时，寄存器的值要保存到PCB中</p>\n</blockquote>\n<h4 id=\"线程的引入\"><a href=\"#线程的引入\" class=\"headerlink\" title=\"线程的引入\"></a>线程的引入</h4><p>引入原因：</p>\n<ul>\n<li>应用需要 （打字与排版与存盘、web服务器）</li>\n<li>开销考虑<ul>\n<li>线程开销小<ul>\n<li>创建新线程花费时间少</li>\n<li>线程切换花费时间少</li>\n<li>线程通信无需调用内核，直接共享资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>性能考虑：多处理器处理多线程</li>\n</ul>\n<p>线程的基本概念</p>\n<p>线程集成了CPU调度单位</p>\n<p>进程还是资源拥有者</p>\n<p>线程 thread：进程中的一个运行实体，是CPU的调度单位，也称轻量级进程</p>\n<p>属性：</p>\n<ul>\n<li>有标识符ID</li>\n<li>有状态及状态切换</li>\n<li>不运行时需要保存上下文</li>\n<li>有自己的栈和栈指针</li>\n<li>共享所在进程的地址空间和其他资源</li>\n<li>可以创建、撤销另一个线程，程序一开始是单线程执行</li>\n</ul>\n<h4 id=\"线程机制的实现\"><a href=\"#线程机制的实现\" class=\"headerlink\" title=\"线程机制的实现\"></a>线程机制的实现</h4><ul>\n<li>用户级线程 （unix）<ul>\n<li>在用户空间建立线程库</li>\n<li>通过 运行时系统（run-time system）完成管理工作</li>\n<li>内核管理、进程都不知道线程的存在</li>\n<li>线程切换不需要内核态特权，不需要操作系统干预</li>\n<li>优点：<ul>\n<li>线程切换快</li>\n<li>调度算法是应用程序特定的</li>\n<li>可运行在任何操作系统上</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>内核只分配处理器给进程，同一进程两线程不能同时运行于两个处理器</li>\n<li>系统调用大多是阻塞的，内核阻塞进程时所有线程也被阻塞</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>核心级线程 （windows）<ul>\n<li>内核管理所有线程，向应用程序提供API</li>\n<li>内核维护线程和进程</li>\n<li>线程切换需要内核</li>\n<li>以线程为单位进行调度</li>\n</ul>\n</li>\n<li>混合模型：<ul>\n<li>线程在用户空间创建</li>\n<li>线程调度在核心态完成</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"处理器调度\"><a href=\"#处理器调度\" class=\"headerlink\" title=\"处理器调度\"></a>处理器调度</h3><p>教材重点：</p>\n<ul>\n<li>第二章： 2.4</li>\n<li>第11章： 11.4.3</li>\n</ul>\n<p>重点：</p>\n<ul>\n<li>掌握处理器调度的相关概念：<ul>\n<li>调度时机、进程切换</li>\n<li>调度标准：吞吐量、周转时间、响应时间</li>\n<li>优先级/优先数、 抢占/非抢占、 IO型与CPU型</li>\n</ul>\n</li>\n<li>掌握主要的调度算法：<ul>\n<li>先来先服务、短作业有限、最高响应比优先</li>\n<li>时间片轮转、最高优先级</li>\n<li>多级反馈队列</li>\n</ul>\n</li>\n<li>了解Windows、多处理器调度的基本思想</li>\n</ul>\n<h4 id=\"处理器调度的相关概念\"><a href=\"#处理器调度的相关概念\" class=\"headerlink\" title=\"处理器调度的相关概念\"></a>处理器调度的相关概念</h4><p>CPU调度：控制、协调进程对CPU的竞争，按一定调度算法从就绪队列中选一个进程把CPU使用权交给被选中进程</p>\n<p>若没有就绪进程，系统会安排系统空闲进程或idle进程</p>\n<p>三个问题：</p>\n<ul>\n<li>按什么原则选择下一个进程：调度算法</li>\n<li>何时选择：调度时机</li>\n<li>如何让被选中进程上CPU运行：调度过程（进程上下文切换）</li>\n</ul>\n<p>调度时机： 内核对中断、异常、系统调用处理后返回用户态时</p>\n<ul>\n<li>进程正常终止或因错误终止</li>\n<li>新进程创建、等待进程变成就绪</li>\n<li>进程从运行态进入阻塞态</li>\n<li>进程从运行态进入就绪态</li>\n</ul>\n<p>调度过程：</p>\n<ul>\n<li>进程切换：一个进程让出CPU，另一个进程使用CPU<ul>\n<li>包括对原进程状态的保存，和对新进程状态的恢复</li>\n<li>过程<ul>\n<li>切换全局页目录以加载新的地址空间</li>\n<li>切换内核栈和硬件上下文</li>\n</ul>\n</li>\n<li>开销：<ul>\n<li>直接开销：内核完成切换所用的CPU时间<ul>\n<li>保存、恢复寄存器</li>\n<li>切换地址空间</li>\n</ul>\n</li>\n<li>间接开销<ul>\n<li>高速缓存、缓冲区缓存、TLB失效</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>调度算法的设计：</p>\n<ul>\n<li>衡量指标：<ul>\n<li>吞吐量 throughput： 单位时间完成的进程数目</li>\n<li>周转时间 TT turnaround time：进程从提出请求到运行完成的时间</li>\n<li>响应时间 RT response time：提出请求到第一次回应的事件</li>\n<li>CPU利用率：CPU有效工作的时间</li>\n<li>等待时间：进程在就绪队列中等待的时间</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/schedulalgo.png\" alt=\"调度算法设计\"></p>\n<h4 id=\"调度算法的设计\"><a href=\"#调度算法的设计\" class=\"headerlink\" title=\"调度算法的设计\"></a>调度算法的设计</h4><p>优先级：</p>\n<ul>\n<li>优先级与优先数</li>\n<li>静态与动态</li>\n</ul>\n<p>占用CPU的方式：</p>\n<ul>\n<li>抢占式 preemptive：<ul>\n<li>有优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU</li>\n</ul>\n</li>\n<li>不可抢占式 non-preemptive：<ul>\n<li>除非因自身原因不能运行，否则进程会一直运行下去</li>\n</ul>\n</li>\n</ul>\n<p>进程按执行过程行为划分：</p>\n<ul>\n<li>IO密集型 IO-bound</li>\n<li>CPU密集型 CPU-bound</li>\n</ul>\n<p>时间片： time slice 或 quantum：</p>\n<ul>\n<li>分配给调度上CPU的进程的时间段</li>\n</ul>\n<h4 id=\"批处理中的调度算法\"><a href=\"#批处理中的调度算法\" class=\"headerlink\" title=\"批处理中的调度算法\"></a>批处理中的调度算法</h4><ul>\n<li>先来先服务 FCFS  first come first serve：<ul>\n<li>按进程就绪先后顺序使用CPU</li>\n<li>非抢占式</li>\n<li>优点： 公平、实现简单</li>\n<li>缺点：短进程需要等长时间</li>\n</ul>\n</li>\n<li>最短作业优先 SJF shortest job first：<ul>\n<li>最短完成时间的进程优先</li>\n<li>非抢占式</li>\n<li>改善短作业的周转时间</li>\n<li>优点：最短平均周转时间（所有进程同时可运行时）</li>\n<li>缺点：不公平，长任务饥饿现象 starvation</li>\n</ul>\n</li>\n<li>最短剩余时间优先 SRTN  shortest remaining time next：<ul>\n<li>最短作业优先的抢占版本</li>\n</ul>\n</li>\n<li>最高响应比优先 HRRN  highest response ratio next<ul>\n<li>调度时，先计算每个进程的响应比R，总选择R最高的进程</li>\n<li>R = $\\frac{周转时间}{处理时间}$ =  $1+\\frac{等待时间}{处理时间}$ </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"交互式系统采用的调度算法\"><a href=\"#交互式系统采用的调度算法\" class=\"headerlink\" title=\"交互式系统采用的调度算法\"></a>交互式系统采用的调度算法</h4><ul>\n<li>轮转调度 RR round robin<ul>\n<li>目标：为短任务改善平均响应时间</li>\n<li>思路：<ul>\n<li>周期性切换</li>\n<li>每个进程一个时间片</li>\n<li>时钟中断 -&gt; 轮换</li>\n</ul>\n</li>\n<li>时间片选择：<ul>\n<li>太长：短进程响应时间长</li>\n<li>太短：切换开销大</li>\n</ul>\n</li>\n<li>优点：公平、利于交互式计算</li>\n<li>缺点：进程切换使得轮转开销大、对大小相近的进程不利、对IO型进程不利</li>\n</ul>\n</li>\n<li>最高优先级调度 HPF highest priority first：<ul>\n<li>通常： 系统进程优先于用户进程、前台进程优先于后台，偏向于IO型进程</li>\n<li>优先级反转问题 priority inversion（基于优先级的抢占式时）：低优先级进程占有高优先级进程需要的资源<ul>\n<li>影响： <ul>\n<li>系统错误</li>\n<li>高优先级进程停滞不前</li>\n</ul>\n</li>\n<li>解决方案：<ul>\n<li>设置优先级上限（临界区的进程优先级最高）</li>\n<li>优先级继承（低优先级继承高优先级）</li>\n<li>使用中断禁止（临界区进程不响应中断）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多级反馈队列 Multiple feedback queue：<ul>\n<li>设置多个就绪队列，第一级队列优先级最高</li>\n<li>时间片长度不同，级别越低，时间片越大</li>\n<li>每个队列用时间片轮转方式调度</li>\n<li>新进程创建就绪后，进入第一级</li>\n<li>进程用完时间片并放弃CPU，进入下一级就绪队列</li>\n<li>因阻塞放弃CPU的进程从等待队列出来时回到原来就绪队列</li>\n</ul>\n</li>\n<li>最短进程优先 Shortest process next</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/schedulalgo1.png\" alt=\"调度算法总结\"></p>\n<p>多处理器调度算法设计：</p>\n<ul>\n<li>不仅选择哪个进程，还要选择在哪个CPU</li>\n<li>考虑进程在多个CPU迁移的开销</li>\n<li>负载均衡问题</li>\n</ul>\n<h4 id=\"Windows-线程调度\"><a href=\"#Windows-线程调度\" class=\"headerlink\" title=\"Windows 线程调度\"></a>Windows 线程调度</h4><p>调度单位是线程</p>\n<p>采用基于动态优先级、抢占式调度，结合时间配额的调整</p>\n<p>引发线程调度的条件：</p>\n<ul>\n<li>线程优先级改变</li>\n<li>线程改变了亲和affinity处理机集合</li>\n<li>正常调度条件（4条）</li>\n</ul>\n<p>32个优先级，分三类：</p>\n<ul>\n<li>实时优先级：不改变优先级</li>\n<li>可变优先级：在一定范围内可变</li>\n<li>系统线程</li>\n</ul>\n<p>时间配额：配额单位的整数，不是时间长度值</p>\n<p>调度策略：</p>\n<ul>\n<li>主动切换</li>\n<li>抢占： <ul>\n<li>被抢占线程：<ul>\n<li>实时优先级：时间配额重置</li>\n<li>可变优先级：时间配额不变</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>时间配额用完<ul>\n<li>A优先级未降低：A进入原就绪队列末尾</li>\n<li>A优先级降低</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h3><p>重点：</p>\n<ul>\n<li>基本概念：<ul>\n<li>竞争条件、临界区</li>\n<li>进程同步、互斥</li>\n<li>自旋锁（忙等待）</li>\n</ul>\n</li>\n<li>信号量，PV操作</li>\n<li>经典问题模型及解决方案<ul>\n<li>生产者消费者问题，读者写者问题</li>\n</ul>\n</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第2章： 2.3.1~2.3.5， 2.5.2</li>\n</ul>\n<h4 id=\"进程互斥\"><a href=\"#进程互斥\" class=\"headerlink\" title=\"进程互斥\"></a>进程互斥</h4><p>竞争条件 race condition： 两个或多个进程读写某些共享数据，最后结果取决于进程的精确时序</p>\n<p>进程互斥 mutual exclusive：共享资源需要排他性使用，各进程之间竞争使用这些资源</p>\n<p>临界资源、共享资源、互斥资源 critical resource： 某些资源一次只允许一个进程使用</p>\n<p>临界区（互斥区）：critical section：各个进程中对临界资源实时操作的程序片断</p>\n<p>临界区的使用原则：</p>\n<ul>\n<li>没有进程在临界区时，想进入的可以进入</li>\n<li>不允许两个进程同时处于临界区</li>\n<li>临界区外的进程不得阻塞其他进程进入临界区</li>\n<li>不得使进程在临界区外无限等待</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>软件：<ul>\n<li>dekker解法</li>\n<li>peterson解法</li>\n</ul>\n</li>\n<li>硬件：<ul>\n<li>屏蔽中断</li>\n<li>TSL（XCHG）指令</li>\n</ul>\n</li>\n</ul>\n<p>忙等待 busy waiting：进程得到临界区访问权之前，持续测试</p>\n<ul>\n<li>自旋锁 spin lock （多处理器）</li>\n<li>为什么不直接切换进程： 临界区使用时间一般很短，切换进程的开销更大</li>\n</ul>\n<p>优先级反转（倒置）：由于临界区保护带来的问题</p>\n<h4 id=\"软件解法\"><a href=\"#软件解法\" class=\"headerlink\" title=\"软件解法\"></a>软件解法</h4><p>解法1：</p>\n<ul>\n<li>用free作为标志：临界区是否空闲<ul>\n<li>true：有进程在临界区</li>\n<li>false：无进程在临界区</li>\n<li>初始值：false</li>\n</ul>\n</li>\n<li>使用 lock(),unlock()作为原语</li>\n</ul>\n<p>dekker算法：</p>\n<ul>\n<li>引入turn变量，判断是否轮到自己</li>\n</ul>\n<p>peterson算法：</p>\n<ul>\n<li>解决了互斥访问的问题，而且克服了强制轮流的缺点</li>\n<li>通过 enter_region()  和 leave_region()函数</li>\n<li>while( turn==process &amp;&amp; interested[other]==TURE );</li>\n</ul>\n<h4 id=\"硬件解法\"><a href=\"#硬件解法\" class=\"headerlink\" title=\"硬件解法\"></a>硬件解法</h4><p>通过指令完成</p>\n<p>解法1：中断屏蔽方法</p>\n<ul>\n<li>使用  开关中断 指令 （特权指令）</li>\n<li>入临界区： 执行 关中断 指令</li>\n<li>出临界区： 执行 开中断 指令</li>\n<li>优点：简单高效</li>\n<li>缺点：<ul>\n<li>代价高，限制CPU并发能力</li>\n<li>不适用于多处理器</li>\n<li>适合操作系统，不适合用户进程</li>\n</ul>\n</li>\n</ul>\n<p>解法2：测试并加锁 指令：</p>\n<ul>\n<li>TSL指令：TEST AND SET LOCK</li>\n<li>复制 锁 到寄存器 并把锁置为1（上锁）</li>\n<li>判断寄存器是不是0<ul>\n<li>若不是0，跳转到enter_region（反复循环）</li>\n<li>若是0，返回，进入临界区</li>\n</ul>\n</li>\n</ul>\n<p>解法3： 交换 指令：</p>\n<ul>\n<li>XCHG指令：EXCHANGE</li>\n<li>寄存器设置为1，交换寄存器和锁的内容，判断寄存器是否是0（与TSL类似）</li>\n</ul>\n<h4 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h4><p>进程同步 synchronization：多个进程中发生的事件存在某种时序关系，需要合作</p>\n<p>生产者、消费者问题（有界缓冲区）：</p>\n<ul>\n<li>一个或多个生产者生产某种数据放在缓冲区</li>\n<li>有消费者从缓冲区中取数据，每次取一项</li>\n<li>只能有一个生产者或一个消费者对缓冲区进行操作</li>\n<li>问题：<ul>\n<li>缓冲区满时，生产者不添加数据</li>\n<li>缓冲区空时，消费者不移走数据</li>\n</ul>\n</li>\n<li>避免忙等待<ul>\n<li>睡眠 与 唤醒 操作（原语）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"信号量及P、V操作\"><a href=\"#信号量及P、V操作\" class=\"headerlink\" title=\"信号量及P、V操作\"></a>信号量及P、V操作</h4><p>典型的进程同步机制</p>\n<p>信号量：特殊的变量，用于进程间传递信息的整数值 （count、queue）</p>\n<p>可执行的操作： 初始化、 P（test） 、 V（increment）</p>\n<p>P操作： 测试</p>\n<ul>\n<li>把信号量的值减一</li>\n<li>判断信号量是否 &lt; 0 ：<ul>\n<li>&lt;0：该进程状态为阻塞态，插入等待队列 s.queue末尾，重新调度</li>\n<li>false：执行进程</li>\n</ul>\n</li>\n</ul>\n<p>V操作：</p>\n<ul>\n<li>信号量的值+1</li>\n<li>判断信号量是否&lt;=0:<ul>\n<li>true ：唤醒s.queue的一个进程，插入就绪队列</li>\n</ul>\n</li>\n</ul>\n<p>P、 V操作是原语操作 primitive or atomic action</p>\n<p>最初提出：二元信号量（解决互斥）</p>\n<p>推广：一般信号量（解决同步）</p>\n<p>用PV解决互斥问题：</p>\n<ul>\n<li>分析并发进程关键活动，划定临界区</li>\n<li>设置信号量 mutex，初始值为1</li>\n<li>临界区前实施 P</li>\n<li>临界区后实施 V</li>\n</ul>\n<p>用PV解决生产者消费者问题：</p>\n<ul>\n<li>用full、empty两个变量记录满缓冲区和空缓冲区数目</li>\n<li>分别用P、V操作维护full和empty</li>\n<li>用 mutex 维护互斥，防止同时读写buffer<img src=\"http://ot1c7ttzm.bkt.clouddn.com/PV.png\" alt=\"PV\"></li>\n<li>两边的P操作顺序不可逆，必须先判断empty或full才能判断mutex（因为P操作可能使进程进入阻塞态）</li>\n<li>两边的V操作顺序可逆</li>\n<li>位置：尽可能缩小临界区</li>\n</ul>\n<p>PV操作解决读者、写者问题：</p>\n<ul>\n<li><p>多个进程共享一个数据区，分为两组：</p>\n<ul>\n<li>读者进程：只读数据区数据</li>\n<li>写者进程：只写数据区数据</li>\n</ul>\n</li>\n<li><p>条件：</p>\n<ul>\n<li>允许多个读者同时读</li>\n<li>不允许多个写者同时操作</li>\n<li>不允许读写同时</li>\n<li>（读写互斥，写者之间互斥）</li>\n</ul>\n</li>\n<li><p>Linux提供的读写锁：</p>\n</li>\n<li><p>第一类读者写者问题：读者优先：</p>\n<ul>\n<li>若有写者在等，有其他读者在读，则新读者可以读</li>\n<li>有读者在读，写者等待</li>\n<li>解法：<ul>\n<li>第一个读者做P操作，最后一个读者做V操作</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"同步机制（2）\"><a href=\"#同步机制（2）\" class=\"headerlink\" title=\"同步机制（2）\"></a>同步机制（2）</h3><p>重点：</p>\n<ul>\n<li>管程：<ul>\n<li>如何保证互斥</li>\n<li>如何保证同步：条件变量及wait、signal</li>\n<li>HOARE管程</li>\n<li>MESA管程</li>\n</ul>\n</li>\n<li>进程间通信：<ul>\n<li>消息传递、共享内存、管道</li>\n</ul>\n</li>\n<li>Pthread中的同步机制</li>\n<li>Linux的IPC机制</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第二章： 2.3.6～ 2.3.9</li>\n</ul>\n<h4 id=\"管程-monitor\"><a href=\"#管程-monitor\" class=\"headerlink\" title=\"管程 monitor\"></a>管程 monitor</h4><p>出现原因： 信息量机制不足：程序编写困难、易出错（PV操作的位置）</p>\n<p>解决：在程序设计语言中引入管程成分：高级同步机制</p>\n<p>定义：</p>\n<ul>\n<li>一个特殊的模块</li>\n<li>每个管程有一个名字</li>\n<li>管理共享资源的数据结构及其上操作的一组过程组成</li>\n</ul>\n<p>进程与管程： 进程只能通过调用管程中的过程来间接访问管程的数据结构</p>\n<p>管程解决的问题：</p>\n<ul>\n<li>互斥：<ul>\n<li>管程是互斥进入的：为了保证管程中数据结构的数据完整性</li>\n<li>互斥性由编译器负责保证</li>\n</ul>\n</li>\n<li>同步：<ul>\n<li>管程中设置条件变量及等待、唤醒操作以解决同步问题</li>\n<li>可以使一个进程或线程在条件变量上等待或唤醒</li>\n</ul>\n</li>\n</ul>\n<p>使用管程的问题：</p>\n<ul>\n<li>进入管程的操作执行唤醒操作（P唤醒Q）：<ul>\n<li>规定唤醒操作为管程中最后一个可执行的操作</li>\n<li>P等待，Q执行 （HOARE管程）</li>\n<li>Q等待，P继续执行（MESA管程）</li>\n</ul>\n</li>\n</ul>\n<p>HOARE管程：</p>\n<ul>\n<li>管程内增加紧急等待队列，P唤醒Q后P进入紧急等待队列（优先级高于入口等待队列）</li>\n<li>管程外有入口等待队列</li>\n<li>条件变量：在管程内部说明和使用的一种特殊类型的变量<ul>\n<li>wait操作：紧急队列非空，则唤醒第一个等待者，否则释放管程互斥权，执行该操作的进程进入c链末尾</li>\n<li>signal：c链为空则相当于空操作，否则唤醒第一个等待者，执行该操作的进程进入紧急等待队列</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>两次额外的进程切换</li>\n</ul>\n</li>\n</ul>\n<p>管程的实现：</p>\n<ul>\n<li>直接构造：效率高</li>\n<li>间接构造：用某种已经实现的同步机制构造（如信号量及PV操作）</li>\n</ul>\n<p>MESA管程：（P唤醒Q，P继续执行）</p>\n<ul>\n<li>signal -&gt; notify： notif(x)使得x条件队列得到通知，发信号的进程继续执行</li>\n<li>notify的结果：条件队列头的进程在将来合适的时候恢复执行</li>\n<li>不能保证在它之前没有其他进程进入管程，因此进程必须重新检查条件：用while循环取代if语句检查条件</li>\n<li>导致对条件变量至少多一次额外检测，对等待进程什么时候执行没有限制</li>\n<li>对notify的改进：<ol>\n<li>每个条件原语关联计时器，超过一定等待时间的进程直接进入就绪态</li>\n<li>broadcast：所有在该条件上等待的进程都被释放且进入就绪序列</li>\n</ol>\n</li>\n</ul>\n<p>HOARE和MESA的比较：</p>\n<ul>\n<li>MESA一般优于HOARE：MESA错误较少</li>\n<li>MESA：每个过程收到信号后重新检查管程变量，且使用while</li>\n</ul>\n<h4 id=\"PTHREAD中的同步机制\"><a href=\"#PTHREAD中的同步机制\" class=\"headerlink\" title=\"PTHREAD中的同步机制\"></a>PTHREAD中的同步机制</h4><p>通过互斥量保护临界区： Pthread_mutex</p>\n<p>解决同步问题：条件变量： wait \\ signal \\ broadcast</p>\n<h4 id=\"进程间通信机制\"><a href=\"#进程间通信机制\" class=\"headerlink\" title=\"进程间通信机制\"></a>进程间通信机制</h4><p>原因：</p>\n<ul>\n<li>信号量和管程的不足</li>\n<li>不适合多处理器的情况</li>\n</ul>\n<p>进程通信机制：消息传递：send &amp; receive 原语</p>\n<p>适用于： 分布式系统、单处理器系统、共享内存的多处理器系统</p>\n<p>通信方式：</p>\n<ul>\n<li>消息传递<ul>\n<li>操作系统空间设置消息缓冲区：<ul>\n<li>消息头（消息类型，进程ID：发送、接收，消息长度，控制信息）</li>\n<li>消息体</li>\n</ul>\n</li>\n<li>发送原语，由操作系统完成</li>\n<li>过程：陷入内核、复制消息、消息入队（接收进程的PCB消息队列指针）、复制消息</li>\n<li>通过PV操作实现</li>\n</ul>\n</li>\n<li>共享内存<ul>\n<li>需要解决两个问题：<ul>\n<li>物理内存中建立共享空间，并建立两个进程的地址空间到内存的映射</li>\n<li>读者写者问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>管道 pipe：<ul>\n<li>利用缓冲传输介质：内存或文件连接两个进程</li>\n<li>问题：<ul>\n<li>字符流方式写入读出</li>\n<li>先入先出顺序</li>\n<li>管道通信必须提供协调能力：互斥、同步、判断对方进程是否存在</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>套接字</li>\n<li>远程过程调用</li>\n</ul>\n<h4 id=\"典型操作系统的IPC机制\"><a href=\"#典型操作系统的IPC机制\" class=\"headerlink\" title=\"典型操作系统的IPC机制\"></a>典型操作系统的IPC机制</h4><p>linux的进程通信机制：</p>\n<ul>\n<li>用户程序：管道、消息队列、共享内存、信号、套接字</li>\n<li>内核同步机制：原子操作、自旋锁、读写锁、信号量、屏障</li>\n</ul>\n<p>原子操作：</p>\n<ul>\n<li>不可分割，不会被打断</li>\n<li>常用于资源计数</li>\n</ul>\n<p>屏障 barrier：</p>\n<ul>\n<li>同步机制</li>\n<li>用于对一组线程进行协调，要求所有线程到达一个汇合点后一起向前</li>\n</ul>\n<h3 id=\"存储模型（1）\"><a href=\"#存储模型（1）\" class=\"headerlink\" title=\"存储模型（1）\"></a>存储模型（1）</h3><p>重点：</p>\n<ul>\n<li>地址重定位</li>\n<li>基本内存管理方案</li>\n<li>物理内存管理技术</li>\n<li>交换技术</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第3章 3.1、 3.2</li>\n</ul>\n<h4 id=\"地址重定位\"><a href=\"#地址重定位\" class=\"headerlink\" title=\"地址重定位\"></a>地址重定位</h4><p>进程中的地址不是最终的物理地址</p>\n<p>进程运行前无法计算出物理地址</p>\n<p>地址重定位：</p>\n<ul>\n<li>逻辑地址（相对地址、虚拟地址）：<ul>\n<li>用户程序经过编译汇编后形成目标代码，首地址为0，其它地址相对于首地址编址</li>\n<li>不能用逻辑地址在内存中读取信息</li>\n</ul>\n</li>\n<li>物理地址（绝对地址，实地址）：<ul>\n<li>内存存储单元的地址，可直接寻址</li>\n</ul>\n</li>\n<li>概念：需要将用户程序的逻辑地址转换为可由其直接寻址的物理地址</li>\n<li>分类：<ul>\n<li>静态重定位：<ul>\n<li>用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换</li>\n<li>一般由软件完成</li>\n</ul>\n</li>\n<li>动态重定位：（常用）<ul>\n<li>进程执行过程中进行地址变换：逐条指令执行时完成地址转换</li>\n<li>需要硬件部件支持（部件：内存管理单元MMU memory management unit）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"物理内存划分\"><a href=\"#物理内存划分\" class=\"headerlink\" title=\"物理内存划分\"></a>物理内存划分</h4><p>空闲内存管理：</p>\n<ul>\n<li>等长划分：<ul>\n<li>bitmap 位图：每个分配单元对应一位</li>\n</ul>\n</li>\n<li>不等长划分：<ul>\n<li>空闲区表、已分配区表：表中每一项记录起始地址、长度、标志</li>\n<li>空闲块链表：每个表项用链相连</li>\n</ul>\n</li>\n</ul>\n<p>内存分配算法：</p>\n<ul>\n<li>首次适配 first fit：空闲区表第一个满足进程要求的空闲区</li>\n<li>下次适配 next fit：从上次找到的空闲区接着找</li>\n<li>最佳适配 best fit：查找整个表，找到满足要求的最小空闲区</li>\n<li>最差适配 worst fit：总分配满足进程要求的最大空闲区</li>\n</ul>\n<p>空闲区划分：一部分供进程使用，一部分作为新的空闲区</p>\n<p>回收问题：</p>\n<ul>\n<li>内存回收算法：<ul>\n<li>某一块归还后，空闲空间合并，修改空闲区表</li>\n<li>四种情况：<ul>\n<li>上相邻、下相邻、上下都相邻、上下都不相邻</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>伙伴系统：</p>\n<ul>\n<li>linux底层内存管理采用</li>\n<li>经典的内存分配方案</li>\n<li>主要思想： 内存按2的幂划分，组成空闲块链表，查找最佳匹配</li>\n<li>算法：<ul>\n<li>首先将整个空间看做一块 $2^U$</li>\n<li>假设进程申请空间大小为s，若满足 $ 2^{U-1}&lt;s&lt;=2^U $则分配整个块</li>\n<li>否则把块划分成两个大小相等的伙伴 $2^{U-1}$</li>\n<li>一直划分直到产生大于等于s的块</li>\n</ul>\n</li>\n<li>进程使用完后归还空间，空间进行可能的合并</li>\n</ul>\n<h4 id=\"基本内存管理方案（1）\"><a href=\"#基本内存管理方案（1）\" class=\"headerlink\" title=\"基本内存管理方案（1）\"></a>基本内存管理方案（1）</h4><p>整个进程进入内存连续区域</p>\n<p>以进程为单位装载</p>\n<p>方案：</p>\n<ul>\n<li>单一连续区：<ul>\n<li>特点：一段时间内只有一个进程在内存</li>\n<li>简单，但内存利用率低</li>\n</ul>\n</li>\n<li>固定分区：<ul>\n<li>分区：内存空间分割</li>\n<li>分区固定不变，大小可以相同也可以不同</li>\n<li>一个分区装一个进程</li>\n</ul>\n</li>\n<li>可变分区：<ul>\n<li>根据进程需要把空闲空间分割，分配进程，剩余部分成为新的空闲区</li>\n<li>缺点：有外碎片(进程之间的小空闲空间无法分配)，导致内存利用率下降</li>\n<li>碎片：很小的，不易利用的空闲区</li>\n<li>问题解决：紧缩技术 memory compaction：<ul>\n<li>在内存移动程序把小空闲区合并：</li>\n<li>需要考虑：<ul>\n<li>系统开销</li>\n<li>移动时机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基本内存管理方案（2）\"><a href=\"#基本内存管理方案（2）\" class=\"headerlink\" title=\"基本内存管理方案（2）\"></a>基本内存管理方案（2）</h4><p>一个进程进入内存中若干不连续区域</p>\n<p>方案：</p>\n<ul>\n<li>页式存储管理：<ul>\n<li>用户进程被划分为大小相等的部分称 页 page 或页面</li>\n<li>内存空间按同样大小分区域，称页框 page frame</li>\n<li>内存分配：<ul>\n<li>以页为单位分配，按进程需要的页数分配</li>\n<li>逻辑相邻的页，物理上不一定相邻</li>\n</ul>\n</li>\n<li>典型页面尺寸： 4K或4M</li>\n<li>逻辑地址： 页号+页内地址</li>\n<li>页表：<ul>\n<li>页表项：记录逻辑地址和物理地址的映射关系</li>\n<li>每个进程一个页表，一般放在内存</li>\n</ul>\n</li>\n<li>空闲内存管理：bitmap</li>\n<li>地址转换：硬件支持：<ul>\n<li>逻辑地址，CPU自动划分为页号和页内地址，用页号查页表得到页框号，再与页内偏移拼接成物理地址</li>\n</ul>\n</li>\n<li>内碎片：页框内浪费空间</li>\n</ul>\n</li>\n<li>段式存储方案：<ul>\n<li>按程序逻辑划分若干程序段，每个段一个段名</li>\n<li>内存空间被动态划分为长度不同的区域，称为物理段</li>\n<li>以段为单位进行划分，每段占连续空间，段之间可以不相邻</li>\n<li>逻辑地址 = 段号+段内地址 ， 无法自动划分</li>\n<li>段表： 记录每段长度和段起始地址，存放在内存</li>\n<li>物理内存管理：空闲区表</li>\n<li>地址转换：硬件支持：<ul>\n<li>逻辑地址，用段号查段表，得到起始地址，与段内偏移地址计算出地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段页式存储方案：<ul>\n<li>综合页式，段式优点</li>\n<li>先按段划分，每个段按页划分</li>\n<li>逻辑地址：段号+页号+页内地址</li>\n<li>内存划分：同页式存储方案</li>\n<li>内存分配：以页为单位分配</li>\n<li>段表： 记录每一段页表起始地址和长度</li>\n<li>页表：逻辑页号和页框的对应关系</li>\n<li>一个进程一个段表多个页表，一个段表一个页表</li>\n<li>空闲区同页式管理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"交换技术-swapping\"><a href=\"#交换技术-swapping\" class=\"headerlink\" title=\"交换技术 swapping\"></a>交换技术 swapping</h4><p>内存不足时的解决方案，当大的地址空间装不进小的内存空间</p>\n<p>内存”扩充“技术</p>\n<ul>\n<li>内存紧缩技术（可变分区）</li>\n<li>覆盖技术 overlaying：（早期操作系统）<ul>\n<li>程序大小超过物理内存总和</li>\n<li>程序不同部分在内存中相互替代，把不会同时执行的程序段共享同一内存区域</li>\n<li>要求程序各模块有明确的调用结构</li>\n<li>程序员声明覆盖结构，操作系统完成自动覆盖</li>\n<li>缺点：用户不透明，增加用户负担</li>\n</ul>\n</li>\n<li>交换技术 swapping：<ul>\n<li>系统把内存中某些进程暂时移到外存，把外存某些进程换入内存</li>\n<li>问题：<ul>\n<li>进程哪些内容要交换：运行中创建或修改的内容：栈和堆</li>\n<li>磁盘什么位置保存：交换区swap space：一块特殊的区域，包含连续的磁道，操作系统通过底层的磁盘读写操作对其高效访问</li>\n<li>交换时机：只要不用就换出； 内存空间不足或即将不足时</li>\n<li>如何选择被换出的进程：不应换出处于等待IO状态的进程</li>\n<li>如何处理进程空间增长：预留空间给数据段、栈增长</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟存储技术 virtual memory</li>\n</ul>\n<h3 id=\"存储模型（2）-虚拟存储\"><a href=\"#存储模型（2）-虚拟存储\" class=\"headerlink\" title=\"存储模型（2） 虚拟存储\"></a>存储模型（2） 虚拟存储</h3><p>重点：</p>\n<ul>\n<li>虚拟存储技术</li>\n<li>虚拟页式存储方案的实现：<ul>\n<li>多级页表、翻转页表、页表项、地址转换、MMU、快表TLB、页错误、缺页异常处理</li>\n</ul>\n</li>\n<li>软件策略：<ul>\n<li>驻留集、置换范围、清除策略</li>\n<li>置换算法：OPT、FIFO、第二次机会、时钟算法、LRU、老化、工作集</li>\n</ul>\n</li>\n<li>虚存相关的软件技术：内存映射文件、写时复制</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第三章：3.3、 3.4、 3.5.1、 3.5.7、 3.5.8、 3.6.1</li>\n</ul>\n<h4 id=\"虚拟存储技术\"><a href=\"#虚拟存储技术\" class=\"headerlink\" title=\"虚拟存储技术\"></a>虚拟存储技术</h4><p>定义： 进程运行时，一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成从磁盘调入内存的工作</p>\n<p>虚拟地址空间：分配给进程的虚拟内存</p>\n<p>虚拟地址：虚拟内存中指令或数据的位置</p>\n<p>虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用</p>\n<p>大小限制：寻址空间和磁盘大小</p>\n<p>地址保护：（硬件）</p>\n<ul>\n<li>确保每个进程都有独立的地址空间</li>\n<li>确保进程访问合法的地址范围： 基地址寄存器+界限寄存器</li>\n<li>确保进程的操作是合法的</li>\n</ul>\n<p>虚拟页式paging：</p>\n<ul>\n<li>虚拟存储技术+页式存储方案</li>\n<li>基本思想：<ul>\n<li>进程开始前装入一个或0个页面</li>\n<li>根据进程需要动态装入其他页面</li>\n<li>当内存空间满，又需要装入新的页面，则根据置换算法置换某个页面，以装入新的页面</li>\n</ul>\n</li>\n<li>方式：<ul>\n<li>请求调页 demand paging</li>\n<li>预先调页 prepaging</li>\n</ul>\n</li>\n<li>用CPU时间和磁盘空间换内存空间</li>\n</ul>\n<h4 id=\"页表和页表项的设计\"><a href=\"#页表和页表项的设计\" class=\"headerlink\" title=\"页表和页表项的设计\"></a>页表和页表项的设计</h4><p>页表由页表项组成：</p>\n<ul>\n<li>页框号：内存块号、物理页面号</li>\n<li>有效位：表示该页在内存还是在磁盘</li>\n<li>访问位R：引用位，表示这个页被访问过</li>\n<li>修改位M：表示该页在内存中是否被修改过</li>\n<li>保护位：读 / 可读写</li>\n</ul>\n<p>通常页表项是硬件设计的</p>\n<p>页表在内存不应该连续存放，因此需要引入页表页的地址索引表：页目录 page directory</p>\n<p>二级页表：</p>\n<ul>\n<li>虚拟地址： 页目录偏移+页表偏移+页内偏移</li>\n<li>可以表示4G的虚拟地址</li>\n<li>从页目录地址寄存器得到页目录首地址，加上页目录偏移得到页表首地址，加上页表偏移得到在第i个页表的页框号，页框号+页内偏移得到物理地址</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/virtualpage.png\" alt=\"虚存页表\"></li>\n</ul>\n<p>反转页表（倒排页表）：</p>\n<ul>\n<li>每个进程一张页表过于庞大</li>\n<li>从物理地址空间出发，系统建立一张页表</li>\n<li>页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系</li>\n<li>解决从虚拟地址到物理地址的映射：虚拟地址页号部分映射到散列值，散列值指向一个反转页表</li>\n</ul>\n<h4 id=\"地址转换过程和TLB引入\"><a href=\"#地址转换过程和TLB引入\" class=\"headerlink\" title=\"地址转换过程和TLB引入\"></a>地址转换过程和TLB引入</h4><p>虚拟地址到物理地址映射： MMU 内存管理单元</p>\n<p>快表 TLB translation look-aside buffers的引入：</p>\n<ul>\n<li>原因：<ul>\n<li>页表需要进行多次内存访问</li>\n<li>CPU指令处理速度和内存指令访问速度差异大</li>\n</ul>\n</li>\n<li>程序访问的局部性原理</li>\n<li>CPU中引入的高速缓存（cache），随机存取型存储器组成</li>\n<li>有特殊的接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较</li>\n<li>相联存储器 associative memory：特点：按内容并行查找</li>\n<li>保存正在运行进程的页表的子集</li>\n</ul>\n<p>页错误：page fault</p>\n<ul>\n<li>地址转换过程中硬件产生的异常</li>\n<li>具体原因：<ul>\n<li>缺页异常：所访问的虚拟页面没调入物理内存</li>\n<li>违反权限：读/写、用户/内核</li>\n<li>错误的访问地址</li>\n</ul>\n</li>\n<li>处理缺页异常：<ul>\n<li>地址映射过程中，硬件检查页表发现所要页面不在内存</li>\n<li>操作系统执行缺页异常处理程序：获得磁盘地址、启动磁盘、将该页调入内存：<ul>\n<li>内存中有空闲页框，修改页表中相应页表项的有效位和页框号</li>\n<li>内存中没有空闲页框，置换某一页，若该页修改过，还需要写回磁盘</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"软件相关策略\"><a href=\"#软件相关策略\" class=\"headerlink\" title=\"软件相关策略\"></a>软件相关策略</h4><p>驻留集：</p>\n<ul>\n<li>操作系统给每个进程分配页框数目</li>\n<li>策略：<ul>\n<li>固定分配策略：<ul>\n<li>进程创建时确定</li>\n<li>可以根据进程类型或程序员或系统管理员需要确定</li>\n</ul>\n</li>\n<li>可变分配策略：<ul>\n<li>根据缺页率评估进程局部性表现</li>\n<li>带来额外系统开销</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>页框锁定：</p>\n<ul>\n<li>为什么要锁定页面：虚存技术使得进程运行时间不确定</li>\n<li>给每一页框增加一个锁定位</li>\n<li>不让操作系统将进程换出内存</li>\n<li>如：操作系统核心代码，关键数据结构，IO缓冲区</li>\n</ul>\n<p>置换问题：</p>\n<ul>\n<li>置换范围：<ul>\n<li>置换集合是局限于产生缺页中断的进程，还是所有进程的页框</li>\n<li>策略：<ul>\n<li>局部置换：只在产生本次缺页的进程的驻留集中选择</li>\n<li>全局置换：将内存中所有未锁定的页框都作为置换的候选</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>置换策略：<ul>\n<li>选择换出哪个页框</li>\n<li>目标：置换最近最不可能访问的页</li>\n<li>局部性原理：基于过去行为来预测将来行为</li>\n<li>但策略设置越复杂，实现时软硬件开销越大</li>\n<li>约束：不能置换锁定的页框</li>\n</ul>\n</li>\n</ul>\n<p>清除策略：</p>\n<ul>\n<li>清除：从进程驻留集中集中回收页框（进程运行过程中回收）</li>\n<li>需要在系统中保持一定数目空闲页框，使得系统在最佳状态工作</li>\n<li>分页守护进程 paging daemon：<ul>\n<li>大部分时间睡眠，定期唤醒检查内存状态</li>\n<li>若空闲页框数过少，该进程通过页面置换算法换出内存</li>\n<li>若页面被修改过，则写回磁盘，以保证所有空闲页框是干净的</li>\n</ul>\n</li>\n<li>页缓冲技术：<ul>\n<li>不丢弃置换出的页，放入两个表之一：空闲链表和修改链表</li>\n<li>修改链表定期写回磁盘</li>\n<li>被置换的页仍在内存，一旦进程又要访问，则可以迅速将它加入进程的驻留集合</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"置换算法-replacement\"><a href=\"#置换算法-replacement\" class=\"headerlink\" title=\"置换算法 replacement\"></a>置换算法 replacement</h4><p>颠簸 thrashing：页面在内存和磁盘间调度的事件多于实际运行的时间</p>\n<p>影响缺页次数的因素：</p>\n<ul>\n<li>置换算法</li>\n<li>页面大小：<ul>\n<li>内部碎片</li>\n<li>页表长度</li>\n<li>辅存的物理特性</li>\n</ul>\n</li>\n<li>程序编制问题</li>\n<li>分配给进程的页框数目</li>\n</ul>\n<p>最佳页面置换算法 OPT：</p>\n<ul>\n<li>置换以后不再需要或最远的将来才会用到的页面</li>\n<li>无法实现</li>\n<li>作用：作为一种标准来衡量其他算法性能</li>\n</ul>\n<p>先进先出 FIFO：</p>\n<ul>\n<li>选择在内存中驻留时间最长的页并置换</li>\n<li>实现：页面链表法</li>\n</ul>\n<p>第二次机会算法 SCR second chance：</p>\n<ul>\n<li>按先进先出选择页面，检查其访问位R，若为0，则置换，若为1，则给第二次机会并把R置位0</li>\n</ul>\n<p>时钟算法 CLOCK：</p>\n<ul>\n<li>SCR的改进，把链表改成环，用指针指向当前要置换的页</li>\n</ul>\n<p>最近未使用算法 NRU：</p>\n<ul>\n<li>最近未使用的一页</li>\n<li>实现：根据页表项的两位：访问位R，修改位M（若硬件没有这两位，则用软件模拟）</li>\n<li>R位定期清零</li>\n<li>优先级：<ul>\n<li>1 最低：R=0，M=0，无使用，未修改</li>\n<li>2： R=0，M=1</li>\n<li>3： R=1，M=0</li>\n<li>4： R=1，M=1</li>\n</ul>\n</li>\n<li>时钟算法实现：<ul>\n<li>环状链表，选中遇到第一个R=0，M=0,用于置换</li>\n<li>若没有，则扫描第一个 R=0，M=1，对每个跳过的页框，把R置为0</li>\n<li>若仍没有，重新扫描R=0，M=0</li>\n<li>若仍没有，则扫描 R=0，M=1</li>\n</ul>\n</li>\n</ul>\n<p>最近最少使用 LRU：</p>\n<ul>\n<li>置换未使用时间最长的一页</li>\n<li>性能最接近 OPT 最佳算法，使用最多</li>\n<li>实现： 开销大，需要维护时间戳或访问页的栈</li>\n</ul>\n<p>最不经常使用 NFU：</p>\n<ul>\n<li>LRU的一种软件解决方案（自说）</li>\n<li>选择访问次数最少的页面置换</li>\n<li>实现：<ul>\n<li>软件计数器，每一个页一个，初值为0</li>\n<li>每次事件中断，计数器加该页的R</li>\n<li>缺页中断时，选择计数器最小的置换</li>\n</ul>\n</li>\n</ul>\n<p>老化算法 AGING：</p>\n<ul>\n<li>对NFU的改进（模拟LRU）：</li>\n<li>计数器在加R前先右移一位（除以2），R加到计数器最左端</li>\n</ul>\n<p>BELADY现象：</p>\n<ul>\n<li>页框数目多，缺页次数反而多</li>\n</ul>\n<p>工作集working set 算法：</p>\n<ul>\n<li>程序局部性： 活跃页面：进程一段时间中集中访问的页面</li>\n<li>为进程提供和活跃页面数相等的物理页面数，则可以减少中断次数</li>\n<li>工作集：当前正在使用的页框集合， W(t, delta)=该进程在时刻 t 过去 delta 事件单位中访问的页面的集合</li>\n<li>核心思想：找出一个不在工作集的页面并置换它</li>\n<li>思路：<ul>\n<li>每个页表项记录该页面最后一次被访问的时间</li>\n<li>设置时间T</li>\n<li>判断：根据一个页面访问时间在 当前时间-T 之前或之中决定其在工作集之内还是之外</li>\n</ul>\n</li>\n<li>实现：扫描所有页表项：<ul>\n<li>若 R=1，则把其最后一次访问时间设置为当前时间，R清零</li>\n<li>R=0，则检查访问时间是否在 当前时间-T 之前（不在工作集）<ul>\n<li>若是，则置换</li>\n<li>若不是，则记录最后访问时间的最小值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/replacement.png\" alt=\"置换算法\"></p>\n<h4 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h4><p>内存映射文件：</p>\n<ul>\n<li>进程通过系统调用 mmap 将文件或部分 映射到虚拟地址空间的一部分，访问该文件就像访问内存中的大数组，而不是对文件进行读写</li>\n<li>不会实际读入页面，在访问页面时才会被读入内存</li>\n<li>进程退出或显示解除文件映射时，修改写回磁盘</li>\n</ul>\n<p>写时复制技术：</p>\n<ul>\n<li>多个进程共享页面，页标志为写时复制</li>\n<li>进程试图改变页面数据时，操作系统复制一个页面，对执行写操作的进程是私有的</li>\n</ul>\n<h3 id=\"文件系统（1）\"><a href=\"#文件系统（1）\" class=\"headerlink\" title=\"文件系统（1）\"></a>文件系统（1）</h3><p>重点：</p>\n<ul>\n<li>文件系统相关概念：文件、文件分类、文件逻辑结构和物理结构</li>\n<li>文件目录的实现：文件控制块FCB、目录项、目录文件</li>\n<li>文件系统的实现：磁盘布局、内存树结构</li>\n<li>磁盘空间的管理：存储介质、扇区、物理块block、簇cluster</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第四章：4.1、 4.2、 4.3、 4.5.3</li>\n</ul>\n<h4 id=\"文件与文件系统\"><a href=\"#文件与文件系统\" class=\"headerlink\" title=\"文件与文件系统\"></a>文件与文件系统</h4><p>文件 是 对磁盘的抽象</p>\n<p>文件：一组带标识的、在逻辑上有完整意义的信息项的序列</p>\n<p>信息项：构成文件内容的基本单位（单个字节或多个字节），各信息项之间有顺序关系</p>\n<p>文件内容的意义：由文件建立者和使用者解释</p>\n<p>文件系统：操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供共享和保护手段：</p>\n<ul>\n<li>统一管理磁盘空间，实施磁盘空间分配和回收</li>\n<li>实现文件按名存取（名字空间 -&gt; 映射 -&gt; 磁盘空间）</li>\n<li>实现文件信息的共享</li>\n<li>向用户提供方便使用和维护的接口</li>\n<li>提高文件系统性能</li>\n<li>提供与IO系统的统一接口</li>\n</ul>\n<p>文件分类：（UNIX）：按文件性质和用途</p>\n<ul>\n<li>普通文件</li>\n<li>目录文件</li>\n<li>特殊文件（设备文件）：设备作为文件处理，分为字符设备或块设备</li>\n<li>管道文件</li>\n<li>套接字</li>\n</ul>\n<p>文件的逻辑结构：</p>\n<ul>\n<li>由用户的访问方式决定</li>\n<li>典型文件逻辑结构：<ul>\n<li>流式文件：文件是有逻辑意义、无结构的一串字符的集合</li>\n<li>记录式文件：文件由若干记录组成，可以按记录读写查找等</li>\n</ul>\n</li>\n<li>文件存取：<ul>\n<li>顺序存取（访问）</li>\n<li>随机存取（访问）：提供读写位置</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件的存储介质\"><a href=\"#文件的存储介质\" class=\"headerlink\" title=\"文件的存储介质\"></a>文件的存储介质</h4><p>典型存储介质：磁盘、磁带、光盘、U盘</p>\n<p>物理块：</p>\n<ul>\n<li>信息存储、传输、分配的独立单位</li>\n<li>存储设备划分为大小相等的物理块，统一编号</li>\n</ul>\n<p>典型磁盘结构：</p>\n<ul>\n<li>任何时刻只有一个磁头处于活动状态：输入输出数据流以位串形式出现</li>\n<li>物理地址形式：磁头号、磁道号、扇区号</li>\n</ul>\n<p>磁盘访问：</p>\n<ul>\n<li>寻道：磁头移动到指定磁道</li>\n<li>旋转延迟：等待指定扇区</li>\n<li>数据传输：数据在磁盘和内存之间实际传输</li>\n</ul>\n<p>磁盘空间管理：</p>\n<ul>\n<li>数据结构：<ul>\n<li>位图：用二进制位反应块的分配情况，0为已经分配，1为空闲</li>\n<li>空闲块表：所有空闲块记录在一张表</li>\n<li>空闲块链表：<strong>成组链接法</strong></li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/grouplink.png\" alt=\"成组链接法\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件属性\"><a href=\"#文件属性\" class=\"headerlink\" title=\"文件属性\"></a>文件属性</h4><p>文件控制块 file control block：为了管理文件而设置的数据结构，保存所需要等待有关信息</p>\n<p>文件目录：</p>\n<ul>\n<li>统一管理每个文件的元数据，以支持文件名到文件物理地址的转换</li>\n<li>将所有文件的管理信息组织在一起</li>\n</ul>\n<p>目录文件：文件目录以文件的形式存放在磁盘上</p>\n<p>目录项：</p>\n<ul>\n<li>构成文件目录的基本单元</li>\n<li>目录项可以是FCB，目录是文件控制块的有序集合</li>\n</ul>\n<h4 id=\"文件的物理结构\"><a href=\"#文件的物理结构\" class=\"headerlink\" title=\"文件的物理结构\"></a>文件的物理结构</h4><p>文件在存储介质的存放方式</p>\n<p>结构：</p>\n<ul>\n<li>连续（顺序）结构：<ul>\n<li>文件的信息在若干连续的物理块中</li>\n<li>优点：<ul>\n<li>简单</li>\n<li>支持顺序存取、随机存取</li>\n<li>需要的磁盘寻道次数和寻道时间最少</li>\n<li>可以同时读入多个块，检索一个块也容易</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>文件不能动态增长</li>\n<li>不利于文件插入和删除</li>\n<li>会产生外部碎片：紧缩技术</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链接结构：<ul>\n<li>一个文件的信息存放在若干不连续物理块中，各块用指针相连，前一个物理块指向下一个物理块</li>\n<li>优点：<ul>\n<li>提高磁盘空间利用率，不存在外部碎片问题</li>\n<li>利于文件插入、删除</li>\n<li>利于文件动态扩充</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>存取速度慢，不利于随机存取</li>\n<li>可靠性问题，如指针出错</li>\n<li>更多寻道时间和寻道次数</li>\n<li>链接指针占用空间</li>\n</ul>\n</li>\n<li>变形：文件分配表 FAT：记录每个物理块的下一块的索引</li>\n</ul>\n</li>\n<li>索引结构：<ul>\n<li>信息存放在若干不连续的物理块中</li>\n<li>系统为每个文件建立一个索引表，块号放在索引表</li>\n<li>索引表就是磁盘块地址数组</li>\n<li>FCB放索引表的起始地址</li>\n<li>优点：<ul>\n<li>保持链接结构优点，又解决其缺点：<ul>\n<li>能顺序和随机存取</li>\n<li>满足文件动态增长、插入删除要求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>寻道次数和寻道时间多</li>\n<li>索引表需要额外空间</li>\n</ul>\n</li>\n<li>组织方式：<ul>\n<li>当索引表很大，需要多个物理块存放时：<ul>\n<li>链接方式：一个盘块存一个表</li>\n<li>多级索引</li>\n<li>综合索引：直接索引加间接索引：部分直接索引，指向一个物理块，一部分间接寻址，指向索引表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>UNIX 三级索引结构（综合模式）：<ul>\n<li>每个文件主索引表放FCB中，有15项，每项2字节</li>\n<li>前12个直接寻址</li>\n<li>第13项指向一级索引表</li>\n<li>第14项作为二级索引表</li>\n<li>第15项作为三级索引表</li>\n<li>最大总文件大小 = 12 + 256 + 256*256 + 256^3 个block</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件系统的实现\"><a href=\"#文件系统的实现\" class=\"headerlink\" title=\"文件系统的实现\"></a>文件系统的实现</h4><p>需要考虑： 磁盘上 和 内存中 内容布局</p>\n<p>磁盘分区 partition：把一个物理磁盘存储空间划分为几个相互独立部分</p>\n<p>文件卷 volume：磁盘上的逻辑分区，由一个或多个物理块组成：</p>\n<ul>\n<li>一个文件卷可以使一个盘或部分盘或跨盘 RAID</li>\n<li>同一个文件卷使用同一份管理数据</li>\n<li>文件卷上：文件系统信息、一组文件（用户文件+目录文件）、未分配空间</li>\n<li>块 block 或 簇cluster：</li>\n</ul>\n<p>格式化 format：在一个文件卷上建立文件系统，建立并初始化元数据</p>\n<p>UNIX：</p>\n<ul>\n<li>FCB = 目录项 + i节点</li>\n<li>目录项 = 文件名+i节点号</li>\n<li>i节点 = 保存描述文件的相关信息</li>\n</ul>\n<h3 id=\"文件系统（2）\"><a href=\"#文件系统（2）\" class=\"headerlink\" title=\"文件系统（2）\"></a>文件系统（2）</h3><p>重点：</p>\n<ul>\n<li>文件操作的实现流程</li>\n<li>文件系统的可靠性、一致性、写入策略、安全性</li>\n<li>提高文件系统性能</li>\n<li>FAT文件系统的实现</li>\n</ul>\n<h4 id=\"文件操作的实现\"><a href=\"#文件操作的实现\" class=\"headerlink\" title=\"文件操作的实现\"></a>文件操作的实现</h4><p>创建文件：</p>\n<ul>\n<li>建立系统和文件的联系，实质是建立文件的FCB</li>\n<li>在目录中为新文件建立一个目录项，填写参数</li>\n<li>分配必要的存储空间</li>\n<li>流程：<ol>\n<li>检查参数合法性（命名规则、重名文件等）</li>\n<li>申请空闲目录项，填写相关信息</li>\n<li>为文件申请磁盘块</li>\n</ol>\n</li>\n</ul>\n<p>打开文件：</p>\n<ul>\n<li>根据文件名在文件目录中检索，找到目录项或FCB</li>\n<li>将目录项读入内存，建立相应的数据结构（文件描述符或文件句柄），为后续操作做好准备</li>\n<li>流程：<ol>\n<li>给出路径名查目录，找到目录项或i节点号</li>\n<li>根据文件号查系统打开文件表<ol>\n<li>是 则共享计数加1</li>\n<li>否 将信息填入系统打开文件表，共享计数为1</li>\n</ol>\n</li>\n<li>根据打开方式、共享说明和用户身份检查访问合法性</li>\n<li>在用户打开文件表获取一个空表项，填写参数，返回文件句柄</li>\n</ol>\n</li>\n<li>指针定位：<ul>\n<li>每个进程打开的每个文件维护一个读写指针</li>\n<li>在用户打开文件表中</li>\n</ul>\n</li>\n</ul>\n<p>读文件：</p>\n<ol>\n<li>根据打开文件时的文件描述符，找到FCB，确定操作合法性</li>\n<li>把文件的逻辑块号转换成物理块号</li>\n<li>申请缓冲区</li>\n<li>启动磁盘IO操作，把磁盘块内容送到缓冲区，而后送到内存</li>\n</ol>\n<h4 id=\"文件系统的管理\"><a href=\"#文件系统的管理\" class=\"headerlink\" title=\"文件系统的管理\"></a>文件系统的管理</h4><p>可靠性：</p>\n<ul>\n<li>抵御和预防各种物理性破坏和人为性破坏的能力</li>\n<li>坏块问题</li>\n<li>备份：通过转储操作，形成文件或文件系统的多个副本</li>\n</ul>\n<p>转储：</p>\n<ul>\n<li>全量转储：定期拷贝所有文件</li>\n<li>增量转储：只转储修改过的文件，两次备份之间的修改</li>\n<li>物理转储：从磁盘第0块开始，将所有磁盘块按序输出到磁带</li>\n<li>逻辑转储：从指定目录开始，递归转储给定日期后所有更改的文件或目录</li>\n</ul>\n<p>文件系统一致性：</p>\n<ul>\n<li>问题的产生：磁盘块 -&gt; 内存 -&gt; 写回磁盘块，若在写回之前系统崩溃，则文件系统不一致（FCB、目录文件已经更新）</li>\n<li>解决方案：设计程序，当系统再次启动时检查磁盘块和目录系统</li>\n<li>磁盘块的一致性检查：<ul>\n<li>用两张表，每个表项对应一个磁盘块，第一张表记录每个块在文件中出现的次数，第二张表记录在空闲块表中出现的次数</li>\n<li>情况1： 使用块和空闲块相反：正常</li>\n<li>情况2： 使用块和空闲块均为0：把空闲块置1</li>\n<li>情况3： 使用块和空闲块均为1：空闲块置0</li>\n<li>情况4： 使用块为2，空闲为0： 在空闲中寻找一个把多出的文件写入</li>\n</ul>\n</li>\n</ul>\n<p>写入策略：</p>\n<ul>\n<li>write-through：直写：内存中修改立刻返回磁盘：FAT</li>\n<li>lazy-write：延迟写：利用回写write back缓存的方法增加速度</li>\n<li>transaction log：可恢复写：利用事务日志实现文件系统写入 ： NTFS，EXT3</li>\n</ul>\n<p>访问控制：</p>\n<ol>\n<li>主动控制：访问控制表：<ul>\n<li>每个文件一张表</li>\n<li>记录用户id和访问权限</li>\n<li>用户可以是一组用户</li>\n<li>文件可以是一组文件</li>\n</ul>\n</li>\n<li>能力表（权限表）<ul>\n<li>每个用户一个</li>\n<li>记录文件名及访问权限</li>\n<li>用户可以是一组用户</li>\n<li>文件可以是一组文件</li>\n</ul>\n</li>\n</ol>\n<p>UNIX文件访问控制：</p>\n<ul>\n<li>采用文件二级存取控制</li>\n<li>第一级：对访问者的识别：<ul>\n<li>对用户分类：<ul>\n<li>文件主</li>\n<li>文件主的同组用户</li>\n<li>其他用户</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第二级：对操作权限的识别：<ul>\n<li>对操作分类：<ul>\n<li>读 r</li>\n<li>写 w</li>\n<li>执行 x</li>\n<li>不能执行任何操作 -</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件系统的性能\"><a href=\"#文件系统的性能\" class=\"headerlink\" title=\"文件系统的性能\"></a>文件系统的性能</h4><p>设计文件系统应该尽可能减少磁盘访问次数</p>\n<p>方法：</p>\n<ul>\n<li>目录项FCB分解、当前目录、磁盘碎片整理</li>\n<li>块高速缓存 block cache：<ul>\n<li>在内存中为磁盘块设置一个缓冲区，保存磁盘某些块的副本</li>\n<li>检查所有读请求，看是否在块高速缓存中<ul>\n<li>若在，则直接读</li>\n<li>若不再，先将块拷入块高速缓存，再拷入所需地方</li>\n</ul>\n</li>\n<li>组织：用hash</li>\n<li>置换：LRU</li>\n<li>写入策略（文件系统一致性）：定期写回磁盘</li>\n</ul>\n</li>\n<li>合理分配磁盘空间：<ul>\n<li>分配磁盘块时，有可能顺序存取的块放在一起</li>\n<li>尽可能分配在同一柱面上，从而减少磁盘臂移动次数和距离</li>\n</ul>\n</li>\n<li>磁盘调度：<ul>\n<li>有多个访盘请求时，采用一定策略调整顺序</li>\n<li>降低平均磁盘服务时间</li>\n<li>调度算法：<ul>\n<li>先来先服务 FCFS</li>\n<li>最短寻道时间优先：优先选择离当前磁头最近的访问请求<ul>\n<li>优点：改善平均服务请求</li>\n<li>缺点：饥饿现象</li>\n</ul>\n</li>\n<li>扫描算法 SCAN （电梯算法）：按一个方向移动，若该方向没有请求，则改变方向</li>\n<li>单向扫描算法 C-SCAN：SCAN的改进：总从0号柱面向里扫描，到达最后一个柱面时，立即返回0号，返回时不服务，返回后再次扫描</li>\n<li>N-step-SCAN策略：磁盘请求划分为长度为N的子队列，每一次用SCAN处理一个子队列</li>\n<li>FSCAN策略：使用两个子队列，开始时请求在一个队列，扫描时请求加入另一个队列</li>\n<li>旋转调度：根据延迟时间决定执行次序的调度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>信息的优化分布：<ul>\n<li>记录在磁盘的排列方式</li>\n</ul>\n</li>\n<li>记录的成组与分解：<ul>\n<li>若干逻辑记录合成一组存放</li>\n<li>成组操作必须用内存缓冲区，缓存区长度 = 记录长度 * 块因子</li>\n<li>目的：提高空间利用率和工作效率</li>\n</ul>\n</li>\n<li>RAID 独立磁盘冗余阵列 技术：<ul>\n<li>多块磁盘按一定要求构成一个独立存储设备</li>\n<li>目标：提高可靠性和性能</li>\n<li>组织：<ul>\n<li>多个磁盘组织，作为一个逻辑卷</li>\n<li>数据分成多个数据块，并行写入、读出多个磁盘</li>\n<li>通过镜像或校验，提供容错能力（冗余）</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>RAID 0-条带化，数据分布在所有磁盘上，无冗余，性能最佳</li>\n<li>RAID 1 - 镜像：利用率 50%，所有数据同时保存在两块盘相同位置，安全性最好</li>\n<li>RAID 4 -交错块奇偶校验：带奇偶校验，以数据块为单位 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Windows的文件访问方式：</p>\n<ul>\n<li>不使用文件缓存</li>\n<li>使用文件缓存：<ul>\n<li>Windows的cache manager实现对缓存的控制：<ul>\n<li>读取数据时预取</li>\n<li>在cache满时，根据LRU清除缓存内容</li>\n<li>定期更新磁盘内容使其与cache一致</li>\n</ul>\n</li>\n<li>write-back机制：只更改cache内容，由cache manager定期写回</li>\n</ul>\n</li>\n<li>异步模式：<ul>\n<li>不等待磁盘操作的完成</li>\n<li>使CPU和IO并发工作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IO系统\"><a href=\"#IO系统\" class=\"headerlink\" title=\"IO系统\"></a>IO系统</h3><p>重点：</p>\n<ul>\n<li>IO系统的概念：<ul>\n<li>IO设备的特点及分类</li>\n<li>IO管理的任务</li>\n</ul>\n</li>\n<li>IO管理的解决方案<ul>\n<li>IO硬件组成</li>\n<li>IO控制方式</li>\n<li>IO软件层次及功能</li>\n</ul>\n</li>\n<li>IO相关技术</li>\n<li>IO性能提高的解决方案</li>\n</ul>\n<p>教材：第五章：5.1、 5.2、 5.4</p>\n<h4 id=\"IO管理概述\"><a href=\"#IO管理概述\" class=\"headerlink\" title=\"IO管理概述\"></a>IO管理概述</h4><p>IO设备管理：</p>\n<ul>\n<li>逻辑IO：统一的操作，与具体设备无关</li>\n<li>设备驱动程序</li>\n<li>中断服务程序</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/IO.png\" alt=\"IO\"></p>\n<p>IO的特点：</p>\n<ul>\n<li>IO性能经常成为系统性能的瓶颈</li>\n<li>操作系统庞大复杂的原因之一：IO资源多而杂，并发<ul>\n<li>速度差异大</li>\n<li>应用</li>\n<li>控制接口的复杂性</li>\n<li>传送单位</li>\n<li>数据表示</li>\n<li>错误条件</li>\n</ul>\n</li>\n<li>与其他功能密切相关，尤其是文件系统</li>\n</ul>\n<p>设备分类：</p>\n<ul>\n<li>按数据组织分：<ul>\n<li>块设备：<ul>\n<li>以数据块为单位</li>\n<li>传输速度块，可寻址</li>\n</ul>\n</li>\n<li>字符设备：<ul>\n<li>以字符为单位</li>\n<li>速率低、不可寻址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从资源分配角度：<ul>\n<li>独占设备：一段时间只能有一个进程使用，一般低速，如打印机</li>\n<li>共享设备：一段时间可有多个进程共同使用，以交叉方式使用</li>\n<li>虚设备：<ul>\n<li>在一类设备上模拟另一类，常用 共享模拟独占、高速模拟低速</li>\n<li>实例：SPOOLing技术，用硬盘模拟输入输出</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>目标：</p>\n<ul>\n<li>按用户请求，控制设备的各种操作，完成设备和内存的数据交换<ul>\n<li>设备的分配和回收<ul>\n<li>记录设备的状态</li>\n<li>根据用户请求和设备类型，采用一定分配算法，选择设备到内存的数据通路</li>\n</ul>\n</li>\n<li>执行设备驱动程序</li>\n<li>设备中断处理</li>\n<li>缓冲区管理：管理IO缓冲区</li>\n</ul>\n</li>\n<li>建立方便统一的独立于设备的接口：通用性<ul>\n<li>方便性：用户编程时不考虑设备的物理特性</li>\n<li>统一性：用户程序使用的是逻辑设备，以屏蔽硬件细节</li>\n</ul>\n</li>\n<li>利用各种技术提高CPU与设备、设备之间的并行工作能力，充分利用资源<ul>\n<li>并行性</li>\n<li>均衡性</li>\n</ul>\n</li>\n<li>​</li>\n</ul>\n<h4 id=\"IO设备组成\"><a href=\"#IO设备组成\" class=\"headerlink\" title=\"IO设备组成\"></a>IO设备组成</h4><p>一般由机械和电子部分组成：</p>\n<ul>\n<li>机械部分是设备本身（物理装置）</li>\n<li>电子部分又称设备控制器（适配器）<ul>\n<li>地址译码</li>\n<li>接受计算机发来或向计算机发送数据和状态信号</li>\n<li>把计算机数字信号转换成机械能识别的模拟信号，或反过来</li>\n<li>设备内部硬件缓冲或数据加工等提升性能</li>\n</ul>\n</li>\n</ul>\n<p>机械部分：设备接口——控制器：</p>\n<ul>\n<li>操作系统将命令写入控制器的接口寄存器，并从中读取状态信息或结果信息</li>\n<li>控制器接受命令后独立于CPU执行，命令完成后产生中断，操作系统通过读控制寄存器的信息获取操作结果和状态</li>\n<li>控制器和设备的接口通常是低级借口</li>\n<li>控制器的任务：串行位流转换成字节块，并进行必要的错误修正</li>\n</ul>\n<p>IO端口地址：</p>\n<ul>\n<li>每个寄存器都有的唯一的地址</li>\n<li>所有端口地址形成IO端口空间</li>\n<li>IO指令形式和IO地址关联：<ul>\n<li>内存映像编址（内存映像IO模式）：内存一部分用作IO端口<ul>\n<li>把IO端口看作一个存储单元</li>\n<li>优点：<ul>\n<li>凡是可对内存的操作均可对IO操作</li>\n<li>不需要专门IO指令</li>\n<li>IO端口空间大</li>\n<li>不需要专门机制阻止用户操作IO</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>占用内存空间</li>\n<li>不能对控制寄存器进行高速缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IO独立编址（IO专用指令）：IO空间独立于内存<ul>\n<li>使用专门的IO指令对端口操作</li>\n<li>优点：<ul>\n<li>外设不占内存</li>\n<li>编程时可以区分对内存还是对IO</li>\n</ul>\n</li>\n<li>缺点：IO操作指令类型少，操作不灵活</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>IO控制方式：</p>\n<ol>\n<li>可编程IO（轮询、查询）<ul>\n<li>CPU不断询问IO模块</li>\n<li>设置控制寄存器后不断查询状态寄存器，完成后把数据寄存器中数据读取</li>\n</ul>\n</li>\n<li>中断驱动IO<ul>\n<li>IO结束后，由设备控制器主动通知设备驱动程序</li>\n</ul>\n</li>\n<li>DMA<ul>\n<li>直接内存存取</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"IO软件组成\"><a href=\"#IO软件组成\" class=\"headerlink\" title=\"IO软件组成\"></a>IO软件组成</h4><p>设计思想：</p>\n<ul>\n<li>IO软件组织成多层次</li>\n<li>每层执行所需要功能的子集，依赖于低一层实现的功能</li>\n<li>低层考虑硬件特性，向高层提供接口</li>\n<li>高层不考虑硬件细节，提供良好接口</li>\n</ul>\n<p>软件层次：</p>\n<ul>\n<li>用户级IO</li>\n<li>与设备无关的OS软件：<ul>\n<li>驱动程序统一接口</li>\n<li>缓存</li>\n<li>错误报告</li>\n<li>分配与释放设备</li>\n<li>提供与设备无关的尺寸大小</li>\n</ul>\n</li>\n<li>设备驱动程序</li>\n<li>中断处理程序</li>\n</ul>\n<p>设备无关性：用户程序可以访问任意IO设备，无需事先指定设备</p>\n<ul>\n<li>好处：易实现IO重定向，设备分配灵活</li>\n</ul>\n<h4 id=\"IO相关技术\"><a href=\"#IO相关技术\" class=\"headerlink\" title=\"IO相关技术\"></a>IO相关技术</h4><p>缓冲技术：</p>\n<ul>\n<li>凡是数据到达和离去速度不匹配的地方均可用缓冲技术</li>\n<li>实现：<ul>\n<li>硬缓冲：由硬件寄存器实现</li>\n<li>软缓存：内存中开辟空间作缓冲区</li>\n</ul>\n</li>\n<li>缓冲区管理：<ul>\n<li>单缓冲</li>\n<li>双缓冲</li>\n<li>缓冲池（多缓存）：统一管理多个缓冲区，缓冲区循环使用</li>\n</ul>\n</li>\n<li>UNIX缓冲技术：<ul>\n<li>结合提前读和延迟写技术</li>\n<li>充分利用从磁盘读入，已传入用户区但仍在缓冲区的数据</li>\n<li>缓冲区组成：缓冲控制块+数据区</li>\n<li>空闲缓冲区对联 av链</li>\n<li>设备缓冲队列 b链：链接所有分配给设备使用的缓冲区，按散列方式组织</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"IO设备管理\"><a href=\"#IO设备管理\" class=\"headerlink\" title=\"IO设备管理\"></a>IO设备管理</h4><p>独占设备的分配：</p>\n<ul>\n<li>静态分配：<ul>\n<li>运行前完成设备分配，结束时收回设备</li>\n<li>缺点：利用率低</li>\n</ul>\n</li>\n<li>动态分配：<ul>\n<li>运行过程中，用户提出设备要求时进行分配，一旦停止使用立刻收回</li>\n<li>优点：效率高</li>\n<li>缺点：可能死锁</li>\n</ul>\n</li>\n</ul>\n<p>分时式共享设备：</p>\n<ul>\n<li>以一次IO为单位分时使用设备，不同IO请求排队使用</li>\n</ul>\n<p>设备驱动程序：</p>\n<ul>\n<li>每个设备驱动程序管理一类设备</li>\n<li>接收来自与设备无关的上层软件抽象请求，并执行请求</li>\n<li>每个控制器有一个或多个设备寄存器用于存命令和参数，设备驱动程序负责释放命令并监督执行</li>\n<li>与外界的接口：<ul>\n<li>与操作系统的接口</li>\n<li>与系统引导的接口</li>\n<li>与设备的接口</li>\n</ul>\n</li>\n<li>接口函数</li>\n<li>IO进程：专门处理系统IO请求与IO中断</li>\n</ul>\n<h4 id=\"IO性能问题\"><a href=\"#IO性能问题\" class=\"headerlink\" title=\"IO性能问题\"></a>IO性能问题</h4><p>核心：</p>\n<ul>\n<li>使CPU利用率尽可能不被IO降低</li>\n<li>使CPU尽可能摆脱IO</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>减少或缓解速度差距：缓冲技术</li>\n<li>使CPU不等待IO：异步IO：用其他操作填充IO操作间等待的CPU时间</li>\n<li>使CPU摆脱IO：DMA、通道</li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>重点：</p>\n<ul>\n<li>死锁的基本概念<ul>\n<li>死锁的四个必要条件</li>\n<li>死锁和活锁、饥饿的区别</li>\n</ul>\n</li>\n<li>死锁的解决方案：<ul>\n<li>死锁预防：资源的有序分配法</li>\n<li>死锁避免：银行家算法、安全/不安全状态</li>\n<li>死锁检测与解除</li>\n</ul>\n</li>\n<li>资源分配图和在解决死锁问题的应用</li>\n<li>哲学家就餐问题</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>死锁：</p>\n<ul>\n<li>一组进程中每个进程都无限等待被该组另一进程占用的资源</li>\n<li>参与死锁的所有进程都在等待资源</li>\n<li>参与死锁的进程是当前系统中所有进程的子集</li>\n</ul>\n<p>死锁的原因：</p>\n<ul>\n<li>资源数目有限、锁和信号量错误使用</li>\n<li>资源的使用方式： 申请 — 分配 — 使用 — 释放</li>\n<li>资源分类：<ul>\n<li>可重用资源：可被多个资源多次使用<ul>\n<li>可抢占资源：CPU</li>\n<li>不可抢占资源：打印机<ul>\n<li>可消耗资源：只使用一次、可创建和销毁的资源：如信号、中断、消息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>活锁和饥饿：</p>\n<ul>\n<li>活锁：得不到资源，但能够运行，既无进展也无阻塞</li>\n<li>饥饿：资源分配策略决定</li>\n</ul>\n<p>死锁的产生条件：</p>\n<ul>\n<li>互斥使用（资源独占）：一个资源一次一个进程使用</li>\n<li>占有且等待：在申请新资源的同时保持对原资源的占有</li>\n<li>不可抢占、不可剥夺：资源只能由占有者自愿释放</li>\n<li>循环等待</li>\n</ul>\n<h4 id=\"资源分配图\"><a href=\"#资源分配图\" class=\"headerlink\" title=\"资源分配图\"></a>资源分配图</h4><p>用有向图描述系统资源和进程的状态</p>\n<p>结点V：分为P 进程 ， R 资源</p>\n<p>有向边E：有向边的集合，资源 R 指向 进程 P （资源分配）或 进程P 指向资源R（申请资源）</p>\n<p>死锁定理：</p>\n<ul>\n<li>资源分配图中没有环路，则没有死锁</li>\n<li>图中存在环路，系统可能有死锁</li>\n<li>若每个资源类只有一个资源实例，则 环路存在  &lt;=&gt; 死锁存在</li>\n</ul>\n<h4 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h4><p>解决死锁的方法：</p>\n<ul>\n<li>鸵鸟算法：不考虑死锁问题</li>\n<li>不让死锁发生<ul>\n<li>死锁预防：静态策略：设计合适的资源分配算法</li>\n<li>死锁避免：动态策略：以不让死锁发生为目标，跟踪和评估资源分配过程，根据评估结果决策是否分配</li>\n</ul>\n</li>\n<li>死锁检测与解除</li>\n</ul>\n<p>死锁预防：</p>\n<ul>\n<li>防止产生死锁的四个必要条件之一</li>\n<li>破坏 互斥使用、资源独占 条件：<ul>\n<li>资源转换技术：把独占资源变为共享资源</li>\n</ul>\n</li>\n<li>破坏 占有且等待 条件：<ul>\n<li>方案1：每个进程运行前必须一次性申请所有资源，仅当进程需要的资源都可满足才一次性分配<ul>\n<li>资源利用率低，饥饿现象</li>\n</ul>\n</li>\n<li>方案2：申请新资源得不到满足而变为等待状态前，必须释放已经占有的所有资源</li>\n</ul>\n</li>\n<li>破坏 不可抢占 条件：<ul>\n<li>申请的资源被其他进程占用时，可通过操作系统抢占资源（进程优先级不同）<ul>\n<li>局限性：适用于状态易于保存和恢复的资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>破坏 循环等待 条件：<ul>\n<li>资源有序分配法：进程申请资源时必须按资源编号的递增次序进行，否则操作系统不予分配</li>\n</ul>\n</li>\n</ul>\n<p>死锁避免：</p>\n<ul>\n<li><p>对进程发出的资源申请进行动态检查，根据分配后是否会发送死锁或是否可能导致死锁决定是否分配资源</p>\n</li>\n<li><p>安全状态：系统中存在一个由所有进程构成的安全序列，对每个进程 Pi 以后所需要资源量不超过 （系统当前剩余资源+所有进程Pj( j&lt;i )当前所占有的资源）</p>\n</li>\n<li><p>安全状态一定不死锁，不安全状态一定导致死锁（哪怕当前未死锁）</p>\n</li>\n<li><p>银行家算法 banker’s algorithm：仿照银行发放贷款采取的控制方式</p>\n<ul>\n<li><p>应用条件：</p>\n<ul>\n<li>固定数目进程 共享 固定数目资源</li>\n<li>每个进程预先指定所需要的最大资源数</li>\n<li>进程不能申请大于系统可用资源总数的资源</li>\n<li>进程等待资源的时间有限</li>\n<li>系统满足进程的最大需求后，进程应在有限时间内尽快使用并归还</li>\n</ul>\n</li>\n<li><p>变量：</p>\n<ul>\n<li>n：进程数目</li>\n<li>m：资源类数目</li>\n<li>available   【1.m】系统每类资源剩余数目</li>\n<li>max  【1.n 1.m】每个进程对每类资源要求的最大数目</li>\n<li>allocation 【1.n 1.m】每个进程已经分配的每类资源数目</li>\n<li>need 【1.n 1.m】每个进程还需要的每类资源的数目</li>\n<li>request 【1.n 1.m】 这次每个进程申请的每类资源数目</li>\n</ul>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li><p>若 request[i] &lt;= need[i] 继续，否则报错</p>\n</li>\n<li><p>若 request[i] &lt;= available 继续，否则等待</p>\n</li>\n<li><p>假设系统分配了资源：</p>\n<p> available -= request[i]</p>\n<p> allocation[i] += request[i] </p>\n<p> need[i] -= request[i]</p>\n</li>\n<li><p>若系统新状态安全，则分配完成，若不安全，则恢复分配</p>\n</li>\n</ol>\n</li>\n<li><p>安全性检查：</p>\n<ol>\n<li>work = available，finish=false</li>\n<li>检查每个i 有 finish[i]==false &amp;&amp; need[i]&lt;=work</li>\n<li>而后 work += allocation[i];  finish[i]=true, 转2</li>\n<li>若对所有i都有 finish[i]==true 则系统安全</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"死锁检测与解除\"><a href=\"#死锁检测与解除\" class=\"headerlink\" title=\"死锁检测与解除\"></a>死锁检测与解除</h4><p>死锁检测：</p>\n<ul>\n<li>允许死锁发生，但操作系统不断监视系统，判断死锁是否发生</li>\n<li>一旦发生死锁则解除死锁并以最小代价恢复系统运行</li>\n<li>检测时机：<ul>\n<li>当进程由于资源请求不满足而等待时</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时</li>\n</ul>\n</li>\n</ul>\n<p>死锁解除：</p>\n<ol>\n<li>撤销所有死锁进程</li>\n<li>进程回退roll back ，再启动</li>\n<li>按某原则逐一撤销死锁进程</li>\n<li>按某种原则逐一抢占资源</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>操作系统学习笔记，包括：</p>\n<ol>\n<li>操作系统基本概念</li>\n<li>进程、线程</li>\n<li>处理器调度</li>\n<li>同步机制</li>\n<li>存储模型</li>\n<li>文件系统</li>\n<li>IO</li>\n<li>死锁</li>\n</ol>","more":"<p>重点：</p>\n<p>《现代操作系统》(第三版)</p>\n<ul>\n<li>教材：<ul>\n<li>第一章： 1.1 、1.2 、 1.4</li>\n<li>第10章： 10.2.5 linux</li>\n<li>第11章： 11.3.1 </li>\n</ul>\n</li>\n<li>重点概念：<ul>\n<li>操作系统定义</li>\n<li>操作系统三个作用</li>\n<li>操作系统四个特点</li>\n<li>SPOOLING技术</li>\n<li>windows、linux、unix架构及主要功能</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"操作系统的定义与作用\"><a href=\"#操作系统的定义与作用\" class=\"headerlink\" title=\"操作系统的定义与作用\"></a>操作系统的定义与作用</h4><ol>\n<li>有效管理资源</li>\n</ol>\n<blockquote>\n<ol>\n<li>静态分配：在进程执行前准备好需要的所有资源，会造成资源浪费</li>\n<li>动态分配：进程需要时进行申请</li>\n</ol>\n</blockquote>\n<ol>\n<li><p>通过命令接口、编程接口为用户提供服务</p>\n</li>\n<li><p>对硬件机器的扩展</p>\n<blockquote>\n<p>对硬件进行抽象，硬件之上的虚拟机器</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"操作系统的特征\"><a href=\"#操作系统的特征\" class=\"headerlink\" title=\"操作系统的特征\"></a>操作系统的特征</h4><ol>\n<li><p>并发 concurrency: 指处理多个同时性活动的能力</p>\n<blockquote>\n<p>引发问题： 活动切换、保护、相互依赖的活动的同步</p>\n<p>并行parallel： 不同程序同时在多个硬件上执行</p>\n</blockquote>\n</li>\n<li><p>共享 sharing：操作系统与用户的程序共享系统中的资源</p>\n<blockquote>\n<p>操作系统要对资源进行合理分配和使用</p>\n<ol>\n<li>互斥共享（打印机）</li>\n<li>同时共享（代码、文件）</li>\n</ol>\n</blockquote>\n</li>\n<li><p>虚拟 virtual：物理实体映射为若干个对应的逻辑实体（分时、分空间）</p>\n<blockquote>\n<p>目的：提高资源利用率</p>\n<p>CPU：每个进程 “虚处理器”</p>\n<p>存储器：虚拟地址空间</p>\n<p>显示器：多窗口</p>\n</blockquote>\n</li>\n<li><p>随机：随时对不可预测的次序发生的事件进行响应并处理</p>\n<blockquote>\n<ul>\n<li>进程运行速度不可预知</li>\n<li>难以重现系统在某个时刻的状态</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"操作系统的架构\"><a href=\"#操作系统的架构\" class=\"headerlink\" title=\"操作系统的架构\"></a>操作系统的架构</h4><p>Windows 、 Unix 、 Linux</p>\n<h4 id=\"操作系统的分类\"><a href=\"#操作系统的分类\" class=\"headerlink\" title=\"操作系统的分类\"></a>操作系统的分类</h4><p>发展： 硬件发展、应用需求发展、软件技术发展</p>\n<p>目的：充分利用硬件，提供更好服务</p>\n<p>掌握各种操作系统的目标和不同点</p>\n<ul>\n<li><p>批处理操作系统</p>\n<ol>\n<li><p>方式</p>\n<blockquote>\n<p>系统操作员从用户处收集作业并输入系统，而后启动操作系统，操作系统自动处理作业并输出，系统操作员从输出处获取作业</p>\n</blockquote>\n</li>\n<li><p>目的： 提高资源利用率，增加吞吐量</p>\n</li>\n<li><p>概念：</p>\n<ul>\n<li>作业：程序、数据、作业说明素</li>\n<li>成批：由若干作业组成</li>\n<li>批作业处理：对每个作业做相同处理</li>\n</ul>\n</li>\n<li><p>问题：</p>\n<ul>\n<li>输入输出慢，由主机完成，CPU处于等待状态</li>\n<li>解决：用卫星机：完成输入输出，暂存输入输出结果，流程：用户-&gt;卫星机-&gt;系统操作员-&gt;计算机-&gt;系统操作员-&gt;卫星机-&gt;用户</li>\n</ul>\n</li>\n<li><p>分类：</p>\n<ul>\n<li>单道批处理：一次处理一个作业</li>\n<li>多道批处理：一次选中多个作业进行处理</li>\n</ul>\n</li>\n<li><p>技术： Spooling 同时外围设备联机操作，假脱机技术</p>\n<blockquote>\n<p>用磁盘作缓冲，输入输出和计算并行在一台机器上进行</p>\n<p>现代打印过程通常用spooling技术</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>分时系统：time-sharing ，最早的交互式系统</p>\n<ol>\n<li><p>方式：</p>\n<ul>\n<li>一台主机对多个终端，用户在终端输入命令等待结果</li>\n</ul>\n</li>\n<li><p>概念：时间片 （time slice）</p>\n<p>操作系统将CPU时间划分成若干片段，以时间片为单位轮流为终端服务，每次一个时间片</p>\n</li>\n<li><p>特点：利用人的错觉，使得人感觉系统只在为自己服务（每个用户在一个虚拟机上运行）</p>\n</li>\n<li><p>目标：及时响应</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>通用操作系统：分时和批处理结合，原则：以分时优先，批处理在后</p>\n<ul>\n<li>实时操作系统<ol>\n<li>概念：计算机能及时响应外部事件的请求，在严格时间内完成处理</li>\n<li>分类：<ol>\n<li>实施过程控制（军事控制、航空）</li>\n<li>实时通信处理（订票）</li>\n</ol>\n</li>\n<li>目标：<ul>\n<li>严格时间范围内响应</li>\n<li>高可靠性</li>\n</ul>\n</li>\n<li>特征：<ol>\n<li>硬实时系统：某个动作必须在规定时间内或规定时刻完成（焊接）</li>\n<li>软实时系统：接受偶尔违反时限（播放音乐、视频等）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>PC操作系统<ol>\n<li>目标：<ul>\n<li>界面友好、使用方便</li>\n<li>丰富的应用软件</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>网络操作系统<ol>\n<li>概念：按网络体系结构协议标准开发的软件</li>\n<li>功能：网络管理，通信，安全，资源共享和网络应用</li>\n<li>追求目标：相互通信，资源共享</li>\n</ol>\n</li>\n<li>分布式操作系统<ol>\n<li>概念：以计算机网络或多处理器为基础，特征是处理分布在不同计算机上</li>\n</ol>\n</li>\n<li>嵌入式操作系统<ol>\n<li>概念：<ul>\n<li>在各种设备、装置中完成特定功能的软硬件系统（汽车、手机、播放器等）</li>\n<li>大设备、装置中的一部分</li>\n<li>对反应时间、处理时间有严格要求</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"操作系统运行环境\"><a href=\"#操作系统运行环境\" class=\"headerlink\" title=\"操作系统运行环境\"></a>操作系统运行环境</h3><p>重点：</p>\n<ul>\n<li>理解计算机系统的保护机制<ul>\n<li>掌握处理器状态</li>\n<li>掌握特权指令与非特权指令</li>\n</ul>\n</li>\n<li>掌握中断、异常机制<ul>\n<li>掌握中断、异常的基本概念</li>\n<li>理解中断、异常机制的工作原理</li>\n</ul>\n</li>\n<li>掌握系统调用机制<ul>\n<li>掌握系统调用的设计原理</li>\n<li>掌握系统调用的执行过程</li>\n</ul>\n</li>\n</ul>\n<p>重点阅读：</p>\n<ul>\n<li>第一章： 1.3、 1.6</li>\n<li>第二章： P52 图2-5</li>\n</ul>\n<p>重点概念：</p>\n<p>​    CPU状态、内核态 用户态、特权指令 非特权指令、中断、异常、中断响应、中断向量、中断处理程序、系统调用、陷入指令、系统调用号、系统调用表</p>\n<h4 id=\"处理器状态\"><a href=\"#处理器状态\" class=\"headerlink\" title=\"处理器状态\"></a>处理器状态</h4><p>中断与异常机制</p>\n<p>CPU由运算器、控制器、寄存器及高速缓存组成</p>\n<ul>\n<li>两类寄存器：<ul>\n<li>用户可见寄存器：高级语言编译器通过优化算法分配寄存器并使用，减少访问内存次数</li>\n<li>控制和状态寄存器：用于控制处理器操作，只能由操作系统代码使用，<ul>\n<li>程序计数器 PC</li>\n<li>指令寄存器 IR</li>\n<li>程序字寄存器 PSW</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>并发和共享 -&gt; 要求保护： 用户程序不对操作系统干扰</p>\n<p>要求硬件提供基本运行机制：</p>\n<ul>\n<li>CPU具有特权级别，不同特权级下运行不同指令集合</li>\n<li>将OS与用户程序隔离</li>\n</ul>\n<p>cpu状态通常为两种、三种或四种：</p>\n<p>​    在程序状态字寄存器PSW专门设置一位，根据程序的使用权限设置不同的CPU状态</p>\n<p>操作系统需要两种CPU状态：</p>\n<pre><code>       1. 内核态 ： 运行操作系统程序\n     2. 用户态： 运行用户程序\n</code></pre><p>指令分类：</p>\n<ol>\n<li>特权指令：只能由操作系统使用，用户程序不能使用（启动IO、内存清零）</li>\n<li>非特权指令：操作系统和用户程序都可以使用（控制转移）</li>\n</ol>\n<p>CPU状态的转换：</p>\n<ul>\n<li>用户态 -&gt; 内核态： 唯一途径：中断、异常、陷入机制（提供给用户程序的接口，用于调用操作系统功能）</li>\n<li>内核态 -&gt; 用户态：设置程序状态字PSW</li>\n</ul>\n<h4 id=\"中断与异常机制\"><a href=\"#中断与异常机制\" class=\"headerlink\" title=\"中断与异常机制\"></a>中断与异常机制</h4><p>操作系统是由 中断驱动的 或是 事件驱动的</p>\n<p>概念：CPU对系统发生的某个事件的反应</p>\n<p>事件的发生改变了CPU的控制流</p>\n<p>主要作用：</p>\n<ul>\n<li>及时处理外部设备中断请求</li>\n<li>捕获用户程序提出的服务请求</li>\n<li>防止用户程序执行过程中的破坏活动</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>随机发生</li>\n<li>自动处理 (硬件自动完成的)</li>\n<li>可恢复</li>\n</ul>\n<p>中断的引入原因：支持CPU与设备之间的并行操作</p>\n<p>异常的引入原因：CPU执行指令时本身出错</p>\n<p>事件：</p>\n<ul>\n<li>中断（外中断）：<ul>\n<li>IO中断（按键、外部设备）</li>\n<li>时钟中断（定时器，CPU时间片到了）</li>\n<li>硬件故障（充电）</li>\n</ul>\n</li>\n<li>异常（内中断）：<ul>\n<li>系统调用</li>\n<li>页故障、页错误（缺页）</li>\n<li>保护性异常（只读文件和写操作）</li>\n<li>断点指令（debug）</li>\n<li>其他程序性异常（算术溢出）</li>\n</ul>\n</li>\n</ul>\n<p>异常类别：</p>\n<ul>\n<li>陷入 Trap ： 有意识安排的      同步   返回到下一条指令</li>\n<li>故障 Fault： 可恢复的错误     同步    返回到当前指令</li>\n<li>终止 Abort： 不可恢复的错误   同步   不会返回</li>\n</ul>\n<h4 id=\"中断、异常机制的工作原理\"><a href=\"#中断、异常机制的工作原理\" class=\"headerlink\" title=\"中断、异常机制的工作原理\"></a>中断、异常机制的工作原理</h4><p><strong>硬件和软件相互配合</strong></p>\n<p>硬件：响应异常</p>\n<p>​    捕获请求，以一定方式相应，把CPU的控制权交给处理程序</p>\n<p>软件：处理异常</p>\n<p>​    识别类型并完成处理</p>\n<p>中断响应：硬件</p>\n<p>​    每条指令执行最后扫描中断寄存器查看是否有中断信号，若有，则中断硬件将中断触发器内容按编码送入PSW，并查询中断向量表引出处理程序</p>\n<p>​    中断向量：一个内存单元，存放中断处理程序入口地址和程序运行时需要的处理机状态字</p>\n<p>​    流程： 设备发出中断信号 -&gt; 硬件保存现场(PSW,PC) -&gt; 根据中断码查表 -&gt; 中断处理程序入口地址送入相应寄存器 -&gt; 执行处理程序    </p>\n<p>中断处理：软件</p>\n<ul>\n<li>保存相关寄存器信息（硬件只保存关键寄存器）</li>\n<li>分析具体原因</li>\n<li>执行处理功能</li>\n<li>恢复现场，返回被打断的程序</li>\n</ul>\n<h4 id=\"系统调用机制\"><a href=\"#系统调用机制\" class=\"headerlink\" title=\"系统调用机制\"></a>系统调用机制</h4><p>操作系统给用户提供的接口，在编程时可调用的操作系统功能</p>\n<p>使CPU状态从用户态陷入内核态</p>\n<p>区分： 系统调用、库函数、API、内核函数</p>\n<p>​    应用程序通常借函数库、API接口间接进行系统调用</p>\n<p>​    内核函数包含系统调用，大部分不开放给用户</p>\n<p>设计系统调用机制：</p>\n<pre><code>       1. 利用中断异常机制\n     2. 选择一条特殊指令：陷入指令，从用户态切换到内核态\n     3. 每个系统调用给定一个编号\n     4. 存放系统调用服务例程的入口地址\n</code></pre><p>用户的参数传递给内核：（从用户栈到内核栈）</p>\n<ol>\n<li>陷入指令自带参数（长度有限）</li>\n<li>通用寄存器传递参数（寄存器个数有限） （主要方法）</li>\n<li>内存中开辟专用堆栈区传递参数</li>\n</ol>\n<p>系统调用执行过程：</p>\n<ol>\n<li>中断异常机制：硬件保护现场，查询中断向量表，控制权交给系统调用总入口程序</li>\n<li>系统调用总入口程序：保存现场，把参数保存到内核栈，查系统调用表把控制权转给相应的系统调用例程或内核函数</li>\n<li>执行系统调用例程</li>\n<li>恢复现场，返回用户程序</li>\n</ol>\n<h3 id=\"进程、线程模型\"><a href=\"#进程、线程模型\" class=\"headerlink\" title=\"进程、线程模型\"></a>进程、线程模型</h3><p>重点：</p>\n<p>​    第2章： 2.1、 2.2(除 2.2.8 - 2.2.10外)</p>\n<p>重点概念：<br>​    进程、进程状态及切换、进程控制、PCB、进程地址空间、进程上下文环境、线程、线程属性、用户级线程、核心级线程、Pthreads、可再入程序、原语、web服务器</p>\n<h4 id=\"进程的基本概念\"><a href=\"#进程的基本概念\" class=\"headerlink\" title=\"进程的基本概念\"></a>进程的基本概念</h4><p>多道程序设计： 允许多个程序同时进入内存并运行</p>\n<p>并发环境：一段时间间隔内，单处理器由两个或以上程序同时处于开始运行但尚未结束的状态且次序不是事先确定的</p>\n<p>进程 process： 具有独立功能的程序关于某个数据集合上的一次运行活动，是资源分配和调度的单位，又称任务</p>\n<ul>\n<li>程序一次执行过程</li>\n<li>正在运行程序的抽象</li>\n<li>一个CPU变换成多个虚拟的CPU</li>\n<li>系统资源以进程为单位分配，如内存、文件</li>\n<li>每个进程有独立的地址空间</li>\n<li>操作系统把CPU调度给需要的进程</li>\n</ul>\n<p>进程控制块 PCB</p>\n<ul>\n<li>又称 进程描述符、进程属性</li>\n<li>操作系统用于管理控制进程的一个专门数据结构</li>\n<li>记录进程的各种属性，并描述进程的动态变化过程</li>\n<li>是系统感知进程的唯一标识，与进程一一对应</li>\n<li>包含：<ul>\n<li>进程描述信息<ul>\n<li>进程标识符 ID，唯一</li>\n<li>进程名，不唯一</li>\n<li>用户ID</li>\n<li>进程组关系（子进程、父进程等）</li>\n</ul>\n</li>\n<li>进程控制信息<ul>\n<li>当前状态、优先级、代码执行入口地址、磁盘地址、队列指针等</li>\n</ul>\n</li>\n<li>所拥有资源和使用情况<ul>\n<li>虚拟空间空间状况</li>\n<li>打开文件列表</li>\n</ul>\n</li>\n<li>CPU现场信息<ul>\n<li>寄存器值</li>\n<li>指向该进程页表的指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>进程表： 所有进程的PCB的集合（大小固定）</p>\n<h4 id=\"进程状态及状态转换\"><a href=\"#进程状态及状态转换\" class=\"headerlink\" title=\"进程状态及状态转换\"></a>进程状态及状态转换</h4><p>进程三种基本状态：运行态、就绪态、等待态</p>\n<p>运行态 running：</p>\n<p>​    占有CPU并在CPU上运行</p>\n<p>就绪态 ready：</p>\n<p>​    已具备运行条件，但没有空闲CPU</p>\n<p>等待态、阻塞态、封锁态、睡眠态：</p>\n<p>​    因等待某一事件而暂停（如读盘）</p>\n<p>状态转换：</p>\n<ol>\n<li>就绪 -&gt; 运行：调度程序选中</li>\n<li>运行 -&gt; 就绪：运行进程用完时间片，或高优先级进程进入就绪态</li>\n<li>运行 -&gt; 等待：进程等待事件（请求OS服务，资源尚未访问，等待IO，等待另一进程等） </li>\n<li>等待 -&gt; 就绪：所等待的事件发生</li>\n</ol>\n<p>其它状态：</p>\n<ul>\n<li>创建态 new：已完成创建进程必备工作（PID、PCB），但未被同意执行（资源有限）</li>\n<li>终止态 terminated：执行后，完成数据统计工作，回收资源</li>\n<li>挂起态 suspend：进行负载调节，进程不占用内存空间，进程映像交换到磁盘</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sevenlevel.png\" alt=\"\"></p>\n<p>进程队列：</p>\n<ul>\n<li>每一类进程建立一个或多个队列</li>\n<li>队列元素为PCB</li>\n<li>进程状态改变，其PCB从一个队列进入另一队列</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><p>完成进程状态之间的转换，由具有特定功能的原语完成</p>\n<p>原语 primitive：完成某特定功能的程序，不可分割、不可中断</p>\n<ol>\n<li>进程创建<ol>\n<li>新进程分配唯一标识ID以及进程控制块PCB</li>\n<li>分配地址空间</li>\n<li>初始化PCB：设置默认值</li>\n<li>设置相应的队列指针</li>\n</ol>\n</li>\n<li>进程的撤销：结束进程<ol>\n<li>回收进程占用的资源（关闭文件、断开网络、回收内存）</li>\n<li>收回PCB</li>\n</ol>\n</li>\n<li>进程阻塞：由<strong>进程自己</strong>执行阻塞原语，使自己由运行态变为阻塞态</li>\n</ol>\n<p>UNIX下进程控制： 系统调用</p>\n<ul>\n<li>fork 通过复制调用进程建立新进程</li>\n<li>exec 用新代码覆盖原来的地址空间，建立新进程</li>\n<li>wait 进程进入阻塞态 </li>\n<li>exit 终止进程运行 </li>\n</ul>\n<h4 id=\"进程相关概念\"><a href=\"#进程相关概念\" class=\"headerlink\" title=\"进程相关概念\"></a>进程相关概念</h4><p>进程的分类：</p>\n<ol>\n<li><ul>\n<li>系统进程：优先级较高</li>\n<li>用户进程</li>\n</ul>\n</li>\n<li><ul>\n<li>前台进程</li>\n<li>后台进程</li>\n</ul>\n</li>\n<li><ul>\n<li>CPU密集型进程</li>\n<li>IO密集型进程</li>\n</ul>\n</li>\n</ol>\n<p>进程的层次结构：</p>\n<ul>\n<li>Unix进程家族树：init为根</li>\n<li>Windows：地位相同</li>\n</ul>\n<p>进程和程序的区别：</p>\n<ul>\n<li>进程更准确刻画并发</li>\n<li>程序是静态的，进程是动态的</li>\n<li>进程由生命周期，程序相对长久</li>\n<li>一个程序可以对应多个进程</li>\n<li>进程可以创建其它进程，程序不行</li>\n</ul>\n<p>进程映像 image： 进程执行活动全过程的静态描述，程序+数据+栈（用户栈+内核栈）+PCB</p>\n<p>上下文context 切换： CPU硬件状态从一个进程切换到另一个进程的过程</p>\n<blockquote>\n<p>进程运行时硬件状态保存在CPU的寄存器，当进程不运行时，寄存器的值要保存到PCB中</p>\n</blockquote>\n<h4 id=\"线程的引入\"><a href=\"#线程的引入\" class=\"headerlink\" title=\"线程的引入\"></a>线程的引入</h4><p>引入原因：</p>\n<ul>\n<li>应用需要 （打字与排版与存盘、web服务器）</li>\n<li>开销考虑<ul>\n<li>线程开销小<ul>\n<li>创建新线程花费时间少</li>\n<li>线程切换花费时间少</li>\n<li>线程通信无需调用内核，直接共享资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>性能考虑：多处理器处理多线程</li>\n</ul>\n<p>线程的基本概念</p>\n<p>线程集成了CPU调度单位</p>\n<p>进程还是资源拥有者</p>\n<p>线程 thread：进程中的一个运行实体，是CPU的调度单位，也称轻量级进程</p>\n<p>属性：</p>\n<ul>\n<li>有标识符ID</li>\n<li>有状态及状态切换</li>\n<li>不运行时需要保存上下文</li>\n<li>有自己的栈和栈指针</li>\n<li>共享所在进程的地址空间和其他资源</li>\n<li>可以创建、撤销另一个线程，程序一开始是单线程执行</li>\n</ul>\n<h4 id=\"线程机制的实现\"><a href=\"#线程机制的实现\" class=\"headerlink\" title=\"线程机制的实现\"></a>线程机制的实现</h4><ul>\n<li>用户级线程 （unix）<ul>\n<li>在用户空间建立线程库</li>\n<li>通过 运行时系统（run-time system）完成管理工作</li>\n<li>内核管理、进程都不知道线程的存在</li>\n<li>线程切换不需要内核态特权，不需要操作系统干预</li>\n<li>优点：<ul>\n<li>线程切换快</li>\n<li>调度算法是应用程序特定的</li>\n<li>可运行在任何操作系统上</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>内核只分配处理器给进程，同一进程两线程不能同时运行于两个处理器</li>\n<li>系统调用大多是阻塞的，内核阻塞进程时所有线程也被阻塞</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>核心级线程 （windows）<ul>\n<li>内核管理所有线程，向应用程序提供API</li>\n<li>内核维护线程和进程</li>\n<li>线程切换需要内核</li>\n<li>以线程为单位进行调度</li>\n</ul>\n</li>\n<li>混合模型：<ul>\n<li>线程在用户空间创建</li>\n<li>线程调度在核心态完成</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"处理器调度\"><a href=\"#处理器调度\" class=\"headerlink\" title=\"处理器调度\"></a>处理器调度</h3><p>教材重点：</p>\n<ul>\n<li>第二章： 2.4</li>\n<li>第11章： 11.4.3</li>\n</ul>\n<p>重点：</p>\n<ul>\n<li>掌握处理器调度的相关概念：<ul>\n<li>调度时机、进程切换</li>\n<li>调度标准：吞吐量、周转时间、响应时间</li>\n<li>优先级/优先数、 抢占/非抢占、 IO型与CPU型</li>\n</ul>\n</li>\n<li>掌握主要的调度算法：<ul>\n<li>先来先服务、短作业有限、最高响应比优先</li>\n<li>时间片轮转、最高优先级</li>\n<li>多级反馈队列</li>\n</ul>\n</li>\n<li>了解Windows、多处理器调度的基本思想</li>\n</ul>\n<h4 id=\"处理器调度的相关概念\"><a href=\"#处理器调度的相关概念\" class=\"headerlink\" title=\"处理器调度的相关概念\"></a>处理器调度的相关概念</h4><p>CPU调度：控制、协调进程对CPU的竞争，按一定调度算法从就绪队列中选一个进程把CPU使用权交给被选中进程</p>\n<p>若没有就绪进程，系统会安排系统空闲进程或idle进程</p>\n<p>三个问题：</p>\n<ul>\n<li>按什么原则选择下一个进程：调度算法</li>\n<li>何时选择：调度时机</li>\n<li>如何让被选中进程上CPU运行：调度过程（进程上下文切换）</li>\n</ul>\n<p>调度时机： 内核对中断、异常、系统调用处理后返回用户态时</p>\n<ul>\n<li>进程正常终止或因错误终止</li>\n<li>新进程创建、等待进程变成就绪</li>\n<li>进程从运行态进入阻塞态</li>\n<li>进程从运行态进入就绪态</li>\n</ul>\n<p>调度过程：</p>\n<ul>\n<li>进程切换：一个进程让出CPU，另一个进程使用CPU<ul>\n<li>包括对原进程状态的保存，和对新进程状态的恢复</li>\n<li>过程<ul>\n<li>切换全局页目录以加载新的地址空间</li>\n<li>切换内核栈和硬件上下文</li>\n</ul>\n</li>\n<li>开销：<ul>\n<li>直接开销：内核完成切换所用的CPU时间<ul>\n<li>保存、恢复寄存器</li>\n<li>切换地址空间</li>\n</ul>\n</li>\n<li>间接开销<ul>\n<li>高速缓存、缓冲区缓存、TLB失效</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>调度算法的设计：</p>\n<ul>\n<li>衡量指标：<ul>\n<li>吞吐量 throughput： 单位时间完成的进程数目</li>\n<li>周转时间 TT turnaround time：进程从提出请求到运行完成的时间</li>\n<li>响应时间 RT response time：提出请求到第一次回应的事件</li>\n<li>CPU利用率：CPU有效工作的时间</li>\n<li>等待时间：进程在就绪队列中等待的时间</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/schedulalgo.png\" alt=\"调度算法设计\"></p>\n<h4 id=\"调度算法的设计\"><a href=\"#调度算法的设计\" class=\"headerlink\" title=\"调度算法的设计\"></a>调度算法的设计</h4><p>优先级：</p>\n<ul>\n<li>优先级与优先数</li>\n<li>静态与动态</li>\n</ul>\n<p>占用CPU的方式：</p>\n<ul>\n<li>抢占式 preemptive：<ul>\n<li>有优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU</li>\n</ul>\n</li>\n<li>不可抢占式 non-preemptive：<ul>\n<li>除非因自身原因不能运行，否则进程会一直运行下去</li>\n</ul>\n</li>\n</ul>\n<p>进程按执行过程行为划分：</p>\n<ul>\n<li>IO密集型 IO-bound</li>\n<li>CPU密集型 CPU-bound</li>\n</ul>\n<p>时间片： time slice 或 quantum：</p>\n<ul>\n<li>分配给调度上CPU的进程的时间段</li>\n</ul>\n<h4 id=\"批处理中的调度算法\"><a href=\"#批处理中的调度算法\" class=\"headerlink\" title=\"批处理中的调度算法\"></a>批处理中的调度算法</h4><ul>\n<li>先来先服务 FCFS  first come first serve：<ul>\n<li>按进程就绪先后顺序使用CPU</li>\n<li>非抢占式</li>\n<li>优点： 公平、实现简单</li>\n<li>缺点：短进程需要等长时间</li>\n</ul>\n</li>\n<li>最短作业优先 SJF shortest job first：<ul>\n<li>最短完成时间的进程优先</li>\n<li>非抢占式</li>\n<li>改善短作业的周转时间</li>\n<li>优点：最短平均周转时间（所有进程同时可运行时）</li>\n<li>缺点：不公平，长任务饥饿现象 starvation</li>\n</ul>\n</li>\n<li>最短剩余时间优先 SRTN  shortest remaining time next：<ul>\n<li>最短作业优先的抢占版本</li>\n</ul>\n</li>\n<li>最高响应比优先 HRRN  highest response ratio next<ul>\n<li>调度时，先计算每个进程的响应比R，总选择R最高的进程</li>\n<li>R = $\\frac{周转时间}{处理时间}$ =  $1+\\frac{等待时间}{处理时间}$ </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"交互式系统采用的调度算法\"><a href=\"#交互式系统采用的调度算法\" class=\"headerlink\" title=\"交互式系统采用的调度算法\"></a>交互式系统采用的调度算法</h4><ul>\n<li>轮转调度 RR round robin<ul>\n<li>目标：为短任务改善平均响应时间</li>\n<li>思路：<ul>\n<li>周期性切换</li>\n<li>每个进程一个时间片</li>\n<li>时钟中断 -&gt; 轮换</li>\n</ul>\n</li>\n<li>时间片选择：<ul>\n<li>太长：短进程响应时间长</li>\n<li>太短：切换开销大</li>\n</ul>\n</li>\n<li>优点：公平、利于交互式计算</li>\n<li>缺点：进程切换使得轮转开销大、对大小相近的进程不利、对IO型进程不利</li>\n</ul>\n</li>\n<li>最高优先级调度 HPF highest priority first：<ul>\n<li>通常： 系统进程优先于用户进程、前台进程优先于后台，偏向于IO型进程</li>\n<li>优先级反转问题 priority inversion（基于优先级的抢占式时）：低优先级进程占有高优先级进程需要的资源<ul>\n<li>影响： <ul>\n<li>系统错误</li>\n<li>高优先级进程停滞不前</li>\n</ul>\n</li>\n<li>解决方案：<ul>\n<li>设置优先级上限（临界区的进程优先级最高）</li>\n<li>优先级继承（低优先级继承高优先级）</li>\n<li>使用中断禁止（临界区进程不响应中断）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多级反馈队列 Multiple feedback queue：<ul>\n<li>设置多个就绪队列，第一级队列优先级最高</li>\n<li>时间片长度不同，级别越低，时间片越大</li>\n<li>每个队列用时间片轮转方式调度</li>\n<li>新进程创建就绪后，进入第一级</li>\n<li>进程用完时间片并放弃CPU，进入下一级就绪队列</li>\n<li>因阻塞放弃CPU的进程从等待队列出来时回到原来就绪队列</li>\n</ul>\n</li>\n<li>最短进程优先 Shortest process next</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/schedulalgo1.png\" alt=\"调度算法总结\"></p>\n<p>多处理器调度算法设计：</p>\n<ul>\n<li>不仅选择哪个进程，还要选择在哪个CPU</li>\n<li>考虑进程在多个CPU迁移的开销</li>\n<li>负载均衡问题</li>\n</ul>\n<h4 id=\"Windows-线程调度\"><a href=\"#Windows-线程调度\" class=\"headerlink\" title=\"Windows 线程调度\"></a>Windows 线程调度</h4><p>调度单位是线程</p>\n<p>采用基于动态优先级、抢占式调度，结合时间配额的调整</p>\n<p>引发线程调度的条件：</p>\n<ul>\n<li>线程优先级改变</li>\n<li>线程改变了亲和affinity处理机集合</li>\n<li>正常调度条件（4条）</li>\n</ul>\n<p>32个优先级，分三类：</p>\n<ul>\n<li>实时优先级：不改变优先级</li>\n<li>可变优先级：在一定范围内可变</li>\n<li>系统线程</li>\n</ul>\n<p>时间配额：配额单位的整数，不是时间长度值</p>\n<p>调度策略：</p>\n<ul>\n<li>主动切换</li>\n<li>抢占： <ul>\n<li>被抢占线程：<ul>\n<li>实时优先级：时间配额重置</li>\n<li>可变优先级：时间配额不变</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>时间配额用完<ul>\n<li>A优先级未降低：A进入原就绪队列末尾</li>\n<li>A优先级降低</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h3><p>重点：</p>\n<ul>\n<li>基本概念：<ul>\n<li>竞争条件、临界区</li>\n<li>进程同步、互斥</li>\n<li>自旋锁（忙等待）</li>\n</ul>\n</li>\n<li>信号量，PV操作</li>\n<li>经典问题模型及解决方案<ul>\n<li>生产者消费者问题，读者写者问题</li>\n</ul>\n</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第2章： 2.3.1~2.3.5， 2.5.2</li>\n</ul>\n<h4 id=\"进程互斥\"><a href=\"#进程互斥\" class=\"headerlink\" title=\"进程互斥\"></a>进程互斥</h4><p>竞争条件 race condition： 两个或多个进程读写某些共享数据，最后结果取决于进程的精确时序</p>\n<p>进程互斥 mutual exclusive：共享资源需要排他性使用，各进程之间竞争使用这些资源</p>\n<p>临界资源、共享资源、互斥资源 critical resource： 某些资源一次只允许一个进程使用</p>\n<p>临界区（互斥区）：critical section：各个进程中对临界资源实时操作的程序片断</p>\n<p>临界区的使用原则：</p>\n<ul>\n<li>没有进程在临界区时，想进入的可以进入</li>\n<li>不允许两个进程同时处于临界区</li>\n<li>临界区外的进程不得阻塞其他进程进入临界区</li>\n<li>不得使进程在临界区外无限等待</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>软件：<ul>\n<li>dekker解法</li>\n<li>peterson解法</li>\n</ul>\n</li>\n<li>硬件：<ul>\n<li>屏蔽中断</li>\n<li>TSL（XCHG）指令</li>\n</ul>\n</li>\n</ul>\n<p>忙等待 busy waiting：进程得到临界区访问权之前，持续测试</p>\n<ul>\n<li>自旋锁 spin lock （多处理器）</li>\n<li>为什么不直接切换进程： 临界区使用时间一般很短，切换进程的开销更大</li>\n</ul>\n<p>优先级反转（倒置）：由于临界区保护带来的问题</p>\n<h4 id=\"软件解法\"><a href=\"#软件解法\" class=\"headerlink\" title=\"软件解法\"></a>软件解法</h4><p>解法1：</p>\n<ul>\n<li>用free作为标志：临界区是否空闲<ul>\n<li>true：有进程在临界区</li>\n<li>false：无进程在临界区</li>\n<li>初始值：false</li>\n</ul>\n</li>\n<li>使用 lock(),unlock()作为原语</li>\n</ul>\n<p>dekker算法：</p>\n<ul>\n<li>引入turn变量，判断是否轮到自己</li>\n</ul>\n<p>peterson算法：</p>\n<ul>\n<li>解决了互斥访问的问题，而且克服了强制轮流的缺点</li>\n<li>通过 enter_region()  和 leave_region()函数</li>\n<li>while( turn==process &amp;&amp; interested[other]==TURE );</li>\n</ul>\n<h4 id=\"硬件解法\"><a href=\"#硬件解法\" class=\"headerlink\" title=\"硬件解法\"></a>硬件解法</h4><p>通过指令完成</p>\n<p>解法1：中断屏蔽方法</p>\n<ul>\n<li>使用  开关中断 指令 （特权指令）</li>\n<li>入临界区： 执行 关中断 指令</li>\n<li>出临界区： 执行 开中断 指令</li>\n<li>优点：简单高效</li>\n<li>缺点：<ul>\n<li>代价高，限制CPU并发能力</li>\n<li>不适用于多处理器</li>\n<li>适合操作系统，不适合用户进程</li>\n</ul>\n</li>\n</ul>\n<p>解法2：测试并加锁 指令：</p>\n<ul>\n<li>TSL指令：TEST AND SET LOCK</li>\n<li>复制 锁 到寄存器 并把锁置为1（上锁）</li>\n<li>判断寄存器是不是0<ul>\n<li>若不是0，跳转到enter_region（反复循环）</li>\n<li>若是0，返回，进入临界区</li>\n</ul>\n</li>\n</ul>\n<p>解法3： 交换 指令：</p>\n<ul>\n<li>XCHG指令：EXCHANGE</li>\n<li>寄存器设置为1，交换寄存器和锁的内容，判断寄存器是否是0（与TSL类似）</li>\n</ul>\n<h4 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h4><p>进程同步 synchronization：多个进程中发生的事件存在某种时序关系，需要合作</p>\n<p>生产者、消费者问题（有界缓冲区）：</p>\n<ul>\n<li>一个或多个生产者生产某种数据放在缓冲区</li>\n<li>有消费者从缓冲区中取数据，每次取一项</li>\n<li>只能有一个生产者或一个消费者对缓冲区进行操作</li>\n<li>问题：<ul>\n<li>缓冲区满时，生产者不添加数据</li>\n<li>缓冲区空时，消费者不移走数据</li>\n</ul>\n</li>\n<li>避免忙等待<ul>\n<li>睡眠 与 唤醒 操作（原语）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"信号量及P、V操作\"><a href=\"#信号量及P、V操作\" class=\"headerlink\" title=\"信号量及P、V操作\"></a>信号量及P、V操作</h4><p>典型的进程同步机制</p>\n<p>信号量：特殊的变量，用于进程间传递信息的整数值 （count、queue）</p>\n<p>可执行的操作： 初始化、 P（test） 、 V（increment）</p>\n<p>P操作： 测试</p>\n<ul>\n<li>把信号量的值减一</li>\n<li>判断信号量是否 &lt; 0 ：<ul>\n<li>&lt;0：该进程状态为阻塞态，插入等待队列 s.queue末尾，重新调度</li>\n<li>false：执行进程</li>\n</ul>\n</li>\n</ul>\n<p>V操作：</p>\n<ul>\n<li>信号量的值+1</li>\n<li>判断信号量是否&lt;=0:<ul>\n<li>true ：唤醒s.queue的一个进程，插入就绪队列</li>\n</ul>\n</li>\n</ul>\n<p>P、 V操作是原语操作 primitive or atomic action</p>\n<p>最初提出：二元信号量（解决互斥）</p>\n<p>推广：一般信号量（解决同步）</p>\n<p>用PV解决互斥问题：</p>\n<ul>\n<li>分析并发进程关键活动，划定临界区</li>\n<li>设置信号量 mutex，初始值为1</li>\n<li>临界区前实施 P</li>\n<li>临界区后实施 V</li>\n</ul>\n<p>用PV解决生产者消费者问题：</p>\n<ul>\n<li>用full、empty两个变量记录满缓冲区和空缓冲区数目</li>\n<li>分别用P、V操作维护full和empty</li>\n<li>用 mutex 维护互斥，防止同时读写buffer<img src=\"http://ot1c7ttzm.bkt.clouddn.com/PV.png\" alt=\"PV\"></li>\n<li>两边的P操作顺序不可逆，必须先判断empty或full才能判断mutex（因为P操作可能使进程进入阻塞态）</li>\n<li>两边的V操作顺序可逆</li>\n<li>位置：尽可能缩小临界区</li>\n</ul>\n<p>PV操作解决读者、写者问题：</p>\n<ul>\n<li><p>多个进程共享一个数据区，分为两组：</p>\n<ul>\n<li>读者进程：只读数据区数据</li>\n<li>写者进程：只写数据区数据</li>\n</ul>\n</li>\n<li><p>条件：</p>\n<ul>\n<li>允许多个读者同时读</li>\n<li>不允许多个写者同时操作</li>\n<li>不允许读写同时</li>\n<li>（读写互斥，写者之间互斥）</li>\n</ul>\n</li>\n<li><p>Linux提供的读写锁：</p>\n</li>\n<li><p>第一类读者写者问题：读者优先：</p>\n<ul>\n<li>若有写者在等，有其他读者在读，则新读者可以读</li>\n<li>有读者在读，写者等待</li>\n<li>解法：<ul>\n<li>第一个读者做P操作，最后一个读者做V操作</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"同步机制（2）\"><a href=\"#同步机制（2）\" class=\"headerlink\" title=\"同步机制（2）\"></a>同步机制（2）</h3><p>重点：</p>\n<ul>\n<li>管程：<ul>\n<li>如何保证互斥</li>\n<li>如何保证同步：条件变量及wait、signal</li>\n<li>HOARE管程</li>\n<li>MESA管程</li>\n</ul>\n</li>\n<li>进程间通信：<ul>\n<li>消息传递、共享内存、管道</li>\n</ul>\n</li>\n<li>Pthread中的同步机制</li>\n<li>Linux的IPC机制</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第二章： 2.3.6～ 2.3.9</li>\n</ul>\n<h4 id=\"管程-monitor\"><a href=\"#管程-monitor\" class=\"headerlink\" title=\"管程 monitor\"></a>管程 monitor</h4><p>出现原因： 信息量机制不足：程序编写困难、易出错（PV操作的位置）</p>\n<p>解决：在程序设计语言中引入管程成分：高级同步机制</p>\n<p>定义：</p>\n<ul>\n<li>一个特殊的模块</li>\n<li>每个管程有一个名字</li>\n<li>管理共享资源的数据结构及其上操作的一组过程组成</li>\n</ul>\n<p>进程与管程： 进程只能通过调用管程中的过程来间接访问管程的数据结构</p>\n<p>管程解决的问题：</p>\n<ul>\n<li>互斥：<ul>\n<li>管程是互斥进入的：为了保证管程中数据结构的数据完整性</li>\n<li>互斥性由编译器负责保证</li>\n</ul>\n</li>\n<li>同步：<ul>\n<li>管程中设置条件变量及等待、唤醒操作以解决同步问题</li>\n<li>可以使一个进程或线程在条件变量上等待或唤醒</li>\n</ul>\n</li>\n</ul>\n<p>使用管程的问题：</p>\n<ul>\n<li>进入管程的操作执行唤醒操作（P唤醒Q）：<ul>\n<li>规定唤醒操作为管程中最后一个可执行的操作</li>\n<li>P等待，Q执行 （HOARE管程）</li>\n<li>Q等待，P继续执行（MESA管程）</li>\n</ul>\n</li>\n</ul>\n<p>HOARE管程：</p>\n<ul>\n<li>管程内增加紧急等待队列，P唤醒Q后P进入紧急等待队列（优先级高于入口等待队列）</li>\n<li>管程外有入口等待队列</li>\n<li>条件变量：在管程内部说明和使用的一种特殊类型的变量<ul>\n<li>wait操作：紧急队列非空，则唤醒第一个等待者，否则释放管程互斥权，执行该操作的进程进入c链末尾</li>\n<li>signal：c链为空则相当于空操作，否则唤醒第一个等待者，执行该操作的进程进入紧急等待队列</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>两次额外的进程切换</li>\n</ul>\n</li>\n</ul>\n<p>管程的实现：</p>\n<ul>\n<li>直接构造：效率高</li>\n<li>间接构造：用某种已经实现的同步机制构造（如信号量及PV操作）</li>\n</ul>\n<p>MESA管程：（P唤醒Q，P继续执行）</p>\n<ul>\n<li>signal -&gt; notify： notif(x)使得x条件队列得到通知，发信号的进程继续执行</li>\n<li>notify的结果：条件队列头的进程在将来合适的时候恢复执行</li>\n<li>不能保证在它之前没有其他进程进入管程，因此进程必须重新检查条件：用while循环取代if语句检查条件</li>\n<li>导致对条件变量至少多一次额外检测，对等待进程什么时候执行没有限制</li>\n<li>对notify的改进：<ol>\n<li>每个条件原语关联计时器，超过一定等待时间的进程直接进入就绪态</li>\n<li>broadcast：所有在该条件上等待的进程都被释放且进入就绪序列</li>\n</ol>\n</li>\n</ul>\n<p>HOARE和MESA的比较：</p>\n<ul>\n<li>MESA一般优于HOARE：MESA错误较少</li>\n<li>MESA：每个过程收到信号后重新检查管程变量，且使用while</li>\n</ul>\n<h4 id=\"PTHREAD中的同步机制\"><a href=\"#PTHREAD中的同步机制\" class=\"headerlink\" title=\"PTHREAD中的同步机制\"></a>PTHREAD中的同步机制</h4><p>通过互斥量保护临界区： Pthread_mutex</p>\n<p>解决同步问题：条件变量： wait \\ signal \\ broadcast</p>\n<h4 id=\"进程间通信机制\"><a href=\"#进程间通信机制\" class=\"headerlink\" title=\"进程间通信机制\"></a>进程间通信机制</h4><p>原因：</p>\n<ul>\n<li>信号量和管程的不足</li>\n<li>不适合多处理器的情况</li>\n</ul>\n<p>进程通信机制：消息传递：send &amp; receive 原语</p>\n<p>适用于： 分布式系统、单处理器系统、共享内存的多处理器系统</p>\n<p>通信方式：</p>\n<ul>\n<li>消息传递<ul>\n<li>操作系统空间设置消息缓冲区：<ul>\n<li>消息头（消息类型，进程ID：发送、接收，消息长度，控制信息）</li>\n<li>消息体</li>\n</ul>\n</li>\n<li>发送原语，由操作系统完成</li>\n<li>过程：陷入内核、复制消息、消息入队（接收进程的PCB消息队列指针）、复制消息</li>\n<li>通过PV操作实现</li>\n</ul>\n</li>\n<li>共享内存<ul>\n<li>需要解决两个问题：<ul>\n<li>物理内存中建立共享空间，并建立两个进程的地址空间到内存的映射</li>\n<li>读者写者问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>管道 pipe：<ul>\n<li>利用缓冲传输介质：内存或文件连接两个进程</li>\n<li>问题：<ul>\n<li>字符流方式写入读出</li>\n<li>先入先出顺序</li>\n<li>管道通信必须提供协调能力：互斥、同步、判断对方进程是否存在</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>套接字</li>\n<li>远程过程调用</li>\n</ul>\n<h4 id=\"典型操作系统的IPC机制\"><a href=\"#典型操作系统的IPC机制\" class=\"headerlink\" title=\"典型操作系统的IPC机制\"></a>典型操作系统的IPC机制</h4><p>linux的进程通信机制：</p>\n<ul>\n<li>用户程序：管道、消息队列、共享内存、信号、套接字</li>\n<li>内核同步机制：原子操作、自旋锁、读写锁、信号量、屏障</li>\n</ul>\n<p>原子操作：</p>\n<ul>\n<li>不可分割，不会被打断</li>\n<li>常用于资源计数</li>\n</ul>\n<p>屏障 barrier：</p>\n<ul>\n<li>同步机制</li>\n<li>用于对一组线程进行协调，要求所有线程到达一个汇合点后一起向前</li>\n</ul>\n<h3 id=\"存储模型（1）\"><a href=\"#存储模型（1）\" class=\"headerlink\" title=\"存储模型（1）\"></a>存储模型（1）</h3><p>重点：</p>\n<ul>\n<li>地址重定位</li>\n<li>基本内存管理方案</li>\n<li>物理内存管理技术</li>\n<li>交换技术</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第3章 3.1、 3.2</li>\n</ul>\n<h4 id=\"地址重定位\"><a href=\"#地址重定位\" class=\"headerlink\" title=\"地址重定位\"></a>地址重定位</h4><p>进程中的地址不是最终的物理地址</p>\n<p>进程运行前无法计算出物理地址</p>\n<p>地址重定位：</p>\n<ul>\n<li>逻辑地址（相对地址、虚拟地址）：<ul>\n<li>用户程序经过编译汇编后形成目标代码，首地址为0，其它地址相对于首地址编址</li>\n<li>不能用逻辑地址在内存中读取信息</li>\n</ul>\n</li>\n<li>物理地址（绝对地址，实地址）：<ul>\n<li>内存存储单元的地址，可直接寻址</li>\n</ul>\n</li>\n<li>概念：需要将用户程序的逻辑地址转换为可由其直接寻址的物理地址</li>\n<li>分类：<ul>\n<li>静态重定位：<ul>\n<li>用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换</li>\n<li>一般由软件完成</li>\n</ul>\n</li>\n<li>动态重定位：（常用）<ul>\n<li>进程执行过程中进行地址变换：逐条指令执行时完成地址转换</li>\n<li>需要硬件部件支持（部件：内存管理单元MMU memory management unit）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"物理内存划分\"><a href=\"#物理内存划分\" class=\"headerlink\" title=\"物理内存划分\"></a>物理内存划分</h4><p>空闲内存管理：</p>\n<ul>\n<li>等长划分：<ul>\n<li>bitmap 位图：每个分配单元对应一位</li>\n</ul>\n</li>\n<li>不等长划分：<ul>\n<li>空闲区表、已分配区表：表中每一项记录起始地址、长度、标志</li>\n<li>空闲块链表：每个表项用链相连</li>\n</ul>\n</li>\n</ul>\n<p>内存分配算法：</p>\n<ul>\n<li>首次适配 first fit：空闲区表第一个满足进程要求的空闲区</li>\n<li>下次适配 next fit：从上次找到的空闲区接着找</li>\n<li>最佳适配 best fit：查找整个表，找到满足要求的最小空闲区</li>\n<li>最差适配 worst fit：总分配满足进程要求的最大空闲区</li>\n</ul>\n<p>空闲区划分：一部分供进程使用，一部分作为新的空闲区</p>\n<p>回收问题：</p>\n<ul>\n<li>内存回收算法：<ul>\n<li>某一块归还后，空闲空间合并，修改空闲区表</li>\n<li>四种情况：<ul>\n<li>上相邻、下相邻、上下都相邻、上下都不相邻</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>伙伴系统：</p>\n<ul>\n<li>linux底层内存管理采用</li>\n<li>经典的内存分配方案</li>\n<li>主要思想： 内存按2的幂划分，组成空闲块链表，查找最佳匹配</li>\n<li>算法：<ul>\n<li>首先将整个空间看做一块 $2^U$</li>\n<li>假设进程申请空间大小为s，若满足 $ 2^{U-1}&lt;s&lt;=2^U $则分配整个块</li>\n<li>否则把块划分成两个大小相等的伙伴 $2^{U-1}$</li>\n<li>一直划分直到产生大于等于s的块</li>\n</ul>\n</li>\n<li>进程使用完后归还空间，空间进行可能的合并</li>\n</ul>\n<h4 id=\"基本内存管理方案（1）\"><a href=\"#基本内存管理方案（1）\" class=\"headerlink\" title=\"基本内存管理方案（1）\"></a>基本内存管理方案（1）</h4><p>整个进程进入内存连续区域</p>\n<p>以进程为单位装载</p>\n<p>方案：</p>\n<ul>\n<li>单一连续区：<ul>\n<li>特点：一段时间内只有一个进程在内存</li>\n<li>简单，但内存利用率低</li>\n</ul>\n</li>\n<li>固定分区：<ul>\n<li>分区：内存空间分割</li>\n<li>分区固定不变，大小可以相同也可以不同</li>\n<li>一个分区装一个进程</li>\n</ul>\n</li>\n<li>可变分区：<ul>\n<li>根据进程需要把空闲空间分割，分配进程，剩余部分成为新的空闲区</li>\n<li>缺点：有外碎片(进程之间的小空闲空间无法分配)，导致内存利用率下降</li>\n<li>碎片：很小的，不易利用的空闲区</li>\n<li>问题解决：紧缩技术 memory compaction：<ul>\n<li>在内存移动程序把小空闲区合并：</li>\n<li>需要考虑：<ul>\n<li>系统开销</li>\n<li>移动时机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基本内存管理方案（2）\"><a href=\"#基本内存管理方案（2）\" class=\"headerlink\" title=\"基本内存管理方案（2）\"></a>基本内存管理方案（2）</h4><p>一个进程进入内存中若干不连续区域</p>\n<p>方案：</p>\n<ul>\n<li>页式存储管理：<ul>\n<li>用户进程被划分为大小相等的部分称 页 page 或页面</li>\n<li>内存空间按同样大小分区域，称页框 page frame</li>\n<li>内存分配：<ul>\n<li>以页为单位分配，按进程需要的页数分配</li>\n<li>逻辑相邻的页，物理上不一定相邻</li>\n</ul>\n</li>\n<li>典型页面尺寸： 4K或4M</li>\n<li>逻辑地址： 页号+页内地址</li>\n<li>页表：<ul>\n<li>页表项：记录逻辑地址和物理地址的映射关系</li>\n<li>每个进程一个页表，一般放在内存</li>\n</ul>\n</li>\n<li>空闲内存管理：bitmap</li>\n<li>地址转换：硬件支持：<ul>\n<li>逻辑地址，CPU自动划分为页号和页内地址，用页号查页表得到页框号，再与页内偏移拼接成物理地址</li>\n</ul>\n</li>\n<li>内碎片：页框内浪费空间</li>\n</ul>\n</li>\n<li>段式存储方案：<ul>\n<li>按程序逻辑划分若干程序段，每个段一个段名</li>\n<li>内存空间被动态划分为长度不同的区域，称为物理段</li>\n<li>以段为单位进行划分，每段占连续空间，段之间可以不相邻</li>\n<li>逻辑地址 = 段号+段内地址 ， 无法自动划分</li>\n<li>段表： 记录每段长度和段起始地址，存放在内存</li>\n<li>物理内存管理：空闲区表</li>\n<li>地址转换：硬件支持：<ul>\n<li>逻辑地址，用段号查段表，得到起始地址，与段内偏移地址计算出地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段页式存储方案：<ul>\n<li>综合页式，段式优点</li>\n<li>先按段划分，每个段按页划分</li>\n<li>逻辑地址：段号+页号+页内地址</li>\n<li>内存划分：同页式存储方案</li>\n<li>内存分配：以页为单位分配</li>\n<li>段表： 记录每一段页表起始地址和长度</li>\n<li>页表：逻辑页号和页框的对应关系</li>\n<li>一个进程一个段表多个页表，一个段表一个页表</li>\n<li>空闲区同页式管理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"交换技术-swapping\"><a href=\"#交换技术-swapping\" class=\"headerlink\" title=\"交换技术 swapping\"></a>交换技术 swapping</h4><p>内存不足时的解决方案，当大的地址空间装不进小的内存空间</p>\n<p>内存”扩充“技术</p>\n<ul>\n<li>内存紧缩技术（可变分区）</li>\n<li>覆盖技术 overlaying：（早期操作系统）<ul>\n<li>程序大小超过物理内存总和</li>\n<li>程序不同部分在内存中相互替代，把不会同时执行的程序段共享同一内存区域</li>\n<li>要求程序各模块有明确的调用结构</li>\n<li>程序员声明覆盖结构，操作系统完成自动覆盖</li>\n<li>缺点：用户不透明，增加用户负担</li>\n</ul>\n</li>\n<li>交换技术 swapping：<ul>\n<li>系统把内存中某些进程暂时移到外存，把外存某些进程换入内存</li>\n<li>问题：<ul>\n<li>进程哪些内容要交换：运行中创建或修改的内容：栈和堆</li>\n<li>磁盘什么位置保存：交换区swap space：一块特殊的区域，包含连续的磁道，操作系统通过底层的磁盘读写操作对其高效访问</li>\n<li>交换时机：只要不用就换出； 内存空间不足或即将不足时</li>\n<li>如何选择被换出的进程：不应换出处于等待IO状态的进程</li>\n<li>如何处理进程空间增长：预留空间给数据段、栈增长</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟存储技术 virtual memory</li>\n</ul>\n<h3 id=\"存储模型（2）-虚拟存储\"><a href=\"#存储模型（2）-虚拟存储\" class=\"headerlink\" title=\"存储模型（2） 虚拟存储\"></a>存储模型（2） 虚拟存储</h3><p>重点：</p>\n<ul>\n<li>虚拟存储技术</li>\n<li>虚拟页式存储方案的实现：<ul>\n<li>多级页表、翻转页表、页表项、地址转换、MMU、快表TLB、页错误、缺页异常处理</li>\n</ul>\n</li>\n<li>软件策略：<ul>\n<li>驻留集、置换范围、清除策略</li>\n<li>置换算法：OPT、FIFO、第二次机会、时钟算法、LRU、老化、工作集</li>\n</ul>\n</li>\n<li>虚存相关的软件技术：内存映射文件、写时复制</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第三章：3.3、 3.4、 3.5.1、 3.5.7、 3.5.8、 3.6.1</li>\n</ul>\n<h4 id=\"虚拟存储技术\"><a href=\"#虚拟存储技术\" class=\"headerlink\" title=\"虚拟存储技术\"></a>虚拟存储技术</h4><p>定义： 进程运行时，一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成从磁盘调入内存的工作</p>\n<p>虚拟地址空间：分配给进程的虚拟内存</p>\n<p>虚拟地址：虚拟内存中指令或数据的位置</p>\n<p>虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用</p>\n<p>大小限制：寻址空间和磁盘大小</p>\n<p>地址保护：（硬件）</p>\n<ul>\n<li>确保每个进程都有独立的地址空间</li>\n<li>确保进程访问合法的地址范围： 基地址寄存器+界限寄存器</li>\n<li>确保进程的操作是合法的</li>\n</ul>\n<p>虚拟页式paging：</p>\n<ul>\n<li>虚拟存储技术+页式存储方案</li>\n<li>基本思想：<ul>\n<li>进程开始前装入一个或0个页面</li>\n<li>根据进程需要动态装入其他页面</li>\n<li>当内存空间满，又需要装入新的页面，则根据置换算法置换某个页面，以装入新的页面</li>\n</ul>\n</li>\n<li>方式：<ul>\n<li>请求调页 demand paging</li>\n<li>预先调页 prepaging</li>\n</ul>\n</li>\n<li>用CPU时间和磁盘空间换内存空间</li>\n</ul>\n<h4 id=\"页表和页表项的设计\"><a href=\"#页表和页表项的设计\" class=\"headerlink\" title=\"页表和页表项的设计\"></a>页表和页表项的设计</h4><p>页表由页表项组成：</p>\n<ul>\n<li>页框号：内存块号、物理页面号</li>\n<li>有效位：表示该页在内存还是在磁盘</li>\n<li>访问位R：引用位，表示这个页被访问过</li>\n<li>修改位M：表示该页在内存中是否被修改过</li>\n<li>保护位：读 / 可读写</li>\n</ul>\n<p>通常页表项是硬件设计的</p>\n<p>页表在内存不应该连续存放，因此需要引入页表页的地址索引表：页目录 page directory</p>\n<p>二级页表：</p>\n<ul>\n<li>虚拟地址： 页目录偏移+页表偏移+页内偏移</li>\n<li>可以表示4G的虚拟地址</li>\n<li>从页目录地址寄存器得到页目录首地址，加上页目录偏移得到页表首地址，加上页表偏移得到在第i个页表的页框号，页框号+页内偏移得到物理地址</li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/virtualpage.png\" alt=\"虚存页表\"></li>\n</ul>\n<p>反转页表（倒排页表）：</p>\n<ul>\n<li>每个进程一张页表过于庞大</li>\n<li>从物理地址空间出发，系统建立一张页表</li>\n<li>页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系</li>\n<li>解决从虚拟地址到物理地址的映射：虚拟地址页号部分映射到散列值，散列值指向一个反转页表</li>\n</ul>\n<h4 id=\"地址转换过程和TLB引入\"><a href=\"#地址转换过程和TLB引入\" class=\"headerlink\" title=\"地址转换过程和TLB引入\"></a>地址转换过程和TLB引入</h4><p>虚拟地址到物理地址映射： MMU 内存管理单元</p>\n<p>快表 TLB translation look-aside buffers的引入：</p>\n<ul>\n<li>原因：<ul>\n<li>页表需要进行多次内存访问</li>\n<li>CPU指令处理速度和内存指令访问速度差异大</li>\n</ul>\n</li>\n<li>程序访问的局部性原理</li>\n<li>CPU中引入的高速缓存（cache），随机存取型存储器组成</li>\n<li>有特殊的接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较</li>\n<li>相联存储器 associative memory：特点：按内容并行查找</li>\n<li>保存正在运行进程的页表的子集</li>\n</ul>\n<p>页错误：page fault</p>\n<ul>\n<li>地址转换过程中硬件产生的异常</li>\n<li>具体原因：<ul>\n<li>缺页异常：所访问的虚拟页面没调入物理内存</li>\n<li>违反权限：读/写、用户/内核</li>\n<li>错误的访问地址</li>\n</ul>\n</li>\n<li>处理缺页异常：<ul>\n<li>地址映射过程中，硬件检查页表发现所要页面不在内存</li>\n<li>操作系统执行缺页异常处理程序：获得磁盘地址、启动磁盘、将该页调入内存：<ul>\n<li>内存中有空闲页框，修改页表中相应页表项的有效位和页框号</li>\n<li>内存中没有空闲页框，置换某一页，若该页修改过，还需要写回磁盘</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"软件相关策略\"><a href=\"#软件相关策略\" class=\"headerlink\" title=\"软件相关策略\"></a>软件相关策略</h4><p>驻留集：</p>\n<ul>\n<li>操作系统给每个进程分配页框数目</li>\n<li>策略：<ul>\n<li>固定分配策略：<ul>\n<li>进程创建时确定</li>\n<li>可以根据进程类型或程序员或系统管理员需要确定</li>\n</ul>\n</li>\n<li>可变分配策略：<ul>\n<li>根据缺页率评估进程局部性表现</li>\n<li>带来额外系统开销</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>页框锁定：</p>\n<ul>\n<li>为什么要锁定页面：虚存技术使得进程运行时间不确定</li>\n<li>给每一页框增加一个锁定位</li>\n<li>不让操作系统将进程换出内存</li>\n<li>如：操作系统核心代码，关键数据结构，IO缓冲区</li>\n</ul>\n<p>置换问题：</p>\n<ul>\n<li>置换范围：<ul>\n<li>置换集合是局限于产生缺页中断的进程，还是所有进程的页框</li>\n<li>策略：<ul>\n<li>局部置换：只在产生本次缺页的进程的驻留集中选择</li>\n<li>全局置换：将内存中所有未锁定的页框都作为置换的候选</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>置换策略：<ul>\n<li>选择换出哪个页框</li>\n<li>目标：置换最近最不可能访问的页</li>\n<li>局部性原理：基于过去行为来预测将来行为</li>\n<li>但策略设置越复杂，实现时软硬件开销越大</li>\n<li>约束：不能置换锁定的页框</li>\n</ul>\n</li>\n</ul>\n<p>清除策略：</p>\n<ul>\n<li>清除：从进程驻留集中集中回收页框（进程运行过程中回收）</li>\n<li>需要在系统中保持一定数目空闲页框，使得系统在最佳状态工作</li>\n<li>分页守护进程 paging daemon：<ul>\n<li>大部分时间睡眠，定期唤醒检查内存状态</li>\n<li>若空闲页框数过少，该进程通过页面置换算法换出内存</li>\n<li>若页面被修改过，则写回磁盘，以保证所有空闲页框是干净的</li>\n</ul>\n</li>\n<li>页缓冲技术：<ul>\n<li>不丢弃置换出的页，放入两个表之一：空闲链表和修改链表</li>\n<li>修改链表定期写回磁盘</li>\n<li>被置换的页仍在内存，一旦进程又要访问，则可以迅速将它加入进程的驻留集合</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"置换算法-replacement\"><a href=\"#置换算法-replacement\" class=\"headerlink\" title=\"置换算法 replacement\"></a>置换算法 replacement</h4><p>颠簸 thrashing：页面在内存和磁盘间调度的事件多于实际运行的时间</p>\n<p>影响缺页次数的因素：</p>\n<ul>\n<li>置换算法</li>\n<li>页面大小：<ul>\n<li>内部碎片</li>\n<li>页表长度</li>\n<li>辅存的物理特性</li>\n</ul>\n</li>\n<li>程序编制问题</li>\n<li>分配给进程的页框数目</li>\n</ul>\n<p>最佳页面置换算法 OPT：</p>\n<ul>\n<li>置换以后不再需要或最远的将来才会用到的页面</li>\n<li>无法实现</li>\n<li>作用：作为一种标准来衡量其他算法性能</li>\n</ul>\n<p>先进先出 FIFO：</p>\n<ul>\n<li>选择在内存中驻留时间最长的页并置换</li>\n<li>实现：页面链表法</li>\n</ul>\n<p>第二次机会算法 SCR second chance：</p>\n<ul>\n<li>按先进先出选择页面，检查其访问位R，若为0，则置换，若为1，则给第二次机会并把R置位0</li>\n</ul>\n<p>时钟算法 CLOCK：</p>\n<ul>\n<li>SCR的改进，把链表改成环，用指针指向当前要置换的页</li>\n</ul>\n<p>最近未使用算法 NRU：</p>\n<ul>\n<li>最近未使用的一页</li>\n<li>实现：根据页表项的两位：访问位R，修改位M（若硬件没有这两位，则用软件模拟）</li>\n<li>R位定期清零</li>\n<li>优先级：<ul>\n<li>1 最低：R=0，M=0，无使用，未修改</li>\n<li>2： R=0，M=1</li>\n<li>3： R=1，M=0</li>\n<li>4： R=1，M=1</li>\n</ul>\n</li>\n<li>时钟算法实现：<ul>\n<li>环状链表，选中遇到第一个R=0，M=0,用于置换</li>\n<li>若没有，则扫描第一个 R=0，M=1，对每个跳过的页框，把R置为0</li>\n<li>若仍没有，重新扫描R=0，M=0</li>\n<li>若仍没有，则扫描 R=0，M=1</li>\n</ul>\n</li>\n</ul>\n<p>最近最少使用 LRU：</p>\n<ul>\n<li>置换未使用时间最长的一页</li>\n<li>性能最接近 OPT 最佳算法，使用最多</li>\n<li>实现： 开销大，需要维护时间戳或访问页的栈</li>\n</ul>\n<p>最不经常使用 NFU：</p>\n<ul>\n<li>LRU的一种软件解决方案（自说）</li>\n<li>选择访问次数最少的页面置换</li>\n<li>实现：<ul>\n<li>软件计数器，每一个页一个，初值为0</li>\n<li>每次事件中断，计数器加该页的R</li>\n<li>缺页中断时，选择计数器最小的置换</li>\n</ul>\n</li>\n</ul>\n<p>老化算法 AGING：</p>\n<ul>\n<li>对NFU的改进（模拟LRU）：</li>\n<li>计数器在加R前先右移一位（除以2），R加到计数器最左端</li>\n</ul>\n<p>BELADY现象：</p>\n<ul>\n<li>页框数目多，缺页次数反而多</li>\n</ul>\n<p>工作集working set 算法：</p>\n<ul>\n<li>程序局部性： 活跃页面：进程一段时间中集中访问的页面</li>\n<li>为进程提供和活跃页面数相等的物理页面数，则可以减少中断次数</li>\n<li>工作集：当前正在使用的页框集合， W(t, delta)=该进程在时刻 t 过去 delta 事件单位中访问的页面的集合</li>\n<li>核心思想：找出一个不在工作集的页面并置换它</li>\n<li>思路：<ul>\n<li>每个页表项记录该页面最后一次被访问的时间</li>\n<li>设置时间T</li>\n<li>判断：根据一个页面访问时间在 当前时间-T 之前或之中决定其在工作集之内还是之外</li>\n</ul>\n</li>\n<li>实现：扫描所有页表项：<ul>\n<li>若 R=1，则把其最后一次访问时间设置为当前时间，R清零</li>\n<li>R=0，则检查访问时间是否在 当前时间-T 之前（不在工作集）<ul>\n<li>若是，则置换</li>\n<li>若不是，则记录最后访问时间的最小值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/replacement.png\" alt=\"置换算法\"></p>\n<h4 id=\"其他技术\"><a href=\"#其他技术\" class=\"headerlink\" title=\"其他技术\"></a>其他技术</h4><p>内存映射文件：</p>\n<ul>\n<li>进程通过系统调用 mmap 将文件或部分 映射到虚拟地址空间的一部分，访问该文件就像访问内存中的大数组，而不是对文件进行读写</li>\n<li>不会实际读入页面，在访问页面时才会被读入内存</li>\n<li>进程退出或显示解除文件映射时，修改写回磁盘</li>\n</ul>\n<p>写时复制技术：</p>\n<ul>\n<li>多个进程共享页面，页标志为写时复制</li>\n<li>进程试图改变页面数据时，操作系统复制一个页面，对执行写操作的进程是私有的</li>\n</ul>\n<h3 id=\"文件系统（1）\"><a href=\"#文件系统（1）\" class=\"headerlink\" title=\"文件系统（1）\"></a>文件系统（1）</h3><p>重点：</p>\n<ul>\n<li>文件系统相关概念：文件、文件分类、文件逻辑结构和物理结构</li>\n<li>文件目录的实现：文件控制块FCB、目录项、目录文件</li>\n<li>文件系统的实现：磁盘布局、内存树结构</li>\n<li>磁盘空间的管理：存储介质、扇区、物理块block、簇cluster</li>\n</ul>\n<p>教材：</p>\n<ul>\n<li>第四章：4.1、 4.2、 4.3、 4.5.3</li>\n</ul>\n<h4 id=\"文件与文件系统\"><a href=\"#文件与文件系统\" class=\"headerlink\" title=\"文件与文件系统\"></a>文件与文件系统</h4><p>文件 是 对磁盘的抽象</p>\n<p>文件：一组带标识的、在逻辑上有完整意义的信息项的序列</p>\n<p>信息项：构成文件内容的基本单位（单个字节或多个字节），各信息项之间有顺序关系</p>\n<p>文件内容的意义：由文件建立者和使用者解释</p>\n<p>文件系统：操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供共享和保护手段：</p>\n<ul>\n<li>统一管理磁盘空间，实施磁盘空间分配和回收</li>\n<li>实现文件按名存取（名字空间 -&gt; 映射 -&gt; 磁盘空间）</li>\n<li>实现文件信息的共享</li>\n<li>向用户提供方便使用和维护的接口</li>\n<li>提高文件系统性能</li>\n<li>提供与IO系统的统一接口</li>\n</ul>\n<p>文件分类：（UNIX）：按文件性质和用途</p>\n<ul>\n<li>普通文件</li>\n<li>目录文件</li>\n<li>特殊文件（设备文件）：设备作为文件处理，分为字符设备或块设备</li>\n<li>管道文件</li>\n<li>套接字</li>\n</ul>\n<p>文件的逻辑结构：</p>\n<ul>\n<li>由用户的访问方式决定</li>\n<li>典型文件逻辑结构：<ul>\n<li>流式文件：文件是有逻辑意义、无结构的一串字符的集合</li>\n<li>记录式文件：文件由若干记录组成，可以按记录读写查找等</li>\n</ul>\n</li>\n<li>文件存取：<ul>\n<li>顺序存取（访问）</li>\n<li>随机存取（访问）：提供读写位置</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件的存储介质\"><a href=\"#文件的存储介质\" class=\"headerlink\" title=\"文件的存储介质\"></a>文件的存储介质</h4><p>典型存储介质：磁盘、磁带、光盘、U盘</p>\n<p>物理块：</p>\n<ul>\n<li>信息存储、传输、分配的独立单位</li>\n<li>存储设备划分为大小相等的物理块，统一编号</li>\n</ul>\n<p>典型磁盘结构：</p>\n<ul>\n<li>任何时刻只有一个磁头处于活动状态：输入输出数据流以位串形式出现</li>\n<li>物理地址形式：磁头号、磁道号、扇区号</li>\n</ul>\n<p>磁盘访问：</p>\n<ul>\n<li>寻道：磁头移动到指定磁道</li>\n<li>旋转延迟：等待指定扇区</li>\n<li>数据传输：数据在磁盘和内存之间实际传输</li>\n</ul>\n<p>磁盘空间管理：</p>\n<ul>\n<li>数据结构：<ul>\n<li>位图：用二进制位反应块的分配情况，0为已经分配，1为空闲</li>\n<li>空闲块表：所有空闲块记录在一张表</li>\n<li>空闲块链表：<strong>成组链接法</strong></li>\n<li><img src=\"http://ot1c7ttzm.bkt.clouddn.com/grouplink.png\" alt=\"成组链接法\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件属性\"><a href=\"#文件属性\" class=\"headerlink\" title=\"文件属性\"></a>文件属性</h4><p>文件控制块 file control block：为了管理文件而设置的数据结构，保存所需要等待有关信息</p>\n<p>文件目录：</p>\n<ul>\n<li>统一管理每个文件的元数据，以支持文件名到文件物理地址的转换</li>\n<li>将所有文件的管理信息组织在一起</li>\n</ul>\n<p>目录文件：文件目录以文件的形式存放在磁盘上</p>\n<p>目录项：</p>\n<ul>\n<li>构成文件目录的基本单元</li>\n<li>目录项可以是FCB，目录是文件控制块的有序集合</li>\n</ul>\n<h4 id=\"文件的物理结构\"><a href=\"#文件的物理结构\" class=\"headerlink\" title=\"文件的物理结构\"></a>文件的物理结构</h4><p>文件在存储介质的存放方式</p>\n<p>结构：</p>\n<ul>\n<li>连续（顺序）结构：<ul>\n<li>文件的信息在若干连续的物理块中</li>\n<li>优点：<ul>\n<li>简单</li>\n<li>支持顺序存取、随机存取</li>\n<li>需要的磁盘寻道次数和寻道时间最少</li>\n<li>可以同时读入多个块，检索一个块也容易</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>文件不能动态增长</li>\n<li>不利于文件插入和删除</li>\n<li>会产生外部碎片：紧缩技术</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链接结构：<ul>\n<li>一个文件的信息存放在若干不连续物理块中，各块用指针相连，前一个物理块指向下一个物理块</li>\n<li>优点：<ul>\n<li>提高磁盘空间利用率，不存在外部碎片问题</li>\n<li>利于文件插入、删除</li>\n<li>利于文件动态扩充</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>存取速度慢，不利于随机存取</li>\n<li>可靠性问题，如指针出错</li>\n<li>更多寻道时间和寻道次数</li>\n<li>链接指针占用空间</li>\n</ul>\n</li>\n<li>变形：文件分配表 FAT：记录每个物理块的下一块的索引</li>\n</ul>\n</li>\n<li>索引结构：<ul>\n<li>信息存放在若干不连续的物理块中</li>\n<li>系统为每个文件建立一个索引表，块号放在索引表</li>\n<li>索引表就是磁盘块地址数组</li>\n<li>FCB放索引表的起始地址</li>\n<li>优点：<ul>\n<li>保持链接结构优点，又解决其缺点：<ul>\n<li>能顺序和随机存取</li>\n<li>满足文件动态增长、插入删除要求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>寻道次数和寻道时间多</li>\n<li>索引表需要额外空间</li>\n</ul>\n</li>\n<li>组织方式：<ul>\n<li>当索引表很大，需要多个物理块存放时：<ul>\n<li>链接方式：一个盘块存一个表</li>\n<li>多级索引</li>\n<li>综合索引：直接索引加间接索引：部分直接索引，指向一个物理块，一部分间接寻址，指向索引表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>UNIX 三级索引结构（综合模式）：<ul>\n<li>每个文件主索引表放FCB中，有15项，每项2字节</li>\n<li>前12个直接寻址</li>\n<li>第13项指向一级索引表</li>\n<li>第14项作为二级索引表</li>\n<li>第15项作为三级索引表</li>\n<li>最大总文件大小 = 12 + 256 + 256*256 + 256^3 个block</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件系统的实现\"><a href=\"#文件系统的实现\" class=\"headerlink\" title=\"文件系统的实现\"></a>文件系统的实现</h4><p>需要考虑： 磁盘上 和 内存中 内容布局</p>\n<p>磁盘分区 partition：把一个物理磁盘存储空间划分为几个相互独立部分</p>\n<p>文件卷 volume：磁盘上的逻辑分区，由一个或多个物理块组成：</p>\n<ul>\n<li>一个文件卷可以使一个盘或部分盘或跨盘 RAID</li>\n<li>同一个文件卷使用同一份管理数据</li>\n<li>文件卷上：文件系统信息、一组文件（用户文件+目录文件）、未分配空间</li>\n<li>块 block 或 簇cluster：</li>\n</ul>\n<p>格式化 format：在一个文件卷上建立文件系统，建立并初始化元数据</p>\n<p>UNIX：</p>\n<ul>\n<li>FCB = 目录项 + i节点</li>\n<li>目录项 = 文件名+i节点号</li>\n<li>i节点 = 保存描述文件的相关信息</li>\n</ul>\n<h3 id=\"文件系统（2）\"><a href=\"#文件系统（2）\" class=\"headerlink\" title=\"文件系统（2）\"></a>文件系统（2）</h3><p>重点：</p>\n<ul>\n<li>文件操作的实现流程</li>\n<li>文件系统的可靠性、一致性、写入策略、安全性</li>\n<li>提高文件系统性能</li>\n<li>FAT文件系统的实现</li>\n</ul>\n<h4 id=\"文件操作的实现\"><a href=\"#文件操作的实现\" class=\"headerlink\" title=\"文件操作的实现\"></a>文件操作的实现</h4><p>创建文件：</p>\n<ul>\n<li>建立系统和文件的联系，实质是建立文件的FCB</li>\n<li>在目录中为新文件建立一个目录项，填写参数</li>\n<li>分配必要的存储空间</li>\n<li>流程：<ol>\n<li>检查参数合法性（命名规则、重名文件等）</li>\n<li>申请空闲目录项，填写相关信息</li>\n<li>为文件申请磁盘块</li>\n</ol>\n</li>\n</ul>\n<p>打开文件：</p>\n<ul>\n<li>根据文件名在文件目录中检索，找到目录项或FCB</li>\n<li>将目录项读入内存，建立相应的数据结构（文件描述符或文件句柄），为后续操作做好准备</li>\n<li>流程：<ol>\n<li>给出路径名查目录，找到目录项或i节点号</li>\n<li>根据文件号查系统打开文件表<ol>\n<li>是 则共享计数加1</li>\n<li>否 将信息填入系统打开文件表，共享计数为1</li>\n</ol>\n</li>\n<li>根据打开方式、共享说明和用户身份检查访问合法性</li>\n<li>在用户打开文件表获取一个空表项，填写参数，返回文件句柄</li>\n</ol>\n</li>\n<li>指针定位：<ul>\n<li>每个进程打开的每个文件维护一个读写指针</li>\n<li>在用户打开文件表中</li>\n</ul>\n</li>\n</ul>\n<p>读文件：</p>\n<ol>\n<li>根据打开文件时的文件描述符，找到FCB，确定操作合法性</li>\n<li>把文件的逻辑块号转换成物理块号</li>\n<li>申请缓冲区</li>\n<li>启动磁盘IO操作，把磁盘块内容送到缓冲区，而后送到内存</li>\n</ol>\n<h4 id=\"文件系统的管理\"><a href=\"#文件系统的管理\" class=\"headerlink\" title=\"文件系统的管理\"></a>文件系统的管理</h4><p>可靠性：</p>\n<ul>\n<li>抵御和预防各种物理性破坏和人为性破坏的能力</li>\n<li>坏块问题</li>\n<li>备份：通过转储操作，形成文件或文件系统的多个副本</li>\n</ul>\n<p>转储：</p>\n<ul>\n<li>全量转储：定期拷贝所有文件</li>\n<li>增量转储：只转储修改过的文件，两次备份之间的修改</li>\n<li>物理转储：从磁盘第0块开始，将所有磁盘块按序输出到磁带</li>\n<li>逻辑转储：从指定目录开始，递归转储给定日期后所有更改的文件或目录</li>\n</ul>\n<p>文件系统一致性：</p>\n<ul>\n<li>问题的产生：磁盘块 -&gt; 内存 -&gt; 写回磁盘块，若在写回之前系统崩溃，则文件系统不一致（FCB、目录文件已经更新）</li>\n<li>解决方案：设计程序，当系统再次启动时检查磁盘块和目录系统</li>\n<li>磁盘块的一致性检查：<ul>\n<li>用两张表，每个表项对应一个磁盘块，第一张表记录每个块在文件中出现的次数，第二张表记录在空闲块表中出现的次数</li>\n<li>情况1： 使用块和空闲块相反：正常</li>\n<li>情况2： 使用块和空闲块均为0：把空闲块置1</li>\n<li>情况3： 使用块和空闲块均为1：空闲块置0</li>\n<li>情况4： 使用块为2，空闲为0： 在空闲中寻找一个把多出的文件写入</li>\n</ul>\n</li>\n</ul>\n<p>写入策略：</p>\n<ul>\n<li>write-through：直写：内存中修改立刻返回磁盘：FAT</li>\n<li>lazy-write：延迟写：利用回写write back缓存的方法增加速度</li>\n<li>transaction log：可恢复写：利用事务日志实现文件系统写入 ： NTFS，EXT3</li>\n</ul>\n<p>访问控制：</p>\n<ol>\n<li>主动控制：访问控制表：<ul>\n<li>每个文件一张表</li>\n<li>记录用户id和访问权限</li>\n<li>用户可以是一组用户</li>\n<li>文件可以是一组文件</li>\n</ul>\n</li>\n<li>能力表（权限表）<ul>\n<li>每个用户一个</li>\n<li>记录文件名及访问权限</li>\n<li>用户可以是一组用户</li>\n<li>文件可以是一组文件</li>\n</ul>\n</li>\n</ol>\n<p>UNIX文件访问控制：</p>\n<ul>\n<li>采用文件二级存取控制</li>\n<li>第一级：对访问者的识别：<ul>\n<li>对用户分类：<ul>\n<li>文件主</li>\n<li>文件主的同组用户</li>\n<li>其他用户</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第二级：对操作权限的识别：<ul>\n<li>对操作分类：<ul>\n<li>读 r</li>\n<li>写 w</li>\n<li>执行 x</li>\n<li>不能执行任何操作 -</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"文件系统的性能\"><a href=\"#文件系统的性能\" class=\"headerlink\" title=\"文件系统的性能\"></a>文件系统的性能</h4><p>设计文件系统应该尽可能减少磁盘访问次数</p>\n<p>方法：</p>\n<ul>\n<li>目录项FCB分解、当前目录、磁盘碎片整理</li>\n<li>块高速缓存 block cache：<ul>\n<li>在内存中为磁盘块设置一个缓冲区，保存磁盘某些块的副本</li>\n<li>检查所有读请求，看是否在块高速缓存中<ul>\n<li>若在，则直接读</li>\n<li>若不再，先将块拷入块高速缓存，再拷入所需地方</li>\n</ul>\n</li>\n<li>组织：用hash</li>\n<li>置换：LRU</li>\n<li>写入策略（文件系统一致性）：定期写回磁盘</li>\n</ul>\n</li>\n<li>合理分配磁盘空间：<ul>\n<li>分配磁盘块时，有可能顺序存取的块放在一起</li>\n<li>尽可能分配在同一柱面上，从而减少磁盘臂移动次数和距离</li>\n</ul>\n</li>\n<li>磁盘调度：<ul>\n<li>有多个访盘请求时，采用一定策略调整顺序</li>\n<li>降低平均磁盘服务时间</li>\n<li>调度算法：<ul>\n<li>先来先服务 FCFS</li>\n<li>最短寻道时间优先：优先选择离当前磁头最近的访问请求<ul>\n<li>优点：改善平均服务请求</li>\n<li>缺点：饥饿现象</li>\n</ul>\n</li>\n<li>扫描算法 SCAN （电梯算法）：按一个方向移动，若该方向没有请求，则改变方向</li>\n<li>单向扫描算法 C-SCAN：SCAN的改进：总从0号柱面向里扫描，到达最后一个柱面时，立即返回0号，返回时不服务，返回后再次扫描</li>\n<li>N-step-SCAN策略：磁盘请求划分为长度为N的子队列，每一次用SCAN处理一个子队列</li>\n<li>FSCAN策略：使用两个子队列，开始时请求在一个队列，扫描时请求加入另一个队列</li>\n<li>旋转调度：根据延迟时间决定执行次序的调度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>信息的优化分布：<ul>\n<li>记录在磁盘的排列方式</li>\n</ul>\n</li>\n<li>记录的成组与分解：<ul>\n<li>若干逻辑记录合成一组存放</li>\n<li>成组操作必须用内存缓冲区，缓存区长度 = 记录长度 * 块因子</li>\n<li>目的：提高空间利用率和工作效率</li>\n</ul>\n</li>\n<li>RAID 独立磁盘冗余阵列 技术：<ul>\n<li>多块磁盘按一定要求构成一个独立存储设备</li>\n<li>目标：提高可靠性和性能</li>\n<li>组织：<ul>\n<li>多个磁盘组织，作为一个逻辑卷</li>\n<li>数据分成多个数据块，并行写入、读出多个磁盘</li>\n<li>通过镜像或校验，提供容错能力（冗余）</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>RAID 0-条带化，数据分布在所有磁盘上，无冗余，性能最佳</li>\n<li>RAID 1 - 镜像：利用率 50%，所有数据同时保存在两块盘相同位置，安全性最好</li>\n<li>RAID 4 -交错块奇偶校验：带奇偶校验，以数据块为单位 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Windows的文件访问方式：</p>\n<ul>\n<li>不使用文件缓存</li>\n<li>使用文件缓存：<ul>\n<li>Windows的cache manager实现对缓存的控制：<ul>\n<li>读取数据时预取</li>\n<li>在cache满时，根据LRU清除缓存内容</li>\n<li>定期更新磁盘内容使其与cache一致</li>\n</ul>\n</li>\n<li>write-back机制：只更改cache内容，由cache manager定期写回</li>\n</ul>\n</li>\n<li>异步模式：<ul>\n<li>不等待磁盘操作的完成</li>\n<li>使CPU和IO并发工作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IO系统\"><a href=\"#IO系统\" class=\"headerlink\" title=\"IO系统\"></a>IO系统</h3><p>重点：</p>\n<ul>\n<li>IO系统的概念：<ul>\n<li>IO设备的特点及分类</li>\n<li>IO管理的任务</li>\n</ul>\n</li>\n<li>IO管理的解决方案<ul>\n<li>IO硬件组成</li>\n<li>IO控制方式</li>\n<li>IO软件层次及功能</li>\n</ul>\n</li>\n<li>IO相关技术</li>\n<li>IO性能提高的解决方案</li>\n</ul>\n<p>教材：第五章：5.1、 5.2、 5.4</p>\n<h4 id=\"IO管理概述\"><a href=\"#IO管理概述\" class=\"headerlink\" title=\"IO管理概述\"></a>IO管理概述</h4><p>IO设备管理：</p>\n<ul>\n<li>逻辑IO：统一的操作，与具体设备无关</li>\n<li>设备驱动程序</li>\n<li>中断服务程序</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/IO.png\" alt=\"IO\"></p>\n<p>IO的特点：</p>\n<ul>\n<li>IO性能经常成为系统性能的瓶颈</li>\n<li>操作系统庞大复杂的原因之一：IO资源多而杂，并发<ul>\n<li>速度差异大</li>\n<li>应用</li>\n<li>控制接口的复杂性</li>\n<li>传送单位</li>\n<li>数据表示</li>\n<li>错误条件</li>\n</ul>\n</li>\n<li>与其他功能密切相关，尤其是文件系统</li>\n</ul>\n<p>设备分类：</p>\n<ul>\n<li>按数据组织分：<ul>\n<li>块设备：<ul>\n<li>以数据块为单位</li>\n<li>传输速度块，可寻址</li>\n</ul>\n</li>\n<li>字符设备：<ul>\n<li>以字符为单位</li>\n<li>速率低、不可寻址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从资源分配角度：<ul>\n<li>独占设备：一段时间只能有一个进程使用，一般低速，如打印机</li>\n<li>共享设备：一段时间可有多个进程共同使用，以交叉方式使用</li>\n<li>虚设备：<ul>\n<li>在一类设备上模拟另一类，常用 共享模拟独占、高速模拟低速</li>\n<li>实例：SPOOLing技术，用硬盘模拟输入输出</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>目标：</p>\n<ul>\n<li>按用户请求，控制设备的各种操作，完成设备和内存的数据交换<ul>\n<li>设备的分配和回收<ul>\n<li>记录设备的状态</li>\n<li>根据用户请求和设备类型，采用一定分配算法，选择设备到内存的数据通路</li>\n</ul>\n</li>\n<li>执行设备驱动程序</li>\n<li>设备中断处理</li>\n<li>缓冲区管理：管理IO缓冲区</li>\n</ul>\n</li>\n<li>建立方便统一的独立于设备的接口：通用性<ul>\n<li>方便性：用户编程时不考虑设备的物理特性</li>\n<li>统一性：用户程序使用的是逻辑设备，以屏蔽硬件细节</li>\n</ul>\n</li>\n<li>利用各种技术提高CPU与设备、设备之间的并行工作能力，充分利用资源<ul>\n<li>并行性</li>\n<li>均衡性</li>\n</ul>\n</li>\n<li>​</li>\n</ul>\n<h4 id=\"IO设备组成\"><a href=\"#IO设备组成\" class=\"headerlink\" title=\"IO设备组成\"></a>IO设备组成</h4><p>一般由机械和电子部分组成：</p>\n<ul>\n<li>机械部分是设备本身（物理装置）</li>\n<li>电子部分又称设备控制器（适配器）<ul>\n<li>地址译码</li>\n<li>接受计算机发来或向计算机发送数据和状态信号</li>\n<li>把计算机数字信号转换成机械能识别的模拟信号，或反过来</li>\n<li>设备内部硬件缓冲或数据加工等提升性能</li>\n</ul>\n</li>\n</ul>\n<p>机械部分：设备接口——控制器：</p>\n<ul>\n<li>操作系统将命令写入控制器的接口寄存器，并从中读取状态信息或结果信息</li>\n<li>控制器接受命令后独立于CPU执行，命令完成后产生中断，操作系统通过读控制寄存器的信息获取操作结果和状态</li>\n<li>控制器和设备的接口通常是低级借口</li>\n<li>控制器的任务：串行位流转换成字节块，并进行必要的错误修正</li>\n</ul>\n<p>IO端口地址：</p>\n<ul>\n<li>每个寄存器都有的唯一的地址</li>\n<li>所有端口地址形成IO端口空间</li>\n<li>IO指令形式和IO地址关联：<ul>\n<li>内存映像编址（内存映像IO模式）：内存一部分用作IO端口<ul>\n<li>把IO端口看作一个存储单元</li>\n<li>优点：<ul>\n<li>凡是可对内存的操作均可对IO操作</li>\n<li>不需要专门IO指令</li>\n<li>IO端口空间大</li>\n<li>不需要专门机制阻止用户操作IO</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>占用内存空间</li>\n<li>不能对控制寄存器进行高速缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IO独立编址（IO专用指令）：IO空间独立于内存<ul>\n<li>使用专门的IO指令对端口操作</li>\n<li>优点：<ul>\n<li>外设不占内存</li>\n<li>编程时可以区分对内存还是对IO</li>\n</ul>\n</li>\n<li>缺点：IO操作指令类型少，操作不灵活</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>IO控制方式：</p>\n<ol>\n<li>可编程IO（轮询、查询）<ul>\n<li>CPU不断询问IO模块</li>\n<li>设置控制寄存器后不断查询状态寄存器，完成后把数据寄存器中数据读取</li>\n</ul>\n</li>\n<li>中断驱动IO<ul>\n<li>IO结束后，由设备控制器主动通知设备驱动程序</li>\n</ul>\n</li>\n<li>DMA<ul>\n<li>直接内存存取</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"IO软件组成\"><a href=\"#IO软件组成\" class=\"headerlink\" title=\"IO软件组成\"></a>IO软件组成</h4><p>设计思想：</p>\n<ul>\n<li>IO软件组织成多层次</li>\n<li>每层执行所需要功能的子集，依赖于低一层实现的功能</li>\n<li>低层考虑硬件特性，向高层提供接口</li>\n<li>高层不考虑硬件细节，提供良好接口</li>\n</ul>\n<p>软件层次：</p>\n<ul>\n<li>用户级IO</li>\n<li>与设备无关的OS软件：<ul>\n<li>驱动程序统一接口</li>\n<li>缓存</li>\n<li>错误报告</li>\n<li>分配与释放设备</li>\n<li>提供与设备无关的尺寸大小</li>\n</ul>\n</li>\n<li>设备驱动程序</li>\n<li>中断处理程序</li>\n</ul>\n<p>设备无关性：用户程序可以访问任意IO设备，无需事先指定设备</p>\n<ul>\n<li>好处：易实现IO重定向，设备分配灵活</li>\n</ul>\n<h4 id=\"IO相关技术\"><a href=\"#IO相关技术\" class=\"headerlink\" title=\"IO相关技术\"></a>IO相关技术</h4><p>缓冲技术：</p>\n<ul>\n<li>凡是数据到达和离去速度不匹配的地方均可用缓冲技术</li>\n<li>实现：<ul>\n<li>硬缓冲：由硬件寄存器实现</li>\n<li>软缓存：内存中开辟空间作缓冲区</li>\n</ul>\n</li>\n<li>缓冲区管理：<ul>\n<li>单缓冲</li>\n<li>双缓冲</li>\n<li>缓冲池（多缓存）：统一管理多个缓冲区，缓冲区循环使用</li>\n</ul>\n</li>\n<li>UNIX缓冲技术：<ul>\n<li>结合提前读和延迟写技术</li>\n<li>充分利用从磁盘读入，已传入用户区但仍在缓冲区的数据</li>\n<li>缓冲区组成：缓冲控制块+数据区</li>\n<li>空闲缓冲区对联 av链</li>\n<li>设备缓冲队列 b链：链接所有分配给设备使用的缓冲区，按散列方式组织</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"IO设备管理\"><a href=\"#IO设备管理\" class=\"headerlink\" title=\"IO设备管理\"></a>IO设备管理</h4><p>独占设备的分配：</p>\n<ul>\n<li>静态分配：<ul>\n<li>运行前完成设备分配，结束时收回设备</li>\n<li>缺点：利用率低</li>\n</ul>\n</li>\n<li>动态分配：<ul>\n<li>运行过程中，用户提出设备要求时进行分配，一旦停止使用立刻收回</li>\n<li>优点：效率高</li>\n<li>缺点：可能死锁</li>\n</ul>\n</li>\n</ul>\n<p>分时式共享设备：</p>\n<ul>\n<li>以一次IO为单位分时使用设备，不同IO请求排队使用</li>\n</ul>\n<p>设备驱动程序：</p>\n<ul>\n<li>每个设备驱动程序管理一类设备</li>\n<li>接收来自与设备无关的上层软件抽象请求，并执行请求</li>\n<li>每个控制器有一个或多个设备寄存器用于存命令和参数，设备驱动程序负责释放命令并监督执行</li>\n<li>与外界的接口：<ul>\n<li>与操作系统的接口</li>\n<li>与系统引导的接口</li>\n<li>与设备的接口</li>\n</ul>\n</li>\n<li>接口函数</li>\n<li>IO进程：专门处理系统IO请求与IO中断</li>\n</ul>\n<h4 id=\"IO性能问题\"><a href=\"#IO性能问题\" class=\"headerlink\" title=\"IO性能问题\"></a>IO性能问题</h4><p>核心：</p>\n<ul>\n<li>使CPU利用率尽可能不被IO降低</li>\n<li>使CPU尽可能摆脱IO</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>减少或缓解速度差距：缓冲技术</li>\n<li>使CPU不等待IO：异步IO：用其他操作填充IO操作间等待的CPU时间</li>\n<li>使CPU摆脱IO：DMA、通道</li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>重点：</p>\n<ul>\n<li>死锁的基本概念<ul>\n<li>死锁的四个必要条件</li>\n<li>死锁和活锁、饥饿的区别</li>\n</ul>\n</li>\n<li>死锁的解决方案：<ul>\n<li>死锁预防：资源的有序分配法</li>\n<li>死锁避免：银行家算法、安全/不安全状态</li>\n<li>死锁检测与解除</li>\n</ul>\n</li>\n<li>资源分配图和在解决死锁问题的应用</li>\n<li>哲学家就餐问题</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>死锁：</p>\n<ul>\n<li>一组进程中每个进程都无限等待被该组另一进程占用的资源</li>\n<li>参与死锁的所有进程都在等待资源</li>\n<li>参与死锁的进程是当前系统中所有进程的子集</li>\n</ul>\n<p>死锁的原因：</p>\n<ul>\n<li>资源数目有限、锁和信号量错误使用</li>\n<li>资源的使用方式： 申请 — 分配 — 使用 — 释放</li>\n<li>资源分类：<ul>\n<li>可重用资源：可被多个资源多次使用<ul>\n<li>可抢占资源：CPU</li>\n<li>不可抢占资源：打印机<ul>\n<li>可消耗资源：只使用一次、可创建和销毁的资源：如信号、中断、消息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>活锁和饥饿：</p>\n<ul>\n<li>活锁：得不到资源，但能够运行，既无进展也无阻塞</li>\n<li>饥饿：资源分配策略决定</li>\n</ul>\n<p>死锁的产生条件：</p>\n<ul>\n<li>互斥使用（资源独占）：一个资源一次一个进程使用</li>\n<li>占有且等待：在申请新资源的同时保持对原资源的占有</li>\n<li>不可抢占、不可剥夺：资源只能由占有者自愿释放</li>\n<li>循环等待</li>\n</ul>\n<h4 id=\"资源分配图\"><a href=\"#资源分配图\" class=\"headerlink\" title=\"资源分配图\"></a>资源分配图</h4><p>用有向图描述系统资源和进程的状态</p>\n<p>结点V：分为P 进程 ， R 资源</p>\n<p>有向边E：有向边的集合，资源 R 指向 进程 P （资源分配）或 进程P 指向资源R（申请资源）</p>\n<p>死锁定理：</p>\n<ul>\n<li>资源分配图中没有环路，则没有死锁</li>\n<li>图中存在环路，系统可能有死锁</li>\n<li>若每个资源类只有一个资源实例，则 环路存在  &lt;=&gt; 死锁存在</li>\n</ul>\n<h4 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h4><p>解决死锁的方法：</p>\n<ul>\n<li>鸵鸟算法：不考虑死锁问题</li>\n<li>不让死锁发生<ul>\n<li>死锁预防：静态策略：设计合适的资源分配算法</li>\n<li>死锁避免：动态策略：以不让死锁发生为目标，跟踪和评估资源分配过程，根据评估结果决策是否分配</li>\n</ul>\n</li>\n<li>死锁检测与解除</li>\n</ul>\n<p>死锁预防：</p>\n<ul>\n<li>防止产生死锁的四个必要条件之一</li>\n<li>破坏 互斥使用、资源独占 条件：<ul>\n<li>资源转换技术：把独占资源变为共享资源</li>\n</ul>\n</li>\n<li>破坏 占有且等待 条件：<ul>\n<li>方案1：每个进程运行前必须一次性申请所有资源，仅当进程需要的资源都可满足才一次性分配<ul>\n<li>资源利用率低，饥饿现象</li>\n</ul>\n</li>\n<li>方案2：申请新资源得不到满足而变为等待状态前，必须释放已经占有的所有资源</li>\n</ul>\n</li>\n<li>破坏 不可抢占 条件：<ul>\n<li>申请的资源被其他进程占用时，可通过操作系统抢占资源（进程优先级不同）<ul>\n<li>局限性：适用于状态易于保存和恢复的资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>破坏 循环等待 条件：<ul>\n<li>资源有序分配法：进程申请资源时必须按资源编号的递增次序进行，否则操作系统不予分配</li>\n</ul>\n</li>\n</ul>\n<p>死锁避免：</p>\n<ul>\n<li><p>对进程发出的资源申请进行动态检查，根据分配后是否会发送死锁或是否可能导致死锁决定是否分配资源</p>\n</li>\n<li><p>安全状态：系统中存在一个由所有进程构成的安全序列，对每个进程 Pi 以后所需要资源量不超过 （系统当前剩余资源+所有进程Pj( j&lt;i )当前所占有的资源）</p>\n</li>\n<li><p>安全状态一定不死锁，不安全状态一定导致死锁（哪怕当前未死锁）</p>\n</li>\n<li><p>银行家算法 banker’s algorithm：仿照银行发放贷款采取的控制方式</p>\n<ul>\n<li><p>应用条件：</p>\n<ul>\n<li>固定数目进程 共享 固定数目资源</li>\n<li>每个进程预先指定所需要的最大资源数</li>\n<li>进程不能申请大于系统可用资源总数的资源</li>\n<li>进程等待资源的时间有限</li>\n<li>系统满足进程的最大需求后，进程应在有限时间内尽快使用并归还</li>\n</ul>\n</li>\n<li><p>变量：</p>\n<ul>\n<li>n：进程数目</li>\n<li>m：资源类数目</li>\n<li>available   【1.m】系统每类资源剩余数目</li>\n<li>max  【1.n 1.m】每个进程对每类资源要求的最大数目</li>\n<li>allocation 【1.n 1.m】每个进程已经分配的每类资源数目</li>\n<li>need 【1.n 1.m】每个进程还需要的每类资源的数目</li>\n<li>request 【1.n 1.m】 这次每个进程申请的每类资源数目</li>\n</ul>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li><p>若 request[i] &lt;= need[i] 继续，否则报错</p>\n</li>\n<li><p>若 request[i] &lt;= available 继续，否则等待</p>\n</li>\n<li><p>假设系统分配了资源：</p>\n<p> available -= request[i]</p>\n<p> allocation[i] += request[i] </p>\n<p> need[i] -= request[i]</p>\n</li>\n<li><p>若系统新状态安全，则分配完成，若不安全，则恢复分配</p>\n</li>\n</ol>\n</li>\n<li><p>安全性检查：</p>\n<ol>\n<li>work = available，finish=false</li>\n<li>检查每个i 有 finish[i]==false &amp;&amp; need[i]&lt;=work</li>\n<li>而后 work += allocation[i];  finish[i]=true, 转2</li>\n<li>若对所有i都有 finish[i]==true 则系统安全</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"死锁检测与解除\"><a href=\"#死锁检测与解除\" class=\"headerlink\" title=\"死锁检测与解除\"></a>死锁检测与解除</h4><p>死锁检测：</p>\n<ul>\n<li>允许死锁发生，但操作系统不断监视系统，判断死锁是否发生</li>\n<li>一旦发生死锁则解除死锁并以最小代价恢复系统运行</li>\n<li>检测时机：<ul>\n<li>当进程由于资源请求不满足而等待时</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时</li>\n</ul>\n</li>\n</ul>\n<p>死锁解除：</p>\n<ol>\n<li>撤销所有死锁进程</li>\n<li>进程回退roll back ，再启动</li>\n<li>按某原则逐一撤销死锁进程</li>\n<li>按某种原则逐一抢占资源</li>\n</ol>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjleshqip0000ryfcqdew3xee","tag_id":"cjleshqj00002ryfc1ijco8nt","_id":"cjleshqjd000bryfcltbq4ji0"},{"post_id":"cjleshqip0000ryfcqdew3xee","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqje000dryfcrqvq41z1"},{"post_id":"cjleshqiv0001ryfcwfneaf1o","tag_id":"cjleshqj00002ryfc1ijco8nt","_id":"cjleshqjk000jryfcgvmduez3"},{"post_id":"cjleshqiv0001ryfcwfneaf1o","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqjl000lryfceoz3wp78"},{"post_id":"cjleshqj20003ryfcz6bhohfr","tag_id":"cjleshqji000hryfcrv3xyrw9","_id":"cjleshqjq000rryfcopl3aw46"},{"post_id":"cjleshqj20003ryfcz6bhohfr","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqjs000tryfcb63pch00"},{"post_id":"cjleshqj30004ryfcvv4cs901","tag_id":"cjleshqji000hryfcrv3xyrw9","_id":"cjleshqju000yryfc6htkmdzl"},{"post_id":"cjleshqj30004ryfcvv4cs901","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqjv000zryfcduy1vxvu"},{"post_id":"cjleshqj60005ryfcxqcr0yhg","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqjw0013ryfc7tplxru8"},{"post_id":"cjleshqj60005ryfcxqcr0yhg","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqjw0014ryfczekgy1zt"},{"post_id":"cjleshqj60005ryfcxqcr0yhg","tag_id":"cjleshqjv0011ryfc42r4gbb6","_id":"cjleshqjx0016ryfcmjm6ttkr"},{"post_id":"cjleshqj90007ryfctwgswupg","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqjx0018ryfcwlafxmup"},{"post_id":"cjleshqj90007ryfctwgswupg","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqjx0019ryfcrn3lm942"},{"post_id":"cjleshqj90007ryfctwgswupg","tag_id":"cjleshqjv0011ryfc42r4gbb6","_id":"cjleshqjy001bryfcw32pc7kr"},{"post_id":"cjleshqja0008ryfctetc3iop","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqjy001dryfcfe9zvgkc"},{"post_id":"cjleshqja0008ryfctetc3iop","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqjy001eryfcb91xob7h"},{"post_id":"cjleshqja0008ryfctetc3iop","tag_id":"cjleshqjv0011ryfc42r4gbb6","_id":"cjleshqjz001gryfcw59yogiv"},{"post_id":"cjleshqjc000aryfcyaedqfhp","tag_id":"cjleshqjy001cryfcptnshjo2","_id":"cjleshqjz001hryfc307g0iir"},{"post_id":"cjleshqje000cryfcmknuskzl","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqk0001kryfcpqq1gnkg"},{"post_id":"cjleshqje000cryfcmknuskzl","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqk0001lryfcwd9o58z7"},{"post_id":"cjleshqje000cryfcmknuskzl","tag_id":"cjleshqjv0011ryfc42r4gbb6","_id":"cjleshqk0001nryfceuyid5ha"},{"post_id":"cjleshqjf000fryfcohsjg34z","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqk1001pryfcoszvlm08"},{"post_id":"cjleshqjf000fryfcohsjg34z","tag_id":"cjleshqk0001mryfca6jhbnjr","_id":"cjleshqk2001qryfczpnehlov"},{"post_id":"cjleshqjh000gryfcd6zta3nr","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqk2001sryfcev95s0yb"},{"post_id":"cjleshqjh000gryfcd6zta3nr","tag_id":"cjleshqk1001oryfc2bj6yszh","_id":"cjleshqk2001tryfc1e6yftdk"},{"post_id":"cjleshqjj000iryfc6m81w0h2","tag_id":"cjleshqk2001rryfc7fqkcbdz","_id":"cjleshqk4001xryfckx7rafld"},{"post_id":"cjleshqjj000iryfc6m81w0h2","tag_id":"cjleshqk3001uryfcvoawciik","_id":"cjleshqk4001yryfcsrujwvtl"},{"post_id":"cjleshqjj000iryfc6m81w0h2","tag_id":"cjleshqk3001vryfclchj01g2","_id":"cjleshqk50020ryfc803l6gpa"},{"post_id":"cjleshqjk000kryfc1klv356h","tag_id":"cjleshqji000hryfcrv3xyrw9","_id":"cjleshqk50021ryfcmgza9r4y"},{"post_id":"cjleshqjk000kryfc1klv356h","tag_id":"cjleshqk4001wryfcixjh3s8j","_id":"cjleshqk60023ryfcck6w39d7"},{"post_id":"cjleshqjn000nryfcsixr9bce","tag_id":"cjleshqjm000mryfcf4zhlnr5","_id":"cjleshqk60025ryfchrqycdhh"},{"post_id":"cjleshqjn000nryfcsixr9bce","tag_id":"cjleshqjv0011ryfc42r4gbb6","_id":"cjleshqk60026ryfcjpc8ylcx"},{"post_id":"cjleshqjn000nryfcsixr9bce","tag_id":"cjleshqk0001mryfca6jhbnjr","_id":"cjleshqk70028ryfc57wmm4uv"},{"post_id":"cjleshqjo000oryfc1skdypvi","tag_id":"cjleshqk3001vryfclchj01g2","_id":"cjleshqk9002bryfcdcphtu7a"},{"post_id":"cjleshqjo000oryfc1skdypvi","tag_id":"cjleshqk2001rryfc7fqkcbdz","_id":"cjleshqk9002cryfcufssg9go"},{"post_id":"cjleshqjo000oryfc1skdypvi","tag_id":"cjleshqk70029ryfc3f0jkm6g","_id":"cjleshqk9002eryfcvrduh5qs"},{"post_id":"cjleshqjp000qryfc6spwjizi","tag_id":"cjleshqk2001rryfc7fqkcbdz","_id":"cjleshqka002gryfc712irr42"},{"post_id":"cjleshqjp000qryfc6spwjizi","tag_id":"cjleshqk3001vryfclchj01g2","_id":"cjleshqka002hryfcxw323i46"},{"post_id":"cjleshqjr000sryfcw60sajfr","tag_id":"cjleshqk2001rryfc7fqkcbdz","_id":"cjleshqkc002lryfclhnufvpw"},{"post_id":"cjleshqjr000sryfcw60sajfr","tag_id":"cjleshqka002iryfcu87k4j15","_id":"cjleshqkc002mryfcscw8e8u6"},{"post_id":"cjleshqjr000sryfcw60sajfr","tag_id":"cjleshqkb002jryfckmqs8jji","_id":"cjleshqkc002oryfcbju68a5x"},{"post_id":"cjleshqjs000vryfcbakvocg3","tag_id":"cjleshqkc002kryfckgnnnh8k","_id":"cjleshqkd002rryfcqkkrug80"},{"post_id":"cjleshqjs000vryfcbakvocg3","tag_id":"cjleshqkc002nryfclvpfk9no","_id":"cjleshqkd002sryfcd2hxximx"},{"post_id":"cjleshqjs000vryfcbakvocg3","tag_id":"cjleshqkd002pryfcvrmwazm3","_id":"cjleshqke002uryfchvungqkw"},{"post_id":"cjleshqjt000wryfca5rn4n9f","tag_id":"cjleshqk2001rryfc7fqkcbdz","_id":"cjleshqkf002vryfck2hcd2n2"},{"post_id":"cjleshqjt000wryfca5rn4n9f","tag_id":"cjleshqka002iryfcu87k4j15","_id":"cjleshqkf002wryfc6c0n4v6n"},{"post_id":"cjleshqkm002xryfcp9pcq7pq","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqkq0031ryfcqrdbaj04"},{"post_id":"cjleshqkm002xryfcp9pcq7pq","tag_id":"cjleshqkp002zryfcp6lj3kq7","_id":"cjleshqkq0032ryfcrnhu9f40"},{"post_id":"cjleshqko002yryfci3idgfia","tag_id":"cjleshqj80006ryfc2ql71clb","_id":"cjleshqkq0033ryfc4a8p27ae"},{"post_id":"cjleshqko002yryfci3idgfia","tag_id":"cjleshqkq0030ryfcx0c8lmr7","_id":"cjleshqkr0034ryfckf8kp7e9"}],"Tag":[{"name":"编译原理","_id":"cjleshqj00002ryfc1ijco8nt"},{"name":"学习笔记","_id":"cjleshqj80006ryfc2ql71clb"},{"name":"游戏","_id":"cjleshqji000hryfcrv3xyrw9"},{"name":"c++","_id":"cjleshqjm000mryfcf4zhlnr5"},{"name":"数据结构","_id":"cjleshqjv0011ryfc42r4gbb6"},{"name":"others","_id":"cjleshqjy001cryfcptnshjo2"},{"name":"刷题","_id":"cjleshqk0001mryfca6jhbnjr"},{"name":"JAVA","_id":"cjleshqk1001oryfc2bj6yszh"},{"name":"NLP","_id":"cjleshqk2001rryfc7fqkcbdz"},{"name":"阅读理解","_id":"cjleshqk3001uryfcvoawciik"},{"name":"机器学习","_id":"cjleshqk3001vryfclchj01g2"},{"name":"算法","_id":"cjleshqk4001wryfcixjh3s8j"},{"name":"VSM","_id":"cjleshqk70029ryfc3f0jkm6g"},{"name":"文本纠错","_id":"cjleshqka002iryfcu87k4j15"},{"name":"tensorflow","_id":"cjleshqkb002jryfckmqs8jji"},{"name":"C++","_id":"cjleshqkc002kryfckgnnnh8k"},{"name":"软件开发","_id":"cjleshqkc002nryfclvpfk9no"},{"name":"Qt","_id":"cjleshqkd002pryfcvrmwazm3"},{"name":"network","_id":"cjleshqkp002zryfcp6lj3kq7"},{"name":"OS","_id":"cjleshqkq0030ryfcx0c8lmr7"}]}}