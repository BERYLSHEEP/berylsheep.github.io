{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"f32c465cddf5fbe3c1ff1506cbf438a7b3667dc7","modified":1527251731644},{"_id":"source/README.md","hash":"ddeedf15bed7fc9d74587296bd1f690cdd0aaffe","modified":1527252871653},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1527214970929},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1527214970928},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1527214970929},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1527214970929},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1527214970929},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1527214970929},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1527214970929},{"_id":"themes/yilia/_config.yml","hash":"4a772a5ec6e0e1a869b626443622d0a55c941f2e","modified":1527847152524},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1527214970945},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1527214970968},{"_id":"source/_posts/Compiler1.md","hash":"786a17a587c995a1b365c582b937557af0798c5b","modified":1527252071535},{"_id":"source/_posts/Cyclooctane.md","hash":"bffaca5af9c8c331a8b5a99a86ffdfd09ea6f55f","modified":1527252071994},{"_id":"source/_posts/Compiler2.md","hash":"39d7eb9560d671caa76242b15b8049fdc43f54d1","modified":1527252071924},{"_id":"source/_posts/DataStructure_Graph.md","hash":"2ed40180df156d8b831976a91f077a81f73d650f","modified":1527252072161},{"_id":"source/_posts/DataStructure_List.md","hash":"349bfd9363e8723c53a1e697a796e5b98a81e33a","modified":1527252072233},{"_id":"source/_posts/Hello,World.md","hash":"2d10522f711fbf2e7da59da0e8bb52694f7f015a","modified":1527252072717},{"_id":"source/_posts/Cyclooctane 2.md","hash":"f136d34fe1e120c892e411ecfb0cd7f8189575c4","modified":1527252072071},{"_id":"source/_posts/ProblemSet1.md","hash":"57609f1e86fb2d967edd152b7ddbad97bbb933dc","modified":1527252072572},{"_id":"source/_posts/RC_DuReader.md","hash":"4ba6205d11fcf3b05f1e5affc35c34b3bfbddd80","modified":1527252072886},{"_id":"source/_posts/Java_note1.md","hash":"02ea77f0eb946bb2ab9c716b292f8b8e814d5249","modified":1527252072485},{"_id":"source/_posts/ProblemSet_Tree.md","hash":"3b92ff422b0810199cfb26306204d1ed69b54b36","modified":1527252072805},{"_id":"source/_posts/DataStructure_Tree.md","hash":"2b032ff066a2e6ff0a942004660ff1d294181cfa","modified":1527252072394},{"_id":"source/_posts/SAT.md","hash":"0603c3586399723f3a1d2ac88275a89622f414d7","modified":1527252072646},{"_id":"source/_posts/VSM.md","hash":"279e5cfec8a67b3dfa7cc9a6a70d0e468d86d0ad","modified":1527908392474},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1527214970905},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1527214964214},{"_id":"themes/yilia/.git/config","hash":"032e5805693203a246253009a88385e709bbbe14","modified":1527214970909},{"_id":"source/_posts/DataStructure_Stack.md","hash":"d706805e9d8dba1ef32f29ab5c08f246d51a60f0","modified":1527252072313},{"_id":"themes/yilia/.git/index","hash":"38023b006a359fab7d93df11f2226ea91bea6fd9","modified":1527252331266},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1527214970901},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1527214970930},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1527214970930},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1527214970930},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1527214970930},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1527214970930},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1527214970930},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1527214970930},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1527214970944},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1527214970944},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1527214970944},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1527214970945},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1527214970944},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1527214970945},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1527214970945},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1527214970963},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1527214970967},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1527214970945},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1527214970960},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1527214970964},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527214970943},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1527214970967},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1527214964218},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1527214964218},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1527214964215},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1527214964216},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1527214964216},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1527214964215},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1527214964217},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1527214964216},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1527214964217},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1527214964218},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1527214964217},{"_id":"themes/yilia/.git/logs/HEAD","hash":"8a90d444e08c047a2fd84d18a61ab893569d5f47","modified":1527214970907},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1527214970931},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1527214970932},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1527214970932},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1527214970932},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"ccb143d6aaf65911225e6f40c40217a6e38f32cb","modified":1527240445520},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1527214970934},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1527214970934},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1527214970935},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1527214970935},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1527214970935},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1527214970944},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1527214970944},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1527214970962},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1527214970962},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527214970962},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527214970961},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527214970961},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527214970960},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527214970961},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1527214970960},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527214970961},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1527214970945},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1527214970946},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1527214970946},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1527214970947},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1527214970947},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1527214970947},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1527214970948},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1527214970952},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1527214970953},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1527214970954},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1527214970954},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1527214970953},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1527214970955},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1527214970955},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1527214970955},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1527214970955},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1527214970956},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1527214970956},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1527214970955},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1527214970956},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1527214970957},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1527214970957},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1527214970958},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1527214970958},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1527214970958},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1527214970958},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1527214970959},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1527214970958},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1527214970958},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1527214970959},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1527214970959},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1527214970959},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1527214970959},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1527214970943},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1527214970907},{"_id":"themes/yilia/.git/objects/pack/pack-40d65f13e401affe70836d4abdca0ee54aa7b186.idx","hash":"704c0b5040efce2c79d04ae53872445453160c49","modified":1527214970780},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1527214970941},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1527214970942},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1527214970942},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1527214970942},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1527214970947},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1527214970947},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1527214970948},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1527214970948},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1527214970948},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527214970949},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527214970950},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527214970950},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527214970949},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1527214970954},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527214970954},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527214970954},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1527214970940},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1527214970904},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"8a90d444e08c047a2fd84d18a61ab893569d5f47","modified":1527214970908},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"8a90d444e08c047a2fd84d18a61ab893569d5f47","modified":1527214970904},{"_id":"themes/yilia/.git/objects/pack/pack-40d65f13e401affe70836d4abdca0ee54aa7b186.pack","hash":"5abf4afacaf3b21748592f04b32982768856de49","modified":1527214970779},{"_id":"public/content.json","hash":"331c45dd5bbda235abe4e710cf64a2f8f3953090","modified":1527847219408},{"_id":"public/2018/06/01/VSM/index.html","hash":"11c2c902e2de1f1fa2b6f96901eae800aabe3d8d","modified":1527908414870},{"_id":"public/2018/05/22/RC_DuReader/index.html","hash":"82ef5395c6631866bbe54948b16f9c85f8d0abf4","modified":1527847219927},{"_id":"public/2017/09/11/Java_note1/index.html","hash":"75b90cf5d1463c8c31e29c87fdbddb50f9f70567","modified":1527847219928},{"_id":"public/2017/08/28/Cyclooctane 2/index.html","hash":"0e8cb2238f6d9ffcad1eb3f218fd1f6dcc7008f3","modified":1527847219928},{"_id":"public/2017/08/24/Compiler2/index.html","hash":"fc7b0ada1ef9c1e8e047d84fb26621d6f621d362","modified":1527847219928},{"_id":"public/2017/08/19/DataStructure_Graph/index.html","hash":"4d3648cc455b84c89eff65bc8ad6abda83da6721","modified":1527847219928},{"_id":"public/2017/08/23/Compiler1/index.html","hash":"0d59c7261abcd21605fb904b7e1a569ac9332d79","modified":1527847219928},{"_id":"public/2017/08/18/ProblemSet1/index.html","hash":"6dceeb3a0e175a1b9726b9bcf860dc5523400737","modified":1527847219928},{"_id":"public/2017/08/18/ProblemSet_Tree/index.html","hash":"bb397d1b26a3946036d336865fb82d87a89f2d2c","modified":1527847219928},{"_id":"public/2017/08/15/DataStructure_Tree/index.html","hash":"bc90897d806ccee554d9c4d0f598178a705db442","modified":1527847219928},{"_id":"public/2017/08/14/DataStructure_Stack/index.html","hash":"8ed5db880fc02c5675a15ac60d1a385a712b53f9","modified":1527847219928},{"_id":"public/2017/08/12/DataStructure_List/index.html","hash":"aa25563c0f584547e4ca65675ba6fc78a62503b1","modified":1527847219928},{"_id":"public/2017/07/15/SAT/index.html","hash":"8546a910711176753948ab0e2afef2029c0f2bec","modified":1527847219928},{"_id":"public/2017/05/11/Cyclooctane/index.html","hash":"a9cde963fbaeb48a1cf4687b7ba24d61017b98b4","modified":1527847219929},{"_id":"public/2017/05/10/Hello,World/index.html","hash":"54307a329e934c75dac9deb039783976d7e0c144","modified":1527847219929},{"_id":"public/archives/index.html","hash":"1ca9b190aa81bcaef54021dbb40db73fe9d2ae4a","modified":1527847219929},{"_id":"public/archives/page/2/index.html","hash":"f8e4105c24a10573a1d6097f0a88694eeec0caaf","modified":1527847219929},{"_id":"public/archives/2017/index.html","hash":"7080fc624101fc406738fa7d5251751ad59be8ca","modified":1527847219929},{"_id":"public/archives/2017/page/2/index.html","hash":"aecf8f3108de9e142e5975fa07997dac0366f5a3","modified":1527847219929},{"_id":"public/archives/2017/05/index.html","hash":"4cc866dc78e24fb45d4100dda386c07379b5894e","modified":1527847219929},{"_id":"public/archives/2017/07/index.html","hash":"b45fedd1e9ef652bb2b027ec2b3370d6e12f7793","modified":1527847219929},{"_id":"public/archives/2017/09/index.html","hash":"ae329bed47acf6c73d2f22924e0a9d36ba93fcc0","modified":1527847219929},{"_id":"public/archives/2018/index.html","hash":"43ac9ec8f9b04baf95f50be27390e59164f29c4e","modified":1527847219929},{"_id":"public/archives/2017/08/index.html","hash":"1083b194c12e93d06c0b4d947f9f6c71d3fdf96b","modified":1527847219930},{"_id":"public/archives/2018/05/index.html","hash":"c32bfb8d3d5846f506a407068e235a6e540c2bab","modified":1527847219930},{"_id":"public/archives/2018/06/index.html","hash":"3f5896e96e9100216ddc8167ddf27e5fbff8f26b","modified":1527847219930},{"_id":"public/page/2/index.html","hash":"bb4d8353c6db624713f9b088d3cf5a5a19cb45b4","modified":1527847219930},{"_id":"public/index.html","hash":"850eaa704d2a6cf6e45ad0ec94f71244ab061760","modified":1527847219930},{"_id":"public/tags/编译原理/index.html","hash":"98c7ab120b9216208f66c6e03b02e4daccb6e327","modified":1527847219930},{"_id":"public/tags/学习笔记/index.html","hash":"c3b29e5be1cdfcb54495ac67c3dd81dce67af3aa","modified":1527847219930},{"_id":"public/tags/游戏/index.html","hash":"a594f4b099f3da31f651f416103dd39c5b10ac9a","modified":1527847219930},{"_id":"public/tags/c/index.html","hash":"fa4d5adb9a1ca5ec0e5a6cab953a61e67c1fce92","modified":1527847219930},{"_id":"public/tags/数据结构/index.html","hash":"f59c4ea66297f4350f3a2bea72edb9c9e25d07f8","modified":1527847219930},{"_id":"public/tags/others/index.html","hash":"6c563b47df0a936923ee403f195e63150ecb9efd","modified":1527847219931},{"_id":"public/tags/NLP/index.html","hash":"39195c6c5f7461af699ff47b2066dc60e2464b3b","modified":1527847219931},{"_id":"public/tags/阅读理解/index.html","hash":"3d1094b24dddf87c5ba53cdb31efdcda8707c315","modified":1527847219931},{"_id":"public/tags/机器学习/index.html","hash":"be577fc661c5c914a318b18ce6fea7b9f9d45b12","modified":1527847219931},{"_id":"public/tags/刷题/index.html","hash":"5a63678e82de06c76cf4b31bc2101f3d02c8fc2e","modified":1527847219931},{"_id":"public/tags/JAVA/index.html","hash":"255ba550d5d43f5c67b85ce7574d5391f6280b4b","modified":1527847219931},{"_id":"public/tags/算法/index.html","hash":"edb0c03395159c62b07c8db829ad859ec8544404","modified":1527847219931},{"_id":"public/tags/VSM/index.html","hash":"4d66154084d0e53120391a086fbb417e96991683","modified":1527847219931},{"_id":"public/CNAME","hash":"f32c465cddf5fbe3c1ff1506cbf438a7b3667dc7","modified":1527847219936},{"_id":"public/README.md","hash":"ddeedf15bed7fc9d74587296bd1f690cdd0aaffe","modified":1527847219936},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1527847219936},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1527847219936},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527847219936},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527847219936},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527847219936},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527847219936},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527847219936},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1527847219936},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527847219936},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1527847219946},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1527847219946},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1527847219946},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1527847219946},{"_id":"public/sitemap.xml","hash":"cf1bfac73ca0e2090fa56d1e552f1b2bbb9c061d","modified":1527908414950},{"_id":"public/baidusitemap.xml","hash":"e8c25dd0322411b5dc35d389dac00f16c223a6b1","modified":1527908414365},{"_id":"source/robots.txt","hash":"79cb92b89a36c4b1384fcaa7a3648caca8afcd48","modified":1527863350573},{"_id":"public/robots.txt","hash":"79cb92b89a36c4b1384fcaa7a3648caca8afcd48","modified":1527863360558}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"编译原理笔记（一）：概述","date":"2017-08-22T16:00:00.000Z","comments":1,"_content":"\n\nStanford的CS1 Compilers 课程学习笔记\n\n学习编译知识并最终制作COOL语言的编译器\n\n<!-- more -->\n\n## 01-01. Introduction\n\nTwo major approaches to implementing programming languages:\n**Compilers(编译器)** 、 **Interpreters(解释器)**\n\n### 1. Interpreters(解释器)\n\n![Interpreters](http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG)\n\n**Online**: the work it does is all part of running your program.\n\nThe Interpreter produces the output with data and program directly\n\nIt doesn’t do any processing of the program before it executes the program on the input.\n\n### 2. Compilers(编译器)\n\n![Compilers](http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG)\n\n**Offline**: produces an executable\nThe executable is **another program**, might be another language or bytecode, it can be **run separately** on data.\n\n### 01-02. FORTRAN:\n\nFORTRAN ( Formula Translation Project )：**The first successful high level language**.\nMeanings : The formulas were translated into a form that the machine could execute directly.\n\nProgramming languages = fairly deep theory + good engineering skills\n\nThe structure of FORTRAN one:\n1.Lexical Analysis (词法分析)\n2.Parsing (语法分析)\n3.Semantic Analysis (语义分析)\n4.Optimization (优化)\n5.Code Generation (代码生成)\n\n#### 1.Lexical Analysis (词法分析)\n\nGoal : **divide** the program text into its **tokens** (words)(符号).\n\nExample of tokens :\n1.key words 关键词 ( like “if”)\n2.variable names 变量名 (“x”,”y”,”z”)\n3.constants 常量 (“1”,”2”)\n4.operators 运算符(“=”,”==”)\n5.punctuation 标点符号(“;” “,”)\n\n![tokens](http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG)\n\n#### 2.Parsing (语法分析)\n\nGoal : **diagramming sentences **(分析句子)\n\nThe first step : Identify the role of each word\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG)\n\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG)\n\n#### 3.Semantic Analysis (语义分析)\n\nThe compilers can only do very** limited** kinds of semantic analysis.\n\nIt generally try to catch inconsistencies. (捕捉异常)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG)\n\n![lexically scoped](http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG)\n\n#### 4.Optimization (优化)\n\nGoal : To modify the program so that it **uses less of some resource** ,(use less time, run faster or use less space)\n\nif(x and y are integers)\n![Optimization](http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG)\n\n#### 5.Code Generation (代码生成)\n\nThe most common goal : produce assembly code (生成汇编代码)\n\nGeneral goal : do a translation into some other languages.\n\n#### The proportions (比例)\n\n![proportions](http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG)\n\nFORTRAN I :\ncomplex lexical analysis phase and parsing phase,\nsmall semantic anaysis phase (very weak)\n\nToday:\nvery little in parsing and lexical analysis. ( we have good tools to help us )\nvery large optimization phase\na small code-generation phase ( we also have good tools )\n\n### 01-03. The Economy of Programming Languages\n\n1.Why are there so many programming languages\n2.Why are there new programming languages\n3.What is a good programming language\n\n#### 1. Why are there so many programming languages\n\n1.**application domains**(应用域) have distinctive and conflicting needs.\n\n![application domains](http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG)\n\nIt would be** difficult to integrate all of these into one system **that would do good job on all of these things.\n\n#### 2. Why are there new programming languages\n\n**Programmer training** is the dominant cost for a programming language\n\nHere are some facts:\n\n1. Widely-used languages are slow to change\n\n   > Design and build a compiler for a new language are not actually taht expensive.\n   > The real cost is in all the **users and educating them**.\n\n2. Easy to start a new language\n\n   > Zero or low training cost\n   > Adapt quickly to changing situations, not very costly to experiment.\n\n3. Languages adopted to fill a void\n\n   > Programming languages exist for **purpose**.\n   > There are **new application domains** coming along all the time.\n\n#### 3. What is a good programming language\n\nThere is **no universally accepted metric**(普遍接受的标准) for language design.\n\n### 02-(01-03). Cool Overview\n\n**COOL**: Classroom Object Oriented Language\n\nCOOL -> MIPS assembly language\n\n```\nclass Main\n{\n\tmain():Int { 1 };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():IO {  i.out_string(\"Hello World!\\n\") };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():Object {  i.out_string(\"Hello World!\\n\"); 1; };\n};\nclass Main\n{\n\tmain():IO {  (new IO).out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  self.out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  out_string(\"Hello World!\\n\") };\n};\n\n\n\nclass Main\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string( (new IO).in_string.concat(\"\\n\\\") )\n\t};\n};\n// in_string : 接受输入，返回string\n// concat :  连接字符串\nclass Main inherits A2I    // ascii to integer\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(\"\\n\\\")       )\n\t};\n};\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int { if(i=0) then 1 else i*fact(i-1) fi };\n};\n\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int \n\t{ \n\t\tlet fact: Int <- 1 in  // 声明局部变量\n\t\t{\n\t\t\twhile ( not (i=0) ) loop\n\t\t\t{\n\t\t\t\tfact <- fact*i;\n\t\t\t\ti <- i-1;\n\t\t\t}\n\t\t\tpool;\n\t\t\tfact;\n\t\t}\n\t};\n};\n\n\nclass List inherits A2I    //链表类\n{\n\titem : Object;    // 数据\n\tnext : List ;    // 指向下一个\n\tinit ( i: Object , n: List ): List\n\t{\n\t\titem <- i;\n\t\tnext <- n;\n\t\tself;    // 返回值为List \n\t}\n\tflatten (): String\n\t{\n\t\tlet string : String <-\n\t\t\tcase item of       // 相当于switch    关键词为 case .. of \n\t\t\t\ti : Int => i2a(i);     //  变量名+“:”+类型+操作\n\t\t\t\ts : String => s;\n\t\t\t\to : Object => { abort(); \"\"; };    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了\"\" 以返回String\n\t\t\tesac;    // case的结束标志\n\t\tin    // 局部变量范围\n\t\t\tif ( isvoid next ) then    // 若next为空\n\t\t\t\tstring\n\t\t\telse\n\t\t\t\tstring.concat(next.flatte())\n\t\t\tfi     // if的结束标志\n\t};\n};\n\t\nclass Main inherits IO\n{\n\tmain(): Object\n\t{\n\t\tlet \thello : String <- \"Hello \",\n\t\t\tworld : String <- \"World!\",\n\t\t\tnewline: String <- \"\\n\",\n\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记\n\t\t\tlist : List <-\n\t\t\t\t(new List).init(hello, \n\t\t\t\t\t(new List).init(world,\n\t\t\t\t\t\t(new List).init(newline, nil ) ) )\n\t\tin\n\t\t\tout_string(list.flatten())\n\t};\n};\n```\n\n语法：\nclass 是一系列method(函数)的集合，每个method以大括号+分号结尾\n必有Main class和main函数\n函数后用 “：”+”type” 声明函数的返回类型\n单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式\n所有类继承自Object, self相当于其它语言中的this\n用“=”作判断，用”<-“作赋值\nif以fi作为结尾\nloop以pool结尾\ncase..of以esac结尾，每个分支都要以分号结尾","source":"_posts/Compiler1.md","raw":"---\nlayout: post\ntitle: \"编译原理笔记（一）：概述\"\ndate: 2017-08-23\ncomments: true\ntags: \n\t- 编译原理\n\t- 学习笔记\n---\n\n\nStanford的CS1 Compilers 课程学习笔记\n\n学习编译知识并最终制作COOL语言的编译器\n\n<!-- more -->\n\n## 01-01. Introduction\n\nTwo major approaches to implementing programming languages:\n**Compilers(编译器)** 、 **Interpreters(解释器)**\n\n### 1. Interpreters(解释器)\n\n![Interpreters](http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG)\n\n**Online**: the work it does is all part of running your program.\n\nThe Interpreter produces the output with data and program directly\n\nIt doesn’t do any processing of the program before it executes the program on the input.\n\n### 2. Compilers(编译器)\n\n![Compilers](http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG)\n\n**Offline**: produces an executable\nThe executable is **another program**, might be another language or bytecode, it can be **run separately** on data.\n\n### 01-02. FORTRAN:\n\nFORTRAN ( Formula Translation Project )：**The first successful high level language**.\nMeanings : The formulas were translated into a form that the machine could execute directly.\n\nProgramming languages = fairly deep theory + good engineering skills\n\nThe structure of FORTRAN one:\n1.Lexical Analysis (词法分析)\n2.Parsing (语法分析)\n3.Semantic Analysis (语义分析)\n4.Optimization (优化)\n5.Code Generation (代码生成)\n\n#### 1.Lexical Analysis (词法分析)\n\nGoal : **divide** the program text into its **tokens** (words)(符号).\n\nExample of tokens :\n1.key words 关键词 ( like “if”)\n2.variable names 变量名 (“x”,”y”,”z”)\n3.constants 常量 (“1”,”2”)\n4.operators 运算符(“=”,”==”)\n5.punctuation 标点符号(“;” “,”)\n\n![tokens](http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG)\n\n#### 2.Parsing (语法分析)\n\nGoal : **diagramming sentences **(分析句子)\n\nThe first step : Identify the role of each word\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG)\n\n![structure tree](http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG)\n\n#### 3.Semantic Analysis (语义分析)\n\nThe compilers can only do very** limited** kinds of semantic analysis.\n\nIt generally try to catch inconsistencies. (捕捉异常)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG)\n\n![lexically scoped](http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG)\n\n#### 4.Optimization (优化)\n\nGoal : To modify the program so that it **uses less of some resource** ,(use less time, run faster or use less space)\n\nif(x and y are integers)\n![Optimization](http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG)\n\n#### 5.Code Generation (代码生成)\n\nThe most common goal : produce assembly code (生成汇编代码)\n\nGeneral goal : do a translation into some other languages.\n\n#### The proportions (比例)\n\n![proportions](http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG)\n\nFORTRAN I :\ncomplex lexical analysis phase and parsing phase,\nsmall semantic anaysis phase (very weak)\n\nToday:\nvery little in parsing and lexical analysis. ( we have good tools to help us )\nvery large optimization phase\na small code-generation phase ( we also have good tools )\n\n### 01-03. The Economy of Programming Languages\n\n1.Why are there so many programming languages\n2.Why are there new programming languages\n3.What is a good programming language\n\n#### 1. Why are there so many programming languages\n\n1.**application domains**(应用域) have distinctive and conflicting needs.\n\n![application domains](http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG)\n\nIt would be** difficult to integrate all of these into one system **that would do good job on all of these things.\n\n#### 2. Why are there new programming languages\n\n**Programmer training** is the dominant cost for a programming language\n\nHere are some facts:\n\n1. Widely-used languages are slow to change\n\n   > Design and build a compiler for a new language are not actually taht expensive.\n   > The real cost is in all the **users and educating them**.\n\n2. Easy to start a new language\n\n   > Zero or low training cost\n   > Adapt quickly to changing situations, not very costly to experiment.\n\n3. Languages adopted to fill a void\n\n   > Programming languages exist for **purpose**.\n   > There are **new application domains** coming along all the time.\n\n#### 3. What is a good programming language\n\nThere is **no universally accepted metric**(普遍接受的标准) for language design.\n\n### 02-(01-03). Cool Overview\n\n**COOL**: Classroom Object Oriented Language\n\nCOOL -> MIPS assembly language\n\n```\nclass Main\n{\n\tmain():Int { 1 };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():IO {  i.out_string(\"Hello World!\\n\") };\n};\nclass Main\n{\n\ti : IO <- new IO;\n\tmain():Object {  i.out_string(\"Hello World!\\n\"); 1; };\n};\nclass Main\n{\n\tmain():IO {  (new IO).out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  self.out_string(\"Hello World!\\n\") };\n};\nclass Main inherits IO\n{\n\tmain():IO {  out_string(\"Hello World!\\n\") };\n};\n\n\n\nclass Main\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string( (new IO).in_string.concat(\"\\n\\\") )\n\t};\n};\n// in_string : 接受输入，返回string\n// concat :  连接字符串\nclass Main inherits A2I    // ascii to integer\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(\"\\n\\\")       )\n\t};\n};\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int { if(i=0) then 1 else i*fact(i-1) fi };\n};\n\nclass Main inherits A2I\n{\n\tmain():Object \n\t{\n\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(\"\\n\\\")       )\n\t};\n\tfact( i: Int ) : Int \n\t{ \n\t\tlet fact: Int <- 1 in  // 声明局部变量\n\t\t{\n\t\t\twhile ( not (i=0) ) loop\n\t\t\t{\n\t\t\t\tfact <- fact*i;\n\t\t\t\ti <- i-1;\n\t\t\t}\n\t\t\tpool;\n\t\t\tfact;\n\t\t}\n\t};\n};\n\n\nclass List inherits A2I    //链表类\n{\n\titem : Object;    // 数据\n\tnext : List ;    // 指向下一个\n\tinit ( i: Object , n: List ): List\n\t{\n\t\titem <- i;\n\t\tnext <- n;\n\t\tself;    // 返回值为List \n\t}\n\tflatten (): String\n\t{\n\t\tlet string : String <-\n\t\t\tcase item of       // 相当于switch    关键词为 case .. of \n\t\t\t\ti : Int => i2a(i);     //  变量名+“:”+类型+操作\n\t\t\t\ts : String => s;\n\t\t\t\to : Object => { abort(); \"\"; };    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了\"\" 以返回String\n\t\t\tesac;    // case的结束标志\n\t\tin    // 局部变量范围\n\t\t\tif ( isvoid next ) then    // 若next为空\n\t\t\t\tstring\n\t\t\telse\n\t\t\t\tstring.concat(next.flatte())\n\t\t\tfi     // if的结束标志\n\t};\n};\n\t\nclass Main inherits IO\n{\n\tmain(): Object\n\t{\n\t\tlet \thello : String <- \"Hello \",\n\t\t\tworld : String <- \"World!\",\n\t\t\tnewline: String <- \"\\n\",\n\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记\n\t\t\tlist : List <-\n\t\t\t\t(new List).init(hello, \n\t\t\t\t\t(new List).init(world,\n\t\t\t\t\t\t(new List).init(newline, nil ) ) )\n\t\tin\n\t\t\tout_string(list.flatten())\n\t};\n};\n```\n\n语法：\nclass 是一系列method(函数)的集合，每个method以大括号+分号结尾\n必有Main class和main函数\n函数后用 “：”+”type” 声明函数的返回类型\n单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式\n所有类继承自Object, self相当于其它语言中的this\n用“=”作判断，用”<-“作赋值\nif以fi作为结尾\nloop以pool结尾\ncase..of以esac结尾，每个分支都要以分号结尾","slug":"Compiler1","published":1,"updated":"2018-05-25T12:41:11.535Z","photos":[],"link":"","_id":"cjhvssacz0000jvfc7vocwubt","content":"<p>Stanford的CS1 Compilers 课程学习笔记</p>\n<p>学习编译知识并最终制作COOL语言的编译器</p>\n<a id=\"more\"></a>\n<h2 id=\"01-01-Introduction\"><a href=\"#01-01-Introduction\" class=\"headerlink\" title=\"01-01. Introduction\"></a>01-01. Introduction</h2><p>Two major approaches to implementing programming languages:<br><strong>Compilers(编译器)</strong> 、 <strong>Interpreters(解释器)</strong></p>\n<h3 id=\"1-Interpreters-解释器\"><a href=\"#1-Interpreters-解释器\" class=\"headerlink\" title=\"1. Interpreters(解释器)\"></a>1. Interpreters(解释器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG\" alt=\"Interpreters\"></p>\n<p><strong>Online</strong>: the work it does is all part of running your program.</p>\n<p>The Interpreter produces the output with data and program directly</p>\n<p>It doesn’t do any processing of the program before it executes the program on the input.</p>\n<h3 id=\"2-Compilers-编译器\"><a href=\"#2-Compilers-编译器\" class=\"headerlink\" title=\"2. Compilers(编译器)\"></a>2. Compilers(编译器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG\" alt=\"Compilers\"></p>\n<p><strong>Offline</strong>: produces an executable<br>The executable is <strong>another program</strong>, might be another language or bytecode, it can be <strong>run separately</strong> on data.</p>\n<h3 id=\"01-02-FORTRAN\"><a href=\"#01-02-FORTRAN\" class=\"headerlink\" title=\"01-02. FORTRAN:\"></a>01-02. FORTRAN:</h3><p>FORTRAN ( Formula Translation Project )：<strong>The first successful high level language</strong>.<br>Meanings : The formulas were translated into a form that the machine could execute directly.</p>\n<p>Programming languages = fairly deep theory + good engineering skills</p>\n<p>The structure of FORTRAN one:<br>1.Lexical Analysis (词法分析)<br>2.Parsing (语法分析)<br>3.Semantic Analysis (语义分析)<br>4.Optimization (优化)<br>5.Code Generation (代码生成)</p>\n<h4 id=\"1-Lexical-Analysis-词法分析\"><a href=\"#1-Lexical-Analysis-词法分析\" class=\"headerlink\" title=\"1.Lexical Analysis (词法分析)\"></a>1.Lexical Analysis (词法分析)</h4><p>Goal : <strong>divide</strong> the program text into its <strong>tokens</strong> (words)(符号).</p>\n<p>Example of tokens :<br>1.key words 关键词 ( like “if”)<br>2.variable names 变量名 (“x”,”y”,”z”)<br>3.constants 常量 (“1”,”2”)<br>4.operators 运算符(“=”,”==”)<br>5.punctuation 标点符号(“;” “,”)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG\" alt=\"tokens\"></p>\n<h4 id=\"2-Parsing-语法分析\"><a href=\"#2-Parsing-语法分析\" class=\"headerlink\" title=\"2.Parsing (语法分析)\"></a>2.Parsing (语法分析)</h4><p>Goal : <strong>diagramming sentences </strong>(分析句子)</p>\n<p>The first step : Identify the role of each word<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG\" alt=\"structure tree\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG\" alt=\"structure tree\"></p>\n<h4 id=\"3-Semantic-Analysis-语义分析\"><a href=\"#3-Semantic-Analysis-语义分析\" class=\"headerlink\" title=\"3.Semantic Analysis (语义分析)\"></a>3.Semantic Analysis (语义分析)</h4><p>The compilers can only do very<strong> limited</strong> kinds of semantic analysis.</p>\n<p>It generally try to catch inconsistencies. (捕捉异常)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG\" alt=\"lexically scoped\"></p>\n<h4 id=\"4-Optimization-优化\"><a href=\"#4-Optimization-优化\" class=\"headerlink\" title=\"4.Optimization (优化)\"></a>4.Optimization (优化)</h4><p>Goal : To modify the program so that it <strong>uses less of some resource</strong> ,(use less time, run faster or use less space)</p>\n<p>if(x and y are integers)<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG\" alt=\"Optimization\"></p>\n<h4 id=\"5-Code-Generation-代码生成\"><a href=\"#5-Code-Generation-代码生成\" class=\"headerlink\" title=\"5.Code Generation (代码生成)\"></a>5.Code Generation (代码生成)</h4><p>The most common goal : produce assembly code (生成汇编代码)</p>\n<p>General goal : do a translation into some other languages.</p>\n<h4 id=\"The-proportions-比例\"><a href=\"#The-proportions-比例\" class=\"headerlink\" title=\"The proportions (比例)\"></a>The proportions (比例)</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG\" alt=\"proportions\"></p>\n<p>FORTRAN I :<br>complex lexical analysis phase and parsing phase,<br>small semantic anaysis phase (very weak)</p>\n<p>Today:<br>very little in parsing and lexical analysis. ( we have good tools to help us )<br>very large optimization phase<br>a small code-generation phase ( we also have good tools )</p>\n<h3 id=\"01-03-The-Economy-of-Programming-Languages\"><a href=\"#01-03-The-Economy-of-Programming-Languages\" class=\"headerlink\" title=\"01-03. The Economy of Programming Languages\"></a>01-03. The Economy of Programming Languages</h3><p>1.Why are there so many programming languages<br>2.Why are there new programming languages<br>3.What is a good programming language</p>\n<h4 id=\"1-Why-are-there-so-many-programming-languages\"><a href=\"#1-Why-are-there-so-many-programming-languages\" class=\"headerlink\" title=\"1. Why are there so many programming languages\"></a>1. Why are there so many programming languages</h4><p>1.<strong>application domains</strong>(应用域) have distinctive and conflicting needs.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG\" alt=\"application domains\"></p>\n<p>It would be<strong> difficult to integrate all of these into one system </strong>that would do good job on all of these things.</p>\n<h4 id=\"2-Why-are-there-new-programming-languages\"><a href=\"#2-Why-are-there-new-programming-languages\" class=\"headerlink\" title=\"2. Why are there new programming languages\"></a>2. Why are there new programming languages</h4><p><strong>Programmer training</strong> is the dominant cost for a programming language</p>\n<p>Here are some facts:</p>\n<ol>\n<li><p>Widely-used languages are slow to change</p>\n<blockquote>\n<p>Design and build a compiler for a new language are not actually taht expensive.<br>The real cost is in all the <strong>users and educating them</strong>.</p>\n</blockquote>\n</li>\n<li><p>Easy to start a new language</p>\n<blockquote>\n<p>Zero or low training cost<br>Adapt quickly to changing situations, not very costly to experiment.</p>\n</blockquote>\n</li>\n<li><p>Languages adopted to fill a void</p>\n<blockquote>\n<p>Programming languages exist for <strong>purpose</strong>.<br>There are <strong>new application domains</strong> coming along all the time.</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"3-What-is-a-good-programming-language\"><a href=\"#3-What-is-a-good-programming-language\" class=\"headerlink\" title=\"3. What is a good programming language\"></a>3. What is a good programming language</h4><p>There is <strong>no universally accepted metric</strong>(普遍接受的标准) for language design.</p>\n<h3 id=\"02-01-03-Cool-Overview\"><a href=\"#02-01-03-Cool-Overview\" class=\"headerlink\" title=\"02-(01-03). Cool Overview\"></a>02-(01-03). Cool Overview</h3><p><strong>COOL</strong>: Classroom Object Oriented Language</p>\n<p>COOL -&gt; MIPS assembly language</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Int &#123; 1 &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():IO &#123;  i.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():Object &#123;  i.out_string(&quot;Hello World!\\n&quot;); 1; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  (new IO).out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  self.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string( (new IO).in_string.concat(&quot;\\n\\&quot;) )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// in_string : 接受输入，返回string</span><br><span class=\"line\">// concat :  连接字符串</span><br><span class=\"line\">class Main inherits A2I    // ascii to integer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int &#123; if(i=0) then 1 else i*fact(i-1) fi &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\tlet fact: Int &lt;- 1 in  // 声明局部变量</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\twhile ( not (i=0) ) loop</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tfact &lt;- fact*i;</span><br><span class=\"line\">\t\t\t\ti &lt;- i-1;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpool;</span><br><span class=\"line\">\t\t\tfact;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class List inherits A2I    //链表类</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\titem : Object;    // 数据</span><br><span class=\"line\">\tnext : List ;    // 指向下一个</span><br><span class=\"line\">\tinit ( i: Object , n: List ): List</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titem &lt;- i;</span><br><span class=\"line\">\t\tnext &lt;- n;</span><br><span class=\"line\">\t\tself;    // 返回值为List </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tflatten (): String</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet string : String &lt;-</span><br><span class=\"line\">\t\t\tcase item of       // 相当于switch    关键词为 case .. of </span><br><span class=\"line\">\t\t\t\ti : Int =&gt; i2a(i);     //  变量名+“:”+类型+操作</span><br><span class=\"line\">\t\t\t\ts : String =&gt; s;</span><br><span class=\"line\">\t\t\t\to : Object =&gt; &#123; abort(); &quot;&quot;; &#125;;    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了&quot;&quot; 以返回String</span><br><span class=\"line\">\t\t\tesac;    // case的结束标志</span><br><span class=\"line\">\t\tin    // 局部变量范围</span><br><span class=\"line\">\t\t\tif ( isvoid next ) then    // 若next为空</span><br><span class=\"line\">\t\t\t\tstring</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tstring.concat(next.flatte())</span><br><span class=\"line\">\t\t\tfi     // if的结束标志</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain(): Object</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet \thello : String &lt;- &quot;Hello &quot;,</span><br><span class=\"line\">\t\t\tworld : String &lt;- &quot;World!&quot;,</span><br><span class=\"line\">\t\t\tnewline: String &lt;- &quot;\\n&quot;,</span><br><span class=\"line\">\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记</span><br><span class=\"line\">\t\t\tlist : List &lt;-</span><br><span class=\"line\">\t\t\t\t(new List).init(hello, </span><br><span class=\"line\">\t\t\t\t\t(new List).init(world,</span><br><span class=\"line\">\t\t\t\t\t\t(new List).init(newline, nil ) ) )</span><br><span class=\"line\">\t\tin</span><br><span class=\"line\">\t\t\tout_string(list.flatten())</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>语法：<br>class 是一系列method(函数)的集合，每个method以大括号+分号结尾<br>必有Main class和main函数<br>函数后用 “：”+”type” 声明函数的返回类型<br>单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式<br>所有类继承自Object, self相当于其它语言中的this<br>用“=”作判断，用”&lt;-“作赋值<br>if以fi作为结尾<br>loop以pool结尾<br>case..of以esac结尾，每个分支都要以分号结尾</p>\n","site":{"data":{}},"excerpt":"<p>Stanford的CS1 Compilers 课程学习笔记</p>\n<p>学习编译知识并最终制作COOL语言的编译器</p>","more":"<h2 id=\"01-01-Introduction\"><a href=\"#01-01-Introduction\" class=\"headerlink\" title=\"01-01. Introduction\"></a>01-01. Introduction</h2><p>Two major approaches to implementing programming languages:<br><strong>Compilers(编译器)</strong> 、 <strong>Interpreters(解释器)</strong></p>\n<h3 id=\"1-Interpreters-解释器\"><a href=\"#1-Interpreters-解释器\" class=\"headerlink\" title=\"1. Interpreters(解释器)\"></a>1. Interpreters(解释器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/5908CiF8j3.JPG\" alt=\"Interpreters\"></p>\n<p><strong>Online</strong>: the work it does is all part of running your program.</p>\n<p>The Interpreter produces the output with data and program directly</p>\n<p>It doesn’t do any processing of the program before it executes the program on the input.</p>\n<h3 id=\"2-Compilers-编译器\"><a href=\"#2-Compilers-编译器\" class=\"headerlink\" title=\"2. Compilers(编译器)\"></a>2. Compilers(编译器)</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/Af9BI1GDC1.JPG\" alt=\"Compilers\"></p>\n<p><strong>Offline</strong>: produces an executable<br>The executable is <strong>another program</strong>, might be another language or bytecode, it can be <strong>run separately</strong> on data.</p>\n<h3 id=\"01-02-FORTRAN\"><a href=\"#01-02-FORTRAN\" class=\"headerlink\" title=\"01-02. FORTRAN:\"></a>01-02. FORTRAN:</h3><p>FORTRAN ( Formula Translation Project )：<strong>The first successful high level language</strong>.<br>Meanings : The formulas were translated into a form that the machine could execute directly.</p>\n<p>Programming languages = fairly deep theory + good engineering skills</p>\n<p>The structure of FORTRAN one:<br>1.Lexical Analysis (词法分析)<br>2.Parsing (语法分析)<br>3.Semantic Analysis (语义分析)<br>4.Optimization (优化)<br>5.Code Generation (代码生成)</p>\n<h4 id=\"1-Lexical-Analysis-词法分析\"><a href=\"#1-Lexical-Analysis-词法分析\" class=\"headerlink\" title=\"1.Lexical Analysis (词法分析)\"></a>1.Lexical Analysis (词法分析)</h4><p>Goal : <strong>divide</strong> the program text into its <strong>tokens</strong> (words)(符号).</p>\n<p>Example of tokens :<br>1.key words 关键词 ( like “if”)<br>2.variable names 变量名 (“x”,”y”,”z”)<br>3.constants 常量 (“1”,”2”)<br>4.operators 运算符(“=”,”==”)<br>5.punctuation 标点符号(“;” “,”)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/I3eDhhmCgf.JPG\" alt=\"tokens\"></p>\n<h4 id=\"2-Parsing-语法分析\"><a href=\"#2-Parsing-语法分析\" class=\"headerlink\" title=\"2.Parsing (语法分析)\"></a>2.Parsing (语法分析)</h4><p>Goal : <strong>diagramming sentences </strong>(分析句子)</p>\n<p>The first step : Identify the role of each word<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/EkedKA1ch4.JPG\" alt=\"structure tree\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/kAjm7Bi5B2.JPG\" alt=\"structure tree\"></p>\n<h4 id=\"3-Semantic-Analysis-语义分析\"><a href=\"#3-Semantic-Analysis-语义分析\" class=\"headerlink\" title=\"3.Semantic Analysis (语义分析)\"></a>3.Semantic Analysis (语义分析)</h4><p>The compilers can only do very<strong> limited</strong> kinds of semantic analysis.</p>\n<p>It generally try to catch inconsistencies. (捕捉异常)</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/6bhGdDehIL.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/d07LaK2mgh.JPG\" alt=\"lexically scoped\"></p>\n<h4 id=\"4-Optimization-优化\"><a href=\"#4-Optimization-优化\" class=\"headerlink\" title=\"4.Optimization (优化)\"></a>4.Optimization (优化)</h4><p>Goal : To modify the program so that it <strong>uses less of some resource</strong> ,(use less time, run faster or use less space)</p>\n<p>if(x and y are integers)<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/lKCdIdhI1K.JPG\" alt=\"Optimization\"></p>\n<h4 id=\"5-Code-Generation-代码生成\"><a href=\"#5-Code-Generation-代码生成\" class=\"headerlink\" title=\"5.Code Generation (代码生成)\"></a>5.Code Generation (代码生成)</h4><p>The most common goal : produce assembly code (生成汇编代码)</p>\n<p>General goal : do a translation into some other languages.</p>\n<h4 id=\"The-proportions-比例\"><a href=\"#The-proportions-比例\" class=\"headerlink\" title=\"The proportions (比例)\"></a>The proportions (比例)</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/CAJ9Dbc8jJ.JPG\" alt=\"proportions\"></p>\n<p>FORTRAN I :<br>complex lexical analysis phase and parsing phase,<br>small semantic anaysis phase (very weak)</p>\n<p>Today:<br>very little in parsing and lexical analysis. ( we have good tools to help us )<br>very large optimization phase<br>a small code-generation phase ( we also have good tools )</p>\n<h3 id=\"01-03-The-Economy-of-Programming-Languages\"><a href=\"#01-03-The-Economy-of-Programming-Languages\" class=\"headerlink\" title=\"01-03. The Economy of Programming Languages\"></a>01-03. The Economy of Programming Languages</h3><p>1.Why are there so many programming languages<br>2.Why are there new programming languages<br>3.What is a good programming language</p>\n<h4 id=\"1-Why-are-there-so-many-programming-languages\"><a href=\"#1-Why-are-there-so-many-programming-languages\" class=\"headerlink\" title=\"1. Why are there so many programming languages\"></a>1. Why are there so many programming languages</h4><p>1.<strong>application domains</strong>(应用域) have distinctive and conflicting needs.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170823/gcEe09H4AH.JPG\" alt=\"application domains\"></p>\n<p>It would be<strong> difficult to integrate all of these into one system </strong>that would do good job on all of these things.</p>\n<h4 id=\"2-Why-are-there-new-programming-languages\"><a href=\"#2-Why-are-there-new-programming-languages\" class=\"headerlink\" title=\"2. Why are there new programming languages\"></a>2. Why are there new programming languages</h4><p><strong>Programmer training</strong> is the dominant cost for a programming language</p>\n<p>Here are some facts:</p>\n<ol>\n<li><p>Widely-used languages are slow to change</p>\n<blockquote>\n<p>Design and build a compiler for a new language are not actually taht expensive.<br>The real cost is in all the <strong>users and educating them</strong>.</p>\n</blockquote>\n</li>\n<li><p>Easy to start a new language</p>\n<blockquote>\n<p>Zero or low training cost<br>Adapt quickly to changing situations, not very costly to experiment.</p>\n</blockquote>\n</li>\n<li><p>Languages adopted to fill a void</p>\n<blockquote>\n<p>Programming languages exist for <strong>purpose</strong>.<br>There are <strong>new application domains</strong> coming along all the time.</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"3-What-is-a-good-programming-language\"><a href=\"#3-What-is-a-good-programming-language\" class=\"headerlink\" title=\"3. What is a good programming language\"></a>3. What is a good programming language</h4><p>There is <strong>no universally accepted metric</strong>(普遍接受的标准) for language design.</p>\n<h3 id=\"02-01-03-Cool-Overview\"><a href=\"#02-01-03-Cool-Overview\" class=\"headerlink\" title=\"02-(01-03). Cool Overview\"></a>02-(01-03). Cool Overview</h3><p><strong>COOL</strong>: Classroom Object Oriented Language</p>\n<p>COOL -&gt; MIPS assembly language</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Int &#123; 1 &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():IO &#123;  i.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti : IO &lt;- new IO;</span><br><span class=\"line\">\tmain():Object &#123;  i.out_string(&quot;Hello World!\\n&quot;); 1; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  (new IO).out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  self.out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():IO &#123;  out_string(&quot;Hello World!\\n&quot;) &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string( (new IO).in_string.concat(&quot;\\n\\&quot;) )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// in_string : 接受输入，返回string</span><br><span class=\"line\">// concat :  连接字符串</span><br><span class=\"line\">class Main inherits A2I    // ascii to integer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( a2i(new IO).in_string)+1 ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int &#123; if(i=0) then 1 else i*fact(i-1) fi &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main inherits A2I</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain():Object </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t(new IO).out_string(  i2a( fact(a2i(new IO).in_string) ).concat(&quot;\\n\\&quot;)       )</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfact( i: Int ) : Int </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\tlet fact: Int &lt;- 1 in  // 声明局部变量</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\twhile ( not (i=0) ) loop</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tfact &lt;- fact*i;</span><br><span class=\"line\">\t\t\t\ti &lt;- i-1;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tpool;</span><br><span class=\"line\">\t\t\tfact;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class List inherits A2I    //链表类</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\titem : Object;    // 数据</span><br><span class=\"line\">\tnext : List ;    // 指向下一个</span><br><span class=\"line\">\tinit ( i: Object , n: List ): List</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\titem &lt;- i;</span><br><span class=\"line\">\t\tnext &lt;- n;</span><br><span class=\"line\">\t\tself;    // 返回值为List </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tflatten (): String</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet string : String &lt;-</span><br><span class=\"line\">\t\t\tcase item of       // 相当于switch    关键词为 case .. of </span><br><span class=\"line\">\t\t\t\ti : Int =&gt; i2a(i);     //  变量名+“:”+类型+操作</span><br><span class=\"line\">\t\t\t\ts : String =&gt; s;</span><br><span class=\"line\">\t\t\t\to : Object =&gt; &#123; abort(); &quot;&quot;; &#125;;    // 相当于default分支，因abort返回Object类，为避免编译错误所以在最后加了&quot;&quot; 以返回String</span><br><span class=\"line\">\t\t\tesac;    // case的结束标志</span><br><span class=\"line\">\t\tin    // 局部变量范围</span><br><span class=\"line\">\t\t\tif ( isvoid next ) then    // 若next为空</span><br><span class=\"line\">\t\t\t\tstring</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tstring.concat(next.flatte())</span><br><span class=\"line\">\t\t\tfi     // if的结束标志</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">class Main inherits IO</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmain(): Object</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlet \thello : String &lt;- &quot;Hello &quot;,</span><br><span class=\"line\">\t\t\tworld : String &lt;- &quot;World!&quot;,</span><br><span class=\"line\">\t\t\tnewline: String &lt;- &quot;\\n&quot;,</span><br><span class=\"line\">\t\t\tnil : List,    // 不初始化则自动为空，因没有NULL标记</span><br><span class=\"line\">\t\t\tlist : List &lt;-</span><br><span class=\"line\">\t\t\t\t(new List).init(hello, </span><br><span class=\"line\">\t\t\t\t\t(new List).init(world,</span><br><span class=\"line\">\t\t\t\t\t\t(new List).init(newline, nil ) ) )</span><br><span class=\"line\">\t\tin</span><br><span class=\"line\">\t\t\tout_string(list.flatten())</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>语法：<br>class 是一系列method(函数)的集合，每个method以大括号+分号结尾<br>必有Main class和main函数<br>函数后用 “：”+”type” 声明函数的返回类型<br>单个表达式无需分号，多个表达式以分号分隔，无需写明返回值为哪个，返回值为最后一个表达式<br>所有类继承自Object, self相当于其它语言中的this<br>用“=”作判断，用”&lt;-“作赋值<br>if以fi作为结尾<br>loop以pool结尾<br>case..of以esac结尾，每个分支都要以分号结尾</p>"},{"layout":"post","title":"第一个自制c++小游戏：Cyclooctane","date":"2017-05-10T16:00:00.000Z","comments":1,"_content":"\n\n游戏名：Cyclooctane\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途：黑框框比赛、C++大作业\n语言：C++\n代码量：3.6k+\n开发时间：30天，2017/04/11->2017/05/10\n推荐分辨率：1920*1080\n=============================================\n\n## 写在前面的话\n\n2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。\n\n<!-- more -->\n\n游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。\n之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。\n绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。\n游戏里的基本算法有碰撞检测、A*、快速排序等\n游戏整体框架和状态转移用基于虚继承的有限状态机\n其它包括基础图形学函数还有一些公式也是自行实现与推演的。\n游戏比较简陋，希望各位莫见笑。\n\n## 游戏概述：\n\n陷入黑暗的勇者被迫进行轮回的战斗\n\n### 游戏介绍：\n\n> 房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）\n>\n> 在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 每闯一定数目关卡有升级或切换人物机会\n>\n> 地形分地刺和岩石，地刺有间歇型地刺和永久型地刺\n>\n> 怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量\n>\n> 为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim)\n\n### 游戏特色：\n\n```\n1.自行实现的基础计算机图形学函数\n2.未使用第三方图形库、游戏引擎、STL\n3.三个主角，6种特色攻击方式\n4.无限挑战模式, 狩猎角色变更玩法\n5.人物升级、更换系统\n6.基于分离轴原理的碰撞检测\n7.局部更新绘图\n8.利用有限状态机实现的游戏状态转移\n9.存读档系统\n10.基于游戏特性而作改动的A*寻路算法\n\n```\n\n### 角色介绍：\n\n#### Benzene：（定位：灵活血厚弱攻击型）\n\n普通攻击为发射子弹，对怪物造成1点伤害\n大招为立即消灭此时出现的所有怪物并获得旋转地图能力\n无法自由切换普通攻击和大招，作为补偿大招无CD\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim)\n\n#### Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\n\n形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力\n形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射\n形态三为旋转地图能力\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim)\n\n#### Pyran：（定位：中规中矩稳健型）\n\n形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）\n形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim)\n\n### 怪物介绍：\n\n血量以边数进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim)\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：使用大招或切换形态\nESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回\nEnter：确定\n\n```\n\n涉及数据结构：链表、队列等\n\n涉及算法：快速排序、分离轴原理、A*、有限状态机等\n\n### 展望：\n\n```\n1.金钱系统、商店系统、地图系统、成就系统\n2.特色道具\n3.可攻击的特殊精英怪物、BOSS\n4.基于哈希函数的种子\n5.分层闯关打BOSS模式\n6.用IDA*或D*或导航网格优化寻路\n\n```\n\n## 完整代码\n\n<https://github.com/zedom1/Cyclooctane>","source":"_posts/Cyclooctane.md","raw":"---\nlayout: post\ntitle: \"第一个自制c++小游戏：Cyclooctane\"\ndate: 2017-05-11\ncomments: true\ntags: \n\t- 游戏\n\t- c++\n---\n\n\n游戏名：Cyclooctane\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途：黑框框比赛、C++大作业\n语言：C++\n代码量：3.6k+\n开发时间：30天，2017/04/11->2017/05/10\n推荐分辨率：1920*1080\n=============================================\n\n## 写在前面的话\n\n2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。\n\n<!-- more -->\n\n游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。\n之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。\n绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。\n游戏里的基本算法有碰撞检测、A*、快速排序等\n游戏整体框架和状态转移用基于虚继承的有限状态机\n其它包括基础图形学函数还有一些公式也是自行实现与推演的。\n游戏比较简陋，希望各位莫见笑。\n\n## 游戏概述：\n\n陷入黑暗的勇者被迫进行轮回的战斗\n\n### 游戏介绍：\n\n> 房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）\n>\n> 在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 每闯一定数目关卡有升级或切换人物机会\n>\n> 地形分地刺和岩石，地刺有间歇型地刺和永久型地刺\n>\n> 怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量\n>\n> 为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim)\n\n### 游戏特色：\n\n```\n1.自行实现的基础计算机图形学函数\n2.未使用第三方图形库、游戏引擎、STL\n3.三个主角，6种特色攻击方式\n4.无限挑战模式, 狩猎角色变更玩法\n5.人物升级、更换系统\n6.基于分离轴原理的碰撞检测\n7.局部更新绘图\n8.利用有限状态机实现的游戏状态转移\n9.存读档系统\n10.基于游戏特性而作改动的A*寻路算法\n\n```\n\n### 角色介绍：\n\n#### Benzene：（定位：灵活血厚弱攻击型）\n\n普通攻击为发射子弹，对怪物造成1点伤害\n大招为立即消灭此时出现的所有怪物并获得旋转地图能力\n无法自由切换普通攻击和大招，作为补偿大招无CD\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim)\n\n#### Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\n\n形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力\n形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射\n形态三为旋转地图能力\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim)\n\n#### Pyran：（定位：中规中矩稳健型）\n\n形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）\n形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果\n可自由切换形态\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim)\n\n### 怪物介绍：\n\n血量以边数进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim)\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：使用大招或切换形态\nESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回\nEnter：确定\n\n```\n\n涉及数据结构：链表、队列等\n\n涉及算法：快速排序、分离轴原理、A*、有限状态机等\n\n### 展望：\n\n```\n1.金钱系统、商店系统、地图系统、成就系统\n2.特色道具\n3.可攻击的特殊精英怪物、BOSS\n4.基于哈希函数的种子\n5.分层闯关打BOSS模式\n6.用IDA*或D*或导航网格优化寻路\n\n```\n\n## 完整代码\n\n<https://github.com/zedom1/Cyclooctane>","slug":"Cyclooctane","published":1,"updated":"2018-05-25T12:41:11.994Z","photos":[],"link":"","_id":"cjhvssad50001jvfcjprn7ada","content":"<p>游戏名：Cyclooctane<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途：黑框框比赛、C++大作业<br>语言：C++<br>代码量：3.6k+<br>开发时间：30天，2017/04/11-&gt;2017/05/10</p>\n<h1 id=\"推荐分辨率：1920-1080\"><a href=\"#推荐分辨率：1920-1080\" class=\"headerlink\" title=\"推荐分辨率：1920*1080\"></a>推荐分辨率：1920*1080</h1><h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。</p>\n<a id=\"more\"></a>\n<p>游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。<br>之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。<br>绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。<br>游戏里的基本算法有碰撞检测、A*、快速排序等<br>游戏整体框架和状态转移用基于虚继承的有限状态机<br>其它包括基础图形学函数还有一些公式也是自行实现与推演的。<br>游戏比较简陋，希望各位莫见笑。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><p>陷入黑暗的勇者被迫进行轮回的战斗</p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）</p>\n<p>在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>每闯一定数目关卡有升级或切换人物机会</p>\n<p>地形分地刺和岩石，地刺有间歇型地刺和永久型地刺</p>\n<p>怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量</p>\n<p>为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.自行实现的基础计算机图形学函数</span><br><span class=\"line\">2.未使用第三方图形库、游戏引擎、STL</span><br><span class=\"line\">3.三个主角，6种特色攻击方式</span><br><span class=\"line\">4.无限挑战模式, 狩猎角色变更玩法</span><br><span class=\"line\">5.人物升级、更换系统</span><br><span class=\"line\">6.基于分离轴原理的碰撞检测</span><br><span class=\"line\">7.局部更新绘图</span><br><span class=\"line\">8.利用有限状态机实现的游戏状态转移</span><br><span class=\"line\">9.存读档系统</span><br><span class=\"line\">10.基于游戏特性而作改动的A*寻路算法</span><br></pre></td></tr></table></figure>\n<h3 id=\"角色介绍：\"><a href=\"#角色介绍：\" class=\"headerlink\" title=\"角色介绍：\"></a>角色介绍：</h3><h4 id=\"Benzene：（定位：灵活血厚弱攻击型）\"><a href=\"#Benzene：（定位：灵活血厚弱攻击型）\" class=\"headerlink\" title=\"Benzene：（定位：灵活血厚弱攻击型）\"></a>Benzene：（定位：灵活血厚弱攻击型）</h4><p>普通攻击为发射子弹，对怪物造成1点伤害<br>大招为立即消灭此时出现的所有怪物并获得旋转地图能力<br>无法自由切换普通攻击和大招，作为补偿大招无CD<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"><a href=\"#Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\" class=\"headerlink\" title=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"></a>Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）</h4><p>形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力<br>形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射<br>形态三为旋转地图能力<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Pyran：（定位：中规中矩稳健型）\"><a href=\"#Pyran：（定位：中规中矩稳健型）\" class=\"headerlink\" title=\"Pyran：（定位：中规中矩稳健型）\"></a>Pyran：（定位：中规中矩稳健型）</h4><p>形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）<br>形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"怪物介绍：\"><a href=\"#怪物介绍：\" class=\"headerlink\" title=\"怪物介绍：\"></a>怪物介绍：</h3><p>血量以边数进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：使用大招或切换形态</span><br><span class=\"line\">ESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<p>涉及数据结构：链表、队列等</p>\n<p>涉及算法：快速排序、分离轴原理、A*、有限状态机等</p>\n<h3 id=\"展望：\"><a href=\"#展望：\" class=\"headerlink\" title=\"展望：\"></a>展望：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.金钱系统、商店系统、地图系统、成就系统</span><br><span class=\"line\">2.特色道具</span><br><span class=\"line\">3.可攻击的特殊精英怪物、BOSS</span><br><span class=\"line\">4.基于哈希函数的种子</span><br><span class=\"line\">5.分层闯关打BOSS模式</span><br><span class=\"line\">6.用IDA*或D*或导航网格优化寻路</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/zedom1/Cyclooctane\" target=\"_blank\" rel=\"noopener\">https://github.com/zedom1/Cyclooctane</a></p>\n","site":{"data":{}},"excerpt":"<p>游戏名：Cyclooctane<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途：黑框框比赛、C++大作业<br>语言：C++<br>代码量：3.6k+<br>开发时间：30天，2017/04/11-&gt;2017/05/10</p>\n<h1 id=\"推荐分辨率：1920-1080\"><a href=\"#推荐分辨率：1920-1080\" class=\"headerlink\" title=\"推荐分辨率：1920*1080\"></a>推荐分辨率：1920*1080</h1><h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>2017年4月，院内举办了个黑框框比赛，正好没什么事情做就去报名参加了，这么一来一个月就搭进去了，但收获很大，从黑黑的控制台中稍微抬头看了眼四周。</p>","more":"<p>游戏基本创意来自以撒的结合，但还有许多是自己的想法以及和朋友讨论的结果。<br>之前还未做过上千行的项目，这次算是给自己的锻炼机会，因此所有的地方都自己来做，尽可能用最简单最底层(还是c++)的方法实现。<br>绘图方面是纯粹调用windows的API，非常麻烦和痛苦，不使用图形库和游戏引擎。<br>游戏里的基本算法有碰撞检测、A*、快速排序等<br>游戏整体框架和状态转移用基于虚继承的有限状态机<br>其它包括基础图形学函数还有一些公式也是自行实现与推演的。<br>游戏比较简陋，希望各位莫见笑。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><p>陷入黑暗的勇者被迫进行轮回的战斗</p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内每秒都有怪物随机生成，可能出生在地刺上也可能就在玩家身边（距离至少50）</p>\n<p>在房间待一段时间后，玩家将会失去攻击能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>每闯一定数目关卡有升级或切换人物机会</p>\n<p>地形分地刺和岩石，地刺有间歇型地刺和永久型地刺</p>\n<p>怪物分为普通怪物和精英怪物，精英怪物分别可无视地刺、岩石和怪物碰撞体积，速度较普通怪物快（温馨提示：用普通怪物碰撞体积卡住精英怪）</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s，初始血量固定但不显示即时血量</p>\n<p>为体现游戏恶意，开始游戏时玩家出生点不作判定，出生在岩石上会被弹开，出生在地刺上开局扣血</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/4Gj7EDGCb9.jpg?imageslim\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/DaLfe1Gc0k.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.自行实现的基础计算机图形学函数</span><br><span class=\"line\">2.未使用第三方图形库、游戏引擎、STL</span><br><span class=\"line\">3.三个主角，6种特色攻击方式</span><br><span class=\"line\">4.无限挑战模式, 狩猎角色变更玩法</span><br><span class=\"line\">5.人物升级、更换系统</span><br><span class=\"line\">6.基于分离轴原理的碰撞检测</span><br><span class=\"line\">7.局部更新绘图</span><br><span class=\"line\">8.利用有限状态机实现的游戏状态转移</span><br><span class=\"line\">9.存读档系统</span><br><span class=\"line\">10.基于游戏特性而作改动的A*寻路算法</span><br></pre></td></tr></table></figure>\n<h3 id=\"角色介绍：\"><a href=\"#角色介绍：\" class=\"headerlink\" title=\"角色介绍：\"></a>角色介绍：</h3><h4 id=\"Benzene：（定位：灵活血厚弱攻击型）\"><a href=\"#Benzene：（定位：灵活血厚弱攻击型）\" class=\"headerlink\" title=\"Benzene：（定位：灵活血厚弱攻击型）\"></a>Benzene：（定位：灵活血厚弱攻击型）</h4><p>普通攻击为发射子弹，对怪物造成1点伤害<br>大招为立即消灭此时出现的所有怪物并获得旋转地图能力<br>无法自由切换普通攻击和大招，作为补偿大招无CD<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/eDe0i08J8A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"><a href=\"#Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\" class=\"headerlink\" title=\"Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）\"></a>Cyclohexadiene：（定位：缓慢脆皮多功能高杀伤型）</h4><p>形态一为穿透激光，对直线上怪物造成一点伤害，对怪物有穿透能力<br>形态二为即死激光，秒杀碰到的怪物，但会因碰到怪物而反射<br>形态三为旋转地图能力<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AK6hFjcL0A.jpg?imageslim\" alt=\"mark\"></p>\n<h4 id=\"Pyran：（定位：中规中矩稳健型）\"><a href=\"#Pyran：（定位：中规中矩稳健型）\" class=\"headerlink\" title=\"Pyran：（定位：中规中矩稳健型）\"></a>Pyran：（定位：中规中矩稳健型）</h4><p>形态一为爆弹，在接触到第一个怪物后爆炸，产生半径75的圆并对其中所有的怪物造成秒杀效果（会伤害自己）<br>形态二为悬浮，子弹数目恒为一，子弹增大并脱离本体变为可操纵形态，用方向键操控悬浮子弹，对触碰到的怪物造成秒杀效果<br>可自由切换形态<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/JlEm66Jhal.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"怪物介绍：\"><a href=\"#怪物介绍：\" class=\"headerlink\" title=\"怪物介绍：\"></a>怪物介绍：</h3><p>血量以边数进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/A6bd0bHAHd.jpg?imageslim\" alt=\"mark\"></p>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：使用大招或切换形态</span><br><span class=\"line\">ESC：游戏中暂停、退出升级（没错你可以选择不升级）、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<p>涉及数据结构：链表、队列等</p>\n<p>涉及算法：快速排序、分离轴原理、A*、有限状态机等</p>\n<h3 id=\"展望：\"><a href=\"#展望：\" class=\"headerlink\" title=\"展望：\"></a>展望：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.金钱系统、商店系统、地图系统、成就系统</span><br><span class=\"line\">2.特色道具</span><br><span class=\"line\">3.可攻击的特殊精英怪物、BOSS</span><br><span class=\"line\">4.基于哈希函数的种子</span><br><span class=\"line\">5.分层闯关打BOSS模式</span><br><span class=\"line\">6.用IDA*或D*或导航网格优化寻路</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/zedom1/Cyclooctane\" target=\"_blank\" rel=\"noopener\">https://github.com/zedom1/Cyclooctane</a></p>"},{"layout":"post","title":"编译原理笔记（二）：词法分析","date":"2017-08-23T16:00:00.000Z","comments":1,"_content":"\n\n## 03-01. Lexical Analysis\n\n**Goal **:\n1 - Recognize substrings corresponding to tokens. ( **lexemes**: substrings )\n2 - Identify the token class of each lexeme.\n3 - Communicate tokens to the parser.\n\n<!-- more -->\n\nWhat the likes of human being will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG)\nWhat the likes of analyzer will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG)\n\n**Token classes**: the role of different elements\nIn a programming language: Identifiers、keywords、’(‘、’)’、numbers….\n**Token classes correspond to sets of strings.**\n\n- Identifier: 标识符\n\n  > strings of letters or digits, starting with a letter\n  > like “a1”,”A0o”\n\n- Number:\n\n  > a non-empty string of digits\n  > like “9”,”001”\n\n- Keyword: 关键字\n\n  > “else” or “if” or “begin “…\n\n- Whitespace:\n\n  > a non-empty swquence of blanks, newlines, and tabs\n\n- Operator:\n\n  > “==”…\n\nThe output of the lexical analyzer: **a series of pairs **which are the token class.\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG)\n\n## 03-02. Lexical Analysis example\n\n1 - The goal is to **partition the string** . This is implemented by reading left-to-right, recognizing **one token at a time**.\n\n2 - **look ahead** may be required to decide where one token ends and the next token begins.\n\n> but we would like to **minimize** the amount of look ahead.\n\n## (extra) 03-02x 词法分析器的实现\n\n1 - 手工编码实现\n相对复杂，且容易出错\n但是目前主流的实现方式\n对词法分析器各部分掌握精确，效率高\n如 GCC、LLVM\n\n2 - 词法分析器的生成器\n可快速生成原型、代码量小\n难以控制实现细节\n如 lex、flex、jlex\n\n### 03-02x-01 手工编码实现\n\n#### 方法一：转移图算法\n\n根据需求画出状态转移图：\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG)\n而后实现该算法：\n\n```\nenum kind{IF , LPAREN , ID, INTLIT, ...};\nstruct token\n{\n\tenum kind k;\n\tchar *lexeme;\n};\ntoken nextToken()\n{\n\tc=getchar();\n\tswitch(c)\n\t{\n\t\tcase '<': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=': return LE;\n\t\t\t\tcase '>': return NE;\n\t\t\t\tdefault: rollback(); return LT;\n\t\t\t}\n\t\tcase '=': return EQ;\n\t\tcase '>': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=' return GE;\n\t\t\t\tdefault: rollback(); return GT;\n\t\t\t}\n\t}\n}\n```\n\n#### 方法二：关键字表算法\n\n对给定语言中所有关键字，构造关键字构成的哈希表H\n对所有标识符和关键字，先统一按转移图识别\n识别后，查看表H是否为关键字\n通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成\n\n## 03-03. Regular Languages (正则语言)\n\nWe must say what set of strings is in a token class.\n\n- The usual tool is to use regular languages( 正则语言 ).\n\n  **Regular expression** (正则表达式) : define the regular language\n  each regular expression is a set.\n\n**1.Basic regular expression:**\n\n- Single character\n\n  > ‘c’= {“c”}\n\n- Epsilon\n\n  > $\\epsilon$ = {“”}\n  > It is a language that has a single string namely the empty string\n  > $\\epsilon$ != $\\emptyset$\n\n**2.Compound regular expression:**\n\n- Union\n  ![union](http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG)\n\n- Concatenation\n  choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.\n  ![Concatenation](http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG)\n\n- Iteration\n  It means one concatenated with itself i times.\n  ![Iteration](http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG)\n\n  Besides:\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG)\n  A+：there has to be at least one A\n\n  There is **more than one way** to write down **the same set**.\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG)\n\n  Quiz :\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG)\n\nExplanation:\n\n> 1. The given regular expression requires every string have at least one 1.\n> 2. (10 + 11 + 1) can be replaced by 1\n> 3. (0+1)* equals to (1+0)*\n\n## 03-04. Formal Languages (形式语言)\n\nLet $\\Sigma$ be a set of characters\nA language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$\n\n### Meaning function: L\n\nL($\\epsilon$)= {“”}\nL: Expression -> Sets of Strings\nWe apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.\n\nWhy use a meaning function?\n\n- Makes clear what is syntax, what is semantics.\n- Allows us to consider notation as a seperate issue\n- Because expressions and meanings are not 1-1\n\n## 03-05. Lexical Specifications\n\n### write regular expressions\n\n1 . Keyword: “if” or “else” or “then”…\n![Keyword](http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG)\n\n2 . Integer: a non-empty string of digits\n![Integer](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG)\n\n3 . Identifier: strings of letters or digits, starting with a letter\nuse square brackets to write a range of characters.\nhave the starting character and an ending character and then separate them by a hyphen.\n\n> [ a - z ] = ‘a’+’b’+’c’…..+’z’\n> ![Identifier](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG)\n\n4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.\n![Whitespace](http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG)\n\n![digits](http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG)\n\n- Regular expressions describe many useful languages\n- Regular languages are a language specification\n\n## 04-01. Lexical Specification\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG)\n\n1 . Write a regular expression for the lexemes of each token class.\n\n> Number = digit+\n> Keyword = ‘if’ + ‘else’…\n> Identifier = letter ( letter + digit )*\n> OpenPar=’(‘….\n> 2 . Construct R, matching all lexemes for all tokens.\n> R= Keyword + Identifier + Number +…\n> = R1 + R2 …\n> 3 . Let input be x1..xn\n> For 1<=i<=n check x1..xi$\\in$L(R)?\n> 4 . If success , then we know that\n> x1..xi $\\in$ L(Rj) for some j\n> 5 . Remove x1..xn from input and go to (3)\n\n### Questions:\n\n1 . How much input is used?\nif x1..xi $\\in$ L(R)\nx1..xj $\\in$ L(R) (i!=j)\n\n> like “=” and “==”\n> **Maximal Munch**: choose the longer one\n\n2 . Whick token is used?\n\n> like “if” is both a keyword and an identifier\n\nUse a priority ordering (优先排序)\nthe rule is to **choose the one listed first**\n\n3 . What if no rule matches?\n\n**do good error handling.**\nCompilers can’t simply crash, it should be able to give the user **a feedback** about where the error is and what kind of error it is.\n\nSolution: **write a category of error strings**and put it in the last of the priority list.\n\n### Summary:\n\n- Use in lexical analysis requires small extensions\n\n  > 1. To resolve ambiguities\n  >\n  >    > 1. matches as long as possible\n  >    > 2. highest priority match\n  >\n  > 2. To handle errors\n  >\n  >    > 1. write a category of error strings and put it in the last of the priority list.\n\n- Good algorithms known\n\n  > 1. Require only single pass over the input\n  > 2. Few operations per character (table lookup)\n\n- Regular expression\n\n  > $\\epsilon$\n  > a\n  > a|b\n  > ab\n  > a*[a-z] == a|b|c…|za+ == a(a)*\n  > a? == $\\epsilon$|a\n  > “a*“ != a*\n  > e{1,3} == (e)|(ee)|(eee)\n  > . == [^\\n]\n\n## 04-02. Finite Automata (有限状态自动机)\n\n**Finite Automata**: are a very convenience as an implementation mechanism for regular expressions.\n\n### A finite automaton consists of :\n\n- An input alphabet **$\\Sigma$**\n- A finite set of states **S**\n- A start state **n**\n- A set of accepting states **F \\subseteq S**\n- A set of transitions state -> (input) state\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG)\n\nTransition s1 ->(a) -> s2\nIf end of input and in accepting state => accept state\nOtherwise => reject state\n\n> terminates in state S \\not\\in $ Final state\n> gets stuck. (no transition)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG)\n\nAnother kind of transition: **$\\epsilon$-moves**\n\nThe automaton can move to a different state without consuming any input.\n\n### Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\n\n- One transition per input per state\n- No $\\epsilon$-moves\n  A DFA takes only** one path **through the state graph\n  **DFAs are faster to execute**\n  **Every DFA is also an NFA**\n\n### Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\n\n- Can have multiple transitions for one input int a given state\n\n- Can have $\\epsilon$-moves\n  An NFA can choose\n  It accepts if some choices lead to an accepting state\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG)\n  In every step an NFA is in a set of states of the machine.\n  We can consider all the possible moves.\n  We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.\n  **NFAs are much more smaller than DFAs.**\n\n## 04-03. Regular expressions into NFAs\n\n![steps](http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG)\n\nFor each kind of regular expression, define an equivalent NFA.\n\n**Thompson Algorithm:**\n\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG)\n\n![quiz](http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG)\n\n## 04-04. NFA to DFA\n\n**$\\epsilon$-closure **\nchoose a state and look at the states that can be reached by following **only epsilon moves**.\n\n![closure](http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG)\n\nHow many different states can an NFA get into ?\n\n> if there are N states\n> The states NFA can get into at most n different states.\n> |S|<=N\n\nHow to convert an NFA to a DFA?\n\n> There are $2^n -1 $ possible subsets of n states.\n> **This is a finite set of possible configurations.**\n> Use DFA to **simulate the behaviour** of the NFA.\n> O($2^n$)\n\nDefine an NFA:\n![NFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG)\n\nDefine a DFA:\n![DFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG)\n\nTransition\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG)\n\n**子集构造算法：**\n工作表算法伪代码：\n\n```\nq0 <- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态\n// eps_closure 为找到s0的所有$\\epsilon$可到达的状态\nQ <- {q0}    // Q 为DFA的所有状态集合\nworkList <- q0   // 队列\nwhile( workList != [] )    \n{\n\tremove q from workList // 队列不为空则取队首元素\n\tforeach (character c)   // 循环判断每个字符\n\t{\n\t\tt <- e-closure( delta(q,c) ) \n\t\t  // delta函数 计算q中每个状态通过c所能到的状态\n\t\t  // t为q通过c所能到的下一个状态集合\n\t\tD[q ,c ] <- t   // 在DFA中记录：q通过c可以转换到t\n\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展\n\t\t\tadd t to Q and workList\n\t}\n}\n```\n\n## 04-05. Implementing Finite Automata\n\n### DFA -> Table-driven Implemetation\n\nNFA -> DFA -> list a 2-dimensional state table -> translate into code\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG)\n\nWe can also use 1-dimensional tables save space.\nThe table contains a pointer to a vector of moves for that particular state.\n**share the rows that are duplicated in the automaton**\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG)\n\n#### DFA 最小化\n\n**Hopcroft 最小化算法**\n伪代码\n\n```\nsplit(S)  // 集合切分\n{\t\n\tforeach (character c )\n\t\tif(c can split S) // S中某些状态通过c转移到同样的状态\n\t\t\tsplit S into T1 , ... Tk\n}\nhopcroft()\n{\n\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份\n\twhile( set is still changes ) // S是否刚刚被切分\n\t\tsplit(S)\n}\n```\n\n#### DFA 代码实现\n\nDFA是一个有向图\n可以根据转移表（类似邻接矩阵），哈希表，跳转表\n\n##### 转移表\n\n将字符和状态先填入一个二维数组table\n例如：\n\n```\ntable [0]['a']=1;\ntable [1]['b']=1;\n....\n```\n\n伪代码\n\n```\nnextToken()\n{\n\tstate=0;  // 当前到了哪个状态，如q0\n\tstack=[];  // 为了实现最长匹配机制\n\twhile( state!=ERROR )\n\t{\n\t\tc=getchar();\n\t\tif(state is ACCEPT)\n\t\t\tclear(stack) \n\t\tpush(state)\n\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态\n\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态\n\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环\n\t}\n\twhile( state is not ACCEPT )\n\t{\n\t\tstate=pop();\n\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)\n\t}\n}\n```\n\n##### 跳转表 jump table\n\n好处：不需要维护一个状态和字符的二维数组并且效率高\n伪代码\n\n```\nnextToken()\n{\n\tstate =0\n\tstack = []\n\tgoto q0\n\nq0:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush (state)\n\tif(c=='a')\n\tgoto q1\n\nq1:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush(state)\n\tif(c=='b'||c=='c')\n\t\tgoto q1\n}\n```\n\n### NFA -> Table-driven Implemetation\n\nIt is also possible that we might not want to convert to a DFA.\nIt might be that the particular specification we gave is very expensive to turn into a DFA.\n\nImplement transition via a table\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG)\n\n## Quiz\n\n### Quiz 1\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG)\n\n> We have 16 distinct strings of length 4,\n> 8 distinct strings of length 3,\n> 4 distinct strings of length 2,\n> 2 distinct strings of length 1,\n> and one empty string\n> Ans=16+8+4+2+1=31\n\n### Quiz 2\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG)\n\n> This is a priority ordering, we should check the list from the beginning to the end.\n> We also have to choose the **Maximal Munch**\n\n### Quiz 3\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG)\n\n> **Maximal Munch**: both rule 3 and 4 match the whole string\n> But the rule 3 has a higher priority.\n\n### Quiz 4\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG)\n\n### Quiz 5\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG)\n\n> We need n states to culculate the number of 0 and 2n states to culculate the number of 1\n> n+2n+1(start state)=3n+1\n\n### Quiz 6\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG)\n\n### Quiz 7\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG)\n\n### Quiz 8\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG)\n\n> b*(ab)* -> abab match better than a(ba)*\n\n### Quiz 9\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG)\n\n### Quiz 10\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG)\n\n> “11” and “1”\n>\n> ### Quiz 11\n>\n> ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim)\n>\n> DFAs must have finite states, no ϵ-moves, and one transition per input per state.\n> The last option has infinite states.\n\n### Quiz 12\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim)\n\n> NFAs must have a finite set of states, which rules out the last option. **Every DFA is also an NFA**, which is why the first option is included.","source":"_posts/Compiler2.md","raw":"---\nlayout: post\ntitle: \"编译原理笔记（二）：词法分析\"\ndate: 2017-08-24\ncomments: true\ntags: \n\t- 编译原理\n\t- 学习笔记\n---\n\n\n## 03-01. Lexical Analysis\n\n**Goal **:\n1 - Recognize substrings corresponding to tokens. ( **lexemes**: substrings )\n2 - Identify the token class of each lexeme.\n3 - Communicate tokens to the parser.\n\n<!-- more -->\n\nWhat the likes of human being will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG)\nWhat the likes of analyzer will see:\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG)\n\n**Token classes**: the role of different elements\nIn a programming language: Identifiers、keywords、’(‘、’)’、numbers….\n**Token classes correspond to sets of strings.**\n\n- Identifier: 标识符\n\n  > strings of letters or digits, starting with a letter\n  > like “a1”,”A0o”\n\n- Number:\n\n  > a non-empty string of digits\n  > like “9”,”001”\n\n- Keyword: 关键字\n\n  > “else” or “if” or “begin “…\n\n- Whitespace:\n\n  > a non-empty swquence of blanks, newlines, and tabs\n\n- Operator:\n\n  > “==”…\n\nThe output of the lexical analyzer: **a series of pairs **which are the token class.\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG)\n\n## 03-02. Lexical Analysis example\n\n1 - The goal is to **partition the string** . This is implemented by reading left-to-right, recognizing **one token at a time**.\n\n2 - **look ahead** may be required to decide where one token ends and the next token begins.\n\n> but we would like to **minimize** the amount of look ahead.\n\n## (extra) 03-02x 词法分析器的实现\n\n1 - 手工编码实现\n相对复杂，且容易出错\n但是目前主流的实现方式\n对词法分析器各部分掌握精确，效率高\n如 GCC、LLVM\n\n2 - 词法分析器的生成器\n可快速生成原型、代码量小\n难以控制实现细节\n如 lex、flex、jlex\n\n### 03-02x-01 手工编码实现\n\n#### 方法一：转移图算法\n\n根据需求画出状态转移图：\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG)\n而后实现该算法：\n\n```\nenum kind{IF , LPAREN , ID, INTLIT, ...};\nstruct token\n{\n\tenum kind k;\n\tchar *lexeme;\n};\ntoken nextToken()\n{\n\tc=getchar();\n\tswitch(c)\n\t{\n\t\tcase '<': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=': return LE;\n\t\t\t\tcase '>': return NE;\n\t\t\t\tdefault: rollback(); return LT;\n\t\t\t}\n\t\tcase '=': return EQ;\n\t\tcase '>': c=getchar();\n\t\t\tswitch(c)\n\t\t\t{\n\t\t\t\tcase '=' return GE;\n\t\t\t\tdefault: rollback(); return GT;\n\t\t\t}\n\t}\n}\n```\n\n#### 方法二：关键字表算法\n\n对给定语言中所有关键字，构造关键字构成的哈希表H\n对所有标识符和关键字，先统一按转移图识别\n识别后，查看表H是否为关键字\n通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成\n\n## 03-03. Regular Languages (正则语言)\n\nWe must say what set of strings is in a token class.\n\n- The usual tool is to use regular languages( 正则语言 ).\n\n  **Regular expression** (正则表达式) : define the regular language\n  each regular expression is a set.\n\n**1.Basic regular expression:**\n\n- Single character\n\n  > ‘c’= {“c”}\n\n- Epsilon\n\n  > $\\epsilon$ = {“”}\n  > It is a language that has a single string namely the empty string\n  > $\\epsilon$ != $\\emptyset$\n\n**2.Compound regular expression:**\n\n- Union\n  ![union](http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG)\n\n- Concatenation\n  choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.\n  ![Concatenation](http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG)\n\n- Iteration\n  It means one concatenated with itself i times.\n  ![Iteration](http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG)\n\n  Besides:\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG)\n  A+：there has to be at least one A\n\n  There is **more than one way** to write down **the same set**.\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG)\n\n  Quiz :\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG)\n\nExplanation:\n\n> 1. The given regular expression requires every string have at least one 1.\n> 2. (10 + 11 + 1) can be replaced by 1\n> 3. (0+1)* equals to (1+0)*\n\n## 03-04. Formal Languages (形式语言)\n\nLet $\\Sigma$ be a set of characters\nA language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$\n\n### Meaning function: L\n\nL($\\epsilon$)= {“”}\nL: Expression -> Sets of Strings\nWe apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.\n\nWhy use a meaning function?\n\n- Makes clear what is syntax, what is semantics.\n- Allows us to consider notation as a seperate issue\n- Because expressions and meanings are not 1-1\n\n## 03-05. Lexical Specifications\n\n### write regular expressions\n\n1 . Keyword: “if” or “else” or “then”…\n![Keyword](http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG)\n\n2 . Integer: a non-empty string of digits\n![Integer](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG)\n\n3 . Identifier: strings of letters or digits, starting with a letter\nuse square brackets to write a range of characters.\nhave the starting character and an ending character and then separate them by a hyphen.\n\n> [ a - z ] = ‘a’+’b’+’c’…..+’z’\n> ![Identifier](http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG)\n\n4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.\n![Whitespace](http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG)\n\n![digits](http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG)\n\n- Regular expressions describe many useful languages\n- Regular languages are a language specification\n\n## 04-01. Lexical Specification\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG)\n\n1 . Write a regular expression for the lexemes of each token class.\n\n> Number = digit+\n> Keyword = ‘if’ + ‘else’…\n> Identifier = letter ( letter + digit )*\n> OpenPar=’(‘….\n> 2 . Construct R, matching all lexemes for all tokens.\n> R= Keyword + Identifier + Number +…\n> = R1 + R2 …\n> 3 . Let input be x1..xn\n> For 1<=i<=n check x1..xi$\\in$L(R)?\n> 4 . If success , then we know that\n> x1..xi $\\in$ L(Rj) for some j\n> 5 . Remove x1..xn from input and go to (3)\n\n### Questions:\n\n1 . How much input is used?\nif x1..xi $\\in$ L(R)\nx1..xj $\\in$ L(R) (i!=j)\n\n> like “=” and “==”\n> **Maximal Munch**: choose the longer one\n\n2 . Whick token is used?\n\n> like “if” is both a keyword and an identifier\n\nUse a priority ordering (优先排序)\nthe rule is to **choose the one listed first**\n\n3 . What if no rule matches?\n\n**do good error handling.**\nCompilers can’t simply crash, it should be able to give the user **a feedback** about where the error is and what kind of error it is.\n\nSolution: **write a category of error strings**and put it in the last of the priority list.\n\n### Summary:\n\n- Use in lexical analysis requires small extensions\n\n  > 1. To resolve ambiguities\n  >\n  >    > 1. matches as long as possible\n  >    > 2. highest priority match\n  >\n  > 2. To handle errors\n  >\n  >    > 1. write a category of error strings and put it in the last of the priority list.\n\n- Good algorithms known\n\n  > 1. Require only single pass over the input\n  > 2. Few operations per character (table lookup)\n\n- Regular expression\n\n  > $\\epsilon$\n  > a\n  > a|b\n  > ab\n  > a*[a-z] == a|b|c…|za+ == a(a)*\n  > a? == $\\epsilon$|a\n  > “a*“ != a*\n  > e{1,3} == (e)|(ee)|(eee)\n  > . == [^\\n]\n\n## 04-02. Finite Automata (有限状态自动机)\n\n**Finite Automata**: are a very convenience as an implementation mechanism for regular expressions.\n\n### A finite automaton consists of :\n\n- An input alphabet **$\\Sigma$**\n- A finite set of states **S**\n- A start state **n**\n- A set of accepting states **F \\subseteq S**\n- A set of transitions state -> (input) state\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG)\n\nTransition s1 ->(a) -> s2\nIf end of input and in accepting state => accept state\nOtherwise => reject state\n\n> terminates in state S \\not\\in $ Final state\n> gets stuck. (no transition)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG)\n\nAnother kind of transition: **$\\epsilon$-moves**\n\nThe automaton can move to a different state without consuming any input.\n\n### Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\n\n- One transition per input per state\n- No $\\epsilon$-moves\n  A DFA takes only** one path **through the state graph\n  **DFAs are faster to execute**\n  **Every DFA is also an NFA**\n\n### Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\n\n- Can have multiple transitions for one input int a given state\n\n- Can have $\\epsilon$-moves\n  An NFA can choose\n  It accepts if some choices lead to an accepting state\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG)\n  In every step an NFA is in a set of states of the machine.\n  We can consider all the possible moves.\n  We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.\n  **NFAs are much more smaller than DFAs.**\n\n## 04-03. Regular expressions into NFAs\n\n![steps](http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG)\n\nFor each kind of regular expression, define an equivalent NFA.\n\n**Thompson Algorithm:**\n\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG)\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG)\n\n![quiz](http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG)\n\n## 04-04. NFA to DFA\n\n**$\\epsilon$-closure **\nchoose a state and look at the states that can be reached by following **only epsilon moves**.\n\n![closure](http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG)\n\nHow many different states can an NFA get into ?\n\n> if there are N states\n> The states NFA can get into at most n different states.\n> |S|<=N\n\nHow to convert an NFA to a DFA?\n\n> There are $2^n -1 $ possible subsets of n states.\n> **This is a finite set of possible configurations.**\n> Use DFA to **simulate the behaviour** of the NFA.\n> O($2^n$)\n\nDefine an NFA:\n![NFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG)\n\nDefine a DFA:\n![DFA](http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG)\n\nTransition\n![Transition](http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG)\n\n**子集构造算法：**\n工作表算法伪代码：\n\n```\nq0 <- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态\n// eps_closure 为找到s0的所有$\\epsilon$可到达的状态\nQ <- {q0}    // Q 为DFA的所有状态集合\nworkList <- q0   // 队列\nwhile( workList != [] )    \n{\n\tremove q from workList // 队列不为空则取队首元素\n\tforeach (character c)   // 循环判断每个字符\n\t{\n\t\tt <- e-closure( delta(q,c) ) \n\t\t  // delta函数 计算q中每个状态通过c所能到的状态\n\t\t  // t为q通过c所能到的下一个状态集合\n\t\tD[q ,c ] <- t   // 在DFA中记录：q通过c可以转换到t\n\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展\n\t\t\tadd t to Q and workList\n\t}\n}\n```\n\n## 04-05. Implementing Finite Automata\n\n### DFA -> Table-driven Implemetation\n\nNFA -> DFA -> list a 2-dimensional state table -> translate into code\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG)\n\nWe can also use 1-dimensional tables save space.\nThe table contains a pointer to a vector of moves for that particular state.\n**share the rows that are duplicated in the automaton**\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG)\n\n#### DFA 最小化\n\n**Hopcroft 最小化算法**\n伪代码\n\n```\nsplit(S)  // 集合切分\n{\t\n\tforeach (character c )\n\t\tif(c can split S) // S中某些状态通过c转移到同样的状态\n\t\t\tsplit S into T1 , ... Tk\n}\nhopcroft()\n{\n\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份\n\twhile( set is still changes ) // S是否刚刚被切分\n\t\tsplit(S)\n}\n```\n\n#### DFA 代码实现\n\nDFA是一个有向图\n可以根据转移表（类似邻接矩阵），哈希表，跳转表\n\n##### 转移表\n\n将字符和状态先填入一个二维数组table\n例如：\n\n```\ntable [0]['a']=1;\ntable [1]['b']=1;\n....\n```\n\n伪代码\n\n```\nnextToken()\n{\n\tstate=0;  // 当前到了哪个状态，如q0\n\tstack=[];  // 为了实现最长匹配机制\n\twhile( state!=ERROR )\n\t{\n\t\tc=getchar();\n\t\tif(state is ACCEPT)\n\t\t\tclear(stack) \n\t\tpush(state)\n\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态\n\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态\n\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环\n\t}\n\twhile( state is not ACCEPT )\n\t{\n\t\tstate=pop();\n\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)\n\t}\n}\n```\n\n##### 跳转表 jump table\n\n好处：不需要维护一个状态和字符的二维数组并且效率高\n伪代码\n\n```\nnextToken()\n{\n\tstate =0\n\tstack = []\n\tgoto q0\n\nq0:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush (state)\n\tif(c=='a')\n\tgoto q1\n\nq1:\n\tc=getchar()\n\tif(state is ACCEPT)\n\t\tclear(stack)\n\tpush(state)\n\tif(c=='b'||c=='c')\n\t\tgoto q1\n}\n```\n\n### NFA -> Table-driven Implemetation\n\nIt is also possible that we might not want to convert to a DFA.\nIt might be that the particular specification we gave is very expensive to turn into a DFA.\n\nImplement transition via a table\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG)\n\n## Quiz\n\n### Quiz 1\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG)\n\n> We have 16 distinct strings of length 4,\n> 8 distinct strings of length 3,\n> 4 distinct strings of length 2,\n> 2 distinct strings of length 1,\n> and one empty string\n> Ans=16+8+4+2+1=31\n\n### Quiz 2\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG)\n\n> This is a priority ordering, we should check the list from the beginning to the end.\n> We also have to choose the **Maximal Munch**\n\n### Quiz 3\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG)\n\n> **Maximal Munch**: both rule 3 and 4 match the whole string\n> But the rule 3 has a higher priority.\n\n### Quiz 4\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG)\n\n### Quiz 5\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG)\n\n> We need n states to culculate the number of 0 and 2n states to culculate the number of 1\n> n+2n+1(start state)=3n+1\n\n### Quiz 6\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG)\n\n### Quiz 7\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG)\n\n### Quiz 8\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG)\n\n> b*(ab)* -> abab match better than a(ba)*\n\n### Quiz 9\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG)\n\n### Quiz 10\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG)\n\n> “11” and “1”\n>\n> ### Quiz 11\n>\n> ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim)\n>\n> DFAs must have finite states, no ϵ-moves, and one transition per input per state.\n> The last option has infinite states.\n\n### Quiz 12\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim)\n\n> NFAs must have a finite set of states, which rules out the last option. **Every DFA is also an NFA**, which is why the first option is included.","slug":"Compiler2","published":1,"updated":"2018-05-25T12:41:11.924Z","photos":[],"link":"","_id":"cjhvssadc0003jvfcy0g5a7gy","content":"<h2 id=\"03-01-Lexical-Analysis\"><a href=\"#03-01-Lexical-Analysis\" class=\"headerlink\" title=\"03-01. Lexical Analysis\"></a>03-01. Lexical Analysis</h2><p><strong>Goal </strong>:<br>1 - Recognize substrings corresponding to tokens. ( <strong>lexemes</strong>: substrings )<br>2 - Identify the token class of each lexeme.<br>3 - Communicate tokens to the parser.</p>\n<a id=\"more\"></a>\n<p>What the likes of human being will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG\" alt=\"mark\"><br>What the likes of analyzer will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG\" alt=\"mark\"></p>\n<p><strong>Token classes</strong>: the role of different elements<br>In a programming language: Identifiers、keywords、’(‘、’)’、numbers….<br><strong>Token classes correspond to sets of strings.</strong></p>\n<ul>\n<li><p>Identifier: 标识符</p>\n<blockquote>\n<p>strings of letters or digits, starting with a letter<br>like “a1”,”A0o”</p>\n</blockquote>\n</li>\n<li><p>Number:</p>\n<blockquote>\n<p>a non-empty string of digits<br>like “9”,”001”</p>\n</blockquote>\n</li>\n<li><p>Keyword: 关键字</p>\n<blockquote>\n<p>“else” or “if” or “begin “…</p>\n</blockquote>\n</li>\n<li><p>Whitespace:</p>\n<blockquote>\n<p>a non-empty swquence of blanks, newlines, and tabs</p>\n</blockquote>\n</li>\n<li><p>Operator:</p>\n<blockquote>\n<p>“==”…</p>\n</blockquote>\n</li>\n</ul>\n<p>The output of the lexical analyzer: <strong>a series of pairs </strong>which are the token class.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG\" alt=\"mark\"></p>\n<h2 id=\"03-02-Lexical-Analysis-example\"><a href=\"#03-02-Lexical-Analysis-example\" class=\"headerlink\" title=\"03-02. Lexical Analysis example\"></a>03-02. Lexical Analysis example</h2><p>1 - The goal is to <strong>partition the string</strong> . This is implemented by reading left-to-right, recognizing <strong>one token at a time</strong>.</p>\n<p>2 - <strong>look ahead</strong> may be required to decide where one token ends and the next token begins.</p>\n<blockquote>\n<p>but we would like to <strong>minimize</strong> the amount of look ahead.</p>\n</blockquote>\n<h2 id=\"extra-03-02x-词法分析器的实现\"><a href=\"#extra-03-02x-词法分析器的实现\" class=\"headerlink\" title=\"(extra) 03-02x 词法分析器的实现\"></a>(extra) 03-02x 词法分析器的实现</h2><p>1 - 手工编码实现<br>相对复杂，且容易出错<br>但是目前主流的实现方式<br>对词法分析器各部分掌握精确，效率高<br>如 GCC、LLVM</p>\n<p>2 - 词法分析器的生成器<br>可快速生成原型、代码量小<br>难以控制实现细节<br>如 lex、flex、jlex</p>\n<h3 id=\"03-02x-01-手工编码实现\"><a href=\"#03-02x-01-手工编码实现\" class=\"headerlink\" title=\"03-02x-01 手工编码实现\"></a>03-02x-01 手工编码实现</h3><h4 id=\"方法一：转移图算法\"><a href=\"#方法一：转移图算法\" class=\"headerlink\" title=\"方法一：转移图算法\"></a>方法一：转移图算法</h4><p>根据需求画出状态转移图：<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG\" alt=\"mark\"><br>而后实现该算法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum kind&#123;IF , LPAREN , ID, INTLIT, ...&#125;;</span><br><span class=\"line\">struct token</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tenum kind k;</span><br><span class=\"line\">\tchar *lexeme;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">token nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tc=getchar();</span><br><span class=\"line\">\tswitch(c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcase &apos;&lt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos;: return LE;</span><br><span class=\"line\">\t\t\t\tcase &apos;&gt;&apos;: return NE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return LT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;=&apos;: return EQ;</span><br><span class=\"line\">\t\tcase &apos;&gt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos; return GE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return GT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：关键字表算法\"><a href=\"#方法二：关键字表算法\" class=\"headerlink\" title=\"方法二：关键字表算法\"></a>方法二：关键字表算法</h4><p>对给定语言中所有关键字，构造关键字构成的哈希表H<br>对所有标识符和关键字，先统一按转移图识别<br>识别后，查看表H是否为关键字<br>通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成</p>\n<h2 id=\"03-03-Regular-Languages-正则语言\"><a href=\"#03-03-Regular-Languages-正则语言\" class=\"headerlink\" title=\"03-03. Regular Languages (正则语言)\"></a>03-03. Regular Languages (正则语言)</h2><p>We must say what set of strings is in a token class.</p>\n<ul>\n<li><p>The usual tool is to use regular languages( 正则语言 ).</p>\n<p><strong>Regular expression</strong> (正则表达式) : define the regular language<br>each regular expression is a set.</p>\n</li>\n</ul>\n<p><strong>1.Basic regular expression:</strong></p>\n<ul>\n<li><p>Single character</p>\n<blockquote>\n<p>‘c’= {“c”}</p>\n</blockquote>\n</li>\n<li><p>Epsilon</p>\n<blockquote>\n<p>$\\epsilon$ = {“”}<br>It is a language that has a single string namely the empty string<br>$\\epsilon$ != $\\emptyset$</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>2.Compound regular expression:</strong></p>\n<ul>\n<li><p>Union<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG\" alt=\"union\"></p>\n</li>\n<li><p>Concatenation<br>choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG\" alt=\"Concatenation\"></p>\n</li>\n<li><p>Iteration<br>It means one concatenated with itself i times.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG\" alt=\"Iteration\"></p>\n<p>Besides:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG\" alt=\"mark\"><br>A+：there has to be at least one A</p>\n<p>There is <strong>more than one way</strong> to write down <strong>the same set</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG\" alt=\"mark\"></p>\n<p>Quiz :<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG\" alt=\"mark\"></p>\n</li>\n</ul>\n<p>Explanation:</p>\n<blockquote>\n<ol>\n<li>The given regular expression requires every string have at least one 1.</li>\n<li>(10 + 11 + 1) can be replaced by 1</li>\n<li>(0+1)<em> equals to (1+0)</em></li>\n</ol>\n</blockquote>\n<h2 id=\"03-04-Formal-Languages-形式语言\"><a href=\"#03-04-Formal-Languages-形式语言\" class=\"headerlink\" title=\"03-04. Formal Languages (形式语言)\"></a>03-04. Formal Languages (形式语言)</h2><p>Let $\\Sigma$ be a set of characters<br>A language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$</p>\n<h3 id=\"Meaning-function-L\"><a href=\"#Meaning-function-L\" class=\"headerlink\" title=\"Meaning function: L\"></a>Meaning function: L</h3><p>L($\\epsilon$)= {“”}<br>L: Expression -&gt; Sets of Strings<br>We apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.</p>\n<p>Why use a meaning function?</p>\n<ul>\n<li>Makes clear what is syntax, what is semantics.</li>\n<li>Allows us to consider notation as a seperate issue</li>\n<li>Because expressions and meanings are not 1-1</li>\n</ul>\n<h2 id=\"03-05-Lexical-Specifications\"><a href=\"#03-05-Lexical-Specifications\" class=\"headerlink\" title=\"03-05. Lexical Specifications\"></a>03-05. Lexical Specifications</h2><h3 id=\"write-regular-expressions\"><a href=\"#write-regular-expressions\" class=\"headerlink\" title=\"write regular expressions\"></a>write regular expressions</h3><p>1 . Keyword: “if” or “else” or “then”…<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG\" alt=\"Keyword\"></p>\n<p>2 . Integer: a non-empty string of digits<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG\" alt=\"Integer\"></p>\n<p>3 . Identifier: strings of letters or digits, starting with a letter<br>use square brackets to write a range of characters.<br>have the starting character and an ending character and then separate them by a hyphen.</p>\n<blockquote>\n<p>[ a - z ] = ‘a’+’b’+’c’…..+’z’<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG\" alt=\"Identifier\"></p>\n</blockquote>\n<p>4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG\" alt=\"Whitespace\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG\" alt=\"digits\"></p>\n<ul>\n<li>Regular expressions describe many useful languages</li>\n<li>Regular languages are a language specification</li>\n</ul>\n<h2 id=\"04-01-Lexical-Specification\"><a href=\"#04-01-Lexical-Specification\" class=\"headerlink\" title=\"04-01. Lexical Specification\"></a>04-01. Lexical Specification</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG\" alt=\"mark\"></p>\n<p>1 . Write a regular expression for the lexemes of each token class.</p>\n<blockquote>\n<p>Number = digit+<br>Keyword = ‘if’ + ‘else’…<br>Identifier = letter ( letter + digit )*<br>OpenPar=’(‘….<br>2 . Construct R, matching all lexemes for all tokens.<br>R= Keyword + Identifier + Number +…<br>= R1 + R2 …<br>3 . Let input be x1..xn<br>For 1&lt;=i&lt;=n check x1..xi$\\in$L(R)?<br>4 . If success , then we know that<br>x1..xi $\\in$ L(Rj) for some j<br>5 . Remove x1..xn from input and go to (3)</p>\n</blockquote>\n<h3 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions:\"></a>Questions:</h3><p>1 . How much input is used?<br>if x1..xi $\\in$ L(R)<br>x1..xj $\\in$ L(R) (i!=j)</p>\n<blockquote>\n<p>like “=” and “==”<br><strong>Maximal Munch</strong>: choose the longer one</p>\n</blockquote>\n<p>2 . Whick token is used?</p>\n<blockquote>\n<p>like “if” is both a keyword and an identifier</p>\n</blockquote>\n<p>Use a priority ordering (优先排序)<br>the rule is to <strong>choose the one listed first</strong></p>\n<p>3 . What if no rule matches?</p>\n<p><strong>do good error handling.</strong><br>Compilers can’t simply crash, it should be able to give the user <strong>a feedback</strong> about where the error is and what kind of error it is.</p>\n<p>Solution: <strong>write a category of error strings</strong>and put it in the last of the priority list.</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary:\"></a>Summary:</h3><ul>\n<li><p>Use in lexical analysis requires small extensions</p>\n<blockquote>\n<ol>\n<li><p>To resolve ambiguities</p>\n<blockquote>\n<ol>\n<li>matches as long as possible</li>\n<li>highest priority match</li>\n</ol>\n</blockquote>\n</li>\n<li><p>To handle errors</p>\n<blockquote>\n<ol>\n<li>write a category of error strings and put it in the last of the priority list.</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Good algorithms known</p>\n<blockquote>\n<ol>\n<li>Require only single pass over the input</li>\n<li>Few operations per character (table lookup)</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Regular expression</p>\n<blockquote>\n<p>$\\epsilon$<br>a<br>a|b<br>ab<br>a<em>[a-z] == a|b|c…|za+ == a(a)</em><br>a? == $\\epsilon$|a<br>“a<em>“ != a</em><br>e{1,3} == (e)|(ee)|(eee)<br>. == <sup><a href=\"#fn_\\n\" id=\"reffn_\\n\">\\n</a></sup></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"04-02-Finite-Automata-有限状态自动机\"><a href=\"#04-02-Finite-Automata-有限状态自动机\" class=\"headerlink\" title=\"04-02. Finite Automata (有限状态自动机)\"></a>04-02. Finite Automata (有限状态自动机)</h2><p><strong>Finite Automata</strong>: are a very convenience as an implementation mechanism for regular expressions.</p>\n<h3 id=\"A-finite-automaton-consists-of\"><a href=\"#A-finite-automaton-consists-of\" class=\"headerlink\" title=\"A finite automaton consists of :\"></a>A finite automaton consists of :</h3><ul>\n<li>An input alphabet <strong>$\\Sigma$</strong></li>\n<li>A finite set of states <strong>S</strong></li>\n<li>A start state <strong>n</strong></li>\n<li>A set of accepting states <strong>F \\subseteq S</strong></li>\n<li>A set of transitions state -&gt; (input) state</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG\" alt=\"mark\"></p>\n<p>Transition s1 -&gt;(a) -&gt; s2<br>If end of input and in accepting state =&gt; accept state<br>Otherwise =&gt; reject state</p>\n<blockquote>\n<p>terminates in state S \\not\\in $ Final state<br>gets stuck. (no transition)</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG\" alt=\"mark\"></p>\n<p>Another kind of transition: <strong>$\\epsilon$-moves</strong></p>\n<p>The automaton can move to a different state without consuming any input.</p>\n<h3 id=\"Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\"><a href=\"#Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\" class=\"headerlink\" title=\"Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\"></a>Deterministic Finite Automata (DFA) (确定的有穷状态自动机)</h3><ul>\n<li>One transition per input per state</li>\n<li>No $\\epsilon$-moves<br>A DFA takes only<strong> one path </strong>through the state graph<br><strong>DFAs are faster to execute</strong><br><strong>Every DFA is also an NFA</strong></li>\n</ul>\n<h3 id=\"Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\"><a href=\"#Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\" class=\"headerlink\" title=\"Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\"></a>Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)</h3><ul>\n<li><p>Can have multiple transitions for one input int a given state</p>\n</li>\n<li><p>Can have $\\epsilon$-moves<br>An NFA can choose<br>It accepts if some choices lead to an accepting state</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG\" alt=\"mark\"><br>In every step an NFA is in a set of states of the machine.<br>We can consider all the possible moves.<br>We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.<br><strong>NFAs are much more smaller than DFAs.</strong></p>\n</li>\n</ul>\n<h2 id=\"04-03-Regular-expressions-into-NFAs\"><a href=\"#04-03-Regular-expressions-into-NFAs\" class=\"headerlink\" title=\"04-03. Regular expressions into NFAs\"></a>04-03. Regular expressions into NFAs</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG\" alt=\"steps\"></p>\n<p>For each kind of regular expression, define an equivalent NFA.</p>\n<p><strong>Thompson Algorithm:</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG\" alt=\"Transition\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG\" alt=\"quiz\"></p>\n<h2 id=\"04-04-NFA-to-DFA\"><a href=\"#04-04-NFA-to-DFA\" class=\"headerlink\" title=\"04-04. NFA to DFA\"></a>04-04. NFA to DFA</h2><p><strong>$\\epsilon$-closure </strong><br>choose a state and look at the states that can be reached by following <strong>only epsilon moves</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG\" alt=\"closure\"></p>\n<p>How many different states can an NFA get into ?</p>\n<blockquote>\n<p>if there are N states<br>The states NFA can get into at most n different states.<br>|S|&lt;=N</p>\n</blockquote>\n<p>How to convert an NFA to a DFA?</p>\n<blockquote>\n<p>There are $2^n -1 $ possible subsets of n states.<br><strong>This is a finite set of possible configurations.</strong><br>Use DFA to <strong>simulate the behaviour</strong> of the NFA.<br>O($2^n$)</p>\n</blockquote>\n<p>Define an NFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG\" alt=\"NFA\"></p>\n<p>Define a DFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG\" alt=\"DFA\"></p>\n<p>Transition<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG\" alt=\"Transition\"></p>\n<p><strong>子集构造算法：</strong><br>工作表算法伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q0 &lt;- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态</span><br><span class=\"line\">// eps_closure 为找到s0的所有$\\epsilon$可到达的状态</span><br><span class=\"line\">Q &lt;- &#123;q0&#125;    // Q 为DFA的所有状态集合</span><br><span class=\"line\">workList &lt;- q0   // 队列</span><br><span class=\"line\">while( workList != [] )    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tremove q from workList // 队列不为空则取队首元素</span><br><span class=\"line\">\tforeach (character c)   // 循环判断每个字符</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tt &lt;- e-closure( delta(q,c) ) </span><br><span class=\"line\">\t\t  // delta函数 计算q中每个状态通过c所能到的状态</span><br><span class=\"line\">\t\t  // t为q通过c所能到的下一个状态集合</span><br><span class=\"line\">\t\tD[q ,c ] &lt;- t   // 在DFA中记录：q通过c可以转换到t</span><br><span class=\"line\">\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展</span><br><span class=\"line\">\t\t\tadd t to Q and workList</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"04-05-Implementing-Finite-Automata\"><a href=\"#04-05-Implementing-Finite-Automata\" class=\"headerlink\" title=\"04-05. Implementing Finite Automata\"></a>04-05. Implementing Finite Automata</h2><h3 id=\"DFA-gt-Table-driven-Implemetation\"><a href=\"#DFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"DFA -&gt; Table-driven Implemetation\"></a>DFA -&gt; Table-driven Implemetation</h3><p>NFA -&gt; DFA -&gt; list a 2-dimensional state table -&gt; translate into code<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG\" alt=\"mark\"></p>\n<p>We can also use 1-dimensional tables save space.<br>The table contains a pointer to a vector of moves for that particular state.<br><strong>share the rows that are duplicated in the automaton</strong><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG\" alt=\"mark\"></p>\n<h4 id=\"DFA-最小化\"><a href=\"#DFA-最小化\" class=\"headerlink\" title=\"DFA 最小化\"></a>DFA 最小化</h4><p><strong>Hopcroft 最小化算法</strong><br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(S)  // 集合切分</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">\tforeach (character c )</span><br><span class=\"line\">\t\tif(c can split S) // S中某些状态通过c转移到同样的状态</span><br><span class=\"line\">\t\t\tsplit S into T1 , ... Tk</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hopcroft()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份</span><br><span class=\"line\">\twhile( set is still changes ) // S是否刚刚被切分</span><br><span class=\"line\">\t\tsplit(S)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DFA-代码实现\"><a href=\"#DFA-代码实现\" class=\"headerlink\" title=\"DFA 代码实现\"></a>DFA 代码实现</h4><p>DFA是一个有向图<br>可以根据转移表（类似邻接矩阵），哈希表，跳转表</p>\n<h5 id=\"转移表\"><a href=\"#转移表\" class=\"headerlink\" title=\"转移表\"></a>转移表</h5><p>将字符和状态先填入一个二维数组table<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table [0][&apos;a&apos;]=1;</span><br><span class=\"line\">table [1][&apos;b&apos;]=1;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate=0;  // 当前到了哪个状态，如q0</span><br><span class=\"line\">\tstack=[];  // 为了实现最长匹配机制</span><br><span class=\"line\">\twhile( state!=ERROR )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tc=getchar();</span><br><span class=\"line\">\t\tif(state is ACCEPT)</span><br><span class=\"line\">\t\t\tclear(stack) </span><br><span class=\"line\">\t\tpush(state)</span><br><span class=\"line\">\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态</span><br><span class=\"line\">\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态</span><br><span class=\"line\">\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( state is not ACCEPT )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstate=pop();</span><br><span class=\"line\">\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"跳转表-jump-table\"><a href=\"#跳转表-jump-table\" class=\"headerlink\" title=\"跳转表 jump table\"></a>跳转表 jump table</h5><p>好处：不需要维护一个状态和字符的二维数组并且效率高<br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate =0</span><br><span class=\"line\">\tstack = []</span><br><span class=\"line\">\tgoto q0</span><br><span class=\"line\"></span><br><span class=\"line\">q0:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush (state)</span><br><span class=\"line\">\tif(c==&apos;a&apos;)</span><br><span class=\"line\">\tgoto q1</span><br><span class=\"line\"></span><br><span class=\"line\">q1:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush(state)</span><br><span class=\"line\">\tif(c==&apos;b&apos;||c==&apos;c&apos;)</span><br><span class=\"line\">\t\tgoto q1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NFA-gt-Table-driven-Implemetation\"><a href=\"#NFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"NFA -&gt; Table-driven Implemetation\"></a>NFA -&gt; Table-driven Implemetation</h3><p>It is also possible that we might not want to convert to a DFA.<br>It might be that the particular specification we gave is very expensive to turn into a DFA.</p>\n<p>Implement transition via a table<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG\" alt=\"mark\"></p>\n<h2 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h2><h3 id=\"Quiz-1\"><a href=\"#Quiz-1\" class=\"headerlink\" title=\"Quiz 1\"></a>Quiz 1</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We have 16 distinct strings of length 4,<br>8 distinct strings of length 3,<br>4 distinct strings of length 2,<br>2 distinct strings of length 1,<br>and one empty string<br>Ans=16+8+4+2+1=31</p>\n</blockquote>\n<h3 id=\"Quiz-2\"><a href=\"#Quiz-2\" class=\"headerlink\" title=\"Quiz 2\"></a>Quiz 2</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>This is a priority ordering, we should check the list from the beginning to the end.<br>We also have to choose the <strong>Maximal Munch</strong></p>\n</blockquote>\n<h3 id=\"Quiz-3\"><a href=\"#Quiz-3\" class=\"headerlink\" title=\"Quiz 3\"></a>Quiz 3</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p><strong>Maximal Munch</strong>: both rule 3 and 4 match the whole string<br>But the rule 3 has a higher priority.</p>\n</blockquote>\n<h3 id=\"Quiz-4\"><a href=\"#Quiz-4\" class=\"headerlink\" title=\"Quiz 4\"></a>Quiz 4</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-5\"><a href=\"#Quiz-5\" class=\"headerlink\" title=\"Quiz 5\"></a>Quiz 5</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We need n states to culculate the number of 0 and 2n states to culculate the number of 1<br>n+2n+1(start state)=3n+1</p>\n</blockquote>\n<h3 id=\"Quiz-6\"><a href=\"#Quiz-6\" class=\"headerlink\" title=\"Quiz 6\"></a>Quiz 6</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-7\"><a href=\"#Quiz-7\" class=\"headerlink\" title=\"Quiz 7\"></a>Quiz 7</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-8\"><a href=\"#Quiz-8\" class=\"headerlink\" title=\"Quiz 8\"></a>Quiz 8</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>b<em>(ab)</em> -&gt; abab match better than a(ba)*</p>\n</blockquote>\n<h3 id=\"Quiz-9\"><a href=\"#Quiz-9\" class=\"headerlink\" title=\"Quiz 9\"></a>Quiz 9</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-10\"><a href=\"#Quiz-10\" class=\"headerlink\" title=\"Quiz 10\"></a>Quiz 10</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>“11” and “1”</p>\n<h3 id=\"Quiz-11\"><a href=\"#Quiz-11\" class=\"headerlink\" title=\"Quiz 11\"></a>Quiz 11</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim\" alt=\"mark\"></p>\n<p>DFAs must have finite states, no ϵ-moves, and one transition per input per state.<br>The last option has infinite states.</p>\n</blockquote>\n<h3 id=\"Quiz-12\"><a href=\"#Quiz-12\" class=\"headerlink\" title=\"Quiz 12\"></a>Quiz 12</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim\" alt=\"mark\"></p>\n<blockquote>\n<p>NFAs must have a finite set of states, which rules out the last option. <strong>Every DFA is also an NFA</strong>, which is why the first option is included.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"03-01-Lexical-Analysis\"><a href=\"#03-01-Lexical-Analysis\" class=\"headerlink\" title=\"03-01. Lexical Analysis\"></a>03-01. Lexical Analysis</h2><p><strong>Goal </strong>:<br>1 - Recognize substrings corresponding to tokens. ( <strong>lexemes</strong>: substrings )<br>2 - Identify the token class of each lexeme.<br>3 - Communicate tokens to the parser.</p>","more":"<p>What the likes of human being will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c2DJbIjL0F.JPG\" alt=\"mark\"><br>What the likes of analyzer will see:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/0bJg7Gfidl.JPG\" alt=\"mark\"></p>\n<p><strong>Token classes</strong>: the role of different elements<br>In a programming language: Identifiers、keywords、’(‘、’)’、numbers….<br><strong>Token classes correspond to sets of strings.</strong></p>\n<ul>\n<li><p>Identifier: 标识符</p>\n<blockquote>\n<p>strings of letters or digits, starting with a letter<br>like “a1”,”A0o”</p>\n</blockquote>\n</li>\n<li><p>Number:</p>\n<blockquote>\n<p>a non-empty string of digits<br>like “9”,”001”</p>\n</blockquote>\n</li>\n<li><p>Keyword: 关键字</p>\n<blockquote>\n<p>“else” or “if” or “begin “…</p>\n</blockquote>\n</li>\n<li><p>Whitespace:</p>\n<blockquote>\n<p>a non-empty swquence of blanks, newlines, and tabs</p>\n</blockquote>\n</li>\n<li><p>Operator:</p>\n<blockquote>\n<p>“==”…</p>\n</blockquote>\n</li>\n</ul>\n<p>The output of the lexical analyzer: <strong>a series of pairs </strong>which are the token class.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/ci2A7H3E5i.JPG\" alt=\"mark\"></p>\n<h2 id=\"03-02-Lexical-Analysis-example\"><a href=\"#03-02-Lexical-Analysis-example\" class=\"headerlink\" title=\"03-02. Lexical Analysis example\"></a>03-02. Lexical Analysis example</h2><p>1 - The goal is to <strong>partition the string</strong> . This is implemented by reading left-to-right, recognizing <strong>one token at a time</strong>.</p>\n<p>2 - <strong>look ahead</strong> may be required to decide where one token ends and the next token begins.</p>\n<blockquote>\n<p>but we would like to <strong>minimize</strong> the amount of look ahead.</p>\n</blockquote>\n<h2 id=\"extra-03-02x-词法分析器的实现\"><a href=\"#extra-03-02x-词法分析器的实现\" class=\"headerlink\" title=\"(extra) 03-02x 词法分析器的实现\"></a>(extra) 03-02x 词法分析器的实现</h2><p>1 - 手工编码实现<br>相对复杂，且容易出错<br>但是目前主流的实现方式<br>对词法分析器各部分掌握精确，效率高<br>如 GCC、LLVM</p>\n<p>2 - 词法分析器的生成器<br>可快速生成原型、代码量小<br>难以控制实现细节<br>如 lex、flex、jlex</p>\n<h3 id=\"03-02x-01-手工编码实现\"><a href=\"#03-02x-01-手工编码实现\" class=\"headerlink\" title=\"03-02x-01 手工编码实现\"></a>03-02x-01 手工编码实现</h3><h4 id=\"方法一：转移图算法\"><a href=\"#方法一：转移图算法\" class=\"headerlink\" title=\"方法一：转移图算法\"></a>方法一：转移图算法</h4><p>根据需求画出状态转移图：<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/c3GCd3ElG2.JPG\" alt=\"mark\"><br>而后实现该算法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum kind&#123;IF , LPAREN , ID, INTLIT, ...&#125;;</span><br><span class=\"line\">struct token</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tenum kind k;</span><br><span class=\"line\">\tchar *lexeme;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">token nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tc=getchar();</span><br><span class=\"line\">\tswitch(c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcase &apos;&lt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos;: return LE;</span><br><span class=\"line\">\t\t\t\tcase &apos;&gt;&apos;: return NE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return LT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;=&apos;: return EQ;</span><br><span class=\"line\">\t\tcase &apos;&gt;&apos;: c=getchar();</span><br><span class=\"line\">\t\t\tswitch(c)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcase &apos;=&apos; return GE;</span><br><span class=\"line\">\t\t\t\tdefault: rollback(); return GT;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：关键字表算法\"><a href=\"#方法二：关键字表算法\" class=\"headerlink\" title=\"方法二：关键字表算法\"></a>方法二：关键字表算法</h4><p>对给定语言中所有关键字，构造关键字构成的哈希表H<br>对所有标识符和关键字，先统一按转移图识别<br>识别后，查看表H是否为关键字<br>通过合理构造哈希表H(完美哈希)，可以以O(1)时间完成</p>\n<h2 id=\"03-03-Regular-Languages-正则语言\"><a href=\"#03-03-Regular-Languages-正则语言\" class=\"headerlink\" title=\"03-03. Regular Languages (正则语言)\"></a>03-03. Regular Languages (正则语言)</h2><p>We must say what set of strings is in a token class.</p>\n<ul>\n<li><p>The usual tool is to use regular languages( 正则语言 ).</p>\n<p><strong>Regular expression</strong> (正则表达式) : define the regular language<br>each regular expression is a set.</p>\n</li>\n</ul>\n<p><strong>1.Basic regular expression:</strong></p>\n<ul>\n<li><p>Single character</p>\n<blockquote>\n<p>‘c’= {“c”}</p>\n</blockquote>\n</li>\n<li><p>Epsilon</p>\n<blockquote>\n<p>$\\epsilon$ = {“”}<br>It is a language that has a single string namely the empty string<br>$\\epsilon$ != $\\emptyset$</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>2.Compound regular expression:</strong></p>\n<ul>\n<li><p>Union<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/hJfgaJGKEm.JPG\" alt=\"union\"></p>\n</li>\n<li><p>Concatenation<br>choose a string from A and a string from B and then combine, put them together with the string from a first and choosing strings at all possible ways from all possible combined strings.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/LDGkL285mA.JPG\" alt=\"Concatenation\"></p>\n</li>\n<li><p>Iteration<br>It means one concatenated with itself i times.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/BfBClc54ha.JPG\" alt=\"Iteration\"></p>\n<p>Besides:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/6ffL3l8eII.JPG\" alt=\"mark\"><br>A+：there has to be at least one A</p>\n<p>There is <strong>more than one way</strong> to write down <strong>the same set</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/225dBIdEgb.JPG\" alt=\"mark\"></p>\n<p>Quiz :<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/c29161Cfd1.JPG\" alt=\"mark\"></p>\n</li>\n</ul>\n<p>Explanation:</p>\n<blockquote>\n<ol>\n<li>The given regular expression requires every string have at least one 1.</li>\n<li>(10 + 11 + 1) can be replaced by 1</li>\n<li>(0+1)<em> equals to (1+0)</em></li>\n</ol>\n</blockquote>\n<h2 id=\"03-04-Formal-Languages-形式语言\"><a href=\"#03-04-Formal-Languages-形式语言\" class=\"headerlink\" title=\"03-04. Formal Languages (形式语言)\"></a>03-04. Formal Languages (形式语言)</h2><p>Let $\\Sigma$ be a set of characters<br>A language over $\\Sigma$ is a set of string of characters drawn from $\\Sigma$</p>\n<h3 id=\"Meaning-function-L\"><a href=\"#Meaning-function-L\" class=\"headerlink\" title=\"Meaning function: L\"></a>Meaning function: L</h3><p>L($\\epsilon$)= {“”}<br>L: Expression -&gt; Sets of Strings<br>We apply L to deconpose the compund expressions into several expressions that we compute the meaning of and then computed the sets from those separate smaller sets.</p>\n<p>Why use a meaning function?</p>\n<ul>\n<li>Makes clear what is syntax, what is semantics.</li>\n<li>Allows us to consider notation as a seperate issue</li>\n<li>Because expressions and meanings are not 1-1</li>\n</ul>\n<h2 id=\"03-05-Lexical-Specifications\"><a href=\"#03-05-Lexical-Specifications\" class=\"headerlink\" title=\"03-05. Lexical Specifications\"></a>03-05. Lexical Specifications</h2><h3 id=\"write-regular-expressions\"><a href=\"#write-regular-expressions\" class=\"headerlink\" title=\"write regular expressions\"></a>write regular expressions</h3><p>1 . Keyword: “if” or “else” or “then”…<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/mH7DDJeB3l.JPG\" alt=\"Keyword\"></p>\n<p>2 . Integer: a non-empty string of digits<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a1i4ebijJe.JPG\" alt=\"Integer\"></p>\n<p>3 . Identifier: strings of letters or digits, starting with a letter<br>use square brackets to write a range of characters.<br>have the starting character and an ending character and then separate them by a hyphen.</p>\n<blockquote>\n<p>[ a - z ] = ‘a’+’b’+’c’…..+’z’<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/a044F7C3f1.JPG\" alt=\"Identifier\"></p>\n</blockquote>\n<p>4 . Whitespace: a non-empty sequence of blanks, newlines, and tabs.<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/Ehe5KDm9DK.JPG\" alt=\"Whitespace\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/lGg51K9GmI.JPG\" alt=\"digits\"></p>\n<ul>\n<li>Regular expressions describe many useful languages</li>\n<li>Regular languages are a language specification</li>\n</ul>\n<h2 id=\"04-01-Lexical-Specification\"><a href=\"#04-01-Lexical-Specification\" class=\"headerlink\" title=\"04-01. Lexical Specification\"></a>04-01. Lexical Specification</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/60A270jmd5.JPG\" alt=\"mark\"></p>\n<p>1 . Write a regular expression for the lexemes of each token class.</p>\n<blockquote>\n<p>Number = digit+<br>Keyword = ‘if’ + ‘else’…<br>Identifier = letter ( letter + digit )*<br>OpenPar=’(‘….<br>2 . Construct R, matching all lexemes for all tokens.<br>R= Keyword + Identifier + Number +…<br>= R1 + R2 …<br>3 . Let input be x1..xn<br>For 1&lt;=i&lt;=n check x1..xi$\\in$L(R)?<br>4 . If success , then we know that<br>x1..xi $\\in$ L(Rj) for some j<br>5 . Remove x1..xn from input and go to (3)</p>\n</blockquote>\n<h3 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions:\"></a>Questions:</h3><p>1 . How much input is used?<br>if x1..xi $\\in$ L(R)<br>x1..xj $\\in$ L(R) (i!=j)</p>\n<blockquote>\n<p>like “=” and “==”<br><strong>Maximal Munch</strong>: choose the longer one</p>\n</blockquote>\n<p>2 . Whick token is used?</p>\n<blockquote>\n<p>like “if” is both a keyword and an identifier</p>\n</blockquote>\n<p>Use a priority ordering (优先排序)<br>the rule is to <strong>choose the one listed first</strong></p>\n<p>3 . What if no rule matches?</p>\n<p><strong>do good error handling.</strong><br>Compilers can’t simply crash, it should be able to give the user <strong>a feedback</strong> about where the error is and what kind of error it is.</p>\n<p>Solution: <strong>write a category of error strings</strong>and put it in the last of the priority list.</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary:\"></a>Summary:</h3><ul>\n<li><p>Use in lexical analysis requires small extensions</p>\n<blockquote>\n<ol>\n<li><p>To resolve ambiguities</p>\n<blockquote>\n<ol>\n<li>matches as long as possible</li>\n<li>highest priority match</li>\n</ol>\n</blockquote>\n</li>\n<li><p>To handle errors</p>\n<blockquote>\n<ol>\n<li>write a category of error strings and put it in the last of the priority list.</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Good algorithms known</p>\n<blockquote>\n<ol>\n<li>Require only single pass over the input</li>\n<li>Few operations per character (table lookup)</li>\n</ol>\n</blockquote>\n</li>\n<li><p>Regular expression</p>\n<blockquote>\n<p>$\\epsilon$<br>a<br>a|b<br>ab<br>a<em>[a-z] == a|b|c…|za+ == a(a)</em><br>a? == $\\epsilon$|a<br>“a<em>“ != a</em><br>e{1,3} == (e)|(ee)|(eee)<br>. == <sup><a href=\"#fn_\\n\" id=\"reffn_\\n\">\\n</a></sup></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"04-02-Finite-Automata-有限状态自动机\"><a href=\"#04-02-Finite-Automata-有限状态自动机\" class=\"headerlink\" title=\"04-02. Finite Automata (有限状态自动机)\"></a>04-02. Finite Automata (有限状态自动机)</h2><p><strong>Finite Automata</strong>: are a very convenience as an implementation mechanism for regular expressions.</p>\n<h3 id=\"A-finite-automaton-consists-of\"><a href=\"#A-finite-automaton-consists-of\" class=\"headerlink\" title=\"A finite automaton consists of :\"></a>A finite automaton consists of :</h3><ul>\n<li>An input alphabet <strong>$\\Sigma$</strong></li>\n<li>A finite set of states <strong>S</strong></li>\n<li>A start state <strong>n</strong></li>\n<li>A set of accepting states <strong>F \\subseteq S</strong></li>\n<li>A set of transitions state -&gt; (input) state</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/Dm5hjkKeGC.JPG\" alt=\"mark\"></p>\n<p>Transition s1 -&gt;(a) -&gt; s2<br>If end of input and in accepting state =&gt; accept state<br>Otherwise =&gt; reject state</p>\n<blockquote>\n<p>terminates in state S \\not\\in $ Final state<br>gets stuck. (no transition)</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/FKD6FFmgJ2.JPG\" alt=\"mark\"></p>\n<p>Another kind of transition: <strong>$\\epsilon$-moves</strong></p>\n<p>The automaton can move to a different state without consuming any input.</p>\n<h3 id=\"Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\"><a href=\"#Deterministic-Finite-Automata-DFA-确定的有穷状态自动机\" class=\"headerlink\" title=\"Deterministic Finite Automata (DFA) (确定的有穷状态自动机)\"></a>Deterministic Finite Automata (DFA) (确定的有穷状态自动机)</h3><ul>\n<li>One transition per input per state</li>\n<li>No $\\epsilon$-moves<br>A DFA takes only<strong> one path </strong>through the state graph<br><strong>DFAs are faster to execute</strong><br><strong>Every DFA is also an NFA</strong></li>\n</ul>\n<h3 id=\"Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\"><a href=\"#Nondeterministic-Finite-Automata-NFA-非确定的有穷状态自动机\" class=\"headerlink\" title=\"Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)\"></a>Nondeterministic Finite Automata (NFA) (非确定的有穷状态自动机)</h3><ul>\n<li><p>Can have multiple transitions for one input int a given state</p>\n</li>\n<li><p>Can have $\\epsilon$-moves<br>An NFA can choose<br>It accepts if some choices lead to an accepting state</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170824/gdLcfhGJKB.JPG\" alt=\"mark\"><br>In every step an NFA is in a set of states of the machine.<br>We can consider all the possible moves.<br>We look at the last set of states after the last input character is read and if there’s any final state in that set, then the machine accepts.<br><strong>NFAs are much more smaller than DFAs.</strong></p>\n</li>\n</ul>\n<h2 id=\"04-03-Regular-expressions-into-NFAs\"><a href=\"#04-03-Regular-expressions-into-NFAs\" class=\"headerlink\" title=\"04-03. Regular expressions into NFAs\"></a>04-03. Regular expressions into NFAs</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/bKF0cmjGKd.JPG\" alt=\"steps\"></p>\n<p>For each kind of regular expression, define an equivalent NFA.</p>\n<p><strong>Thompson Algorithm:</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/i3FI550glK.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EgEe117kFh.JPG\" alt=\"Transition\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/3E2G1150hL.JPG\" alt=\"Transition\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/9AlcACHLHD.JPG\" alt=\"quiz\"></p>\n<h2 id=\"04-04-NFA-to-DFA\"><a href=\"#04-04-NFA-to-DFA\" class=\"headerlink\" title=\"04-04. NFA to DFA\"></a>04-04. NFA to DFA</h2><p><strong>$\\epsilon$-closure </strong><br>choose a state and look at the states that can be reached by following <strong>only epsilon moves</strong>.</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/4H05J22cg1.JPG\" alt=\"closure\"></p>\n<p>How many different states can an NFA get into ?</p>\n<blockquote>\n<p>if there are N states<br>The states NFA can get into at most n different states.<br>|S|&lt;=N</p>\n</blockquote>\n<p>How to convert an NFA to a DFA?</p>\n<blockquote>\n<p>There are $2^n -1 $ possible subsets of n states.<br><strong>This is a finite set of possible configurations.</strong><br>Use DFA to <strong>simulate the behaviour</strong> of the NFA.<br>O($2^n$)</p>\n</blockquote>\n<p>Define an NFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/744hcDeEhc.JPG\" alt=\"NFA\"></p>\n<p>Define a DFA:<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/050HKEm80c.JPG\" alt=\"DFA\"></p>\n<p>Transition<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/JA4Eaa9917.JPG\" alt=\"Transition\"></p>\n<p><strong>子集构造算法：</strong><br>工作表算法伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q0 &lt;- eps_closure(s0)   // s0为NFA起始状态，q0为新构造的DFA的状态</span><br><span class=\"line\">// eps_closure 为找到s0的所有$\\epsilon$可到达的状态</span><br><span class=\"line\">Q &lt;- &#123;q0&#125;    // Q 为DFA的所有状态集合</span><br><span class=\"line\">workList &lt;- q0   // 队列</span><br><span class=\"line\">while( workList != [] )    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tremove q from workList // 队列不为空则取队首元素</span><br><span class=\"line\">\tforeach (character c)   // 循环判断每个字符</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tt &lt;- e-closure( delta(q,c) ) </span><br><span class=\"line\">\t\t  // delta函数 计算q中每个状态通过c所能到的状态</span><br><span class=\"line\">\t\t  // t为q通过c所能到的下一个状态集合</span><br><span class=\"line\">\t\tD[q ,c ] &lt;- t   // 在DFA中记录：q通过c可以转换到t</span><br><span class=\"line\">\t\tif( t \\not \\in Q)  // t在队列中未出现的话，还需要继续扩展</span><br><span class=\"line\">\t\t\tadd t to Q and workList</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"04-05-Implementing-Finite-Automata\"><a href=\"#04-05-Implementing-Finite-Automata\" class=\"headerlink\" title=\"04-05. Implementing Finite Automata\"></a>04-05. Implementing Finite Automata</h2><h3 id=\"DFA-gt-Table-driven-Implemetation\"><a href=\"#DFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"DFA -&gt; Table-driven Implemetation\"></a>DFA -&gt; Table-driven Implemetation</h3><p>NFA -&gt; DFA -&gt; list a 2-dimensional state table -&gt; translate into code<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/j94m246b37.JPG\" alt=\"mark\"></p>\n<p>We can also use 1-dimensional tables save space.<br>The table contains a pointer to a vector of moves for that particular state.<br><strong>share the rows that are duplicated in the automaton</strong><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/0bCIjdDL14.JPG\" alt=\"mark\"></p>\n<h4 id=\"DFA-最小化\"><a href=\"#DFA-最小化\" class=\"headerlink\" title=\"DFA 最小化\"></a>DFA 最小化</h4><p><strong>Hopcroft 最小化算法</strong><br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(S)  // 集合切分</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">\tforeach (character c )</span><br><span class=\"line\">\t\tif(c can split S) // S中某些状态通过c转移到同样的状态</span><br><span class=\"line\">\t\t\tsplit S into T1 , ... Tk</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hopcroft()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsplit all nodes into N,A  // 先把大状态集合根据是否为接受状态分成两份</span><br><span class=\"line\">\twhile( set is still changes ) // S是否刚刚被切分</span><br><span class=\"line\">\t\tsplit(S)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DFA-代码实现\"><a href=\"#DFA-代码实现\" class=\"headerlink\" title=\"DFA 代码实现\"></a>DFA 代码实现</h4><p>DFA是一个有向图<br>可以根据转移表（类似邻接矩阵），哈希表，跳转表</p>\n<h5 id=\"转移表\"><a href=\"#转移表\" class=\"headerlink\" title=\"转移表\"></a>转移表</h5><p>将字符和状态先填入一个二维数组table<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table [0][&apos;a&apos;]=1;</span><br><span class=\"line\">table [1][&apos;b&apos;]=1;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate=0;  // 当前到了哪个状态，如q0</span><br><span class=\"line\">\tstack=[];  // 为了实现最长匹配机制</span><br><span class=\"line\">\twhile( state!=ERROR )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tc=getchar();</span><br><span class=\"line\">\t\tif(state is ACCEPT)</span><br><span class=\"line\">\t\t\tclear(stack) </span><br><span class=\"line\">\t\tpush(state)</span><br><span class=\"line\">\t\t// 保留最接近的接受状态，然后尽可能向前看进行尝试，若向前看失败，则可通过下面的循环不断弹出直到最接近的接受状态</span><br><span class=\"line\">\t\tstate = table [state][c]  // 查表知当前状态通过c能到哪个状态</span><br><span class=\"line\">\t\t// 若当前状态无法通过c到达别的状态，则赋值为ERROR，退出循环</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( state is not ACCEPT )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstate=pop();</span><br><span class=\"line\">\t\trollback();   // 把刚刚读入的那个字符扔回流中(多读了一个字符)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"跳转表-jump-table\"><a href=\"#跳转表-jump-table\" class=\"headerlink\" title=\"跳转表 jump table\"></a>跳转表 jump table</h5><p>好处：不需要维护一个状态和字符的二维数组并且效率高<br>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextToken()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstate =0</span><br><span class=\"line\">\tstack = []</span><br><span class=\"line\">\tgoto q0</span><br><span class=\"line\"></span><br><span class=\"line\">q0:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush (state)</span><br><span class=\"line\">\tif(c==&apos;a&apos;)</span><br><span class=\"line\">\tgoto q1</span><br><span class=\"line\"></span><br><span class=\"line\">q1:</span><br><span class=\"line\">\tc=getchar()</span><br><span class=\"line\">\tif(state is ACCEPT)</span><br><span class=\"line\">\t\tclear(stack)</span><br><span class=\"line\">\tpush(state)</span><br><span class=\"line\">\tif(c==&apos;b&apos;||c==&apos;c&apos;)</span><br><span class=\"line\">\t\tgoto q1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NFA-gt-Table-driven-Implemetation\"><a href=\"#NFA-gt-Table-driven-Implemetation\" class=\"headerlink\" title=\"NFA -&gt; Table-driven Implemetation\"></a>NFA -&gt; Table-driven Implemetation</h3><p>It is also possible that we might not want to convert to a DFA.<br>It might be that the particular specification we gave is very expensive to turn into a DFA.</p>\n<p>Implement transition via a table<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/F9dfJ3Kb7b.JPG\" alt=\"mark\"></p>\n<h2 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h2><h3 id=\"Quiz-1\"><a href=\"#Quiz-1\" class=\"headerlink\" title=\"Quiz 1\"></a>Quiz 1</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/2GkiL3207F.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We have 16 distinct strings of length 4,<br>8 distinct strings of length 3,<br>4 distinct strings of length 2,<br>2 distinct strings of length 1,<br>and one empty string<br>Ans=16+8+4+2+1=31</p>\n</blockquote>\n<h3 id=\"Quiz-2\"><a href=\"#Quiz-2\" class=\"headerlink\" title=\"Quiz 2\"></a>Quiz 2</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EJ4F29cJHA.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>This is a priority ordering, we should check the list from the beginning to the end.<br>We also have to choose the <strong>Maximal Munch</strong></p>\n</blockquote>\n<h3 id=\"Quiz-3\"><a href=\"#Quiz-3\" class=\"headerlink\" title=\"Quiz 3\"></a>Quiz 3</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/49847aGhCJ.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p><strong>Maximal Munch</strong>: both rule 3 and 4 match the whole string<br>But the rule 3 has a higher priority.</p>\n</blockquote>\n<h3 id=\"Quiz-4\"><a href=\"#Quiz-4\" class=\"headerlink\" title=\"Quiz 4\"></a>Quiz 4</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/EEaIjgb23C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-5\"><a href=\"#Quiz-5\" class=\"headerlink\" title=\"Quiz 5\"></a>Quiz 5</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/lmIf5H9dIF.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>We need n states to culculate the number of 0 and 2n states to culculate the number of 1<br>n+2n+1(start state)=3n+1</p>\n</blockquote>\n<h3 id=\"Quiz-6\"><a href=\"#Quiz-6\" class=\"headerlink\" title=\"Quiz 6\"></a>Quiz 6</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/LEj2kKElCi.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-7\"><a href=\"#Quiz-7\" class=\"headerlink\" title=\"Quiz 7\"></a>Quiz 7</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/16lIAb0iL5.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/Ij6i8jLa8C.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-8\"><a href=\"#Quiz-8\" class=\"headerlink\" title=\"Quiz 8\"></a>Quiz 8</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ILKimAdblB.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>b<em>(ab)</em> -&gt; abab match better than a(ba)*</p>\n</blockquote>\n<h3 id=\"Quiz-9\"><a href=\"#Quiz-9\" class=\"headerlink\" title=\"Quiz 9\"></a>Quiz 9</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/h7D7JjaL27.JPG\" alt=\"mark\"></p>\n<h3 id=\"Quiz-10\"><a href=\"#Quiz-10\" class=\"headerlink\" title=\"Quiz 10\"></a>Quiz 10</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/c0J8K5GjJL.JPG\" alt=\"mark\"></p>\n<blockquote>\n<p>“11” and “1”</p>\n<h3 id=\"Quiz-11\"><a href=\"#Quiz-11\" class=\"headerlink\" title=\"Quiz 11\"></a>Quiz 11</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/icagcIlIEF.png?imageslim\" alt=\"mark\"></p>\n<p>DFAs must have finite states, no ϵ-moves, and one transition per input per state.<br>The last option has infinite states.</p>\n</blockquote>\n<h3 id=\"Quiz-12\"><a href=\"#Quiz-12\" class=\"headerlink\" title=\"Quiz 12\"></a>Quiz 12</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170825/ak0L0mdIeA.png?imageslim\" alt=\"mark\"></p>\n<blockquote>\n<p>NFAs must have a finite set of states, which rules out the last option. <strong>Every DFA is also an NFA</strong>, which is why the first option is included.</p>\n</blockquote>"},{"layout":"post","title":"数据结构笔记（四）：图","date":"2017-08-18T16:00:00.000Z","comments":1,"_content":"\n\n## **概念**\n\n什么是图(Graph)：\n表示多对多的关系\n包含\n一组顶点：通常用V(Vertex)表示顶点集合\n一组边：通常用E(Edge)表示边的集合\n边是顶点对\n无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V\n有向边 表示从v指向w的边\n不考虑重边和自回路\n\n<!-- more -->\n\n此前学过的树、线性序列，均可视作图的**特例**。\n在线性序列中，只有直接前驱和后继有邻接关系\n在树中，只有父节点和子节点之间定义邻接关系\n\n![序列、树、图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim)\n\n**分类：**\n1.**无向图(undigraph)**：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)\n2.**有向图(digraph)**：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u->v 即 (u,v) u为尾(tail)，v为头(head)\n3.**混合图**：邻接关系中有的与次序有关，有的与次序无关\n4.**网络(network)**：边有权重\n\n以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。\n\n![分类图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim)\n\n概念：\n\n- **路径 **：\n\n  定义：顶点按依次邻接的关系连成的序列\n  简单路径：不含重复节点的路径\n  一般路径：可能含重复节点\n  环路：起点和终点重合\n\n  - **彼此邻接**：\n    彼此间存在边的两个顶点\n\n  - **连通**：\n    若v到w存在一条路径，则称v和w是连通的\n    强连通：\n\n    ```\n    有向图中v和w存在双向路径\n\n    ```\n\n    **连通分量**：\n\n    ```\n    无向图的**极大**连通子图\n        极大顶点数：再加1个顶点就不连通\n        极大边数：包含子图中所有顶点相连的所有边\n    **强连通分量**：\n        有向图的极大强连通子图\n\n    ```\n\n    **连通图**：\n\n    ```\n    图中任意两顶点均连通\n    **强连通图**：\n        有向图中所有顶点都是强连通\n\n    ```\n\n  - **有向无环图**(directed acyclic graph DAG)：\n    图为有向图且不包含任何环路\n\n  - **欧拉环路**：\n    经过所有边且恰好只经过所有边一次的环路\n\n  - **哈密尔顿环路**：\n    经过所有节点且只经过所有点一次\n\n  - **简单图**：\n    所有节点均不含自环的图\n\n## 抽象数据类型定义\n\n名称： 图 Graph\n数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成\n操作集：\n\n```\n- Graph Create();\n    建立并返回空图\n- Graph InsertVertex(Graph G, Vertex v);\n    把顶点V插入G\n- Graph InsertEdge(Graph G, Edge e);\n    把顶点E插入G    \n- void DFS(Graph G , Vertex v);\n    从v出发深度优先遍历G\n- void BFS(Graph G , Vertex v);\n    从v出发广度优先遍历G\n- void ShortestPath(Graph G , Vertex v, int Dist[]);\n    计算图G中顶点v到任意其它顶点的最短距离\n- void MST(Graph G);\n    计算图G的最小生成树\n\n```\n\n## 表示\n\n### 邻接矩阵\n\n邻接矩阵：G[N][N]——N个顶点从0到N-1编号\n\n```\n- G[i][j]=1 <vi,vj>是边\n- G[i][j]=0 <vi,vj>不是边\n\n```\n\n优点\n\n```\n- 方便、直观\n- 方便检查任意一对顶点间是否有边\n- 方便找任一顶点所有邻接点\n- 方便计算任一顶点的度\n    入度：指向该点的边数\n    出度：从该点发出的边数\n\n```\n\n缺点\n\n```\n- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素\n- 浪费时间，统计稀疏图中共多少条边\n\n```\n\n基本定义与建图：\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct Graph\n{\n\tVertex vertex[MaxSize];      // 顶点表\n\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表\n\tint n , e;                   // 顶点总数和边总数\n\tGraphType type;\n};\n\nvoid CreateGraph ( Graph * g)\n{\n\tg->type = UN;\n\tint i,j,w;\n\tscanf(\"%d%d\",&g->n,&g->e);   // 顶点数和边数\n\tfor( i=0; i<g->n; i++ )\n\t\tscanf(\"%c\",&(g->vertex[i]));\n\tfor( i=0; i<g->n ; i++ )     // 初始化\n\t\tfor( j=0; j<g->n ; j++ )\n\t\t\tg->edge[i][j]=INF;\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d%d%d\",&i,&j,&w);  // 输入e条边的权值\n\t\tg->edge[i][j]=w;\n\t\tg->edge[j][i]=w;\n\t}\n}\n```\n\n### 邻接表\n\n邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素\n优点：\n\n```\n- 方便找任一顶点的所有邻接点\n- 节约稀疏图的空间\n    需要N个头指针，2E个结点（每个节点至少两个域）\n    E < n(n-1)/4 时省空间\n- 方便计算无向图的度\n    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）\n\n```\n\n基本定义与实现\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct ENode\n{\n\tint adjv;    // 指向顶点的序号\n\tENode * next;\n\tint weight;\n};\n\nstruct VNode\n{\n\tVertex vertex;\n\tENode *firstEdge;\n};\n\nstruct Graph\n{\n\tVNode nodeList[MaxSize];\n\tint n,e;\n\tGraphType type;\n};\n\nvoid CreateGraph( Graph *g )\n{\n\tint i,j;\n\tENode *edge;\n\tg->type = DG;\n\tscanf(\"%d%d\",&(g->n),&(g->e));\n\tfor( i=0 ; i<g->n ; i++)\n\t{\n\t\tscanf(\"%c\",&(g->nodeList[i].vertex));\n\t\tg->nodeList[i].firstEdge=NULL;\n\t}\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d %d\",&i,&j);\n\t\tedge = new ENode();\n\t\tedge->adjv = j;\n\t\tedge->next = g->nodeList[i].firstEdge;\n\t\tg->nodeList[i].firstEdge = edge;\n\t}\n}\n```\n\n## 遍历\n\n### 深度优先搜索 DFS (Depth First Search)\n\n相当于树的先序遍历\n\nN个顶点，E条边，时间复杂度：\n用邻接表存储时，为O(N+E)\n用邻接矩阵存储时，为O($N^2$);\n\n伪代码:\n\n```\nvoid DFS( Vertex v )\n{\n\tvisited[v]=true;\n\tfor( v的每个邻接点w )\n\t\tif(!visited[w])\n\t\t\tDFS(w);\n}\n```\n\n### 广度优先搜索 BFS (Breadth First Search)\n\n相当于树的层序遍历\n\n用**队列**实现，把起始结点加入队列后\n每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过\n\nN个顶点，E条边，时间复杂度和DFS相同：\n\n```\n- 用邻接表存储时，为O(N+E)\n- 用邻接矩阵存储时，为O($N^2$);\n\n```\n\n伪代码：\n\n```\nvoid BFS( Vertex v )\n{\n\tvisited[v]=true;\n\tqueue.enqueue(v);\n\twhile(!q.empty())\n\t{\n\t\tv=q.dequeue();\n\t\tfor( v 的每个邻接点w )\n\t\t\tif(!visited[w])\n\t\t\t{\n\t\t\t\tvisited[w]=true;\n\t\t\t\tq.enqueue(w);\n\t\t\t}\n\t}\n\n}\n```\n\nBFS适合找最优解\nDFS适合找任意一解\n\n## 最短路径\n\n定义：\n在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径\n\n```\n- 该路径就是两点之间的最短路径\n- 第一个顶点为源点\n\n```\n\n分类：\n\n```\n1. 单源最短路：\n    从某固定源点出发，求其到所有其他顶点的最短路径\n    - 无权图\n    - 有权图\n2. 多源最短路：\n    求任意两顶点之间的最短路径\n\n```\n\n### 无权图的单源最短路算法\n\n按照**递增（非递减）**的顺序找出到各个顶点的最短路\n\n伪代码\n\n```\n// dist[w] = s到w的最短距离\n// dist[s] = 0\n// path[w] = s到w路径的倒数第二个顶点\n\nvoid　Unweighted( int s )\n{\n\tqueue.enqueue(s);\n\twhile(!queue.empty())\n\t{\n\t\tv = queue.dequeue();\n\t\tfor( v的每个邻接点w )\n\t\t{\n\t\t\tif( dist[w]==-1 )\n\t\t\t{\n\t\t\t\tdist[w]=dist[v]+1;\n\t\t\t\tpath[w]=v;\n\t\t\t\tqueue.enqueue(w);\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid print(int s , int w)\n{\n\tif(path[w]==-1) return;\n\twhile(path[w]!=s)\n\t{\n\t\tstack.push(path[w]);\n\t\tw=path[w];\n\t}\n\twhile(!stack.empty())\n\t\tprintf(\"%d\\n\",stack.pop());\n}\n```\n\n时间复杂度： O( v + e )\n\n### 有权图的单源最短路算法\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG)\n\n不考虑**负值圈(negative-cost cycle)**\n\n按照递增顺序找到各个顶点的最短路： Dijkstra算法\n\n#### Dijkstra:\n\n```\n- 令 S = { 源点S + 已经确定了最短路径的顶点vi }\n- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径{s -> (vi$\\in$s) -> v}的最小长度\n- 路径按照递增（非递减）的顺序生成\n    - 真正的最短路一定只经过s中的顶点\n    - 每次从未收录的顶点中选一个dist最小的收录\n    - 增加一个v进入s，可能影响w的最小值\n        dist[w]=min(dist[w]+<v,w>);\n    - 初始化为INF\n\n```\n\n伪代码\n\n```\nvoid Dijkstra( int s )\n{\n\twhile(1)\n\t{\n\t\tv = 未收录顶点中dist最小的\n\t\tif( v 不存在 )\n\t\t\tbreak;\n\t\tcollected[v]=true;\n\t\tfor( v 的每个顶点w )\n\t\t\tif( collected[w]==false )\n\t\t\t\tif( dist[v]+E<v,w> < dist[w])\n\t\t\t\t{\n\t\t\t\t\tdist[w]=dist[v]+E<v,w>;\n\t\t\t\t\tpath[w]=v;\n\t\t\t\t}\n\t}\n}\n```\n\n时间复杂度：取决于如何找到dist最小的节点\n\n方法1： 直接扫描所有未收录节点 O(v)\nO($v^2$+e) (稠密图效果好)\n方法2： 把dist存入最小堆中 O(logv)\n更新dist[w]的值： O(logv)\nO(elogv) (稀疏图效果好)\n\n### 多源最短路\n\n方法1： 把单源最短路调用V遍 O( v3+e*v )\n\n方法2： Floyd算法 O( v3 )\n\n#### Floyd算法：\n\n```\n- D(k)[i][j] = 路径 { i -> {l<=k} -> j }的最小长度 (从i到j只经过编号<=k的顶点)\n- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离\n- 初始化D为带权值的邻接矩阵，对角元为0\n- 若i,j之间无直接边，则初始化为INF\n- 若D(k-1)已完成，递推D(k):\n    - 若k$\\notin$最短路径，则 D(K)=D(K-1)\n    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：\n        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]\n\n```\n\n伪代码：\n\n```\nvoid Floyd()\n{\n\tfor( int i=0; i<n ; i++ )\n\t\tfor( int j=0; j<n ; j++ )\n\t\t{\t\n\t\t\tD[i][j]=G[i][j]\n\t\t\tpath[i][j]=-1;\n\t\t}\n\tfor( int k=0; k<n ; k++ )\n\t\tfor( int i=0; i<n ; i++ )\n\t\t\tfor( int j=0; j<n ; j++ )\n\t\t\t\tif(D[i][k]+D[k][j]<D[i][j])\n\t\t\t\t{\t\n\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];\n\t\t\t\t\tpath[i][j]=k;\n\t\t\t\t}\n}\nvoid print( int i , int j )\n{\n\tif(i==j) return;\n\tprint(i,path[i][j]);\n\tprintf(path[i][j]);\n\tprint(path[i][j],j);\n}\n```\n\n## 最小生成树 Minimum Spanning Tree\n\n定义：\n\n```\n- 一棵树：\n    - 无回路\n    - V个顶点一定有V-1条边\n- 生成树：\n    - 包含所有顶点\n    - V-1条边都包含在图里\n    - 生成树中任加一条边都一定构成回路\n- 最小：\n    - 边的权重和最小\n\n```\n\n最小生成树存在 <=> 图连通\n\n方法：**贪心**\n\n约束条件：\n\n```\n1. 只能用图里的边\n2. 只能正好用掉V-1条边\n3. 不能有回路\n\n```\n\n### Prim算法\n\n核心思想：让小树长大\n\n思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中\n\n适用场景：稠密图\n\n伪代码：\n\n```\nvoid Prim()\n{\n\tMST = {s}  // 初始化，树中只有初始结点\n\twhile(1)\n\t{\n\t\tv = 未收录结点中到树距离最小的\n\t\tif( v不存在 )\n\t\t\tbreak;\n\t\t把v收入MST中： dist[v]=0\n\t\tfor( v的所有邻接点w )\n\t\t\tif( w 未被收录：dist[w]!=0 && E<v,w> < dist[w] )\n\t\t\t{\n\t\t\t\tdist[w]=E<v,w>;\n\t\t\t\tparent[w]=v;\n\t\t\t}\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)\n\n不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1\n\n时间复杂度： O($v^2$)\n\n### Kruskal算法\n\n核心思想：森林合并成树\n\n思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边\n\n适用场景：稀疏图\n\n伪代码：\n\n```\nvoid Kruskal (Graph G)\n{\n\tMST = {}\n\twhile( MST不到V-1条边 && E中还有边 )\n\t{\n\t\tE中选取权重最小的边E<v,w>;   // 用最小堆\n\t\t把E<v,w>从e中删除\n\t\tif( E<v,w> 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）\n\t\t\t将E<v,w>加入MST；\n\t\telse\n\t\t\t无视E<v,w>\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n时间复杂度： O( E*logE )\n\n## 拓扑排序\n\nAOV （Activity On Vertex）网络\n\n拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列\n\n拓扑排序: 获得一个拓扑序的过程为\n\nAOV若有**合理**的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)\n\n思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出\n\n用途：拓扑排序，还可以用于检测有向图是否为DAG\n\n伪代码：\n\n```\nvoid TopSort()\n{\n\tfor( 每个顶点v )\n\t\tif( Indegree[v]==0 )\n\t\t\tqueue.enqueue(v);\n\twhile(!queue.empty())\n\t{\n\t\tv=queue.dequeue();\n\t\t输出或记录v;\n\t\tcnt++;\n\t\tfor( v的每个结点w )\n\t\t\tif( --Indegree[w]==0 )\n\t\t\t\tqueue.enqueue(w);\n\t}\n\tif( cnt!=v )\n\t{\n\t\tError(图中有回路)\n\t\tbreak;\n\t}\n}\n```\n\n时间复杂度： O(v+e)\n\n### 关键路径问题\n\nAOE( Activity On Edge )网络\n\n```\n- 一般用于安排项目的工序\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG)\n\nEarliestTime[0]=0\nEarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG)\n\nLastTime[i]=min($\\in$E) { LastTime[j]-C}\n\n机动时间： D = LastTime[j]-EarlistTime[i]-C\n\n关键路径：绝对不允许延误的活动组成的路径","source":"_posts/DataStructure_Graph.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（四）：图\"\ndate: 2017-08-19\ncomments: true\ntags: \n\t- 学习笔记\n\t- c++\n\t- 数据结构\n---\n\n\n## **概念**\n\n什么是图(Graph)：\n表示多对多的关系\n包含\n一组顶点：通常用V(Vertex)表示顶点集合\n一组边：通常用E(Edge)表示边的集合\n边是顶点对\n无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V\n有向边 表示从v指向w的边\n不考虑重边和自回路\n\n<!-- more -->\n\n此前学过的树、线性序列，均可视作图的**特例**。\n在线性序列中，只有直接前驱和后继有邻接关系\n在树中，只有父节点和子节点之间定义邻接关系\n\n![序列、树、图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim)\n\n**分类：**\n1.**无向图(undigraph)**：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)\n2.**有向图(digraph)**：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u->v 即 (u,v) u为尾(tail)，v为头(head)\n3.**混合图**：邻接关系中有的与次序有关，有的与次序无关\n4.**网络(network)**：边有权重\n\n以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。\n\n![分类图](http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim)\n\n概念：\n\n- **路径 **：\n\n  定义：顶点按依次邻接的关系连成的序列\n  简单路径：不含重复节点的路径\n  一般路径：可能含重复节点\n  环路：起点和终点重合\n\n  - **彼此邻接**：\n    彼此间存在边的两个顶点\n\n  - **连通**：\n    若v到w存在一条路径，则称v和w是连通的\n    强连通：\n\n    ```\n    有向图中v和w存在双向路径\n\n    ```\n\n    **连通分量**：\n\n    ```\n    无向图的**极大**连通子图\n        极大顶点数：再加1个顶点就不连通\n        极大边数：包含子图中所有顶点相连的所有边\n    **强连通分量**：\n        有向图的极大强连通子图\n\n    ```\n\n    **连通图**：\n\n    ```\n    图中任意两顶点均连通\n    **强连通图**：\n        有向图中所有顶点都是强连通\n\n    ```\n\n  - **有向无环图**(directed acyclic graph DAG)：\n    图为有向图且不包含任何环路\n\n  - **欧拉环路**：\n    经过所有边且恰好只经过所有边一次的环路\n\n  - **哈密尔顿环路**：\n    经过所有节点且只经过所有点一次\n\n  - **简单图**：\n    所有节点均不含自环的图\n\n## 抽象数据类型定义\n\n名称： 图 Graph\n数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成\n操作集：\n\n```\n- Graph Create();\n    建立并返回空图\n- Graph InsertVertex(Graph G, Vertex v);\n    把顶点V插入G\n- Graph InsertEdge(Graph G, Edge e);\n    把顶点E插入G    \n- void DFS(Graph G , Vertex v);\n    从v出发深度优先遍历G\n- void BFS(Graph G , Vertex v);\n    从v出发广度优先遍历G\n- void ShortestPath(Graph G , Vertex v, int Dist[]);\n    计算图G中顶点v到任意其它顶点的最短距离\n- void MST(Graph G);\n    计算图G的最小生成树\n\n```\n\n## 表示\n\n### 邻接矩阵\n\n邻接矩阵：G[N][N]——N个顶点从0到N-1编号\n\n```\n- G[i][j]=1 <vi,vj>是边\n- G[i][j]=0 <vi,vj>不是边\n\n```\n\n优点\n\n```\n- 方便、直观\n- 方便检查任意一对顶点间是否有边\n- 方便找任一顶点所有邻接点\n- 方便计算任一顶点的度\n    入度：指向该点的边数\n    出度：从该点发出的边数\n\n```\n\n缺点\n\n```\n- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素\n- 浪费时间，统计稀疏图中共多少条边\n\n```\n\n基本定义与建图：\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct Graph\n{\n\tVertex vertex[MaxSize];      // 顶点表\n\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表\n\tint n , e;                   // 顶点总数和边总数\n\tGraphType type;\n};\n\nvoid CreateGraph ( Graph * g)\n{\n\tg->type = UN;\n\tint i,j,w;\n\tscanf(\"%d%d\",&g->n,&g->e);   // 顶点数和边数\n\tfor( i=0; i<g->n; i++ )\n\t\tscanf(\"%c\",&(g->vertex[i]));\n\tfor( i=0; i<g->n ; i++ )     // 初始化\n\t\tfor( j=0; j<g->n ; j++ )\n\t\t\tg->edge[i][j]=INF;\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d%d%d\",&i,&j,&w);  // 输入e条边的权值\n\t\tg->edge[i][j]=w;\n\t\tg->edge[j][i]=w;\n\t}\n}\n```\n\n### 邻接表\n\n邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素\n优点：\n\n```\n- 方便找任一顶点的所有邻接点\n- 节约稀疏图的空间\n    需要N个头指针，2E个结点（每个节点至少两个域）\n    E < n(n-1)/4 时省空间\n- 方便计算无向图的度\n    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）\n\n```\n\n基本定义与实现\n\n```\ntypedef char Vertex;\ntypedef int Edge;\n#define MaxSize 1000\n#define INF 0x7fffffff\nenum GraphType{ DG, UG, DN, UN };\n/* 有向图，无向图，有向网图，无向网图 */\n\nstruct ENode\n{\n\tint adjv;    // 指向顶点的序号\n\tENode * next;\n\tint weight;\n};\n\nstruct VNode\n{\n\tVertex vertex;\n\tENode *firstEdge;\n};\n\nstruct Graph\n{\n\tVNode nodeList[MaxSize];\n\tint n,e;\n\tGraphType type;\n};\n\nvoid CreateGraph( Graph *g )\n{\n\tint i,j;\n\tENode *edge;\n\tg->type = DG;\n\tscanf(\"%d%d\",&(g->n),&(g->e));\n\tfor( i=0 ; i<g->n ; i++)\n\t{\n\t\tscanf(\"%c\",&(g->nodeList[i].vertex));\n\t\tg->nodeList[i].firstEdge=NULL;\n\t}\n\tfor( int k=0; k<g->e ; k++ )\n\t{\n\t\tscanf(\"%d %d\",&i,&j);\n\t\tedge = new ENode();\n\t\tedge->adjv = j;\n\t\tedge->next = g->nodeList[i].firstEdge;\n\t\tg->nodeList[i].firstEdge = edge;\n\t}\n}\n```\n\n## 遍历\n\n### 深度优先搜索 DFS (Depth First Search)\n\n相当于树的先序遍历\n\nN个顶点，E条边，时间复杂度：\n用邻接表存储时，为O(N+E)\n用邻接矩阵存储时，为O($N^2$);\n\n伪代码:\n\n```\nvoid DFS( Vertex v )\n{\n\tvisited[v]=true;\n\tfor( v的每个邻接点w )\n\t\tif(!visited[w])\n\t\t\tDFS(w);\n}\n```\n\n### 广度优先搜索 BFS (Breadth First Search)\n\n相当于树的层序遍历\n\n用**队列**实现，把起始结点加入队列后\n每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过\n\nN个顶点，E条边，时间复杂度和DFS相同：\n\n```\n- 用邻接表存储时，为O(N+E)\n- 用邻接矩阵存储时，为O($N^2$);\n\n```\n\n伪代码：\n\n```\nvoid BFS( Vertex v )\n{\n\tvisited[v]=true;\n\tqueue.enqueue(v);\n\twhile(!q.empty())\n\t{\n\t\tv=q.dequeue();\n\t\tfor( v 的每个邻接点w )\n\t\t\tif(!visited[w])\n\t\t\t{\n\t\t\t\tvisited[w]=true;\n\t\t\t\tq.enqueue(w);\n\t\t\t}\n\t}\n\n}\n```\n\nBFS适合找最优解\nDFS适合找任意一解\n\n## 最短路径\n\n定义：\n在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径\n\n```\n- 该路径就是两点之间的最短路径\n- 第一个顶点为源点\n\n```\n\n分类：\n\n```\n1. 单源最短路：\n    从某固定源点出发，求其到所有其他顶点的最短路径\n    - 无权图\n    - 有权图\n2. 多源最短路：\n    求任意两顶点之间的最短路径\n\n```\n\n### 无权图的单源最短路算法\n\n按照**递增（非递减）**的顺序找出到各个顶点的最短路\n\n伪代码\n\n```\n// dist[w] = s到w的最短距离\n// dist[s] = 0\n// path[w] = s到w路径的倒数第二个顶点\n\nvoid　Unweighted( int s )\n{\n\tqueue.enqueue(s);\n\twhile(!queue.empty())\n\t{\n\t\tv = queue.dequeue();\n\t\tfor( v的每个邻接点w )\n\t\t{\n\t\t\tif( dist[w]==-1 )\n\t\t\t{\n\t\t\t\tdist[w]=dist[v]+1;\n\t\t\t\tpath[w]=v;\n\t\t\t\tqueue.enqueue(w);\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid print(int s , int w)\n{\n\tif(path[w]==-1) return;\n\twhile(path[w]!=s)\n\t{\n\t\tstack.push(path[w]);\n\t\tw=path[w];\n\t}\n\twhile(!stack.empty())\n\t\tprintf(\"%d\\n\",stack.pop());\n}\n```\n\n时间复杂度： O( v + e )\n\n### 有权图的单源最短路算法\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG)\n\n不考虑**负值圈(negative-cost cycle)**\n\n按照递增顺序找到各个顶点的最短路： Dijkstra算法\n\n#### Dijkstra:\n\n```\n- 令 S = { 源点S + 已经确定了最短路径的顶点vi }\n- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径{s -> (vi$\\in$s) -> v}的最小长度\n- 路径按照递增（非递减）的顺序生成\n    - 真正的最短路一定只经过s中的顶点\n    - 每次从未收录的顶点中选一个dist最小的收录\n    - 增加一个v进入s，可能影响w的最小值\n        dist[w]=min(dist[w]+<v,w>);\n    - 初始化为INF\n\n```\n\n伪代码\n\n```\nvoid Dijkstra( int s )\n{\n\twhile(1)\n\t{\n\t\tv = 未收录顶点中dist最小的\n\t\tif( v 不存在 )\n\t\t\tbreak;\n\t\tcollected[v]=true;\n\t\tfor( v 的每个顶点w )\n\t\t\tif( collected[w]==false )\n\t\t\t\tif( dist[v]+E<v,w> < dist[w])\n\t\t\t\t{\n\t\t\t\t\tdist[w]=dist[v]+E<v,w>;\n\t\t\t\t\tpath[w]=v;\n\t\t\t\t}\n\t}\n}\n```\n\n时间复杂度：取决于如何找到dist最小的节点\n\n方法1： 直接扫描所有未收录节点 O(v)\nO($v^2$+e) (稠密图效果好)\n方法2： 把dist存入最小堆中 O(logv)\n更新dist[w]的值： O(logv)\nO(elogv) (稀疏图效果好)\n\n### 多源最短路\n\n方法1： 把单源最短路调用V遍 O( v3+e*v )\n\n方法2： Floyd算法 O( v3 )\n\n#### Floyd算法：\n\n```\n- D(k)[i][j] = 路径 { i -> {l<=k} -> j }的最小长度 (从i到j只经过编号<=k的顶点)\n- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离\n- 初始化D为带权值的邻接矩阵，对角元为0\n- 若i,j之间无直接边，则初始化为INF\n- 若D(k-1)已完成，递推D(k):\n    - 若k$\\notin$最短路径，则 D(K)=D(K-1)\n    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：\n        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]\n\n```\n\n伪代码：\n\n```\nvoid Floyd()\n{\n\tfor( int i=0; i<n ; i++ )\n\t\tfor( int j=0; j<n ; j++ )\n\t\t{\t\n\t\t\tD[i][j]=G[i][j]\n\t\t\tpath[i][j]=-1;\n\t\t}\n\tfor( int k=0; k<n ; k++ )\n\t\tfor( int i=0; i<n ; i++ )\n\t\t\tfor( int j=0; j<n ; j++ )\n\t\t\t\tif(D[i][k]+D[k][j]<D[i][j])\n\t\t\t\t{\t\n\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];\n\t\t\t\t\tpath[i][j]=k;\n\t\t\t\t}\n}\nvoid print( int i , int j )\n{\n\tif(i==j) return;\n\tprint(i,path[i][j]);\n\tprintf(path[i][j]);\n\tprint(path[i][j],j);\n}\n```\n\n## 最小生成树 Minimum Spanning Tree\n\n定义：\n\n```\n- 一棵树：\n    - 无回路\n    - V个顶点一定有V-1条边\n- 生成树：\n    - 包含所有顶点\n    - V-1条边都包含在图里\n    - 生成树中任加一条边都一定构成回路\n- 最小：\n    - 边的权重和最小\n\n```\n\n最小生成树存在 <=> 图连通\n\n方法：**贪心**\n\n约束条件：\n\n```\n1. 只能用图里的边\n2. 只能正好用掉V-1条边\n3. 不能有回路\n\n```\n\n### Prim算法\n\n核心思想：让小树长大\n\n思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中\n\n适用场景：稠密图\n\n伪代码：\n\n```\nvoid Prim()\n{\n\tMST = {s}  // 初始化，树中只有初始结点\n\twhile(1)\n\t{\n\t\tv = 未收录结点中到树距离最小的\n\t\tif( v不存在 )\n\t\t\tbreak;\n\t\t把v收入MST中： dist[v]=0\n\t\tfor( v的所有邻接点w )\n\t\t\tif( w 未被收录：dist[w]!=0 && E<v,w> < dist[w] )\n\t\t\t{\n\t\t\t\tdist[w]=E<v,w>;\n\t\t\t\tparent[w]=v;\n\t\t\t}\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)\n\n不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1\n\n时间复杂度： O($v^2$)\n\n### Kruskal算法\n\n核心思想：森林合并成树\n\n思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边\n\n适用场景：稀疏图\n\n伪代码：\n\n```\nvoid Kruskal (Graph G)\n{\n\tMST = {}\n\twhile( MST不到V-1条边 && E中还有边 )\n\t{\n\t\tE中选取权重最小的边E<v,w>;   // 用最小堆\n\t\t把E<v,w>从e中删除\n\t\tif( E<v,w> 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）\n\t\t\t将E<v,w>加入MST；\n\t\telse\n\t\t\t无视E<v,w>\n\t}\n\tif( MST里节点数< v 个 )\n\t\tError( 生成树不存在 ) // 说明图本身不连通\n}\n```\n\n时间复杂度： O( E*logE )\n\n## 拓扑排序\n\nAOV （Activity On Vertex）网络\n\n拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列\n\n拓扑排序: 获得一个拓扑序的过程为\n\nAOV若有**合理**的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)\n\n思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出\n\n用途：拓扑排序，还可以用于检测有向图是否为DAG\n\n伪代码：\n\n```\nvoid TopSort()\n{\n\tfor( 每个顶点v )\n\t\tif( Indegree[v]==0 )\n\t\t\tqueue.enqueue(v);\n\twhile(!queue.empty())\n\t{\n\t\tv=queue.dequeue();\n\t\t输出或记录v;\n\t\tcnt++;\n\t\tfor( v的每个结点w )\n\t\t\tif( --Indegree[w]==0 )\n\t\t\t\tqueue.enqueue(w);\n\t}\n\tif( cnt!=v )\n\t{\n\t\tError(图中有回路)\n\t\tbreak;\n\t}\n}\n```\n\n时间复杂度： O(v+e)\n\n### 关键路径问题\n\nAOE( Activity On Edge )网络\n\n```\n- 一般用于安排项目的工序\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG)\n\nEarliestTime[0]=0\nEarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG)\n\nLastTime[i]=min($\\in$E) { LastTime[j]-C}\n\n机动时间： D = LastTime[j]-EarlistTime[i]-C\n\n关键路径：绝对不允许延误的活动组成的路径","slug":"DataStructure_Graph","published":1,"updated":"2018-05-25T12:41:12.161Z","photos":[],"link":"","_id":"cjhvssade0004jvfck8ttxrr6","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>什么是图(Graph)：<br>表示多对多的关系<br>包含<br>一组顶点：通常用V(Vertex)表示顶点集合<br>一组边：通常用E(Edge)表示边的集合<br>边是顶点对<br>无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V<br>有向边 表示从v指向w的边<br>不考虑重边和自回路</p>\n<a id=\"more\"></a>\n<p>此前学过的树、线性序列，均可视作图的<strong>特例</strong>。<br>在线性序列中，只有直接前驱和后继有邻接关系<br>在树中，只有父节点和子节点之间定义邻接关系</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim\" alt=\"序列、树、图\"></p>\n<p><strong>分类：</strong><br>1.<strong>无向图(undigraph)</strong>：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)<br>2.<strong>有向图(digraph)</strong>：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u-&gt;v 即 (u,v) u为尾(tail)，v为头(head)<br>3.<strong>混合图</strong>：邻接关系中有的与次序有关，有的与次序无关<br>4.<strong>网络(network)</strong>：边有权重</p>\n<p>以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim\" alt=\"分类图\"></p>\n<p>概念：</p>\n<ul>\n<li><p><strong>路径 </strong>：</p>\n<p>定义：顶点按依次邻接的关系连成的序列<br>简单路径：不含重复节点的路径<br>一般路径：可能含重复节点<br>环路：起点和终点重合</p>\n<ul>\n<li><p><strong>彼此邻接</strong>：<br>彼此间存在边的两个顶点</p>\n</li>\n<li><p><strong>连通</strong>：<br>若v到w存在一条路径，则称v和w是连通的<br>强连通：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有向图中v和w存在双向路径</span><br></pre></td></tr></table></figure>\n<p><strong>连通分量</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无向图的**极大**连通子图</span><br><span class=\"line\">    极大顶点数：再加1个顶点就不连通</span><br><span class=\"line\">    极大边数：包含子图中所有顶点相连的所有边</span><br><span class=\"line\">**强连通分量**：</span><br><span class=\"line\">    有向图的极大强连通子图</span><br></pre></td></tr></table></figure>\n<p><strong>连通图</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">图中任意两顶点均连通</span><br><span class=\"line\">**强连通图**：</span><br><span class=\"line\">    有向图中所有顶点都是强连通</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>有向无环图</strong>(directed acyclic graph DAG)：<br>图为有向图且不包含任何环路</p>\n</li>\n<li><p><strong>欧拉环路</strong>：<br>经过所有边且恰好只经过所有边一次的环路</p>\n</li>\n<li><p><strong>哈密尔顿环路</strong>：<br>经过所有节点且只经过所有点一次</p>\n</li>\n<li><p><strong>简单图</strong>：<br>所有节点均不含自环的图</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象数据类型定义\"><a href=\"#抽象数据类型定义\" class=\"headerlink\" title=\"抽象数据类型定义\"></a>抽象数据类型定义</h2><p>名称： 图 Graph<br>数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成<br>操作集：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Graph Create();</span><br><span class=\"line\">    建立并返回空图</span><br><span class=\"line\">- Graph InsertVertex(Graph G, Vertex v);</span><br><span class=\"line\">    把顶点V插入G</span><br><span class=\"line\">- Graph InsertEdge(Graph G, Edge e);</span><br><span class=\"line\">    把顶点E插入G    </span><br><span class=\"line\">- void DFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发深度优先遍历G</span><br><span class=\"line\">- void BFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发广度优先遍历G</span><br><span class=\"line\">- void ShortestPath(Graph G , Vertex v, int Dist[]);</span><br><span class=\"line\">    计算图G中顶点v到任意其它顶点的最短距离</span><br><span class=\"line\">- void MST(Graph G);</span><br><span class=\"line\">    计算图G的最小生成树</span><br></pre></td></tr></table></figure>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a>表示</h2><h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><p>邻接矩阵：G[N][N]——N个顶点从0到N-1编号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- G[i][j]=1 &lt;vi,vj&gt;是边</span><br><span class=\"line\">- G[i][j]=0 &lt;vi,vj&gt;不是边</span><br></pre></td></tr></table></figure>\n<p>优点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便、直观</span><br><span class=\"line\">- 方便检查任意一对顶点间是否有边</span><br><span class=\"line\">- 方便找任一顶点所有邻接点</span><br><span class=\"line\">- 方便计算任一顶点的度</span><br><span class=\"line\">    入度：指向该点的边数</span><br><span class=\"line\">    出度：从该点发出的边数</span><br></pre></td></tr></table></figure>\n<p>缺点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素</span><br><span class=\"line\">- 浪费时间，统计稀疏图中共多少条边</span><br></pre></td></tr></table></figure>\n<p>基本定义与建图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex[MaxSize];      // 顶点表</span><br><span class=\"line\">\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表</span><br><span class=\"line\">\tint n , e;                   // 顶点总数和边总数</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph ( Graph * g)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tg-&gt;type = UN;</span><br><span class=\"line\">\tint i,j,w;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;g-&gt;n,&amp;g-&gt;e);   // 顶点数和边数</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n; i++ )</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;vertex[i]));</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n ; i++ )     // 初始化</span><br><span class=\"line\">\t\tfor( j=0; j&lt;g-&gt;n ; j++ )</span><br><span class=\"line\">\t\t\tg-&gt;edge[i][j]=INF;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;w);  // 输入e条边的权值</span><br><span class=\"line\">\t\tg-&gt;edge[i][j]=w;</span><br><span class=\"line\">\t\tg-&gt;edge[j][i]=w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>优点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便找任一顶点的所有邻接点</span><br><span class=\"line\">- 节约稀疏图的空间</span><br><span class=\"line\">    需要N个头指针，2E个结点（每个节点至少两个域）</span><br><span class=\"line\">    E &lt; n(n-1)/4 时省空间</span><br><span class=\"line\">- 方便计算无向图的度</span><br><span class=\"line\">    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）</span><br></pre></td></tr></table></figure>\n<p>基本定义与实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct ENode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint adjv;    // 指向顶点的序号</span><br><span class=\"line\">\tENode * next;</span><br><span class=\"line\">\tint weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct VNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex;</span><br><span class=\"line\">\tENode *firstEdge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVNode nodeList[MaxSize];</span><br><span class=\"line\">\tint n,e;</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph( Graph *g )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i,j;</span><br><span class=\"line\">\tENode *edge;</span><br><span class=\"line\">\tg-&gt;type = DG;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;(g-&gt;n),&amp;(g-&gt;e));</span><br><span class=\"line\">\tfor( i=0 ; i&lt;g-&gt;n ; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;nodeList[i].vertex));</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d %d&quot;,&amp;i,&amp;j);</span><br><span class=\"line\">\t\tedge = new ENode();</span><br><span class=\"line\">\t\tedge-&gt;adjv = j;</span><br><span class=\"line\">\t\tedge-&gt;next = g-&gt;nodeList[i].firstEdge;</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge = edge;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><h3 id=\"深度优先搜索-DFS-Depth-First-Search\"><a href=\"#深度优先搜索-DFS-Depth-First-Search\" class=\"headerlink\" title=\"深度优先搜索 DFS (Depth First Search)\"></a>深度优先搜索 DFS (Depth First Search)</h3><p>相当于树的先序遍历</p>\n<p>N个顶点，E条边，时间复杂度：<br>用邻接表存储时，为O(N+E)<br>用邻接矩阵存储时，为O($N^2$);</p>\n<p>伪代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\tDFS(w);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"广度优先搜索-BFS-Breadth-First-Search\"><a href=\"#广度优先搜索-BFS-Breadth-First-Search\" class=\"headerlink\" title=\"广度优先搜索 BFS (Breadth First Search)\"></a>广度优先搜索 BFS (Breadth First Search)</h3><p>相当于树的层序遍历</p>\n<p>用<strong>队列</strong>实现，把起始结点加入队列后<br>每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过</p>\n<p>N个顶点，E条边，时间复杂度和DFS相同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 用邻接表存储时，为O(N+E)</span><br><span class=\"line\">- 用邻接矩阵存储时，为O($N^2$);</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!q.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=q.dequeue();</span><br><span class=\"line\">\t\tfor( v 的每个邻接点w )</span><br><span class=\"line\">\t\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tvisited[w]=true;</span><br><span class=\"line\">\t\t\t\tq.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BFS适合找最优解<br>DFS适合找任意一解</p>\n<h2 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h2><p>定义：<br>在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 该路径就是两点之间的最短路径</span><br><span class=\"line\">- 第一个顶点为源点</span><br></pre></td></tr></table></figure>\n<p>分类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 单源最短路：</span><br><span class=\"line\">    从某固定源点出发，求其到所有其他顶点的最短路径</span><br><span class=\"line\">    - 无权图</span><br><span class=\"line\">    - 有权图</span><br><span class=\"line\">2. 多源最短路：</span><br><span class=\"line\">    求任意两顶点之间的最短路径</span><br></pre></td></tr></table></figure>\n<h3 id=\"无权图的单源最短路算法\"><a href=\"#无权图的单源最短路算法\" class=\"headerlink\" title=\"无权图的单源最短路算法\"></a>无权图的单源最短路算法</h3><p>按照<strong>递增（非递减）</strong>的顺序找出到各个顶点的最短路</p>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// dist[w] = s到w的最短距离</span><br><span class=\"line\">// dist[s] = 0</span><br><span class=\"line\">// path[w] = s到w路径的倒数第二个顶点</span><br><span class=\"line\"></span><br><span class=\"line\">void　Unweighted( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueue.enqueue(s);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = queue.dequeue();</span><br><span class=\"line\">\t\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( dist[w]==-1 )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=dist[v]+1;</span><br><span class=\"line\">\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print(int s , int w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(path[w]==-1) return;</span><br><span class=\"line\">\twhile(path[w]!=s)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack.push(path[w]);</span><br><span class=\"line\">\t\tw=path[w];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(!stack.empty())</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;,stack.pop());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( v + e )</p>\n<h3 id=\"有权图的单源最短路算法\"><a href=\"#有权图的单源最短路算法\" class=\"headerlink\" title=\"有权图的单源最短路算法\"></a>有权图的单源最短路算法</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG\" alt=\"mark\"></p>\n<p>不考虑<strong>负值圈(negative-cost cycle)</strong></p>\n<p>按照递增顺序找到各个顶点的最短路： Dijkstra算法</p>\n<h4 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra:\"></a>Dijkstra:</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 令 S = &#123; 源点S + 已经确定了最短路径的顶点vi &#125;</span><br><span class=\"line\">- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径&#123;s -&gt; (vi$\\in$s) -&gt; v&#125;的最小长度</span><br><span class=\"line\">- 路径按照递增（非递减）的顺序生成</span><br><span class=\"line\">    - 真正的最短路一定只经过s中的顶点</span><br><span class=\"line\">    - 每次从未收录的顶点中选一个dist最小的收录</span><br><span class=\"line\">    - 增加一个v进入s，可能影响w的最小值</span><br><span class=\"line\">        dist[w]=min(dist[w]+&lt;v,w&gt;);</span><br><span class=\"line\">    - 初始化为INF</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Dijkstra( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录顶点中dist最小的</span><br><span class=\"line\">\t\tif( v 不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcollected[v]=true;</span><br><span class=\"line\">\t\tfor( v 的每个顶点w )</span><br><span class=\"line\">\t\t\tif( collected[w]==false )</span><br><span class=\"line\">\t\t\t\tif( dist[v]+E&lt;v,w&gt; &lt; dist[w])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tdist[w]=dist[v]+E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：取决于如何找到dist最小的节点</p>\n<p>方法1： 直接扫描所有未收录节点 O(v)<br>O($v^2$+e) (稠密图效果好)<br>方法2： 把dist存入最小堆中 O(logv)<br>更新dist[w]的值： O(logv)<br>O(elogv) (稀疏图效果好)</p>\n<h3 id=\"多源最短路\"><a href=\"#多源最短路\" class=\"headerlink\" title=\"多源最短路\"></a>多源最短路</h3><p>方法1： 把单源最短路调用V遍 O( v3+e*v )</p>\n<p>方法2： Floyd算法 O( v3 )</p>\n<h4 id=\"Floyd算法：\"><a href=\"#Floyd算法：\" class=\"headerlink\" title=\"Floyd算法：\"></a>Floyd算法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- D(k)[i][j] = 路径 &#123; i -&gt; &#123;l&lt;=k&#125; -&gt; j &#125;的最小长度 (从i到j只经过编号&lt;=k的顶点)</span><br><span class=\"line\">- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离</span><br><span class=\"line\">- 初始化D为带权值的邻接矩阵，对角元为0</span><br><span class=\"line\">- 若i,j之间无直接边，则初始化为INF</span><br><span class=\"line\">- 若D(k-1)已完成，递推D(k):</span><br><span class=\"line\">    - 若k$\\notin$最短路径，则 D(K)=D(K-1)</span><br><span class=\"line\">    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：</span><br><span class=\"line\">        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Floyd()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tD[i][j]=G[i][j]</span><br><span class=\"line\">\t\t\tpath[i][j]=-1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;n ; k++ )</span><br><span class=\"line\">\t\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t\t\tif(D[i][k]+D[k][j]&lt;D[i][j])</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];</span><br><span class=\"line\">\t\t\t\t\tpath[i][j]=k;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print( int i , int j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(i==j) return;</span><br><span class=\"line\">\tprint(i,path[i][j]);</span><br><span class=\"line\">\tprintf(path[i][j]);</span><br><span class=\"line\">\tprint(path[i][j],j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最小生成树-Minimum-Spanning-Tree\"><a href=\"#最小生成树-Minimum-Spanning-Tree\" class=\"headerlink\" title=\"最小生成树 Minimum Spanning Tree\"></a>最小生成树 Minimum Spanning Tree</h2><p>定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一棵树：</span><br><span class=\"line\">    - 无回路</span><br><span class=\"line\">    - V个顶点一定有V-1条边</span><br><span class=\"line\">- 生成树：</span><br><span class=\"line\">    - 包含所有顶点</span><br><span class=\"line\">    - V-1条边都包含在图里</span><br><span class=\"line\">    - 生成树中任加一条边都一定构成回路</span><br><span class=\"line\">- 最小：</span><br><span class=\"line\">    - 边的权重和最小</span><br></pre></td></tr></table></figure>\n<p>最小生成树存在 &lt;=&gt; 图连通</p>\n<p>方法：<strong>贪心</strong></p>\n<p>约束条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 只能用图里的边</span><br><span class=\"line\">2. 只能正好用掉V-1条边</span><br><span class=\"line\">3. 不能有回路</span><br></pre></td></tr></table></figure>\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>核心思想：让小树长大</p>\n<p>思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中</p>\n<p>适用场景：稠密图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Prim()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;s&#125;  // 初始化，树中只有初始结点</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录结点中到树距离最小的</span><br><span class=\"line\">\t\tif( v不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t把v收入MST中： dist[v]=0</span><br><span class=\"line\">\t\tfor( v的所有邻接点w )</span><br><span class=\"line\">\t\t\tif( w 未被收录：dist[w]!=0 &amp;&amp; E&lt;v,w&gt; &lt; dist[w] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\tparent[w]=v;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)</p>\n<p>不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1</p>\n<p>时间复杂度： O($v^2$)</p>\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>核心思想：森林合并成树</p>\n<p>思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边</p>\n<p>适用场景：稀疏图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Kruskal (Graph G)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;&#125;</span><br><span class=\"line\">\twhile( MST不到V-1条边 &amp;&amp; E中还有边 )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tE中选取权重最小的边E&lt;v,w&gt;;   // 用最小堆</span><br><span class=\"line\">\t\t把E&lt;v,w&gt;从e中删除</span><br><span class=\"line\">\t\tif( E&lt;v,w&gt; 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）</span><br><span class=\"line\">\t\t\t将E&lt;v,w&gt;加入MST；</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\t无视E&lt;v,w&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( E*logE )</p>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><p>AOV （Activity On Vertex）网络</p>\n<p>拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列</p>\n<p>拓扑排序: 获得一个拓扑序的过程为</p>\n<p>AOV若有<strong>合理</strong>的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)</p>\n<p>思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出</p>\n<p>用途：拓扑排序，还可以用于检测有向图是否为DAG</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TopSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( 每个顶点v )</span><br><span class=\"line\">\t\tif( Indegree[v]==0 )</span><br><span class=\"line\">\t\t\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=queue.dequeue();</span><br><span class=\"line\">\t\t输出或记录v;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t\tfor( v的每个结点w )</span><br><span class=\"line\">\t\t\tif( --Indegree[w]==0 )</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( cnt!=v )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tError(图中有回路)</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O(v+e)</p>\n<h3 id=\"关键路径问题\"><a href=\"#关键路径问题\" class=\"headerlink\" title=\"关键路径问题\"></a>关键路径问题</h3><p>AOE( Activity On Edge )网络</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一般用于安排项目的工序</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG\" alt=\"mark\"></p>\n<p>EarliestTime[0]=0<br>EarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG\" alt=\"mark\"></p>\n<p>LastTime[i]=min($\\in$E) { LastTime[j]-C}</p>\n<p>机动时间： D = LastTime[j]-EarlistTime[i]-C</p>\n<p>关键路径：绝对不允许延误的活动组成的路径</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>什么是图(Graph)：<br>表示多对多的关系<br>包含<br>一组顶点：通常用V(Vertex)表示顶点集合<br>一组边：通常用E(Edge)表示边的集合<br>边是顶点对<br>无向边 (v,w)$\\in$E ， 其中 v,w $\\in$ V<br>有向边 表示从v指向w的边<br>不考虑重边和自回路</p>","more":"<p>此前学过的树、线性序列，均可视作图的<strong>特例</strong>。<br>在线性序列中，只有直接前驱和后继有邻接关系<br>在树中，只有父节点和子节点之间定义邻接关系</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/FhHfljELG8.png?imageslim\" alt=\"序列、树、图\"></p>\n<p><strong>分类：</strong><br>1.<strong>无向图(undigraph)</strong>：所有邻接顶点之间次序无所谓 (u为v好友，则v也必定为u好友)<br>2.<strong>有向图(digraph)</strong>：所有邻接顶点之间有次序(u为v好友，v不一定为u好友) u-&gt;v 即 (u,v) u为尾(tail)，v为头(head)<br>3.<strong>混合图</strong>：邻接关系中有的与次序有关，有的与次序无关<br>4.<strong>网络(network)</strong>：边有权重</p>\n<p>以有向图为根本学习，因为无向图可以变为邻接顶点之间双向连接的有向图，混合图也可以化成有向图。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170819/20c7c6lK0G.png?imageslim\" alt=\"分类图\"></p>\n<p>概念：</p>\n<ul>\n<li><p><strong>路径 </strong>：</p>\n<p>定义：顶点按依次邻接的关系连成的序列<br>简单路径：不含重复节点的路径<br>一般路径：可能含重复节点<br>环路：起点和终点重合</p>\n<ul>\n<li><p><strong>彼此邻接</strong>：<br>彼此间存在边的两个顶点</p>\n</li>\n<li><p><strong>连通</strong>：<br>若v到w存在一条路径，则称v和w是连通的<br>强连通：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有向图中v和w存在双向路径</span><br></pre></td></tr></table></figure>\n<p><strong>连通分量</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无向图的**极大**连通子图</span><br><span class=\"line\">    极大顶点数：再加1个顶点就不连通</span><br><span class=\"line\">    极大边数：包含子图中所有顶点相连的所有边</span><br><span class=\"line\">**强连通分量**：</span><br><span class=\"line\">    有向图的极大强连通子图</span><br></pre></td></tr></table></figure>\n<p><strong>连通图</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">图中任意两顶点均连通</span><br><span class=\"line\">**强连通图**：</span><br><span class=\"line\">    有向图中所有顶点都是强连通</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>有向无环图</strong>(directed acyclic graph DAG)：<br>图为有向图且不包含任何环路</p>\n</li>\n<li><p><strong>欧拉环路</strong>：<br>经过所有边且恰好只经过所有边一次的环路</p>\n</li>\n<li><p><strong>哈密尔顿环路</strong>：<br>经过所有节点且只经过所有点一次</p>\n</li>\n<li><p><strong>简单图</strong>：<br>所有节点均不含自环的图</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象数据类型定义\"><a href=\"#抽象数据类型定义\" class=\"headerlink\" title=\"抽象数据类型定义\"></a>抽象数据类型定义</h2><p>名称： 图 Graph<br>数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成<br>操作集：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Graph Create();</span><br><span class=\"line\">    建立并返回空图</span><br><span class=\"line\">- Graph InsertVertex(Graph G, Vertex v);</span><br><span class=\"line\">    把顶点V插入G</span><br><span class=\"line\">- Graph InsertEdge(Graph G, Edge e);</span><br><span class=\"line\">    把顶点E插入G    </span><br><span class=\"line\">- void DFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发深度优先遍历G</span><br><span class=\"line\">- void BFS(Graph G , Vertex v);</span><br><span class=\"line\">    从v出发广度优先遍历G</span><br><span class=\"line\">- void ShortestPath(Graph G , Vertex v, int Dist[]);</span><br><span class=\"line\">    计算图G中顶点v到任意其它顶点的最短距离</span><br><span class=\"line\">- void MST(Graph G);</span><br><span class=\"line\">    计算图G的最小生成树</span><br></pre></td></tr></table></figure>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a>表示</h2><h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><p>邻接矩阵：G[N][N]——N个顶点从0到N-1编号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- G[i][j]=1 &lt;vi,vj&gt;是边</span><br><span class=\"line\">- G[i][j]=0 &lt;vi,vj&gt;不是边</span><br></pre></td></tr></table></figure>\n<p>优点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便、直观</span><br><span class=\"line\">- 方便检查任意一对顶点间是否有边</span><br><span class=\"line\">- 方便找任一顶点所有邻接点</span><br><span class=\"line\">- 方便计算任一顶点的度</span><br><span class=\"line\">    入度：指向该点的边数</span><br><span class=\"line\">    出度：从该点发出的边数</span><br></pre></td></tr></table></figure>\n<p>缺点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 浪费空间，存稀疏图（顶点多，边很少的图）时有大量无效元素</span><br><span class=\"line\">- 浪费时间，统计稀疏图中共多少条边</span><br></pre></td></tr></table></figure>\n<p>基本定义与建图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex[MaxSize];      // 顶点表</span><br><span class=\"line\">\tEdge edge[MaxSize][MaxSize]; // 邻接矩阵，边表</span><br><span class=\"line\">\tint n , e;                   // 顶点总数和边总数</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph ( Graph * g)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tg-&gt;type = UN;</span><br><span class=\"line\">\tint i,j,w;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;g-&gt;n,&amp;g-&gt;e);   // 顶点数和边数</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n; i++ )</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;vertex[i]));</span><br><span class=\"line\">\tfor( i=0; i&lt;g-&gt;n ; i++ )     // 初始化</span><br><span class=\"line\">\t\tfor( j=0; j&lt;g-&gt;n ; j++ )</span><br><span class=\"line\">\t\t\tg-&gt;edge[i][j]=INF;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;w);  // 输入e条边的权值</span><br><span class=\"line\">\t\tg-&gt;edge[i][j]=w;</span><br><span class=\"line\">\t\tg-&gt;edge[j][i]=w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>优点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 方便找任一顶点的所有邻接点</span><br><span class=\"line\">- 节约稀疏图的空间</span><br><span class=\"line\">    需要N个头指针，2E个结点（每个节点至少两个域）</span><br><span class=\"line\">    E &lt; n(n-1)/4 时省空间</span><br><span class=\"line\">- 方便计算无向图的度</span><br><span class=\"line\">    有向图只能计算出度，需要构造逆邻接表（存指向自己的边）</span><br></pre></td></tr></table></figure>\n<p>基本定义与实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char Vertex;</span><br><span class=\"line\">typedef int Edge;</span><br><span class=\"line\">#define MaxSize 1000</span><br><span class=\"line\">#define INF 0x7fffffff</span><br><span class=\"line\">enum GraphType&#123; DG, UG, DN, UN &#125;;</span><br><span class=\"line\">/* 有向图，无向图，有向网图，无向网图 */</span><br><span class=\"line\"></span><br><span class=\"line\">struct ENode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint adjv;    // 指向顶点的序号</span><br><span class=\"line\">\tENode * next;</span><br><span class=\"line\">\tint weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct VNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVertex vertex;</span><br><span class=\"line\">\tENode *firstEdge;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct Graph</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVNode nodeList[MaxSize];</span><br><span class=\"line\">\tint n,e;</span><br><span class=\"line\">\tGraphType type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void CreateGraph( Graph *g )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i,j;</span><br><span class=\"line\">\tENode *edge;</span><br><span class=\"line\">\tg-&gt;type = DG;</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;(g-&gt;n),&amp;(g-&gt;e));</span><br><span class=\"line\">\tfor( i=0 ; i&lt;g-&gt;n ; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%c&quot;,&amp;(g-&gt;nodeList[i].vertex));</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;g-&gt;e ; k++ )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d %d&quot;,&amp;i,&amp;j);</span><br><span class=\"line\">\t\tedge = new ENode();</span><br><span class=\"line\">\t\tedge-&gt;adjv = j;</span><br><span class=\"line\">\t\tedge-&gt;next = g-&gt;nodeList[i].firstEdge;</span><br><span class=\"line\">\t\tg-&gt;nodeList[i].firstEdge = edge;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><h3 id=\"深度优先搜索-DFS-Depth-First-Search\"><a href=\"#深度优先搜索-DFS-Depth-First-Search\" class=\"headerlink\" title=\"深度优先搜索 DFS (Depth First Search)\"></a>深度优先搜索 DFS (Depth First Search)</h3><p>相当于树的先序遍历</p>\n<p>N个顶点，E条边，时间复杂度：<br>用邻接表存储时，为O(N+E)<br>用邻接矩阵存储时，为O($N^2$);</p>\n<p>伪代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void DFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\tDFS(w);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"广度优先搜索-BFS-Breadth-First-Search\"><a href=\"#广度优先搜索-BFS-Breadth-First-Search\" class=\"headerlink\" title=\"广度优先搜索 BFS (Breadth First Search)\"></a>广度优先搜索 BFS (Breadth First Search)</h3><p>相当于树的层序遍历</p>\n<p>用<strong>队列</strong>实现，把起始结点加入队列后<br>每次取队头节点，把该结点所有未访问的结点加入队尾，重复该操作直至队列为空，即所有结点都被访问过</p>\n<p>N个顶点，E条边，时间复杂度和DFS相同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 用邻接表存储时，为O(N+E)</span><br><span class=\"line\">- 用邻接矩阵存储时，为O($N^2$);</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BFS( Vertex v )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisited[v]=true;</span><br><span class=\"line\">\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!q.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=q.dequeue();</span><br><span class=\"line\">\t\tfor( v 的每个邻接点w )</span><br><span class=\"line\">\t\t\tif(!visited[w])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tvisited[w]=true;</span><br><span class=\"line\">\t\t\t\tq.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BFS适合找最优解<br>DFS适合找任意一解</p>\n<h2 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h2><p>定义：<br>在网络中，求两个不同顶点之间所有路径中，边权值之和最小的一条路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 该路径就是两点之间的最短路径</span><br><span class=\"line\">- 第一个顶点为源点</span><br></pre></td></tr></table></figure>\n<p>分类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 单源最短路：</span><br><span class=\"line\">    从某固定源点出发，求其到所有其他顶点的最短路径</span><br><span class=\"line\">    - 无权图</span><br><span class=\"line\">    - 有权图</span><br><span class=\"line\">2. 多源最短路：</span><br><span class=\"line\">    求任意两顶点之间的最短路径</span><br></pre></td></tr></table></figure>\n<h3 id=\"无权图的单源最短路算法\"><a href=\"#无权图的单源最短路算法\" class=\"headerlink\" title=\"无权图的单源最短路算法\"></a>无权图的单源最短路算法</h3><p>按照<strong>递增（非递减）</strong>的顺序找出到各个顶点的最短路</p>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// dist[w] = s到w的最短距离</span><br><span class=\"line\">// dist[s] = 0</span><br><span class=\"line\">// path[w] = s到w路径的倒数第二个顶点</span><br><span class=\"line\"></span><br><span class=\"line\">void　Unweighted( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueue.enqueue(s);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = queue.dequeue();</span><br><span class=\"line\">\t\tfor( v的每个邻接点w )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( dist[w]==-1 )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=dist[v]+1;</span><br><span class=\"line\">\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print(int s , int w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(path[w]==-1) return;</span><br><span class=\"line\">\twhile(path[w]!=s)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack.push(path[w]);</span><br><span class=\"line\">\t\tw=path[w];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(!stack.empty())</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;,stack.pop());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( v + e )</p>\n<h3 id=\"有权图的单源最短路算法\"><a href=\"#有权图的单源最短路算法\" class=\"headerlink\" title=\"有权图的单源最短路算法\"></a>有权图的单源最短路算法</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/7H93JDhHe3.JPG\" alt=\"mark\"></p>\n<p>不考虑<strong>负值圈(negative-cost cycle)</strong></p>\n<p>按照递增顺序找到各个顶点的最短路： Dijkstra算法</p>\n<h4 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra:\"></a>Dijkstra:</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 令 S = &#123; 源点S + 已经确定了最短路径的顶点vi &#125;</span><br><span class=\"line\">- 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点。即路径&#123;s -&gt; (vi$\\in$s) -&gt; v&#125;的最小长度</span><br><span class=\"line\">- 路径按照递增（非递减）的顺序生成</span><br><span class=\"line\">    - 真正的最短路一定只经过s中的顶点</span><br><span class=\"line\">    - 每次从未收录的顶点中选一个dist最小的收录</span><br><span class=\"line\">    - 增加一个v进入s，可能影响w的最小值</span><br><span class=\"line\">        dist[w]=min(dist[w]+&lt;v,w&gt;);</span><br><span class=\"line\">    - 初始化为INF</span><br></pre></td></tr></table></figure>\n<p>伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Dijkstra( int s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录顶点中dist最小的</span><br><span class=\"line\">\t\tif( v 不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcollected[v]=true;</span><br><span class=\"line\">\t\tfor( v 的每个顶点w )</span><br><span class=\"line\">\t\t\tif( collected[w]==false )</span><br><span class=\"line\">\t\t\t\tif( dist[v]+E&lt;v,w&gt; &lt; dist[w])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tdist[w]=dist[v]+E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\t\tpath[w]=v;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：取决于如何找到dist最小的节点</p>\n<p>方法1： 直接扫描所有未收录节点 O(v)<br>O($v^2$+e) (稠密图效果好)<br>方法2： 把dist存入最小堆中 O(logv)<br>更新dist[w]的值： O(logv)<br>O(elogv) (稀疏图效果好)</p>\n<h3 id=\"多源最短路\"><a href=\"#多源最短路\" class=\"headerlink\" title=\"多源最短路\"></a>多源最短路</h3><p>方法1： 把单源最短路调用V遍 O( v3+e*v )</p>\n<p>方法2： Floyd算法 O( v3 )</p>\n<h4 id=\"Floyd算法：\"><a href=\"#Floyd算法：\" class=\"headerlink\" title=\"Floyd算法：\"></a>Floyd算法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- D(k)[i][j] = 路径 &#123; i -&gt; &#123;l&lt;=k&#125; -&gt; j &#125;的最小长度 (从i到j只经过编号&lt;=k的顶点)</span><br><span class=\"line\">- D(0)[i][j]...D(v-1)[i][j]给出i到j的真正最短距离</span><br><span class=\"line\">- 初始化D为带权值的邻接矩阵，对角元为0</span><br><span class=\"line\">- 若i,j之间无直接边，则初始化为INF</span><br><span class=\"line\">- 若D(k-1)已完成，递推D(k):</span><br><span class=\"line\">    - 若k$\\notin$最短路径，则 D(K)=D(K-1)</span><br><span class=\"line\">    - 若k$\\in$最短路径,则该路径必定由两段最短路径组成：</span><br><span class=\"line\">        D(k)[i][j]= D(k-1)[i][k]+D(k-1)[k][j]</span><br></pre></td></tr></table></figure>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Floyd()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tD[i][j]=G[i][j]</span><br><span class=\"line\">\t\t\tpath[i][j]=-1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tfor( int k=0; k&lt;n ; k++ )</span><br><span class=\"line\">\t\tfor( int i=0; i&lt;n ; i++ )</span><br><span class=\"line\">\t\t\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t\t\t\tif(D[i][k]+D[k][j]&lt;D[i][j])</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\tD[i][j]=D[i][k]+D[k][j];</span><br><span class=\"line\">\t\t\t\t\tpath[i][j]=k;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void print( int i , int j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(i==j) return;</span><br><span class=\"line\">\tprint(i,path[i][j]);</span><br><span class=\"line\">\tprintf(path[i][j]);</span><br><span class=\"line\">\tprint(path[i][j],j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最小生成树-Minimum-Spanning-Tree\"><a href=\"#最小生成树-Minimum-Spanning-Tree\" class=\"headerlink\" title=\"最小生成树 Minimum Spanning Tree\"></a>最小生成树 Minimum Spanning Tree</h2><p>定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一棵树：</span><br><span class=\"line\">    - 无回路</span><br><span class=\"line\">    - V个顶点一定有V-1条边</span><br><span class=\"line\">- 生成树：</span><br><span class=\"line\">    - 包含所有顶点</span><br><span class=\"line\">    - V-1条边都包含在图里</span><br><span class=\"line\">    - 生成树中任加一条边都一定构成回路</span><br><span class=\"line\">- 最小：</span><br><span class=\"line\">    - 边的权重和最小</span><br></pre></td></tr></table></figure>\n<p>最小生成树存在 &lt;=&gt; 图连通</p>\n<p>方法：<strong>贪心</strong></p>\n<p>约束条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 只能用图里的边</span><br><span class=\"line\">2. 只能正好用掉V-1条边</span><br><span class=\"line\">3. 不能有回路</span><br></pre></td></tr></table></figure>\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>核心思想：让小树长大</p>\n<p>思路：从起始点出发，每次选取到树的距离（权值）最小的节点并加入树中，重复操作直至所有节点都纳入树中</p>\n<p>适用场景：稠密图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Prim()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;s&#125;  // 初始化，树中只有初始结点</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv = 未收录结点中到树距离最小的</span><br><span class=\"line\">\t\tif( v不存在 )</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t把v收入MST中： dist[v]=0</span><br><span class=\"line\">\t\tfor( v的所有邻接点w )</span><br><span class=\"line\">\t\t\tif( w 未被收录：dist[w]!=0 &amp;&amp; E&lt;v,w&gt; &lt; dist[w] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdist[w]=E&lt;v,w&gt;;</span><br><span class=\"line\">\t\t\t\tparent[w]=v;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化： dist[v]= E (若s和v有直接边) 或 INF (s和v没有直接边)</p>\n<p>不需要实际构造一棵树，用parent数组记录节点的父节点序号，初始化为-1</p>\n<p>时间复杂度： O($v^2$)</p>\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>核心思想：森林合并成树</p>\n<p>思路：把每个结点都看作单独的一棵树，每次从边中选取权值最小的(不构成回路)，并将边所连接的两棵树合并，重复操作直至收录了v-1条边</p>\n<p>适用场景：稀疏图</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Kruskal (Graph G)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMST = &#123;&#125;</span><br><span class=\"line\">\twhile( MST不到V-1条边 &amp;&amp; E中还有边 )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tE中选取权重最小的边E&lt;v,w&gt;;   // 用最小堆</span><br><span class=\"line\">\t\t把E&lt;v,w&gt;从e中删除</span><br><span class=\"line\">\t\tif( E&lt;v,w&gt; 不在MST中构成回路 )   // 并查集，判断v和w在不在同一棵树（集合）</span><br><span class=\"line\">\t\t\t将E&lt;v,w&gt;加入MST；</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\t无视E&lt;v,w&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( MST里节点数&lt; v 个 )</span><br><span class=\"line\">\t\tError( 生成树不存在 ) // 说明图本身不连通</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O( E*logE )</p>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><p>AOV （Activity On Vertex）网络</p>\n<p>拓扑序：若v到w有一条路径，那么v一定排在w前面，满足该条件的顶点序列</p>\n<p>拓扑排序: 获得一个拓扑序的过程为</p>\n<p>AOV若有<strong>合理</strong>的拓扑序，则必定是有向无环图DAG(Directed Acyclic Graph) (合理：不存在环)</p>\n<p>思路：扫描图中所有节点，选取所有入度为0的结点，记录或输出，并修改与这些节点相连的结点的入度，重复操作直至所有结点都被记录或输出</p>\n<p>用途：拓扑排序，还可以用于检测有向图是否为DAG</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void TopSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( 每个顶点v )</span><br><span class=\"line\">\t\tif( Indegree[v]==0 )</span><br><span class=\"line\">\t\t\tqueue.enqueue(v);</span><br><span class=\"line\">\twhile(!queue.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv=queue.dequeue();</span><br><span class=\"line\">\t\t输出或记录v;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t\tfor( v的每个结点w )</span><br><span class=\"line\">\t\t\tif( --Indegree[w]==0 )</span><br><span class=\"line\">\t\t\t\tqueue.enqueue(w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( cnt!=v )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tError(图中有回路)</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度： O(v+e)</p>\n<h3 id=\"关键路径问题\"><a href=\"#关键路径问题\" class=\"headerlink\" title=\"关键路径问题\"></a>关键路径问题</h3><p>AOE( Activity On Edge )网络</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 一般用于安排项目的工序</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/ed832gdd6G.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/C4JeG3mb6d.JPG\" alt=\"mark\"></p>\n<p>EarliestTime[0]=0<br>EarliestTime[j] = max($\\in$E) {EarliestTime[i]+C}</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170920/K9ba44fdec.JPG\" alt=\"mark\"></p>\n<p>LastTime[i]=min($\\in$E) { LastTime[j]-C}</p>\n<p>机动时间： D = LastTime[j]-EarlistTime[i]-C</p>\n<p>关键路径：绝对不允许延误的活动组成的路径</p>"},{"layout":"post","title":"数据结构笔记（一）：线性表","date":"2017-08-11T16:00:00.000Z","comments":1,"_content":"\n# **写在前面的话**\n\n开始数据结构的学习，将学习过程中的思维过程和代码记录下来。\n教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》\n辅以清华大学以及浙江大学的mooc。\n\n<!-- more -->\n\n# **概述**\n\n## 线性表 List\n\n线性表的定义：由同类型**数据元素**构成**有序序列**的线性结构\n\n```\n- 表中元素的个数称为线性表的**长度**\n- 线性表中没有元素时称为**空表**\n- 表起始位置称为**表头**，表结束为止称为**表尾**\n\n```\n\n线性表的操作类型：\n\n1. 静态操作：仅读取，内容和组成一般不变，如get、search\n2. 动态操作：需写入，局部或整体将改变，如insert、remove\n\n基本操作：\n\n```\n1. List MakeList()\n> 初始化一个空的线性表\n2. Element FindIndex(int index)\n> 根据位序k返回相应元素\n3. int Find(Element x)\n> 查找x第一次出现的位置\n4. void Insert(Element x , int index)\n> 在位序index前插入一个新元素x\n5. void Delete(int index)\n> 删除指定位序的元素\n\n```\n\n实现方式：\n\n```\n1. 顺序存储实现：数组\n\n```\n\n```\ntypedef struct ListNode * List\nstruct ListNode\n{\n\tElement data[MAX_SIZE];\n\tint last;\n}\n```\n\n```\n2. 链式存储实现：链表\n> 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系\n\n```\n\n以下以链表为主介绍并实现线性表\n\n## **链表特点：**\n\n动态存储：\n\n1. 各元素动态地分配和回收空间\n2. 逻辑上相邻的元素记录彼此的物理地址\n3. 动态操作高效，静态操作费时，循秩访问低效\n\n各节点通过指针或引用连接，在逻辑上形成线性序列\n\n**链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。**\n\n以下均用c++实现。\n\n# **分类**\n\n1.单向链表\n\n> 仅有succ指针\n\n2.双向链表\n\n> 有pred和succ指针\n\n3.循环单链表\n\n> 单向链表 + 末节点和首节点相连\n\n4.循环双链表\n\n> 双向链表 + 末节点和首节点相连\n\n5.静态链表\n\n> 在没有指针的语言中使用，借用数组模拟链表\n\n## **建议**\n\n使用**哨兵**节点\n\n单向链表增加**首**哨兵\n\n双向链表增加**首末**哨兵\n\n哨兵不对外公开，在一开始创建，最后销毁\n\n**优点：简化边界条件，增加鲁棒性**\n\n# **单链表**\n\n**基本定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n};\n\ntemplate < typename T >\nstruct list\n{\n    node<T> *header;\n    int _size;\n}\n```\n\n**带接口完整定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n    node( T const & e , node<T> * suc=NULL):data(e),succ(suc) {}\n    node() {succ=NULL;}\n    node<T> * insertAft( T const & e );\n};\n\ntemplate < typename T >\nstruct list\n{\nprivate:\n    node<T> *header;\n    int _size;\npublic:\n    void init ();\n    int clear ();\n    void copyNodes ( node<T> *p , int n );     \n    //从p开始复制n个节点到链表末尾\n    void merge ( node<T> *& p1, int n1, node<T> *&p2, int n2 );\n    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( node<T> *&p, int n );      \n    // 对从p开始连续的n个节点归并排序\n\n    list() { init(); }\n    list( node<T> *p , int n );     // 从p开始复制n个节点\n    ~list();\n\n    // 只读接口\n    bool empty() { return _size==0; }\n    int size() { return _size; }\n    T& operator[] ( int r ) const;    // 实现寻秩访问\n    node<T> * find( T const&e ) const;\n    node<T> * find( T const& e,  node<T>* p, int n ) const;\n    // (无序)从节点p向后n个节点（不含p）内找e\n    node<T> * search( T const & e , node<T> * p , int n ) const;\n    // (有序) 不大于e的最后一个\n    void show();\n\n    // 可写接口\n    node<T> * insertBefore( node<T> *p, T const & e );\n    node<T> * insertAfter( node<T> *p, T const & e );\n    node<T> * insertLast( T const & e );\n    node<T> * insertFirst( T const & e );\n    void createListT( T const * e , int n ); // 尾插法创建链表\n    void createListH( T const * e , int n ); // 头插法创建链表\n    T remove( node<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    void sort(); // 排序\n};\n```\n\n**基本接口**：\n\n\\1. 创建链表\n\n> 分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表\n\n\\2. 插入单节点\n\n> 分为在某节点前、后插入，在表头、表尾插入\n\n\\3. 查找数据\n\n> 无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素\n\n\\4. 循秩访问第n个节点\n\n> 可重载[]运算符，也可单独使用一个函数\n\n\\5. 删除单个节点\n\n\\6. 清空链表\n\n> 思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL\n\n\\7. 打印链表\n\n\\8. 检查链表是否为空\n\n\\9. 返回链表长度\n\n\\10. 排序（归并、插入、选择等）\n\n\\11. 去重（无序、有序版）\n\n\\12. 反转\n\n## 具体实现\n\n### 1. 创建链表\n\n1-1 创建空链表\n\n```\ntemplate < typename T >\nvoid list<T>::init()\n{\n    header = new node<T>; //构造函数已将后继默认置位NULL\n    _size=0;\n}\n```\n\n1-2 尾插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListT( T const *& e , int n )\n{\n    node<T> * last=header; // last作为链表最后一个节点\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i] );\n        last->succ=tem;  // 顺序不可反\n        last=tem;\n    }\n    return;\n}\n```\n\n1-3 头插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListH( T const *& e , int n )\n{\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i], header->succ );\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n1-4 复制链表\n\n```\ntemplate < typename T >\nlist<T>::list( node<T> * p, int n )\n{\n    init();\n    copyNodes( p , n );\n}\n\ntemplate < typename T >\nvoid list<T>::copyNodes( node<T> * p, int n )\n{\n    node<T> *tem=header;\n    while( tem->succ ) // 先探好路再迈步\n        tem=tem->succ;  // tem指向存在的最后一个元素\n    node<T> *create;\n    _size+=n;\n    while(n--)\n    {\n        create=new node<T> ( p->data );\n        tem->succ=create;\n        p=p->succ;\n        tem=tem->succ;  // 实时更新链表尾\n    }\n    return;\n}\n```\n\n### 2. 插入单节点\n\n2-0. 准备：node类的插入函数\n\n```\ntemplate < typename T >\nnode<T> * node<T>::insertAft( T const & e )\n{\n    node<T> *tem=new node<T>( e , succ );\n    succ=tem;\n    return tem;\n}\n```\n\n2-1. 在某节点前插入\n\n```\ntemplate < typename T >\nnode<T> * insertBefore( node<T> *p, T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( (tem=tem->succ)!=p );\n    return tem->insertAft(e);\n}\n```\n\n2-2. 在某节点后插入\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertAfter( node<T> *p, T const & e)\n{\n    _size++;\n    return p->insertAft(e);\n}\n```\n\n2-3. 插入表头\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertFirst( T const & e )\n{\n    _size++;\n    return header->insertAft(e);\n}\n```\n\n2-4. 插入表尾\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertLast( T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( tem->succ )\n        tem=tem->succ;\n    return tem->insertAft(e);\n}\n```\n\n### 3. 查找元素\n\n3-1. 无序链表查找\n\n3-1-0. 整链表查找\n\n```\ntemplate < typename T >\nnode<T> * list<T>::find( T const& e ) const\n{\n    return find( e, header, ,_size );\n}\n```\n\n3-1-1. 部分链表查找\n\n```\ntemplate <typename T>\nnode<T> * list<T>::find( T const& e, node<T>* p , int n ) const\n{  ( p , p+n ]\n    while(n--)\n        if( e==( p=p->succ )->data )\n            return p;\n    return NULL;\n}\n```\n\n3-2. 有序链表查找\n\n返回不大于e的最后一个元素，方便后续插入操作\n\n此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低\n\n```\ntemplate <typename T>\nnode<T> * list<T>::search( T const & e, node<T> * p, int n ) const\n{  [ p , p+n )\n    node<T> *tem=header;  // tem作为p的直接前驱\n    while( tem->succ != p )\n        tem=tem->succ;\n    while( n-- &&p )\n    {\n        if( p->data>e )\n            break;\n        p=p->succ;\n        tem=tem->succ;\n    }\n    return tem;\n}\n```\n\n### 4. 循秩访问单个节点\n\n方式：重载()运算符\n\n```\ntemplate <typename T>\nT & list<T>::operator [] (int r) const\n{\n    node<T> *p=header;\n    while( ( p=p->succ ) && r-- );\n    return p->data;\n}\n```\n\n此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问**本质不同**。\n\n链表的为披着循秩访问外皮的按位置访问。\n\n而顺序表 V[i] = V + i*s (s为单个元素大小)\n\n时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。\n\n### 5. 删除单个节点\n\n```\ntemplate <typename T>\nT list<T>::remove( node<T> * p )\n{\n    T tem=p->data;\n    node<T> *pre=header;\n    while( pre->succ!=p )\n        pre=pre->succ;\n    pre->succ=p->succ;\n    delete p;\n    _size--;\n    return tem;\n}\n```\n\n### 6. 清空链表\n\n```\ntemplate <typename T>\nint list<T>::clear()\n{\n    int old_size=_size;\n    if( header->succ==NULL )\n        return 0;\n    while( header->succ )\n        remove( header->succ );\n    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零\n    return old_size;\n}\n```\n\n### 10. 排序\n\n10-1 归并排序\n\n归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾\n\n该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上\n\n```\ntemplate <typename T>\nvoid list<T>::merge ( node<T> * &p1, int n1, node<T> *&p2, int n2 ) //使用引用绑定节点防止丢失\n{\n    node<T> *head;\n    node<T> *pree=header;\n    while( pree->succ!=p1 )\n        pree=pree->succ;\n    head=pree;\n    node<T> *px1=p1,*px2=p2,*px3;\n    for(int i=0; i<n1-1 ; i++)\n        px1=px1->succ;\n    for(int i=0; i<n2-1 ; i++)\n        px2=px2->succ;\n    px3=px2->succ;\n    px1->succ=px2->succ=NULL;\n    px1=p1;\n    while( n1&&n2 )\n    {\n        if( px1->data<=p2->data )\n        {\n            pree->succ=px1;\n            pree=pree->succ;\n            px1=px1->succ;\n            n1--;\n        }\n        else\n        {\n            pree->succ=p2;\n            pree=pree->succ;\n            p2=p2->succ;\n            n2--;\n        }\n    }\n    if( n1 )\n        pree->succ=px1;\n    if( n2 )\n        pree->succ=p2;\n    while( pree->succ )\n        pree=pree->succ;\n    pree->succ=px3;\n    p1=head->succ;  // 最后设置好排序后的头结点\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::mergeSort( node<T> *&p, int n )\n{ // [ p, p+n ]\n    if(n<2) return;\n    int mid=n/2;\n    node<T> *tem=p;\n    for(int i=0; i<mid; i++)  tem=tem->succ;\n    mergeSort( p, mid );\n    mergeSort( tem, n-mid );\n    merge( p,mid, tem , n-mid );\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::sort( )\n{\n    mergeSort( header->succ , _size );\n}\n```\n\n### 11. 去重\n\n11-1. 无序链表\n\n常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)\n\n其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)\n\n```\ntemplate <typename T>\nint list<T>::deduplicate()\n{\n    if( _size<2 ) // 少于2个节点无需去重\n        return;\n    node<T> *p=header->succ->succ; //第一个节点必定已去重\n    node<T> *pre=header->succ;\n    int old_size=_size;  // 保存_size，方便返回删除数目\n    int r=1;  // 已去重数目\n    while( p )\n    {\n        if( find( p->data , header , r )!=NULL )\n        {    // 借用find接口\n            pre->succ=p->succ;\n            delete p;\n            p=pre->succ;\n            continue;\n        }\n        r++;\n        p=p->succ;\n        pre=pre->succ;\n    }\n    return old_size-_size;\n}\n```\n\n11-2. 有序链表\n\n思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)\n\n```\ntemplate <typename T>\nint list<T>::uniquify()\n{\n    if(_size<2)\n        return 0;\n    int old_size=_size;\n    node<T> *p=header->succ,*q;\n    while( NULL != ( q = p->succ ) ) // q作为p的直接后继，检测是否重复\n        (p->data == q->data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步\n    return old_size-_size;\n}\n```\n\n### 12. 反转\n\n思路：固定目前的首节点，即header->succ，每次将它的直接后继重新绑定至header的直接后继。\n\n```\ntemplate <typename T>\nvoid list<T>::reverse()\n{\n    if(_size<2)\n        return;\n    node<T> *fir=header->succ;\n    node<T> *tem;\n    while( fir->succ )\n    {\n        tem=fir->succ;\n        fir->succ=tem->succ;\n        tem->succ=header->succ;\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n# **双向链表**\n\n双链表和单链表类似，但不同在于有**首末**两个哨兵，每个节点有**前驱**和**后缀**指针，可以省去从头访问到某节点的前驱的时间。\n\n代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。\n\n**基本定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n};\ntemplate <typename T>\nstruct List\n{\n    int _size ;\n    ListNode<T> * header,*trailer;\n};\n```\n\n**带接口定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n    //列表节点模板类（以双向链表形式实现）\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n\n    ListNode () {}\n    ListNode ( T const & e, ListNode<T> * p = NULL, ListNode<T> *a = NULL)\n        :data(e),pred(p),succ(a){}\n\n    ListNode<T> * insertAsPred ( T const & e );\n    ListNode<T> * insertAsSucc ( T const & e );\n};\n\ntemplate <typename T>\nstruct List\n{\nprivate:\n\n    int _size ;\n    ListNode<T> * header,*trailer;\n\nprotected:\n    void init ();\n    void merge ( ListNode<T> * p1, int n1 , List<T>&L,  ListNode<T> *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( ListNode<T> *p, int n );      // 对从p开始连续的n个节点归并排序\n    void selectionSort ( ListNode<T> *p, int n );   // [ p,p+n ) 选择排序\n    void insertionSort ( ListNode<T> *p, int n );   // 对从p开始连续的n个节点插入排序\n\npublic:\n    List() { init(); }\n    List( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    List( T *p , int n );\n    ~List();\n\n    // 只读接口\n    int size() const { return _size; }\n    bool empty() { return _size==0; }\n    T & operator [] ( int r ) const;    // 实现寻秩访问\n    ListNode<T> * first()const\n        {return header->succ;}\n    ListNode<T> * last() const\n        {return trailer->pred;}\n    ListNode<T> * find( T const&e ) const\n        {return find(e,_size,trailer);}\n    ListNode<T> * find( T const& e, int n, ListNode<T>* p ) const; // (无序)从节点p向前n个节点（不含p）内找e\n    ListNode<T> * search( T const & e , int n , ListNode<T> * p ) const; // (有序) 不大于e的最后一个\n    ListNode<T> * selectMax ( ListNode<T> *p , int n )const ;\n    void show() const;\n\n    // 可写接口\n    ListNode<T> * insertBefore( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsPred(e); }\n    ListNode<T> * insertAfter( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsSucc(e); }\n    ListNode<T> * insertLast( T const & e )\n        { _size++; return trailer->insertAsPred(e);}\n    ListNode<T> * insertFirst( T const & e )\n        { _size++; return header->insertAsSucc(e);}\n    T remove( ListNode<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    int clear ();\n    void copyNodes ( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    void sort( ListNode<T> *p, int n, int mod );\n};\n```\n\n## 1. 排序\n\n1-1. 插入排序\n\n思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。\n\n```\ntemplate <typename T>\nvoid List<T>::insertionSort( ListNode<T> * p , int n )\n{\n    for(int r=0; r<n; r++)\n    {\n        insertAfter( search( p->data , r , p ) , p->data );\n        p=p->succ;\n        remove( p->pred );\n    }\n}\n\ntemplate <typename T>\nT List<T>::remove( ListNode<T> * p )\n{\n    T tem=p->data;\n    p->pred->succ=p->succ;\n    p->succ->pred=p->pred;\n    delete p;\n    _size--;\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsSucc( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, this, succ );\n    succ->pred=a;\n    succ=a;\n    return a;\n}\n```\n\n1-2. 选择排序\n\n思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。\n\n```\ntemplate <typename T>\nvoid List<T>::selectionSort( ListNode<T> *p, int n )\n{\n    if(n<2) return;\n    ListNode<T> *head=p->pred , *tail=p;\n    for( int i=0; i<n; i++ )\n        tail=tail->succ;\n    while( 1<n )\n    {\n        insertBefore( tail, remove( selectMax( head->succ , n ) ) );\n        tail=tail->pred;\n        n--;\n    }\n    return;\n}\ntemplate <typename T>\nListNode<T> * List<T>::selectMax ( ListNode<T> *p , int n )const\n{\n    ListNode<T> *tem=p;\n    while(n--&&p)\n    {\n        if(p->data>=tem->data)\n            tem=p;\n        p=p->succ;\n    }\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsPred( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, pred, this );\n    pred->succ=a;\n    pred=a;\n    return a;\n}\n```\n\n# **常见的链表问题**\n\n最常用方法：\n\n> 1. **快慢指针法**\n> 2. **数组过渡法**\n> 3. **先断后接、先接后断法**\n\n\\1. 单链表反转\n\n> 两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。\n\n\\2. 找单链表倒数第n个元素、或中间元素\n\n> 快慢指针法。\n>\n> 找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）\n>\n> 找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。\n>\n> 找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。\n\n\\3. 删除无头单链表的某个节点\n\n> 题意为不知header，但需要删除目前current指针指向的节点。\n>\n> 思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。\n\n\\4. 在无头单链表某节点前增加节点\n\n> 思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。\n\n\\5. 判断单链表是否有环(可能是部分环，非循环单链表)\n\n> 快慢指针法\n>\n> 一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。\n\n\\6. 判断两单链表是否相交\n\n> 首先明确：两单链表一旦相交，自交点之后的节点将完全相同！\n>\n> 时间复杂度均为O( len1+len2 )\n>\n> 1. 法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素\n> 2. 法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。\n> 3. 法3：直接法：直接判断两链表末节点是否相同\n\n\\7. 已知两单链表相交，求相交点\n\n> 快慢指针法\n>\n> 先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点\n\n\\8. 求两递增单链表AB差集A-B(元素在A而不在B)\n\n> 归并的思想\n>\n> 每次取表头元素进行大小判断，若A’<’B则通过，若A==B则剃除，若A>B则将B指针向后移动直至A’<’B或A==B\n\n# **完整实现代码**\n\n[单向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/single_list.cpp)\n\n[双向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/double_list.cpp)","source":"_posts/DataStructure_List.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（一）：线性表\"\ndate: 2017-08-12\ncomments: true\ntags: \n    - 学习笔记\n    - c++\n    - 数据结构\n\n---\n\n# **写在前面的话**\n\n开始数据结构的学习，将学习过程中的思维过程和代码记录下来。\n教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》\n辅以清华大学以及浙江大学的mooc。\n\n<!-- more -->\n\n# **概述**\n\n## 线性表 List\n\n线性表的定义：由同类型**数据元素**构成**有序序列**的线性结构\n\n```\n- 表中元素的个数称为线性表的**长度**\n- 线性表中没有元素时称为**空表**\n- 表起始位置称为**表头**，表结束为止称为**表尾**\n\n```\n\n线性表的操作类型：\n\n1. 静态操作：仅读取，内容和组成一般不变，如get、search\n2. 动态操作：需写入，局部或整体将改变，如insert、remove\n\n基本操作：\n\n```\n1. List MakeList()\n> 初始化一个空的线性表\n2. Element FindIndex(int index)\n> 根据位序k返回相应元素\n3. int Find(Element x)\n> 查找x第一次出现的位置\n4. void Insert(Element x , int index)\n> 在位序index前插入一个新元素x\n5. void Delete(int index)\n> 删除指定位序的元素\n\n```\n\n实现方式：\n\n```\n1. 顺序存储实现：数组\n\n```\n\n```\ntypedef struct ListNode * List\nstruct ListNode\n{\n\tElement data[MAX_SIZE];\n\tint last;\n}\n```\n\n```\n2. 链式存储实现：链表\n> 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系\n\n```\n\n以下以链表为主介绍并实现线性表\n\n## **链表特点：**\n\n动态存储：\n\n1. 各元素动态地分配和回收空间\n2. 逻辑上相邻的元素记录彼此的物理地址\n3. 动态操作高效，静态操作费时，循秩访问低效\n\n各节点通过指针或引用连接，在逻辑上形成线性序列\n\n**链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。**\n\n以下均用c++实现。\n\n# **分类**\n\n1.单向链表\n\n> 仅有succ指针\n\n2.双向链表\n\n> 有pred和succ指针\n\n3.循环单链表\n\n> 单向链表 + 末节点和首节点相连\n\n4.循环双链表\n\n> 双向链表 + 末节点和首节点相连\n\n5.静态链表\n\n> 在没有指针的语言中使用，借用数组模拟链表\n\n## **建议**\n\n使用**哨兵**节点\n\n单向链表增加**首**哨兵\n\n双向链表增加**首末**哨兵\n\n哨兵不对外公开，在一开始创建，最后销毁\n\n**优点：简化边界条件，增加鲁棒性**\n\n# **单链表**\n\n**基本定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n};\n\ntemplate < typename T >\nstruct list\n{\n    node<T> *header;\n    int _size;\n}\n```\n\n**带接口完整定义**\n\n```\ntemplate < typename T >\nstruct node\n{\n    T data;\n    node<T> *succ;\n    node( T const & e , node<T> * suc=NULL):data(e),succ(suc) {}\n    node() {succ=NULL;}\n    node<T> * insertAft( T const & e );\n};\n\ntemplate < typename T >\nstruct list\n{\nprivate:\n    node<T> *header;\n    int _size;\npublic:\n    void init ();\n    int clear ();\n    void copyNodes ( node<T> *p , int n );     \n    //从p开始复制n个节点到链表末尾\n    void merge ( node<T> *& p1, int n1, node<T> *&p2, int n2 );\n    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( node<T> *&p, int n );      \n    // 对从p开始连续的n个节点归并排序\n\n    list() { init(); }\n    list( node<T> *p , int n );     // 从p开始复制n个节点\n    ~list();\n\n    // 只读接口\n    bool empty() { return _size==0; }\n    int size() { return _size; }\n    T& operator[] ( int r ) const;    // 实现寻秩访问\n    node<T> * find( T const&e ) const;\n    node<T> * find( T const& e,  node<T>* p, int n ) const;\n    // (无序)从节点p向后n个节点（不含p）内找e\n    node<T> * search( T const & e , node<T> * p , int n ) const;\n    // (有序) 不大于e的最后一个\n    void show();\n\n    // 可写接口\n    node<T> * insertBefore( node<T> *p, T const & e );\n    node<T> * insertAfter( node<T> *p, T const & e );\n    node<T> * insertLast( T const & e );\n    node<T> * insertFirst( T const & e );\n    void createListT( T const * e , int n ); // 尾插法创建链表\n    void createListH( T const * e , int n ); // 头插法创建链表\n    T remove( node<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    void sort(); // 排序\n};\n```\n\n**基本接口**：\n\n\\1. 创建链表\n\n> 分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表\n\n\\2. 插入单节点\n\n> 分为在某节点前、后插入，在表头、表尾插入\n\n\\3. 查找数据\n\n> 无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素\n\n\\4. 循秩访问第n个节点\n\n> 可重载[]运算符，也可单独使用一个函数\n\n\\5. 删除单个节点\n\n\\6. 清空链表\n\n> 思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL\n\n\\7. 打印链表\n\n\\8. 检查链表是否为空\n\n\\9. 返回链表长度\n\n\\10. 排序（归并、插入、选择等）\n\n\\11. 去重（无序、有序版）\n\n\\12. 反转\n\n## 具体实现\n\n### 1. 创建链表\n\n1-1 创建空链表\n\n```\ntemplate < typename T >\nvoid list<T>::init()\n{\n    header = new node<T>; //构造函数已将后继默认置位NULL\n    _size=0;\n}\n```\n\n1-2 尾插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListT( T const *& e , int n )\n{\n    node<T> * last=header; // last作为链表最后一个节点\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i] );\n        last->succ=tem;  // 顺序不可反\n        last=tem;\n    }\n    return;\n}\n```\n\n1-3 头插法\n\n```\ntemplate < typename T >\nvoid list<T>::createListH( T const *& e , int n )\n{\n    node<T> * tem;\n    _size+=n;\n    for( int i=0; i<n; i++ )\n    {\n        tem = new node<T>( e[i], header->succ );\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n1-4 复制链表\n\n```\ntemplate < typename T >\nlist<T>::list( node<T> * p, int n )\n{\n    init();\n    copyNodes( p , n );\n}\n\ntemplate < typename T >\nvoid list<T>::copyNodes( node<T> * p, int n )\n{\n    node<T> *tem=header;\n    while( tem->succ ) // 先探好路再迈步\n        tem=tem->succ;  // tem指向存在的最后一个元素\n    node<T> *create;\n    _size+=n;\n    while(n--)\n    {\n        create=new node<T> ( p->data );\n        tem->succ=create;\n        p=p->succ;\n        tem=tem->succ;  // 实时更新链表尾\n    }\n    return;\n}\n```\n\n### 2. 插入单节点\n\n2-0. 准备：node类的插入函数\n\n```\ntemplate < typename T >\nnode<T> * node<T>::insertAft( T const & e )\n{\n    node<T> *tem=new node<T>( e , succ );\n    succ=tem;\n    return tem;\n}\n```\n\n2-1. 在某节点前插入\n\n```\ntemplate < typename T >\nnode<T> * insertBefore( node<T> *p, T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( (tem=tem->succ)!=p );\n    return tem->insertAft(e);\n}\n```\n\n2-2. 在某节点后插入\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertAfter( node<T> *p, T const & e)\n{\n    _size++;\n    return p->insertAft(e);\n}\n```\n\n2-3. 插入表头\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertFirst( T const & e )\n{\n    _size++;\n    return header->insertAft(e);\n}\n```\n\n2-4. 插入表尾\n\n```\ntemplate < typename T >\nnode<T> * list<T>::insertLast( T const & e )\n{\n    _size++;\n    node<T> *tem=header;\n    while( tem->succ )\n        tem=tem->succ;\n    return tem->insertAft(e);\n}\n```\n\n### 3. 查找元素\n\n3-1. 无序链表查找\n\n3-1-0. 整链表查找\n\n```\ntemplate < typename T >\nnode<T> * list<T>::find( T const& e ) const\n{\n    return find( e, header, ,_size );\n}\n```\n\n3-1-1. 部分链表查找\n\n```\ntemplate <typename T>\nnode<T> * list<T>::find( T const& e, node<T>* p , int n ) const\n{  ( p , p+n ]\n    while(n--)\n        if( e==( p=p->succ )->data )\n            return p;\n    return NULL;\n}\n```\n\n3-2. 有序链表查找\n\n返回不大于e的最后一个元素，方便后续插入操作\n\n此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低\n\n```\ntemplate <typename T>\nnode<T> * list<T>::search( T const & e, node<T> * p, int n ) const\n{  [ p , p+n )\n    node<T> *tem=header;  // tem作为p的直接前驱\n    while( tem->succ != p )\n        tem=tem->succ;\n    while( n-- &&p )\n    {\n        if( p->data>e )\n            break;\n        p=p->succ;\n        tem=tem->succ;\n    }\n    return tem;\n}\n```\n\n### 4. 循秩访问单个节点\n\n方式：重载()运算符\n\n```\ntemplate <typename T>\nT & list<T>::operator [] (int r) const\n{\n    node<T> *p=header;\n    while( ( p=p->succ ) && r-- );\n    return p->data;\n}\n```\n\n此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问**本质不同**。\n\n链表的为披着循秩访问外皮的按位置访问。\n\n而顺序表 V[i] = V + i*s (s为单个元素大小)\n\n时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。\n\n### 5. 删除单个节点\n\n```\ntemplate <typename T>\nT list<T>::remove( node<T> * p )\n{\n    T tem=p->data;\n    node<T> *pre=header;\n    while( pre->succ!=p )\n        pre=pre->succ;\n    pre->succ=p->succ;\n    delete p;\n    _size--;\n    return tem;\n}\n```\n\n### 6. 清空链表\n\n```\ntemplate <typename T>\nint list<T>::clear()\n{\n    int old_size=_size;\n    if( header->succ==NULL )\n        return 0;\n    while( header->succ )\n        remove( header->succ );\n    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零\n    return old_size;\n}\n```\n\n### 10. 排序\n\n10-1 归并排序\n\n归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾\n\n该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上\n\n```\ntemplate <typename T>\nvoid list<T>::merge ( node<T> * &p1, int n1, node<T> *&p2, int n2 ) //使用引用绑定节点防止丢失\n{\n    node<T> *head;\n    node<T> *pree=header;\n    while( pree->succ!=p1 )\n        pree=pree->succ;\n    head=pree;\n    node<T> *px1=p1,*px2=p2,*px3;\n    for(int i=0; i<n1-1 ; i++)\n        px1=px1->succ;\n    for(int i=0; i<n2-1 ; i++)\n        px2=px2->succ;\n    px3=px2->succ;\n    px1->succ=px2->succ=NULL;\n    px1=p1;\n    while( n1&&n2 )\n    {\n        if( px1->data<=p2->data )\n        {\n            pree->succ=px1;\n            pree=pree->succ;\n            px1=px1->succ;\n            n1--;\n        }\n        else\n        {\n            pree->succ=p2;\n            pree=pree->succ;\n            p2=p2->succ;\n            n2--;\n        }\n    }\n    if( n1 )\n        pree->succ=px1;\n    if( n2 )\n        pree->succ=p2;\n    while( pree->succ )\n        pree=pree->succ;\n    pree->succ=px3;\n    p1=head->succ;  // 最后设置好排序后的头结点\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::mergeSort( node<T> *&p, int n )\n{ // [ p, p+n ]\n    if(n<2) return;\n    int mid=n/2;\n    node<T> *tem=p;\n    for(int i=0; i<mid; i++)  tem=tem->succ;\n    mergeSort( p, mid );\n    mergeSort( tem, n-mid );\n    merge( p,mid, tem , n-mid );\n    return;\n}\n\ntemplate <typename T>\nvoid list<T>::sort( )\n{\n    mergeSort( header->succ , _size );\n}\n```\n\n### 11. 去重\n\n11-1. 无序链表\n\n常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)\n\n其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)\n\n```\ntemplate <typename T>\nint list<T>::deduplicate()\n{\n    if( _size<2 ) // 少于2个节点无需去重\n        return;\n    node<T> *p=header->succ->succ; //第一个节点必定已去重\n    node<T> *pre=header->succ;\n    int old_size=_size;  // 保存_size，方便返回删除数目\n    int r=1;  // 已去重数目\n    while( p )\n    {\n        if( find( p->data , header , r )!=NULL )\n        {    // 借用find接口\n            pre->succ=p->succ;\n            delete p;\n            p=pre->succ;\n            continue;\n        }\n        r++;\n        p=p->succ;\n        pre=pre->succ;\n    }\n    return old_size-_size;\n}\n```\n\n11-2. 有序链表\n\n思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)\n\n```\ntemplate <typename T>\nint list<T>::uniquify()\n{\n    if(_size<2)\n        return 0;\n    int old_size=_size;\n    node<T> *p=header->succ,*q;\n    while( NULL != ( q = p->succ ) ) // q作为p的直接后继，检测是否重复\n        (p->data == q->data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步\n    return old_size-_size;\n}\n```\n\n### 12. 反转\n\n思路：固定目前的首节点，即header->succ，每次将它的直接后继重新绑定至header的直接后继。\n\n```\ntemplate <typename T>\nvoid list<T>::reverse()\n{\n    if(_size<2)\n        return;\n    node<T> *fir=header->succ;\n    node<T> *tem;\n    while( fir->succ )\n    {\n        tem=fir->succ;\n        fir->succ=tem->succ;\n        tem->succ=header->succ;\n        header->succ=tem;\n    }\n    return;\n}\n```\n\n# **双向链表**\n\n双链表和单链表类似，但不同在于有**首末**两个哨兵，每个节点有**前驱**和**后缀**指针，可以省去从头访问到某节点的前驱的时间。\n\n代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。\n\n**基本定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n};\ntemplate <typename T>\nstruct List\n{\n    int _size ;\n    ListNode<T> * header,*trailer;\n};\n```\n\n**带接口定义**\n\n```\ntemplate <typename T>\nstruct ListNode\n    //列表节点模板类（以双向链表形式实现）\n{\n    T data;\n    ListNode<T> * pred;\n    ListNode<T> * succ;\n\n    ListNode () {}\n    ListNode ( T const & e, ListNode<T> * p = NULL, ListNode<T> *a = NULL)\n        :data(e),pred(p),succ(a){}\n\n    ListNode<T> * insertAsPred ( T const & e );\n    ListNode<T> * insertAsSucc ( T const & e );\n};\n\ntemplate <typename T>\nstruct List\n{\nprivate:\n\n    int _size ;\n    ListNode<T> * header,*trailer;\n\nprotected:\n    void init ();\n    void merge ( ListNode<T> * p1, int n1 , List<T>&L,  ListNode<T> *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序\n    void mergeSort ( ListNode<T> *p, int n );      // 对从p开始连续的n个节点归并排序\n    void selectionSort ( ListNode<T> *p, int n );   // [ p,p+n ) 选择排序\n    void insertionSort ( ListNode<T> *p, int n );   // 对从p开始连续的n个节点插入排序\n\npublic:\n    List() { init(); }\n    List( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    List( T *p , int n );\n    ~List();\n\n    // 只读接口\n    int size() const { return _size; }\n    bool empty() { return _size==0; }\n    T & operator [] ( int r ) const;    // 实现寻秩访问\n    ListNode<T> * first()const\n        {return header->succ;}\n    ListNode<T> * last() const\n        {return trailer->pred;}\n    ListNode<T> * find( T const&e ) const\n        {return find(e,_size,trailer);}\n    ListNode<T> * find( T const& e, int n, ListNode<T>* p ) const; // (无序)从节点p向前n个节点（不含p）内找e\n    ListNode<T> * search( T const & e , int n , ListNode<T> * p ) const; // (有序) 不大于e的最后一个\n    ListNode<T> * selectMax ( ListNode<T> *p , int n )const ;\n    void show() const;\n\n    // 可写接口\n    ListNode<T> * insertBefore( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsPred(e); }\n    ListNode<T> * insertAfter( ListNode<T> *p, T const & e)\n        { _size++; return p->insertAsSucc(e); }\n    ListNode<T> * insertLast( T const & e )\n        { _size++; return trailer->insertAsPred(e);}\n    ListNode<T> * insertFirst( T const & e )\n        { _size++; return header->insertAsSucc(e);}\n    T remove( ListNode<T> *p );\n    int deduplicate (); // 无序列表去重\n    int uniquify ();    // 有序列表去重\n    int clear ();\n    void copyNodes ( ListNode<T> *p , int n );     // 从p开始复制n个节点\n    void sort( ListNode<T> *p, int n, int mod );\n};\n```\n\n## 1. 排序\n\n1-1. 插入排序\n\n思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。\n\n```\ntemplate <typename T>\nvoid List<T>::insertionSort( ListNode<T> * p , int n )\n{\n    for(int r=0; r<n; r++)\n    {\n        insertAfter( search( p->data , r , p ) , p->data );\n        p=p->succ;\n        remove( p->pred );\n    }\n}\n\ntemplate <typename T>\nT List<T>::remove( ListNode<T> * p )\n{\n    T tem=p->data;\n    p->pred->succ=p->succ;\n    p->succ->pred=p->pred;\n    delete p;\n    _size--;\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsSucc( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, this, succ );\n    succ->pred=a;\n    succ=a;\n    return a;\n}\n```\n\n1-2. 选择排序\n\n思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。\n\n```\ntemplate <typename T>\nvoid List<T>::selectionSort( ListNode<T> *p, int n )\n{\n    if(n<2) return;\n    ListNode<T> *head=p->pred , *tail=p;\n    for( int i=0; i<n; i++ )\n        tail=tail->succ;\n    while( 1<n )\n    {\n        insertBefore( tail, remove( selectMax( head->succ , n ) ) );\n        tail=tail->pred;\n        n--;\n    }\n    return;\n}\ntemplate <typename T>\nListNode<T> * List<T>::selectMax ( ListNode<T> *p , int n )const\n{\n    ListNode<T> *tem=p;\n    while(n--&&p)\n    {\n        if(p->data>=tem->data)\n            tem=p;\n        p=p->succ;\n    }\n    return tem;\n}\n\n// node类的准备工作\ntemplate <typename T>\nListNode<T>* ListNode<T>::insertAsPred( T const & e )\n{\n    ListNode<T> *a=new ListNode<T>( e, pred, this );\n    pred->succ=a;\n    pred=a;\n    return a;\n}\n```\n\n# **常见的链表问题**\n\n最常用方法：\n\n> 1. **快慢指针法**\n> 2. **数组过渡法**\n> 3. **先断后接、先接后断法**\n\n\\1. 单链表反转\n\n> 两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。\n\n\\2. 找单链表倒数第n个元素、或中间元素\n\n> 快慢指针法。\n>\n> 找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）\n>\n> 找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。\n>\n> 找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。\n\n\\3. 删除无头单链表的某个节点\n\n> 题意为不知header，但需要删除目前current指针指向的节点。\n>\n> 思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。\n\n\\4. 在无头单链表某节点前增加节点\n\n> 思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。\n\n\\5. 判断单链表是否有环(可能是部分环，非循环单链表)\n\n> 快慢指针法\n>\n> 一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。\n\n\\6. 判断两单链表是否相交\n\n> 首先明确：两单链表一旦相交，自交点之后的节点将完全相同！\n>\n> 时间复杂度均为O( len1+len2 )\n>\n> 1. 法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素\n> 2. 法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。\n> 3. 法3：直接法：直接判断两链表末节点是否相同\n\n\\7. 已知两单链表相交，求相交点\n\n> 快慢指针法\n>\n> 先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点\n\n\\8. 求两递增单链表AB差集A-B(元素在A而不在B)\n\n> 归并的思想\n>\n> 每次取表头元素进行大小判断，若A’<’B则通过，若A==B则剃除，若A>B则将B指针向后移动直至A’<’B或A==B\n\n# **完整实现代码**\n\n[单向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/single_list.cpp)\n\n[双向链表的完整实现](https://github.com/zedom1/DSA/blob/master/list/double_list.cpp)","slug":"DataStructure_List","published":1,"updated":"2018-05-25T12:41:12.233Z","photos":[],"link":"","_id":"cjhvssadg0005jvfchbmkrhp2","content":"<h1 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a><strong>写在前面的话</strong></h1><p>开始数据结构的学习，将学习过程中的思维过程和代码记录下来。<br>教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》<br>辅以清华大学以及浙江大学的mooc。</p>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><h2 id=\"线性表-List\"><a href=\"#线性表-List\" class=\"headerlink\" title=\"线性表 List\"></a>线性表 List</h2><p>线性表的定义：由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表中元素的个数称为线性表的**长度**</span><br><span class=\"line\">- 线性表中没有元素时称为**空表**</span><br><span class=\"line\">- 表起始位置称为**表头**，表结束为止称为**表尾**</span><br></pre></td></tr></table></figure>\n<p>线性表的操作类型：</p>\n<ol>\n<li>静态操作：仅读取，内容和组成一般不变，如get、search</li>\n<li>动态操作：需写入，局部或整体将改变，如insert、remove</li>\n</ol>\n<p>基本操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. List MakeList()</span><br><span class=\"line\">&gt; 初始化一个空的线性表</span><br><span class=\"line\">2. Element FindIndex(int index)</span><br><span class=\"line\">&gt; 根据位序k返回相应元素</span><br><span class=\"line\">3. int Find(Element x)</span><br><span class=\"line\">&gt; 查找x第一次出现的位置</span><br><span class=\"line\">4. void Insert(Element x , int index)</span><br><span class=\"line\">&gt; 在位序index前插入一个新元素x</span><br><span class=\"line\">5. void Delete(int index)</span><br><span class=\"line\">&gt; 删除指定位序的元素</span><br></pre></td></tr></table></figure>\n<p>实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 顺序存储实现：数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct ListNode * List</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tElement data[MAX_SIZE];</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 链式存储实现：链表</span><br><span class=\"line\">&gt; 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系</span><br></pre></td></tr></table></figure>\n<p>以下以链表为主介绍并实现线性表</p>\n<h2 id=\"链表特点：\"><a href=\"#链表特点：\" class=\"headerlink\" title=\"链表特点：\"></a><strong>链表特点：</strong></h2><p>动态存储：</p>\n<ol>\n<li>各元素动态地分配和回收空间</li>\n<li>逻辑上相邻的元素记录彼此的物理地址</li>\n<li>动态操作高效，静态操作费时，循秩访问低效</li>\n</ol>\n<p>各节点通过指针或引用连接，在逻辑上形成线性序列</p>\n<p><strong>链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。</strong></p>\n<p>以下均用c++实现。</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a><strong>分类</strong></h1><p>1.单向链表</p>\n<blockquote>\n<p>仅有succ指针</p>\n</blockquote>\n<p>2.双向链表</p>\n<blockquote>\n<p>有pred和succ指针</p>\n</blockquote>\n<p>3.循环单链表</p>\n<blockquote>\n<p>单向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>4.循环双链表</p>\n<blockquote>\n<p>双向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>5.静态链表</p>\n<blockquote>\n<p>在没有指针的语言中使用，借用数组模拟链表</p>\n</blockquote>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a><strong>建议</strong></h2><p>使用<strong>哨兵</strong>节点</p>\n<p>单向链表增加<strong>首</strong>哨兵</p>\n<p>双向链表增加<strong>首末</strong>哨兵</p>\n<p>哨兵不对外公开，在一开始创建，最后销毁</p>\n<p><strong>优点：简化边界条件，增加鲁棒性</strong></p>\n<h1 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a><strong>单链表</strong></h1><p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口完整定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">    node( T const &amp; e , node&lt;T&gt; * suc=NULL):data(e),succ(suc) &#123;&#125;</span><br><span class=\"line\">    node() &#123;succ=NULL;&#125;</span><br><span class=\"line\">    node&lt;T&gt; * insertAft( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( node&lt;T&gt; *p , int n );     </span><br><span class=\"line\">    //从p开始复制n个节点到链表末尾</span><br><span class=\"line\">    void merge ( node&lt;T&gt; *&amp; p1, int n1, node&lt;T&gt; *&amp;p2, int n2 );</span><br><span class=\"line\">    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( node&lt;T&gt; *&amp;p, int n );      </span><br><span class=\"line\">    // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\"></span><br><span class=\"line\">    list() &#123; init(); &#125;</span><br><span class=\"line\">    list( node&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    ~list();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    int size() &#123; return _size; &#125;</span><br><span class=\"line\">    T&amp; operator[] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp;e ) const;</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp; e,  node&lt;T&gt;* p, int n ) const;</span><br><span class=\"line\">    // (无序)从节点p向后n个节点（不含p）内找e</span><br><span class=\"line\">    node&lt;T&gt; * search( T const &amp; e , node&lt;T&gt; * p , int n ) const;</span><br><span class=\"line\">    // (有序) 不大于e的最后一个</span><br><span class=\"line\">    void show();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertAfter( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertLast( T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertFirst( T const &amp; e );</span><br><span class=\"line\">    void createListT( T const * e , int n ); // 尾插法创建链表</span><br><span class=\"line\">    void createListH( T const * e , int n ); // 头插法创建链表</span><br><span class=\"line\">    T remove( node&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    void sort(); // 排序</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>基本接口</strong>：</p>\n<p>\\1. 创建链表</p>\n<blockquote>\n<p>分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表</p>\n</blockquote>\n<p>\\2. 插入单节点</p>\n<blockquote>\n<p>分为在某节点前、后插入，在表头、表尾插入</p>\n</blockquote>\n<p>\\3. 查找数据</p>\n<blockquote>\n<p>无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素</p>\n</blockquote>\n<p>\\4. 循秩访问第n个节点</p>\n<blockquote>\n<p>可重载[]运算符，也可单独使用一个函数</p>\n</blockquote>\n<p>\\5. 删除单个节点</p>\n<p>\\6. 清空链表</p>\n<blockquote>\n<p>思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL</p>\n</blockquote>\n<p>\\7. 打印链表</p>\n<p>\\8. 检查链表是否为空</p>\n<p>\\9. 返回链表长度</p>\n<p>\\10. 排序（归并、插入、选择等）</p>\n<p>\\11. 去重（无序、有序版）</p>\n<p>\\12. 反转</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"1-创建链表\"><a href=\"#1-创建链表\" class=\"headerlink\" title=\"1. 创建链表\"></a>1. 创建链表</h3><p>1-1 创建空链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    header = new node&lt;T&gt;; //构造函数已将后继默认置位NULL</span><br><span class=\"line\">    _size=0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2 尾插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListT( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * last=header; // last作为链表最后一个节点</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i] );</span><br><span class=\"line\">        last-&gt;succ=tem;  // 顺序不可反</span><br><span class=\"line\">        last=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-3 头插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListH( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i], header-&gt;succ );</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-4 复制链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">list&lt;T&gt;::list( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    copyNodes( p , n );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::copyNodes( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ ) // 先探好路再迈步</span><br><span class=\"line\">        tem=tem-&gt;succ;  // tem指向存在的最后一个元素</span><br><span class=\"line\">    node&lt;T&gt; *create;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        create=new node&lt;T&gt; ( p-&gt;data );</span><br><span class=\"line\">        tem-&gt;succ=create;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;  // 实时更新链表尾</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-插入单节点\"><a href=\"#2-插入单节点\" class=\"headerlink\" title=\"2. 插入单节点\"></a>2. 插入单节点</h3><p>2-0. 准备：node类的插入函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * node&lt;T&gt;::insertAft( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=new node&lt;T&gt;( e , succ );</span><br><span class=\"line\">    succ=tem;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-1. 在某节点前插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( (tem=tem-&gt;succ)!=p );</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-2. 在某节点后插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertAfter( node&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return p-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-3. 插入表头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertFirst( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return header-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-4. 插入表尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertLast( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-查找元素\"><a href=\"#3-查找元素\" class=\"headerlink\" title=\"3. 查找元素\"></a>3. 查找元素</h3><p>3-1. 无序链表查找</p>\n<p>3-1-0. 整链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return find( e, header, ,_size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-1-1. 部分链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e, node&lt;T&gt;* p , int n ) const</span><br><span class=\"line\">&#123;  ( p , p+n ]</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">        if( e==( p=p-&gt;succ )-&gt;data )</span><br><span class=\"line\">            return p;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-2. 有序链表查找</p>\n<p>返回不大于e的最后一个元素，方便后续插入操作</p>\n<p>此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::search( T const &amp; e, node&lt;T&gt; * p, int n ) const</span><br><span class=\"line\">&#123;  [ p , p+n )</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;  // tem作为p的直接前驱</span><br><span class=\"line\">    while( tem-&gt;succ != p )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    while( n-- &amp;&amp;p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( p-&gt;data&gt;e )</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-循秩访问单个节点\"><a href=\"#4-循秩访问单个节点\" class=\"headerlink\" title=\"4. 循秩访问单个节点\"></a>4. 循秩访问单个节点</h3><p>方式：重载()运算符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T &amp; list&lt;T&gt;::operator [] (int r) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *p=header;</span><br><span class=\"line\">    while( ( p=p-&gt;succ ) &amp;&amp; r-- );</span><br><span class=\"line\">    return p-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问<strong>本质不同</strong>。</p>\n<p>链表的为披着循秩访问外皮的按位置访问。</p>\n<p>而顺序表 V[i] = V + i*s (s为单个元素大小)</p>\n<p>时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。</p>\n<h3 id=\"5-删除单个节点\"><a href=\"#5-删除单个节点\" class=\"headerlink\" title=\"5. 删除单个节点\"></a>5. 删除单个节点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T list&lt;T&gt;::remove( node&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    node&lt;T&gt; *pre=header;</span><br><span class=\"line\">    while( pre-&gt;succ!=p )</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-清空链表\"><a href=\"#6-清空链表\" class=\"headerlink\" title=\"6. 清空链表\"></a>6. 清空链表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::clear()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    if( header-&gt;succ==NULL )</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    while( header-&gt;succ )</span><br><span class=\"line\">        remove( header-&gt;succ );</span><br><span class=\"line\">    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零</span><br><span class=\"line\">    return old_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-排序\"><a href=\"#10-排序\" class=\"headerlink\" title=\"10. 排序\"></a>10. 排序</h3><p>10-1 归并排序</p>\n<p>归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾</p>\n<p>该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::merge ( node&lt;T&gt; * &amp;p1, int n1, node&lt;T&gt; *&amp;p2, int n2 ) //使用引用绑定节点防止丢失</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *head;</span><br><span class=\"line\">    node&lt;T&gt; *pree=header;</span><br><span class=\"line\">    while( pree-&gt;succ!=p1 )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    head=pree;</span><br><span class=\"line\">    node&lt;T&gt; *px1=p1,*px2=p2,*px3;</span><br><span class=\"line\">    for(int i=0; i&lt;n1-1 ; i++)</span><br><span class=\"line\">        px1=px1-&gt;succ;</span><br><span class=\"line\">    for(int i=0; i&lt;n2-1 ; i++)</span><br><span class=\"line\">        px2=px2-&gt;succ;</span><br><span class=\"line\">    px3=px2-&gt;succ;</span><br><span class=\"line\">    px1-&gt;succ=px2-&gt;succ=NULL;</span><br><span class=\"line\">    px1=p1;</span><br><span class=\"line\">    while( n1&amp;&amp;n2 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( px1-&gt;data&lt;=p2-&gt;data )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=px1;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            px1=px1-&gt;succ;</span><br><span class=\"line\">            n1--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=p2;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            p2=p2-&gt;succ;</span><br><span class=\"line\">            n2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if( n1 )</span><br><span class=\"line\">        pree-&gt;succ=px1;</span><br><span class=\"line\">    if( n2 )</span><br><span class=\"line\">        pree-&gt;succ=p2;</span><br><span class=\"line\">    while( pree-&gt;succ )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    pree-&gt;succ=px3;</span><br><span class=\"line\">    p1=head-&gt;succ;  // 最后设置好排序后的头结点</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::mergeSort( node&lt;T&gt; *&amp;p, int n )</span><br><span class=\"line\">&#123; // [ p, p+n ]</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    int mid=n/2;</span><br><span class=\"line\">    node&lt;T&gt; *tem=p;</span><br><span class=\"line\">    for(int i=0; i&lt;mid; i++)  tem=tem-&gt;succ;</span><br><span class=\"line\">    mergeSort( p, mid );</span><br><span class=\"line\">    mergeSort( tem, n-mid );</span><br><span class=\"line\">    merge( p,mid, tem , n-mid );</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::sort( )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mergeSort( header-&gt;succ , _size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-去重\"><a href=\"#11-去重\" class=\"headerlink\" title=\"11. 去重\"></a>11. 去重</h3><p>11-1. 无序链表</p>\n<p>常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)</p>\n<p>其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::deduplicate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( _size&lt;2 ) // 少于2个节点无需去重</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ-&gt;succ; //第一个节点必定已去重</span><br><span class=\"line\">    node&lt;T&gt; *pre=header-&gt;succ;</span><br><span class=\"line\">    int old_size=_size;  // 保存_size，方便返回删除数目</span><br><span class=\"line\">    int r=1;  // 已去重数目</span><br><span class=\"line\">    while( p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( find( p-&gt;data , header , r )!=NULL )</span><br><span class=\"line\">        &#123;    // 借用find接口</span><br><span class=\"line\">            pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">            delete p;</span><br><span class=\"line\">            p=pre-&gt;succ;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r++;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>11-2. 有序链表</p>\n<p>思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::uniquify()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ,*q;</span><br><span class=\"line\">    while( NULL != ( q = p-&gt;succ ) ) // q作为p的直接后继，检测是否重复</span><br><span class=\"line\">        (p-&gt;data == q-&gt;data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-反转\"><a href=\"#12-反转\" class=\"headerlink\" title=\"12. 反转\"></a>12. 反转</h3><p>思路：固定目前的首节点，即header-&gt;succ，每次将它的直接后继重新绑定至header的直接后继。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::reverse()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *fir=header-&gt;succ;</span><br><span class=\"line\">    node&lt;T&gt; *tem;</span><br><span class=\"line\">    while( fir-&gt;succ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem=fir-&gt;succ;</span><br><span class=\"line\">        fir-&gt;succ=tem-&gt;succ;</span><br><span class=\"line\">        tem-&gt;succ=header-&gt;succ;</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a><strong>双向链表</strong></h1><p>双链表和单链表类似，但不同在于有<strong>首末</strong>两个哨兵，每个节点有<strong>前驱</strong>和<strong>后缀</strong>指针，可以省去从头访问到某节点的前驱的时间。</p>\n<p>代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。</p>\n<p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">    //列表节点模板类（以双向链表形式实现）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode () &#123;&#125;</span><br><span class=\"line\">    ListNode ( T const &amp; e, ListNode&lt;T&gt; * p = NULL, ListNode&lt;T&gt; *a = NULL)</span><br><span class=\"line\">        :data(e),pred(p),succ(a)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsPred ( T const &amp; e );</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsSucc ( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\"></span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    void merge ( ListNode&lt;T&gt; * p1, int n1 , List&lt;T&gt;&amp;L,  ListNode&lt;T&gt; *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( ListNode&lt;T&gt; *p, int n );      // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\">    void selectionSort ( ListNode&lt;T&gt; *p, int n );   // [ p,p+n ) 选择排序</span><br><span class=\"line\">    void insertionSort ( ListNode&lt;T&gt; *p, int n );   // 对从p开始连续的n个节点插入排序</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    List() &#123; init(); &#125;</span><br><span class=\"line\">    List( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    List( T *p , int n );</span><br><span class=\"line\">    ~List();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    int size() const &#123; return _size; &#125;</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    T &amp; operator [] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    ListNode&lt;T&gt; * first()const</span><br><span class=\"line\">        &#123;return header-&gt;succ;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * last() const</span><br><span class=\"line\">        &#123;return trailer-&gt;pred;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp;e ) const</span><br><span class=\"line\">        &#123;return find(e,_size,trailer);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp; e, int n, ListNode&lt;T&gt;* p ) const; // (无序)从节点p向前n个节点（不含p）内找e</span><br><span class=\"line\">    ListNode&lt;T&gt; * search( T const &amp; e , int n , ListNode&lt;T&gt; * p ) const; // (有序) 不大于e的最后一个</span><br><span class=\"line\">    ListNode&lt;T&gt; * selectMax ( ListNode&lt;T&gt; *p , int n )const ;</span><br><span class=\"line\">    void show() const;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertBefore( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsPred(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAfter( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsSucc(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertLast( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return trailer-&gt;insertAsPred(e);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertFirst( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return header-&gt;insertAsSucc(e);&#125;</span><br><span class=\"line\">    T remove( ListNode&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    void sort( ListNode&lt;T&gt; *p, int n, int mod );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-排序\"><a href=\"#1-排序\" class=\"headerlink\" title=\"1. 排序\"></a>1. 排序</h2><p>1-1. 插入排序</p>\n<p>思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::insertionSort( ListNode&lt;T&gt; * p , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int r=0; r&lt;n; r++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertAfter( search( p-&gt;data , r , p ) , p-&gt;data );</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        remove( p-&gt;pred );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T List&lt;T&gt;::remove( ListNode&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    p-&gt;pred-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    p-&gt;succ-&gt;pred=p-&gt;pred;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsSucc( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, this, succ );</span><br><span class=\"line\">    succ-&gt;pred=a;</span><br><span class=\"line\">    succ=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2. 选择排序</p>\n<p>思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::selectionSort( ListNode&lt;T&gt; *p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    ListNode&lt;T&gt; *head=p-&gt;pred , *tail=p;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">        tail=tail-&gt;succ;</span><br><span class=\"line\">    while( 1&lt;n )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertBefore( tail, remove( selectMax( head-&gt;succ , n ) ) );</span><br><span class=\"line\">        tail=tail-&gt;pred;</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt; * List&lt;T&gt;::selectMax ( ListNode&lt;T&gt; *p , int n )const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *tem=p;</span><br><span class=\"line\">    while(n--&amp;&amp;p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(p-&gt;data&gt;=tem-&gt;data)</span><br><span class=\"line\">            tem=p;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsPred( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, pred, this );</span><br><span class=\"line\">    pred-&gt;succ=a;</span><br><span class=\"line\">    pred=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"常见的链表问题\"><a href=\"#常见的链表问题\" class=\"headerlink\" title=\"常见的链表问题\"></a><strong>常见的链表问题</strong></h1><p>最常用方法：</p>\n<blockquote>\n<ol>\n<li><strong>快慢指针法</strong></li>\n<li><strong>数组过渡法</strong></li>\n<li><strong>先断后接、先接后断法</strong></li>\n</ol>\n</blockquote>\n<p>\\1. 单链表反转</p>\n<blockquote>\n<p>两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。</p>\n</blockquote>\n<p>\\2. 找单链表倒数第n个元素、或中间元素</p>\n<blockquote>\n<p>快慢指针法。</p>\n<p>找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）</p>\n<p>找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。</p>\n<p>找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。</p>\n</blockquote>\n<p>\\3. 删除无头单链表的某个节点</p>\n<blockquote>\n<p>题意为不知header，但需要删除目前current指针指向的节点。</p>\n<p>思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。</p>\n</blockquote>\n<p>\\4. 在无头单链表某节点前增加节点</p>\n<blockquote>\n<p>思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。</p>\n</blockquote>\n<p>\\5. 判断单链表是否有环(可能是部分环，非循环单链表)</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。</p>\n</blockquote>\n<p>\\6. 判断两单链表是否相交</p>\n<blockquote>\n<p>首先明确：两单链表一旦相交，自交点之后的节点将完全相同！</p>\n<p>时间复杂度均为O( len1+len2 )</p>\n<ol>\n<li>法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素</li>\n<li>法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。</li>\n<li>法3：直接法：直接判断两链表末节点是否相同</li>\n</ol>\n</blockquote>\n<p>\\7. 已知两单链表相交，求相交点</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点</p>\n</blockquote>\n<p>\\8. 求两递增单链表AB差集A-B(元素在A而不在B)</p>\n<blockquote>\n<p>归并的思想</p>\n<p>每次取表头元素进行大小判断，若A’&lt;’B则通过，若A==B则剃除，若A&gt;B则将B指针向后移动直至A’&lt;’B或A==B</p>\n</blockquote>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/list/single_list.cpp\" target=\"_blank\" rel=\"noopener\">单向链表的完整实现</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/list/double_list.cpp\" target=\"_blank\" rel=\"noopener\">双向链表的完整实现</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a><strong>写在前面的话</strong></h1><p>开始数据结构的学习，将学习过程中的思维过程和代码记录下来。<br>教材主要使用清华大学邓俊辉教授的《数据结构(c++语言版)》<br>辅以清华大学以及浙江大学的mooc。</p>","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><h2 id=\"线性表-List\"><a href=\"#线性表-List\" class=\"headerlink\" title=\"线性表 List\"></a>线性表 List</h2><p>线性表的定义：由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表中元素的个数称为线性表的**长度**</span><br><span class=\"line\">- 线性表中没有元素时称为**空表**</span><br><span class=\"line\">- 表起始位置称为**表头**，表结束为止称为**表尾**</span><br></pre></td></tr></table></figure>\n<p>线性表的操作类型：</p>\n<ol>\n<li>静态操作：仅读取，内容和组成一般不变，如get、search</li>\n<li>动态操作：需写入，局部或整体将改变，如insert、remove</li>\n</ol>\n<p>基本操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. List MakeList()</span><br><span class=\"line\">&gt; 初始化一个空的线性表</span><br><span class=\"line\">2. Element FindIndex(int index)</span><br><span class=\"line\">&gt; 根据位序k返回相应元素</span><br><span class=\"line\">3. int Find(Element x)</span><br><span class=\"line\">&gt; 查找x第一次出现的位置</span><br><span class=\"line\">4. void Insert(Element x , int index)</span><br><span class=\"line\">&gt; 在位序index前插入一个新元素x</span><br><span class=\"line\">5. void Delete(int index)</span><br><span class=\"line\">&gt; 删除指定位序的元素</span><br></pre></td></tr></table></figure>\n<p>实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 顺序存储实现：数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct ListNode * List</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tElement data[MAX_SIZE];</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 链式存储实现：链表</span><br><span class=\"line\">&gt; 不要求逻辑上相邻的两个元素物理上也相邻，通过“链”建立起数据元素之间的逻辑关系</span><br></pre></td></tr></table></figure>\n<p>以下以链表为主介绍并实现线性表</p>\n<h2 id=\"链表特点：\"><a href=\"#链表特点：\" class=\"headerlink\" title=\"链表特点：\"></a><strong>链表特点：</strong></h2><p>动态存储：</p>\n<ol>\n<li>各元素动态地分配和回收空间</li>\n<li>逻辑上相邻的元素记录彼此的物理地址</li>\n<li>动态操作高效，静态操作费时，循秩访问低效</li>\n</ol>\n<p>各节点通过指针或引用连接，在逻辑上形成线性序列</p>\n<p><strong>链表实现过程中，代码的执行顺序非常重要！要注意的细节也很多。</strong></p>\n<p>以下均用c++实现。</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a><strong>分类</strong></h1><p>1.单向链表</p>\n<blockquote>\n<p>仅有succ指针</p>\n</blockquote>\n<p>2.双向链表</p>\n<blockquote>\n<p>有pred和succ指针</p>\n</blockquote>\n<p>3.循环单链表</p>\n<blockquote>\n<p>单向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>4.循环双链表</p>\n<blockquote>\n<p>双向链表 + 末节点和首节点相连</p>\n</blockquote>\n<p>5.静态链表</p>\n<blockquote>\n<p>在没有指针的语言中使用，借用数组模拟链表</p>\n</blockquote>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a><strong>建议</strong></h2><p>使用<strong>哨兵</strong>节点</p>\n<p>单向链表增加<strong>首</strong>哨兵</p>\n<p>双向链表增加<strong>首末</strong>哨兵</p>\n<p>哨兵不对外公开，在一开始创建，最后销毁</p>\n<p><strong>优点：简化边界条件，增加鲁棒性</strong></p>\n<h1 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a><strong>单链表</strong></h1><p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口完整定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    node&lt;T&gt; *succ;</span><br><span class=\"line\">    node( T const &amp; e , node&lt;T&gt; * suc=NULL):data(e),succ(suc) &#123;&#125;</span><br><span class=\"line\">    node() &#123;succ=NULL;&#125;</span><br><span class=\"line\">    node&lt;T&gt; * insertAft( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">struct list</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    node&lt;T&gt; *header;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( node&lt;T&gt; *p , int n );     </span><br><span class=\"line\">    //从p开始复制n个节点到链表末尾</span><br><span class=\"line\">    void merge ( node&lt;T&gt; *&amp; p1, int n1, node&lt;T&gt; *&amp;p2, int n2 );</span><br><span class=\"line\">    //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( node&lt;T&gt; *&amp;p, int n );      </span><br><span class=\"line\">    // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\"></span><br><span class=\"line\">    list() &#123; init(); &#125;</span><br><span class=\"line\">    list( node&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    ~list();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    int size() &#123; return _size; &#125;</span><br><span class=\"line\">    T&amp; operator[] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp;e ) const;</span><br><span class=\"line\">    node&lt;T&gt; * find( T const&amp; e,  node&lt;T&gt;* p, int n ) const;</span><br><span class=\"line\">    // (无序)从节点p向后n个节点（不含p）内找e</span><br><span class=\"line\">    node&lt;T&gt; * search( T const &amp; e , node&lt;T&gt; * p , int n ) const;</span><br><span class=\"line\">    // (有序) 不大于e的最后一个</span><br><span class=\"line\">    void show();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertAfter( node&lt;T&gt; *p, T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertLast( T const &amp; e );</span><br><span class=\"line\">    node&lt;T&gt; * insertFirst( T const &amp; e );</span><br><span class=\"line\">    void createListT( T const * e , int n ); // 尾插法创建链表</span><br><span class=\"line\">    void createListH( T const * e , int n ); // 头插法创建链表</span><br><span class=\"line\">    T remove( node&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    void sort(); // 排序</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>基本接口</strong>：</p>\n<p>\\1. 创建链表</p>\n<blockquote>\n<p>分为：创建空链表、根据已有数据进行头、尾插入、复制已有链表</p>\n</blockquote>\n<p>\\2. 插入单节点</p>\n<blockquote>\n<p>分为在某节点前、后插入，在表头、表尾插入</p>\n</blockquote>\n<p>\\3. 查找数据</p>\n<blockquote>\n<p>无序单链表：查找是否存在 有序单链表：返回不大于目标数据的最后一个元素</p>\n</blockquote>\n<p>\\4. 循秩访问第n个节点</p>\n<blockquote>\n<p>可重载[]运算符，也可单独使用一个函数</p>\n</blockquote>\n<p>\\5. 删除单个节点</p>\n<p>\\6. 清空链表</p>\n<blockquote>\n<p>思路：循环调用删除单个节点的remove函数删除header的直接后继，直至header的直接后继为NULL</p>\n</blockquote>\n<p>\\7. 打印链表</p>\n<p>\\8. 检查链表是否为空</p>\n<p>\\9. 返回链表长度</p>\n<p>\\10. 排序（归并、插入、选择等）</p>\n<p>\\11. 去重（无序、有序版）</p>\n<p>\\12. 反转</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"1-创建链表\"><a href=\"#1-创建链表\" class=\"headerlink\" title=\"1. 创建链表\"></a>1. 创建链表</h3><p>1-1 创建空链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    header = new node&lt;T&gt;; //构造函数已将后继默认置位NULL</span><br><span class=\"line\">    _size=0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2 尾插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListT( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * last=header; // last作为链表最后一个节点</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i] );</span><br><span class=\"line\">        last-&gt;succ=tem;  // 顺序不可反</span><br><span class=\"line\">        last=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-3 头插法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::createListH( T const *&amp; e , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; * tem;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem = new node&lt;T&gt;( e[i], header-&gt;succ );</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-4 复制链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">list&lt;T&gt;::list( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    copyNodes( p , n );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">void list&lt;T&gt;::copyNodes( node&lt;T&gt; * p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ ) // 先探好路再迈步</span><br><span class=\"line\">        tem=tem-&gt;succ;  // tem指向存在的最后一个元素</span><br><span class=\"line\">    node&lt;T&gt; *create;</span><br><span class=\"line\">    _size+=n;</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        create=new node&lt;T&gt; ( p-&gt;data );</span><br><span class=\"line\">        tem-&gt;succ=create;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;  // 实时更新链表尾</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-插入单节点\"><a href=\"#2-插入单节点\" class=\"headerlink\" title=\"2. 插入单节点\"></a>2. 插入单节点</h3><p>2-0. 准备：node类的插入函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * node&lt;T&gt;::insertAft( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *tem=new node&lt;T&gt;( e , succ );</span><br><span class=\"line\">    succ=tem;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-1. 在某节点前插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * insertBefore( node&lt;T&gt; *p, T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( (tem=tem-&gt;succ)!=p );</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-2. 在某节点后插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertAfter( node&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return p-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-3. 插入表头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertFirst( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    return header-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2-4. 插入表尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::insertLast( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;</span><br><span class=\"line\">    while( tem-&gt;succ )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    return tem-&gt;insertAft(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-查找元素\"><a href=\"#3-查找元素\" class=\"headerlink\" title=\"3. 查找元素\"></a>3. 查找元素</h3><p>3-1. 无序链表查找</p>\n<p>3-1-0. 整链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt; typename T &gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return find( e, header, ,_size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-1-1. 部分链表查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::find( T const&amp; e, node&lt;T&gt;* p , int n ) const</span><br><span class=\"line\">&#123;  ( p , p+n ]</span><br><span class=\"line\">    while(n--)</span><br><span class=\"line\">        if( e==( p=p-&gt;succ )-&gt;data )</span><br><span class=\"line\">            return p;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3-2. 有序链表查找</p>\n<p>返回不大于e的最后一个元素，方便后续插入操作</p>\n<p>此处与顺序表不同，哪怕是在有序链表中查找，和无序相比时间复杂度同为O(n）,原因在于链表的循秩访问问题，详见4. 而在顺序表中，有序表可以借由二分等算法将复杂度降低</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">node&lt;T&gt; * list&lt;T&gt;::search( T const &amp; e, node&lt;T&gt; * p, int n ) const</span><br><span class=\"line\">&#123;  [ p , p+n )</span><br><span class=\"line\">    node&lt;T&gt; *tem=header;  // tem作为p的直接前驱</span><br><span class=\"line\">    while( tem-&gt;succ != p )</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    while( n-- &amp;&amp;p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( p-&gt;data&gt;e )</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        tem=tem-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-循秩访问单个节点\"><a href=\"#4-循秩访问单个节点\" class=\"headerlink\" title=\"4. 循秩访问单个节点\"></a>4. 循秩访问单个节点</h3><p>方式：重载()运算符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T &amp; list&lt;T&gt;::operator [] (int r) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *p=header;</span><br><span class=\"line\">    while( ( p=p-&gt;succ ) &amp;&amp; r-- );</span><br><span class=\"line\">    return p-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处为链表和顺序表的区别，哪怕重载了[]运算符，但链表的循秩访问和顺序表的循秩访问<strong>本质不同</strong>。</p>\n<p>链表的为披着循秩访问外皮的按位置访问。</p>\n<p>而顺序表 V[i] = V + i*s (s为单个元素大小)</p>\n<p>时间复杂度为O(n)，哪怕在双向链表中可以通过判断r和_size/2的大小选择从前或后访问来节省一些时间，但复杂度依旧为O(n/2)=O(n)。</p>\n<h3 id=\"5-删除单个节点\"><a href=\"#5-删除单个节点\" class=\"headerlink\" title=\"5. 删除单个节点\"></a>5. 删除单个节点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T list&lt;T&gt;::remove( node&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    node&lt;T&gt; *pre=header;</span><br><span class=\"line\">    while( pre-&gt;succ!=p )</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-清空链表\"><a href=\"#6-清空链表\" class=\"headerlink\" title=\"6. 清空链表\"></a>6. 清空链表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::clear()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    if( header-&gt;succ==NULL )</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    while( header-&gt;succ )</span><br><span class=\"line\">        remove( header-&gt;succ );</span><br><span class=\"line\">    // 在remove操作里有_size自减的操作，因此这里不再重新将_size置零</span><br><span class=\"line\">    return old_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-排序\"><a href=\"#10-排序\" class=\"headerlink\" title=\"10. 排序\"></a>10. 排序</h3><p>10-1 归并排序</p>\n<p>归并排序思路：将表不断二分再重新合并，每次合并从两个已有序的表头选取较小的加入目标表尾，若其中一个表为空，则将另一表整体接入目标表尾</p>\n<p>该算法思路：同一链表内的归并排序：现将p1段和p2段截断，以px3保留非排序区域的头节点。以p1的直接前继做新表头，每次绑定两表头较小的节点，直至p1、p2段其中一段为空，然后连接上另一非空链表剩余部分，最后将非排序区域的尾部接上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::merge ( node&lt;T&gt; * &amp;p1, int n1, node&lt;T&gt; *&amp;p2, int n2 ) //使用引用绑定节点防止丢失</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    node&lt;T&gt; *head;</span><br><span class=\"line\">    node&lt;T&gt; *pree=header;</span><br><span class=\"line\">    while( pree-&gt;succ!=p1 )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    head=pree;</span><br><span class=\"line\">    node&lt;T&gt; *px1=p1,*px2=p2,*px3;</span><br><span class=\"line\">    for(int i=0; i&lt;n1-1 ; i++)</span><br><span class=\"line\">        px1=px1-&gt;succ;</span><br><span class=\"line\">    for(int i=0; i&lt;n2-1 ; i++)</span><br><span class=\"line\">        px2=px2-&gt;succ;</span><br><span class=\"line\">    px3=px2-&gt;succ;</span><br><span class=\"line\">    px1-&gt;succ=px2-&gt;succ=NULL;</span><br><span class=\"line\">    px1=p1;</span><br><span class=\"line\">    while( n1&amp;&amp;n2 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( px1-&gt;data&lt;=p2-&gt;data )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=px1;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            px1=px1-&gt;succ;</span><br><span class=\"line\">            n1--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pree-&gt;succ=p2;</span><br><span class=\"line\">            pree=pree-&gt;succ;</span><br><span class=\"line\">            p2=p2-&gt;succ;</span><br><span class=\"line\">            n2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if( n1 )</span><br><span class=\"line\">        pree-&gt;succ=px1;</span><br><span class=\"line\">    if( n2 )</span><br><span class=\"line\">        pree-&gt;succ=p2;</span><br><span class=\"line\">    while( pree-&gt;succ )</span><br><span class=\"line\">        pree=pree-&gt;succ;</span><br><span class=\"line\">    pree-&gt;succ=px3;</span><br><span class=\"line\">    p1=head-&gt;succ;  // 最后设置好排序后的头结点</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::mergeSort( node&lt;T&gt; *&amp;p, int n )</span><br><span class=\"line\">&#123; // [ p, p+n ]</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    int mid=n/2;</span><br><span class=\"line\">    node&lt;T&gt; *tem=p;</span><br><span class=\"line\">    for(int i=0; i&lt;mid; i++)  tem=tem-&gt;succ;</span><br><span class=\"line\">    mergeSort( p, mid );</span><br><span class=\"line\">    mergeSort( tem, n-mid );</span><br><span class=\"line\">    merge( p,mid, tem , n-mid );</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::sort( )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mergeSort( header-&gt;succ , _size );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-去重\"><a href=\"#11-去重\" class=\"headerlink\" title=\"11. 去重\"></a>11. 去重</h3><p>11-1. 无序链表</p>\n<p>常规思路：将链表分为已去重和未去重区域，每次取未去重区域第一个元素，在已去重区域查找是否有相同数值的节点，若存在，则任意删除其一，若不存在，则将该节点加入已去重区域。 时间复杂度 O(n2)</p>\n<p>其它思路：将链表数据以数组保存，在数组中剔除重复数据后再赋值并删除多余节点。时间复杂度O(nlogn)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::deduplicate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if( _size&lt;2 ) // 少于2个节点无需去重</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ-&gt;succ; //第一个节点必定已去重</span><br><span class=\"line\">    node&lt;T&gt; *pre=header-&gt;succ;</span><br><span class=\"line\">    int old_size=_size;  // 保存_size，方便返回删除数目</span><br><span class=\"line\">    int r=1;  // 已去重数目</span><br><span class=\"line\">    while( p )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if( find( p-&gt;data , header , r )!=NULL )</span><br><span class=\"line\">        &#123;    // 借用find接口</span><br><span class=\"line\">            pre-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">            delete p;</span><br><span class=\"line\">            p=pre-&gt;succ;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r++;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        pre=pre-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>11-2. 有序链表</p>\n<p>思路：一指针A从表头开始，每次检测相邻节点，若相同则删除后节点，若不同，A向后移动直至表尾。 时间复杂度O(n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int list&lt;T&gt;::uniquify()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    int old_size=_size;</span><br><span class=\"line\">    node&lt;T&gt; *p=header-&gt;succ,*q;</span><br><span class=\"line\">    while( NULL != ( q = p-&gt;succ ) ) // q作为p的直接后继，检测是否重复</span><br><span class=\"line\">        (p-&gt;data == q-&gt;data) ? remove(q) : p=q; // 若重复则删除直接后继，若不重复则p向后一步</span><br><span class=\"line\">    return old_size-_size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-反转\"><a href=\"#12-反转\" class=\"headerlink\" title=\"12. 反转\"></a>12. 反转</h3><p>思路：固定目前的首节点，即header-&gt;succ，每次将它的直接后继重新绑定至header的直接后继。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void list&lt;T&gt;::reverse()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(_size&lt;2)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    node&lt;T&gt; *fir=header-&gt;succ;</span><br><span class=\"line\">    node&lt;T&gt; *tem;</span><br><span class=\"line\">    while( fir-&gt;succ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tem=fir-&gt;succ;</span><br><span class=\"line\">        fir-&gt;succ=tem-&gt;succ;</span><br><span class=\"line\">        tem-&gt;succ=header-&gt;succ;</span><br><span class=\"line\">        header-&gt;succ=tem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a><strong>双向链表</strong></h1><p>双链表和单链表类似，但不同在于有<strong>首末</strong>两个哨兵，每个节点有<strong>前驱</strong>和<strong>后缀</strong>指针，可以省去从头访问到某节点的前驱的时间。</p>\n<p>代码实现与单向链表相差不大，只是需要额外注意需要多维护pred指针和trailer哨兵。</p>\n<p><strong>基本定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>带接口定义</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">    //列表节点模板类（以双向链表形式实现）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    ListNode&lt;T&gt; * pred;</span><br><span class=\"line\">    ListNode&lt;T&gt; * succ;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode () &#123;&#125;</span><br><span class=\"line\">    ListNode ( T const &amp; e, ListNode&lt;T&gt; * p = NULL, ListNode&lt;T&gt; *a = NULL)</span><br><span class=\"line\">        :data(e),pred(p),succ(a)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsPred ( T const &amp; e );</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAsSucc ( T const &amp; e );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct List</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\"></span><br><span class=\"line\">    int _size ;</span><br><span class=\"line\">    ListNode&lt;T&gt; * header,*trailer;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">    void init ();</span><br><span class=\"line\">    void merge ( ListNode&lt;T&gt; * p1, int n1 , List&lt;T&gt;&amp;L,  ListNode&lt;T&gt; *p2, int n2); //[p1,p1+n) 本串p1开始n1个节点与 L串p2开始n2个节点归并排序</span><br><span class=\"line\">    void mergeSort ( ListNode&lt;T&gt; *p, int n );      // 对从p开始连续的n个节点归并排序</span><br><span class=\"line\">    void selectionSort ( ListNode&lt;T&gt; *p, int n );   // [ p,p+n ) 选择排序</span><br><span class=\"line\">    void insertionSort ( ListNode&lt;T&gt; *p, int n );   // 对从p开始连续的n个节点插入排序</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    List() &#123; init(); &#125;</span><br><span class=\"line\">    List( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    List( T *p , int n );</span><br><span class=\"line\">    ~List();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 只读接口</span><br><span class=\"line\">    int size() const &#123; return _size; &#125;</span><br><span class=\"line\">    bool empty() &#123; return _size==0; &#125;</span><br><span class=\"line\">    T &amp; operator [] ( int r ) const;    // 实现寻秩访问</span><br><span class=\"line\">    ListNode&lt;T&gt; * first()const</span><br><span class=\"line\">        &#123;return header-&gt;succ;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * last() const</span><br><span class=\"line\">        &#123;return trailer-&gt;pred;&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp;e ) const</span><br><span class=\"line\">        &#123;return find(e,_size,trailer);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * find( T const&amp; e, int n, ListNode&lt;T&gt;* p ) const; // (无序)从节点p向前n个节点（不含p）内找e</span><br><span class=\"line\">    ListNode&lt;T&gt; * search( T const &amp; e , int n , ListNode&lt;T&gt; * p ) const; // (有序) 不大于e的最后一个</span><br><span class=\"line\">    ListNode&lt;T&gt; * selectMax ( ListNode&lt;T&gt; *p , int n )const ;</span><br><span class=\"line\">    void show() const;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 可写接口</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertBefore( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsPred(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertAfter( ListNode&lt;T&gt; *p, T const &amp; e)</span><br><span class=\"line\">        &#123; _size++; return p-&gt;insertAsSucc(e); &#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertLast( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return trailer-&gt;insertAsPred(e);&#125;</span><br><span class=\"line\">    ListNode&lt;T&gt; * insertFirst( T const &amp; e )</span><br><span class=\"line\">        &#123; _size++; return header-&gt;insertAsSucc(e);&#125;</span><br><span class=\"line\">    T remove( ListNode&lt;T&gt; *p );</span><br><span class=\"line\">    int deduplicate (); // 无序列表去重</span><br><span class=\"line\">    int uniquify ();    // 有序列表去重</span><br><span class=\"line\">    int clear ();</span><br><span class=\"line\">    void copyNodes ( ListNode&lt;T&gt; *p , int n );     // 从p开始复制n个节点</span><br><span class=\"line\">    void sort( ListNode&lt;T&gt; *p, int n, int mod );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-排序\"><a href=\"#1-排序\" class=\"headerlink\" title=\"1. 排序\"></a>1. 排序</h2><p>1-1. 插入排序</p>\n<p>思路：将链表分为前后已排序和未排序区域，每次取未排序区域首节点在已排序区域选位置插入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::insertionSort( ListNode&lt;T&gt; * p , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int r=0; r&lt;n; r++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertAfter( search( p-&gt;data , r , p ) , p-&gt;data );</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">        remove( p-&gt;pred );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T List&lt;T&gt;::remove( ListNode&lt;T&gt; * p )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T tem=p-&gt;data;</span><br><span class=\"line\">    p-&gt;pred-&gt;succ=p-&gt;succ;</span><br><span class=\"line\">    p-&gt;succ-&gt;pred=p-&gt;pred;</span><br><span class=\"line\">    delete p;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsSucc( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, this, succ );</span><br><span class=\"line\">    succ-&gt;pred=a;</span><br><span class=\"line\">    succ=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1-2. 选择排序</p>\n<p>思路：每次从未排序区域中选择最大元素并移入未排序区域最后，即已排序区域之首。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void List&lt;T&gt;::selectionSort( ListNode&lt;T&gt; *p, int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(n&lt;2) return;</span><br><span class=\"line\">    ListNode&lt;T&gt; *head=p-&gt;pred , *tail=p;</span><br><span class=\"line\">    for( int i=0; i&lt;n; i++ )</span><br><span class=\"line\">        tail=tail-&gt;succ;</span><br><span class=\"line\">    while( 1&lt;n )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insertBefore( tail, remove( selectMax( head-&gt;succ , n ) ) );</span><br><span class=\"line\">        tail=tail-&gt;pred;</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt; * List&lt;T&gt;::selectMax ( ListNode&lt;T&gt; *p , int n )const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *tem=p;</span><br><span class=\"line\">    while(n--&amp;&amp;p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(p-&gt;data&gt;=tem-&gt;data)</span><br><span class=\"line\">            tem=p;</span><br><span class=\"line\">        p=p-&gt;succ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// node类的准备工作</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ListNode&lt;T&gt;* ListNode&lt;T&gt;::insertAsPred( T const &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode&lt;T&gt; *a=new ListNode&lt;T&gt;( e, pred, this );</span><br><span class=\"line\">    pred-&gt;succ=a;</span><br><span class=\"line\">    pred=a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"常见的链表问题\"><a href=\"#常见的链表问题\" class=\"headerlink\" title=\"常见的链表问题\"></a><strong>常见的链表问题</strong></h1><p>最常用方法：</p>\n<blockquote>\n<ol>\n<li><strong>快慢指针法</strong></li>\n<li><strong>数组过渡法</strong></li>\n<li><strong>先断后接、先接后断法</strong></li>\n</ol>\n</blockquote>\n<p>\\1. 单链表反转</p>\n<blockquote>\n<p>两个搬运工（指针），一个在header，一个在原链表的第一个节点，每次将第一个节点的直接后继断开接到header直接后继，直至原第一个节点后继为NULL。</p>\n</blockquote>\n<p>\\2. 找单链表倒数第n个元素、或中间元素</p>\n<blockquote>\n<p>快慢指针法。</p>\n<p>找倒数第n个元素，两指针同时走并相差n步，若前面指针到末尾，则后面指针则是倒数第n个节点。（细节：链表长度是否大于等于n）</p>\n<p>找中间元素，慢指针每走一步 快指针则走两步，快指针到尾时慢指针在中间。</p>\n<p>找中间元素，在允许遍历两遍的情况下也可以先遍历一遍求出链表长度，再走第二遍。</p>\n</blockquote>\n<p>\\3. 删除无头单链表的某个节点</p>\n<blockquote>\n<p>题意为不知header，但需要删除目前current指针指向的节点。</p>\n<p>思路：删除节点需要找到该节点的前驱，既然无法知道current节点的前驱，那就改为删除current的直接后继。将直接后继的数据复制给current，然后删除current的直接后继。</p>\n</blockquote>\n<p>\\4. 在无头单链表某节点前增加节点</p>\n<blockquote>\n<p>思路和3类似，先将要创建的节点连接在current节点的直接后继，然后交换两节点的数据。</p>\n</blockquote>\n<p>\\5. 判断单链表是否有环(可能是部分环，非循环单链表)</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>一个步长为2，一个步长为1，若步长为2的跑到末尾，则没有环，若在跑到末尾之前(可能没有末尾)，两指针相遇，则说明有环。</p>\n</blockquote>\n<p>\\6. 判断两单链表是否相交</p>\n<blockquote>\n<p>首先明确：两单链表一旦相交，自交点之后的节点将完全相同！</p>\n<p>时间复杂度均为O( len1+len2 )</p>\n<ol>\n<li>法1：数组过渡法，将两个单链表每个节点的地址记录于两个数组，看两个数组是否有相同元素</li>\n<li>法2：先接后断法，将第一个链表首尾相接，然后用法5对第二个链表进行判断，若有环则相交，若无环则不相交，注意完成判断后要将第一个链表断开。</li>\n<li>法3：直接法：直接判断两链表末节点是否相同</li>\n</ol>\n</blockquote>\n<p>\\7. 已知两单链表相交，求相交点</p>\n<blockquote>\n<p>快慢指针法</p>\n<p>先求两链表长度len1,len2，快指针先走abs(len1-len2)步，而后两指针同时前走并判断是否相等，若在某时刻之前不等，而在此时相等，则此时为交点</p>\n</blockquote>\n<p>\\8. 求两递增单链表AB差集A-B(元素在A而不在B)</p>\n<blockquote>\n<p>归并的思想</p>\n<p>每次取表头元素进行大小判断，若A’&lt;’B则通过，若A==B则剃除，若A&gt;B则将B指针向后移动直至A’&lt;’B或A==B</p>\n</blockquote>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/list/single_list.cpp\" target=\"_blank\" rel=\"noopener\">单向链表的完整实现</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/list/double_list.cpp\" target=\"_blank\" rel=\"noopener\">双向链表的完整实现</a></p>"},{"layout":"post","title":"Hello,World","date":"2017-05-09T16:00:00.000Z","comments":1,"_content":"\n自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.\n\n开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。\n\nStart From Zero, End With Infinite.","source":"_posts/Hello,World.md","raw":"---\nlayout: post\ntitle: \"Hello,World\"\ndate: 2017-05-10\ncomments: true\ntags: \n\t- others\n---\n\n自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.\n\n开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。\n\nStart From Zero, End With Infinite.","slug":"Hello,World","published":1,"updated":"2018-05-25T12:41:12.717Z","photos":[],"link":"","_id":"cjhvssae3000tjvfcdc2uojez","content":"<p>自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.</p>\n<p>开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。</p>\n<p>Start From Zero, End With Infinite.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自踏入大学也近一年了，在这一年的大一生活中，从零开始学习计算机方面的基础知识，一点点接触c++、算法，再到windows编程、git，并打算建立个人博客记录自己学习的点滴，分享些自己的看法。 这个个人博客是基于Hexo搭建的Github pages，主题采用较为简洁、功能丰富的Yilia.</p>\n<p>开始记录时，本人正将踏入大二。已独立完成一个基于win32的小游戏，掌握一些基本的算法和数据结构，当然这些不足一提，但希望每个来到这个博客的人都能够有所收获。</p>\n<p>Start From Zero, End With Infinite.</p>\n"},{"layout":"post","title":"C++大作业 Cyclooctane 2.0","date":"2017-08-27T16:00:00.000Z","comments":1,"_content":"\n游戏名：Cyclooctane 2.0\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途： C++大作业\n语言：C++\n代码量：5.0k+\n开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17->2017/08/28\n推荐分辨率：1920*1080\n\n=============================================\n\n## 写在前面的话\n\nC++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。\n本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。\n\n<!-- more -->\n\n绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。\n优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A*用二叉堆优化甚至升级用 D*等等。\n游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。\n这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。\n商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。\n此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。\n\n## 游戏概述：\n\n```\n陷入黑暗的勇者被迫进行轮回的战斗\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG)\n\n### 游戏介绍：\n\n> 房间内不断有怪物随机生成来袭击玩家。\n>\n> 在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能\n>\n> 每闯一定数目关卡有升级或切换技能机会\n>\n> 每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG)\n\n### 地形：\n\n地形分**地刺**和**岩石**\n\n#### 地刺\n\n分为间歇型地刺和永久型地刺\n地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）\n\n#### 岩石\n\n岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光\n\n### 怪物系统：\n\n怪物血量以**边数**进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n\n### 皮肤系统：\n\n共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG)\n\n### 金钱系统：\n\n金钱分为**魂**和**金币**两种\n\n#### 魂：\n\n当局存在\n获得方式：击杀怪物（不同方式、不同怪物获得的量不同）\n用途：商店内购买属性或购买、切换技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG)\n\n#### 金币：\n\n永久存在\n获得方式：通过房间\n用途：解锁皮肤或重新抽取初始技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG)\n\n### 技能介绍：\n\n#### 0：普通旋转\n\n玩家无法获得，门开后自动获得\n可旋转地图（墙壁和所有障碍物）\n旋转击杀的怪物获得额外的魂奖励\n\n#### 1：子弹\n\n可连续发射\n有限射程\n对怪物造成一点伤害\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG)\n\n#### 2：清场旋转\n\n切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。\n清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。\n切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。\n\n#### 3：穿透激光\n\n可连续发射\n有限射程\n对击中的所有怪物造成2点伤害\n碰到墙壁反弹。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG)\n\n#### 4：即死激光\n\n可连续发射\n有限射程\n立刻秒杀击中的怪物\n但是会被怪物反弹\n碰到墙壁或岩石反弹\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG)\n\n#### 5：爆弹\n\n不可连续发射\n有限射程\n达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG)\n\n#### 6：食弹\n\n自由操控悬浮子弹\n无限射程\n会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家\n体积越小速度越快\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG)\n\n### 游戏特色：\n\n1. 基础图形学函数\n2. 基于分离轴原理的碰撞检测\n3. 基于A*的怪物自动寻路算法\n4. 利用有限状态机实现游戏状态转移\n5. 存取档DES加密解密算法\n6. 6种特色攻击方式，抽技能机制，皮肤解锁机制\n7. 局部更新+双缓冲绘图\n8. 特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：切换技能\nESC：游戏中暂停、退出升级、返回\nEnter：确定\n\n```\n\n### 设计细节\n\n1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。\n2 - 每次开启游戏自动读取存档\n3 - 存档无法使用时会弹出异常并删除存档\n4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能\n5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。\n6 - **更换的第一技能会保存**。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转\n7 - 技能射程恒定：\n\n> 1: 20 3: 500 4: 550 5: 15\n\n8 - 技能速度恒定(除了食弹)\n\n> 1,5: 15 6: 22\n\n9 - 怪物击杀获得魂：\n\n> 普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3\n>\n> 清场击杀： 普通怪物+0，精英怪+0\n>\n> 旋转击杀： 普通怪物+2，精英怪+5\n>\n> 碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10\n\n### 完整实现\n\n[完整代码](https://github.com/zedom1/Cyclooctane-2)\n[游戏exe下载](https://pan.baidu.com/s/1migK4Fe)","source":"_posts/Cyclooctane 2.md","raw":"\n---\nlayout: post\ntitle: \"C++大作业 Cyclooctane 2.0\"\ndate: 2017-08-28\ncomments: true\ntags: \n\t- 游戏\n\t- c++\n---\n\n游戏名：Cyclooctane 2.0\n副名：Who’s the hunter now?\n\n=============================================\n\n作者：Zedom\n平台：Windows\n用途： C++大作业\n语言：C++\n代码量：5.0k+\n开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17->2017/08/28\n推荐分辨率：1920*1080\n\n=============================================\n\n## 写在前面的话\n\nC++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。\n本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。\n\n<!-- more -->\n\n绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。\n优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A*用二叉堆优化甚至升级用 D*等等。\n游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。\n这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。\n商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。\n此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。\n\n## 游戏概述：\n\n```\n陷入黑暗的勇者被迫进行轮回的战斗\n\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG)\n\n### 游戏介绍：\n\n> 房间内不断有怪物随机生成来袭击玩家。\n>\n> 在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）\n>\n> 开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能\n>\n> 每闯一定数目关卡有升级或切换技能机会\n>\n> 每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率\n>\n> 玩家受伤会无敌并闪烁，无敌时间2s\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG)\n\n### 地形：\n\n地形分**地刺**和**岩石**\n\n#### 地刺\n\n分为间歇型地刺和永久型地刺\n地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）\n\n#### 岩石\n\n岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光\n\n### 怪物系统：\n\n怪物血量以**边数**进行衡量，最少为三角形，最多为六边形\n\n#### 普通怪物：\n\n速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡\n\n#### 精英怪物：\n\n速度较普通怪物快\n红色精英怪：无视地刺\n棕色精英怪：无视岩石\n白色精英怪：无视怪物间碰撞体积\n\n### 皮肤系统：\n\n共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG)\n\n### 金钱系统：\n\n金钱分为**魂**和**金币**两种\n\n#### 魂：\n\n当局存在\n获得方式：击杀怪物（不同方式、不同怪物获得的量不同）\n用途：商店内购买属性或购买、切换技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG)\n\n#### 金币：\n\n永久存在\n获得方式：通过房间\n用途：解锁皮肤或重新抽取初始技能\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG)\n\n### 技能介绍：\n\n#### 0：普通旋转\n\n玩家无法获得，门开后自动获得\n可旋转地图（墙壁和所有障碍物）\n旋转击杀的怪物获得额外的魂奖励\n\n#### 1：子弹\n\n可连续发射\n有限射程\n对怪物造成一点伤害\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG)\n\n#### 2：清场旋转\n\n切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。\n清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。\n切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。\n\n#### 3：穿透激光\n\n可连续发射\n有限射程\n对击中的所有怪物造成2点伤害\n碰到墙壁反弹。\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG)\n\n#### 4：即死激光\n\n可连续发射\n有限射程\n立刻秒杀击中的怪物\n但是会被怪物反弹\n碰到墙壁或岩石反弹\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG)\n\n#### 5：爆弹\n\n不可连续发射\n有限射程\n达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG)\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG)\n\n#### 6：食弹\n\n自由操控悬浮子弹\n无限射程\n会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家\n体积越小速度越快\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG)\n\n### 游戏特色：\n\n1. 基础图形学函数\n2. 基于分离轴原理的碰撞检测\n3. 基于A*的怪物自动寻路算法\n4. 利用有限状态机实现游戏状态转移\n5. 存取档DES加密解密算法\n6. 6种特色攻击方式，抽技能机制，皮肤解锁机制\n7. 局部更新+双缓冲绘图\n8. 特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权\n\n### 操作方式：\n\n```\nWASD：操纵主角移动，移动菜单选项\n上下左右：发射子弹、激光或操纵悬浮子弹\nQ：切换技能\nESC：游戏中暂停、退出升级、返回\nEnter：确定\n\n```\n\n### 设计细节\n\n1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。\n2 - 每次开启游戏自动读取存档\n3 - 存档无法使用时会弹出异常并删除存档\n4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能\n5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。\n6 - **更换的第一技能会保存**。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转\n7 - 技能射程恒定：\n\n> 1: 20 3: 500 4: 550 5: 15\n\n8 - 技能速度恒定(除了食弹)\n\n> 1,5: 15 6: 22\n\n9 - 怪物击杀获得魂：\n\n> 普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3\n>\n> 清场击杀： 普通怪物+0，精英怪+0\n>\n> 旋转击杀： 普通怪物+2，精英怪+5\n>\n> 碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10\n\n### 完整实现\n\n[完整代码](https://github.com/zedom1/Cyclooctane-2)\n[游戏exe下载](https://pan.baidu.com/s/1migK4Fe)","slug":"Cyclooctane 2","published":1,"updated":"2018-05-25T12:41:12.071Z","photos":[],"link":"","_id":"cjhvssae5000ujvfcjtq4p8mh","content":"<p>游戏名：Cyclooctane 2.0<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途： C++大作业<br>语言：C++<br>代码量：5.0k+<br>开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17-&gt;2017/08/28<br>推荐分辨率：1920*1080</p>\n<p>=============================================</p>\n<h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>C++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。<br>本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。</p>\n<a id=\"more\"></a>\n<p>绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。<br>优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A<em>用二叉堆优化甚至升级用 D</em>等等。<br>游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。<br>这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。<br>商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。<br>此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">陷入黑暗的勇者被迫进行轮回的战斗</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内不断有怪物随机生成来袭击玩家。</p>\n<p>在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能</p>\n<p>每闯一定数目关卡有升级或切换技能机会</p>\n<p>每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG\" alt=\"mark\"></p>\n<h3 id=\"地形：\"><a href=\"#地形：\" class=\"headerlink\" title=\"地形：\"></a>地形：</h3><p>地形分<strong>地刺</strong>和<strong>岩石</strong></p>\n<h4 id=\"地刺\"><a href=\"#地刺\" class=\"headerlink\" title=\"地刺\"></a>地刺</h4><p>分为间歇型地刺和永久型地刺<br>地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）</p>\n<h4 id=\"岩石\"><a href=\"#岩石\" class=\"headerlink\" title=\"岩石\"></a>岩石</h4><p>岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光</p>\n<h3 id=\"怪物系统：\"><a href=\"#怪物系统：\" class=\"headerlink\" title=\"怪物系统：\"></a>怪物系统：</h3><p>怪物血量以<strong>边数</strong>进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积</p>\n<h3 id=\"皮肤系统：\"><a href=\"#皮肤系统：\" class=\"headerlink\" title=\"皮肤系统：\"></a>皮肤系统：</h3><p>共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG\" alt=\"mark\"></p>\n<h3 id=\"金钱系统：\"><a href=\"#金钱系统：\" class=\"headerlink\" title=\"金钱系统：\"></a>金钱系统：</h3><p>金钱分为<strong>魂</strong>和<strong>金币</strong>两种</p>\n<h4 id=\"魂：\"><a href=\"#魂：\" class=\"headerlink\" title=\"魂：\"></a>魂：</h4><p>当局存在<br>获得方式：击杀怪物（不同方式、不同怪物获得的量不同）<br>用途：商店内购买属性或购买、切换技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG\" alt=\"mark\"></p>\n<h4 id=\"金币：\"><a href=\"#金币：\" class=\"headerlink\" title=\"金币：\"></a>金币：</h4><p>永久存在<br>获得方式：通过房间<br>用途：解锁皮肤或重新抽取初始技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG\" alt=\"mark\"></p>\n<h3 id=\"技能介绍：\"><a href=\"#技能介绍：\" class=\"headerlink\" title=\"技能介绍：\"></a>技能介绍：</h3><h4 id=\"0：普通旋转\"><a href=\"#0：普通旋转\" class=\"headerlink\" title=\"0：普通旋转\"></a>0：普通旋转</h4><p>玩家无法获得，门开后自动获得<br>可旋转地图（墙壁和所有障碍物）<br>旋转击杀的怪物获得额外的魂奖励</p>\n<h4 id=\"1：子弹\"><a href=\"#1：子弹\" class=\"headerlink\" title=\"1：子弹\"></a>1：子弹</h4><p>可连续发射<br>有限射程<br>对怪物造成一点伤害<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG\" alt=\"mark\"></p>\n<h4 id=\"2：清场旋转\"><a href=\"#2：清场旋转\" class=\"headerlink\" title=\"2：清场旋转\"></a>2：清场旋转</h4><p>切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。<br>清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。<br>切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。</p>\n<h4 id=\"3：穿透激光\"><a href=\"#3：穿透激光\" class=\"headerlink\" title=\"3：穿透激光\"></a>3：穿透激光</h4><p>可连续发射<br>有限射程<br>对击中的所有怪物造成2点伤害<br>碰到墙壁反弹。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG\" alt=\"mark\"></p>\n<h4 id=\"4：即死激光\"><a href=\"#4：即死激光\" class=\"headerlink\" title=\"4：即死激光\"></a>4：即死激光</h4><p>可连续发射<br>有限射程<br>立刻秒杀击中的怪物<br>但是会被怪物反弹<br>碰到墙壁或岩石反弹<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG\" alt=\"mark\"></p>\n<h4 id=\"5：爆弹\"><a href=\"#5：爆弹\" class=\"headerlink\" title=\"5：爆弹\"></a>5：爆弹</h4><p>不可连续发射<br>有限射程<br>达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG\" alt=\"mark\"></p>\n<h4 id=\"6：食弹\"><a href=\"#6：食弹\" class=\"headerlink\" title=\"6：食弹\"></a>6：食弹</h4><p>自由操控悬浮子弹<br>无限射程<br>会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家<br>体积越小速度越快<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><ol>\n<li>基础图形学函数</li>\n<li>基于分离轴原理的碰撞检测</li>\n<li>基于A*的怪物自动寻路算法</li>\n<li>利用有限状态机实现游戏状态转移</li>\n<li>存取档DES加密解密算法</li>\n<li>6种特色攻击方式，抽技能机制，皮肤解锁机制</li>\n<li>局部更新+双缓冲绘图</li>\n<li>特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权</li>\n</ol>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：切换技能</span><br><span class=\"line\">ESC：游戏中暂停、退出升级、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<h3 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h3><p>1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。<br>2 - 每次开启游戏自动读取存档<br>3 - 存档无法使用时会弹出异常并删除存档<br>4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能<br>5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。<br>6 - <strong>更换的第一技能会保存</strong>。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转<br>7 - 技能射程恒定：</p>\n<blockquote>\n<p>1: 20 3: 500 4: 550 5: 15</p>\n</blockquote>\n<p>8 - 技能速度恒定(除了食弹)</p>\n<blockquote>\n<p>1,5: 15 6: 22</p>\n</blockquote>\n<p>9 - 怪物击杀获得魂：</p>\n<blockquote>\n<p>普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3</p>\n<p>清场击杀： 普通怪物+0，精英怪+0</p>\n<p>旋转击杀： 普通怪物+2，精英怪+5</p>\n<p>碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10</p>\n</blockquote>\n<h3 id=\"完整实现\"><a href=\"#完整实现\" class=\"headerlink\" title=\"完整实现\"></a>完整实现</h3><p><a href=\"https://github.com/zedom1/Cyclooctane-2\" target=\"_blank\" rel=\"noopener\">完整代码</a><br><a href=\"https://pan.baidu.com/s/1migK4Fe\" target=\"_blank\" rel=\"noopener\">游戏exe下载</a></p>\n","site":{"data":{}},"excerpt":"<p>游戏名：Cyclooctane 2.0<br>副名：Who’s the hunter now?</p>\n<p>=============================================</p>\n<p>作者：Zedom<br>平台：Windows<br>用途： C++大作业<br>语言：C++<br>代码量：5.0k+<br>开发时间：（不计Cyclooctane1时间）间断开发，共计约20天，2017/07/17-&gt;2017/08/28<br>推荐分辨率：1920*1080</p>\n<p>=============================================</p>\n<h2 id=\"写在前面的话\"><a href=\"#写在前面的话\" class=\"headerlink\" title=\"写在前面的话\"></a>写在前面的话</h2><p>C++课程在暑假布置了一个大作业，代码量一千五以上的自制项目，可以是软件或游戏。<br>本来想是另做一个，后来没什么时间，就想着在原本上稍做些改动好了，结果和朋友讨论+头脑风暴后创意又来了一些，于是乎做了大改，个人对于现在这个版本算是比较满意了。</p>","more":"<p>绘图方面，因为尝试过windows的API的麻烦，改用EasyX后大呼方便，它本身提供了双缓冲机制，不过有些地方还是需要局部更新因此没有删去局部更新的代码，而是再加上双缓冲使得图像更流畅。<br>优化方面，稍微做了些优化吧，想法很多，但没有时间实现出来。比如碰撞检测用四叉树优化，A<em>用二叉堆优化甚至升级用 D</em>等等。<br>游戏机制是最大的改动，原版总感觉有些不对劲，但这一版这样的设计感觉很自然，也很具游戏性，至于是哪些地方改动了下文会提到。<br>这一版除了游戏机制的大改动之外，另一个大改动在于存取档方面，黑框框答辩的时候因为没怎么重视存档被揪住A了一会儿。存取档方面加上了较为广泛使用的DES加密解密算法。<br>商店方面，技能购买和更换还可以，但升级数目太少，实际上是懒得画界面，列出的可升级选项很多(比如移除爆炸对玩家的伤害)，但绘制出来太麻烦而时间又不太够，因此升级就只有恢复血量、增加血上限、增加移速三项。<br>此外，游戏中还加入了帮助选项，不过因为绘制定位太麻烦，是在PPT里做成图片后导入的，嵌入了EXE因此EXE很大，图片的清晰度导入后差了很多。</p>\n<h2 id=\"游戏概述：\"><a href=\"#游戏概述：\" class=\"headerlink\" title=\"游戏概述：\"></a>游戏概述：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">陷入黑暗的勇者被迫进行轮回的战斗</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/Fc095KK78m.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏介绍：\"><a href=\"#游戏介绍：\" class=\"headerlink\" title=\"游戏介绍：\"></a>游戏介绍：</h3><blockquote>\n<p>房间内不断有怪物随机生成来袭击玩家。</p>\n<p>在房间待一段时间后，玩家将会失去自己的攻击能力并获得旋转地图能力，房间随机一处会开门，玩家可以选择停留在房间内，但怪物会继续生成并且速度会随玩家逗留时间增加而增加。（每个房间的时间随机，但总体随闯关房间增加而增加）</p>\n<p>开始游戏时玩家会先随机抽取第一技能，而后可以在商店购买第二技能或切换技能</p>\n<p>每闯一定数目关卡有升级或切换技能机会</p>\n<p>每一定数目房间后会进入精英关卡：超快的怪物生成速度，超高的精英怪概率</p>\n<p>玩家受伤会无敌并闪烁，无敌时间2s</p>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/1j72jDAbEA.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d372IFi0k.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/AC46HeLE2j.JPG\" alt=\"mark\"></p>\n<h3 id=\"地形：\"><a href=\"#地形：\" class=\"headerlink\" title=\"地形：\"></a>地形：</h3><p>地形分<strong>地刺</strong>和<strong>岩石</strong></p>\n<h4 id=\"地刺\"><a href=\"#地刺\" class=\"headerlink\" title=\"地刺\"></a>地刺</h4><p>分为间歇型地刺和永久型地刺<br>地刺会不分敌我的扎伤在上面的人或怪物（红色精英怪免疫）</p>\n<h4 id=\"岩石\"><a href=\"#岩石\" class=\"headerlink\" title=\"岩石\"></a>岩石</h4><p>岩石会不分敌我的阻挡所有人（棕色精英怪免疫），此外，岩石还会反弹即死激光</p>\n<h3 id=\"怪物系统：\"><a href=\"#怪物系统：\" class=\"headerlink\" title=\"怪物系统：\"></a>怪物系统：</h3><p>怪物血量以<strong>边数</strong>进行衡量，最少为三角形，最多为六边形</p>\n<h4 id=\"普通怪物：\"><a href=\"#普通怪物：\" class=\"headerlink\" title=\"普通怪物：\"></a>普通怪物：</h4><p>速度适中，生命值随机，怪物间存在碰撞体积，受地刺伤害，受岩石阻挡</p>\n<h4 id=\"精英怪物：\"><a href=\"#精英怪物：\" class=\"headerlink\" title=\"精英怪物：\"></a>精英怪物：</h4><p>速度较普通怪物快<br>红色精英怪：无视地刺<br>棕色精英怪：无视岩石<br>白色精英怪：无视怪物间碰撞体积</p>\n<h3 id=\"皮肤系统：\"><a href=\"#皮肤系统：\" class=\"headerlink\" title=\"皮肤系统：\"></a>皮肤系统：</h3><p>共有三种人物皮肤，1号默认解锁，2号3号需要花费金币解锁，不同皮肤拥有不同属性和外观。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/3k6hEEm3lg.JPG\" alt=\"mark\"></p>\n<h3 id=\"金钱系统：\"><a href=\"#金钱系统：\" class=\"headerlink\" title=\"金钱系统：\"></a>金钱系统：</h3><p>金钱分为<strong>魂</strong>和<strong>金币</strong>两种</p>\n<h4 id=\"魂：\"><a href=\"#魂：\" class=\"headerlink\" title=\"魂：\"></a>魂：</h4><p>当局存在<br>获得方式：击杀怪物（不同方式、不同怪物获得的量不同）<br>用途：商店内购买属性或购买、切换技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/l4hb1EiAhB.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/2d9laAHd7H.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/8gBCd2I8DF.JPG\" alt=\"mark\"></p>\n<h4 id=\"金币：\"><a href=\"#金币：\" class=\"headerlink\" title=\"金币：\"></a>金币：</h4><p>永久存在<br>获得方式：通过房间<br>用途：解锁皮肤或重新抽取初始技能<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170828/25bKhmdF91.JPG\" alt=\"mark\"></p>\n<h3 id=\"技能介绍：\"><a href=\"#技能介绍：\" class=\"headerlink\" title=\"技能介绍：\"></a>技能介绍：</h3><h4 id=\"0：普通旋转\"><a href=\"#0：普通旋转\" class=\"headerlink\" title=\"0：普通旋转\"></a>0：普通旋转</h4><p>玩家无法获得，门开后自动获得<br>可旋转地图（墙壁和所有障碍物）<br>旋转击杀的怪物获得额外的魂奖励</p>\n<h4 id=\"1：子弹\"><a href=\"#1：子弹\" class=\"headerlink\" title=\"1：子弹\"></a>1：子弹</h4><p>可连续发射<br>有限射程<br>对怪物造成一点伤害<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/G09aEACKkI.JPG\" alt=\"mark\"></p>\n<h4 id=\"2：清场旋转\"><a href=\"#2：清场旋转\" class=\"headerlink\" title=\"2：清场旋转\"></a>2：清场旋转</h4><p>切换的瞬间能够清除场上所有怪物，其余与普通旋转相同，可无限次自由切换。<br>清场击杀的怪物不计魂，当前房间内使用清场次数过多则该房间无法获得金币。<br>切换功能只有双技能时能够使用，此技能作为单技能时无法触发清场。</p>\n<h4 id=\"3：穿透激光\"><a href=\"#3：穿透激光\" class=\"headerlink\" title=\"3：穿透激光\"></a>3：穿透激光</h4><p>可连续发射<br>有限射程<br>对击中的所有怪物造成2点伤害<br>碰到墙壁反弹。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/A0gcKgK9lk.JPG\" alt=\"mark\"></p>\n<h4 id=\"4：即死激光\"><a href=\"#4：即死激光\" class=\"headerlink\" title=\"4：即死激光\"></a>4：即死激光</h4><p>可连续发射<br>有限射程<br>立刻秒杀击中的怪物<br>但是会被怪物反弹<br>碰到墙壁或岩石反弹<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/f43BDccEgd.JPG\" alt=\"mark\"></p>\n<h4 id=\"5：爆弹\"><a href=\"#5：爆弹\" class=\"headerlink\" title=\"5：爆弹\"></a>5：爆弹</h4><p>不可连续发射<br>有限射程<br>达到射程或击中怪物后爆炸，秒杀爆炸范围内所有怪物，会伤害玩家<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/J3ijB5IfaE.JPG\" alt=\"mark\"><br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/9jCa8E69g7.JPG\" alt=\"mark\"></p>\n<h4 id=\"6：食弹\"><a href=\"#6：食弹\" class=\"headerlink\" title=\"6：食弹\"></a>6：食弹</h4><p>自由操控悬浮子弹<br>无限射程<br>会吞噬碰到的怪物并使自身体积增大，达到一定体积后爆炸，秒杀爆炸范围内所有怪物，不会伤害玩家<br>体积越小速度越快<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170830/67jbiHIH8K.JPG\" alt=\"mark\"></p>\n<h3 id=\"游戏特色：\"><a href=\"#游戏特色：\" class=\"headerlink\" title=\"游戏特色：\"></a>游戏特色：</h3><ol>\n<li>基础图形学函数</li>\n<li>基于分离轴原理的碰撞检测</li>\n<li>基于A*的怪物自动寻路算法</li>\n<li>利用有限状态机实现游戏状态转移</li>\n<li>存取档DES加密解密算法</li>\n<li>6种特色攻击方式，抽技能机制，皮肤解锁机制</li>\n<li>局部更新+双缓冲绘图</li>\n<li>特色游戏玩法，狩猎角色变更但玩家依旧有些许掌控权</li>\n</ol>\n<h3 id=\"操作方式：\"><a href=\"#操作方式：\" class=\"headerlink\" title=\"操作方式：\"></a>操作方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WASD：操纵主角移动，移动菜单选项</span><br><span class=\"line\">上下左右：发射子弹、激光或操纵悬浮子弹</span><br><span class=\"line\">Q：切换技能</span><br><span class=\"line\">ESC：游戏中暂停、退出升级、返回</span><br><span class=\"line\">Enter：确定</span><br></pre></td></tr></table></figure>\n<h3 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h3><p>1 - 每次死亡后自动存档，游戏中不自动存档，游戏中不存档自行退出则该局不结算金币。结算金币是在死亡界面。<br>2 - 每次开启游戏自动读取存档<br>3 - 存档无法使用时会弹出异常并删除存档<br>4 - 只有一个技能时只能购买第二技能而不能更换第二技能，当两个技能都存在时才可以更换技能<br>5 - 不使用抽取到的技能完成游戏（即玩到人物死亡），那么将无法免费抽取第一技能。<br>6 - <strong>更换的第一技能会保存</strong>。如开局抽取到子弹，而后在商店将第一技能更换为旋转，那么中途退出重开后第一技能将是旋转<br>7 - 技能射程恒定：</p>\n<blockquote>\n<p>1: 20 3: 500 4: 550 5: 15</p>\n</blockquote>\n<p>8 - 技能速度恒定(除了食弹)</p>\n<blockquote>\n<p>1,5: 15 6: 22</p>\n</blockquote>\n<p>9 - 怪物击杀获得魂：</p>\n<blockquote>\n<p>普通击杀(使用技能1、3、4、5、6击杀怪物)： 普通怪物+1，精英怪+3</p>\n<p>清场击杀： 普通怪物+0，精英怪+0</p>\n<p>旋转击杀： 普通怪物+2，精英怪+5</p>\n<p>碰撞击杀(玩家触碰怪物)： 普通怪物+0，红色精英怪+10</p>\n</blockquote>\n<h3 id=\"完整实现\"><a href=\"#完整实现\" class=\"headerlink\" title=\"完整实现\"></a>完整实现</h3><p><a href=\"https://github.com/zedom1/Cyclooctane-2\" target=\"_blank\" rel=\"noopener\">完整代码</a><br><a href=\"https://pan.baidu.com/s/1migK4Fe\" target=\"_blank\" rel=\"noopener\">游戏exe下载</a></p>"},{"layout":"post","title":"百度机器阅读理解比赛赛后总结","date":"2018-05-21T16:00:00.000Z","comments":1,"_content":"\n\n2018年4-5月间，笔者参加了百度举办的[机器阅读理解竞赛](http://mrc2018.cipsc.org.cn/)，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。\n\n\n\n我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。\n\n比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。\n\n![Ranklist](http://ot1c7ttzm.bkt.clouddn.com/ranklist.png)\n\n<!-- more -->\n\n### Step0：了解比赛，掌握数据形式\n\n题目背景：\n\n官方给出解释：\n\n\t对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n\n个人详细解释：\n\t语料库包含很多问题\n\t对于每个问题，语料库中对应几篇文档和该问题的标准答案。\n\t文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。\n\t问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。\n\t我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。\n\n评分机制： \n\tRough-L：相同最大子串(考虑顺序)\n\tBLEU-4：预测答案和实际答案共同出现的词数(无顺序)\n\t评分以Rough-L为主，Rough-L相同以BLEU-4排名\n在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。\n\n介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。\n\n### Step1: 阅读论文，了解state-of-art models\n\n头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：[BIDAF](https://arxiv.org/abs/1611.01603)和[Match-LSTM](https://arxiv.org/abs/1608.07905)，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软[r-net](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf)。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。\n\n阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：\n\n       \t1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       \t2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       \t3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       \t4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n\n### Step2 模型选择与改进\n\n#### 挑选Baseline System：\n\n\tBIDAF与MLSTM区别：\n\t\tBiDAF在Interaction 层中引入了双向注意力机制\n\t\t首先计算一个原文和问题的 Alignment matrix，\n\t\t基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n\t\t基于注意力计算 query-aware 的原文表示，\n\t\t使用双向 LSTM 进行语义信息的聚合。\n\t\n\t\t另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n\t\t词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\t\n\t通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n\n#### 初期想法：\n\n\t师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n\t\t1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n\t\t2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n\t\t3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\t\n\t但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n#### 模型改造：\n\n##### 架构上：end-to-end 到 非 end-to-end\n\n​\t一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。\n\n​\t对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。\n\n​\t由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。\n\n##### 实现上\n\n在实现方面，我们做了两点变化：\n\n###### 问题编码作为上文流入文章编码\n\n第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：\n\n```\nQ：中国第一个乒乓球大满贯是谁？\nA1：刘国梁。\nA2：中国第一个乒乓球大满贯是刘国梁。\nA3：中国第一个乒乓球大满贯。\n```\n\n​\t人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。\n\n###### 加入self-matching层\n\n如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。\n\n虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。\n\n考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。\n\n随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的\"指针\"，而忽略了这句话就会使得变量对应不上。\n\n虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。\n\n#### 答案抽取1： EM算法\n\n起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。\n\nEM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。\n\n这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。\n\n考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。\n\n在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。\n\n#### 答案抽取2：Xgboost\n\n要使用xgboost训练首先得构造训练数据\n\n答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。\n\n特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。\n\n有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。\n\n以下就是我们的成品模型了：\n\n![最终模型](http://ot1c7ttzm.bkt.clouddn.com/Model.jpg)\n\n### Step3 调参\n\n改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。\n\n此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。\n\n在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的\"悲惨境地\"，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了**gridCV**这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。\n\n### 未来改进点与赛后感想\n\n#### 改进：\n\n\t1. 用预先训练好的词向量代替随机初始化词向量进行训练\n\t2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n\t3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n\t4. 加强数据预处理，清洗噪音消息和html标签\n\t5. 有无疑问代词的优化\n\t6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n\t7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n\t8. 字符级别词嵌入：为模型提供更多特征\n\t9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n\t10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n\n#### 感想\n\n首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。\n\n这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。\n\n非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。","source":"_posts/RC_DuReader.md","raw":"---\nlayout: post\ntitle: \"百度机器阅读理解比赛赛后总结\"\ndate: 2018-05-22\ncomments: true\ntags: \n\t- NLP\n\t- 阅读理解\n\t- 机器学习\n---\n\n\n2018年4-5月间，笔者参加了百度举办的[机器阅读理解竞赛](http://mrc2018.cipsc.org.cn/)，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。\n\n\n\n我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。\n\n比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。\n\n![Ranklist](http://ot1c7ttzm.bkt.clouddn.com/ranklist.png)\n\n<!-- more -->\n\n### Step0：了解比赛，掌握数据形式\n\n题目背景：\n\n官方给出解释：\n\n\t对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n\n个人详细解释：\n\t语料库包含很多问题\n\t对于每个问题，语料库中对应几篇文档和该问题的标准答案。\n\t文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。\n\t问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。\n\t我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。\n\n评分机制： \n\tRough-L：相同最大子串(考虑顺序)\n\tBLEU-4：预测答案和实际答案共同出现的词数(无顺序)\n\t评分以Rough-L为主，Rough-L相同以BLEU-4排名\n在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。\n\n介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。\n\n### Step1: 阅读论文，了解state-of-art models\n\n头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：[BIDAF](https://arxiv.org/abs/1611.01603)和[Match-LSTM](https://arxiv.org/abs/1608.07905)，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软[r-net](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf)。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。\n\n阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：\n\n       \t1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       \t2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       \t3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       \t4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n\n### Step2 模型选择与改进\n\n#### 挑选Baseline System：\n\n\tBIDAF与MLSTM区别：\n\t\tBiDAF在Interaction 层中引入了双向注意力机制\n\t\t首先计算一个原文和问题的 Alignment matrix，\n\t\t基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n\t\t基于注意力计算 query-aware 的原文表示，\n\t\t使用双向 LSTM 进行语义信息的聚合。\n\t\n\t\t另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n\t\t词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\t\n\t通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n\n#### 初期想法：\n\n\t师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n\t\t1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n\t\t2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n\t\t3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\t\n\t但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n#### 模型改造：\n\n##### 架构上：end-to-end 到 非 end-to-end\n\n​\t一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。\n\n​\t对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。\n\n​\t由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。\n\n##### 实现上\n\n在实现方面，我们做了两点变化：\n\n###### 问题编码作为上文流入文章编码\n\n第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：\n\n```\nQ：中国第一个乒乓球大满贯是谁？\nA1：刘国梁。\nA2：中国第一个乒乓球大满贯是刘国梁。\nA3：中国第一个乒乓球大满贯。\n```\n\n​\t人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。\n\n###### 加入self-matching层\n\n如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。\n\n虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。\n\n考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。\n\n随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的\"指针\"，而忽略了这句话就会使得变量对应不上。\n\n虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。\n\n#### 答案抽取1： EM算法\n\n起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。\n\nEM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。\n\n这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。\n\n考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。\n\n在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。\n\n#### 答案抽取2：Xgboost\n\n要使用xgboost训练首先得构造训练数据\n\n答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。\n\n特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。\n\n有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。\n\n以下就是我们的成品模型了：\n\n![最终模型](http://ot1c7ttzm.bkt.clouddn.com/Model.jpg)\n\n### Step3 调参\n\n改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。\n\n此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。\n\n在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的\"悲惨境地\"，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了**gridCV**这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。\n\n### 未来改进点与赛后感想\n\n#### 改进：\n\n\t1. 用预先训练好的词向量代替随机初始化词向量进行训练\n\t2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n\t3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n\t4. 加强数据预处理，清洗噪音消息和html标签\n\t5. 有无疑问代词的优化\n\t6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n\t7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n\t8. 字符级别词嵌入：为模型提供更多特征\n\t9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n\t10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n\n#### 感想\n\n首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。\n\n这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。\n\n非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。","slug":"RC_DuReader","published":1,"updated":"2018-05-25T12:41:12.886Z","photos":[],"link":"","_id":"cjhvssae7000wjvfcavbevtue","content":"<p>2018年4-5月间，笔者参加了百度举办的<a href=\"http://mrc2018.cipsc.org.cn/\" target=\"_blank\" rel=\"noopener\">机器阅读理解竞赛</a>，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。</p>\n<p>我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。</p>\n<p>比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ranklist.png\" alt=\"Ranklist\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Step0：了解比赛，掌握数据形式\"><a href=\"#Step0：了解比赛，掌握数据形式\" class=\"headerlink\" title=\"Step0：了解比赛，掌握数据形式\"></a>Step0：了解比赛，掌握数据形式</h3><p>题目背景：</p>\n<p>官方给出解释：</p>\n<pre><code>对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n</code></pre><p>个人详细解释：<br>    语料库包含很多问题<br>    对于每个问题，语料库中对应几篇文档和该问题的标准答案。<br>    文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。<br>    问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。<br>    我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。</p>\n<p>评分机制：<br>    Rough-L：相同最大子串(考虑顺序)<br>    BLEU-4：预测答案和实际答案共同出现的词数(无顺序)<br>    评分以Rough-L为主，Rough-L相同以BLEU-4排名<br>在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。</p>\n<p>介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。</p>\n<h3 id=\"Step1-阅读论文，了解state-of-art-models\"><a href=\"#Step1-阅读论文，了解state-of-art-models\" class=\"headerlink\" title=\"Step1: 阅读论文，了解state-of-art models\"></a>Step1: 阅读论文，了解state-of-art models</h3><p>头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：<a href=\"https://arxiv.org/abs/1611.01603\" target=\"_blank\" rel=\"noopener\">BIDAF</a>和<a href=\"https://arxiv.org/abs/1608.07905\" target=\"_blank\" rel=\"noopener\">Match-LSTM</a>，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软<a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf\" target=\"_blank\" rel=\"noopener\">r-net</a>。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。</p>\n<p>阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：</p>\n<pre><code>       1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n</code></pre><h3 id=\"Step2-模型选择与改进\"><a href=\"#Step2-模型选择与改进\" class=\"headerlink\" title=\"Step2 模型选择与改进\"></a>Step2 模型选择与改进</h3><h4 id=\"挑选Baseline-System：\"><a href=\"#挑选Baseline-System：\" class=\"headerlink\" title=\"挑选Baseline System：\"></a>挑选Baseline System：</h4><pre><code>BIDAF与MLSTM区别：\n    BiDAF在Interaction 层中引入了双向注意力机制\n    首先计算一个原文和问题的 Alignment matrix，\n    基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n    基于注意力计算 query-aware 的原文表示，\n    使用双向 LSTM 进行语义信息的聚合。\n\n    另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n    词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\n通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n</code></pre><h4 id=\"初期想法：\"><a href=\"#初期想法：\" class=\"headerlink\" title=\"初期想法：\"></a>初期想法：</h4><pre><code>师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n    1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n    2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n    3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\n但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n</code></pre><h4 id=\"模型改造：\"><a href=\"#模型改造：\" class=\"headerlink\" title=\"模型改造：\"></a>模型改造：</h4><h5 id=\"架构上：end-to-end-到-非-end-to-end\"><a href=\"#架构上：end-to-end-到-非-end-to-end\" class=\"headerlink\" title=\"架构上：end-to-end 到 非 end-to-end\"></a>架构上：end-to-end 到 非 end-to-end</h5><p>​    一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。</p>\n<p>​    对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。</p>\n<p>​    由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。</p>\n<h5 id=\"实现上\"><a href=\"#实现上\" class=\"headerlink\" title=\"实现上\"></a>实现上</h5><p>在实现方面，我们做了两点变化：</p>\n<h6 id=\"问题编码作为上文流入文章编码\"><a href=\"#问题编码作为上文流入文章编码\" class=\"headerlink\" title=\"问题编码作为上文流入文章编码\"></a>问题编码作为上文流入文章编码</h6><p>第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q：中国第一个乒乓球大满贯是谁？</span><br><span class=\"line\">A1：刘国梁。</span><br><span class=\"line\">A2：中国第一个乒乓球大满贯是刘国梁。</span><br><span class=\"line\">A3：中国第一个乒乓球大满贯。</span><br></pre></td></tr></table></figure>\n<p>​    人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。</p>\n<h6 id=\"加入self-matching层\"><a href=\"#加入self-matching层\" class=\"headerlink\" title=\"加入self-matching层\"></a>加入self-matching层</h6><p>如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。</p>\n<p>虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。</p>\n<p>考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。</p>\n<p>随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的”指针”，而忽略了这句话就会使得变量对应不上。</p>\n<p>虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。</p>\n<h4 id=\"答案抽取1：-EM算法\"><a href=\"#答案抽取1：-EM算法\" class=\"headerlink\" title=\"答案抽取1： EM算法\"></a>答案抽取1： EM算法</h4><p>起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。</p>\n<p>EM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。</p>\n<p>这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。</p>\n<p>考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。</p>\n<p>在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。</p>\n<h4 id=\"答案抽取2：Xgboost\"><a href=\"#答案抽取2：Xgboost\" class=\"headerlink\" title=\"答案抽取2：Xgboost\"></a>答案抽取2：Xgboost</h4><p>要使用xgboost训练首先得构造训练数据</p>\n<p>答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。</p>\n<p>特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。</p>\n<p>有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。</p>\n<p>以下就是我们的成品模型了：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Model.jpg\" alt=\"最终模型\"></p>\n<h3 id=\"Step3-调参\"><a href=\"#Step3-调参\" class=\"headerlink\" title=\"Step3 调参\"></a>Step3 调参</h3><p>改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。</p>\n<p>此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。</p>\n<p>在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的”悲惨境地”，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了<strong>gridCV</strong>这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。</p>\n<h3 id=\"未来改进点与赛后感想\"><a href=\"#未来改进点与赛后感想\" class=\"headerlink\" title=\"未来改进点与赛后感想\"></a>未来改进点与赛后感想</h3><h4 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h4><pre><code>1. 用预先训练好的词向量代替随机初始化词向量进行训练\n2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n4. 加强数据预处理，清洗噪音消息和html标签\n5. 有无疑问代词的优化\n6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n8. 字符级别词嵌入：为模型提供更多特征\n9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n</code></pre><h4 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h4><p>首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。</p>\n<p>这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。</p>\n<p>非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。</p>\n","site":{"data":{}},"excerpt":"<p>2018年4-5月间，笔者参加了百度举办的<a href=\"http://mrc2018.cipsc.org.cn/\" target=\"_blank\" rel=\"noopener\">机器阅读理解竞赛</a>，抱师兄大腿地从不知连机器学习的门入没入的状态到对自然语言以及阅读理解有了一定理解。期间经历了读不懂论文、不会实现算法、对师兄谈及的各种算法一无所知等等痛苦，最终坚持下来，算是有了一些收获，就在这篇文章把参加比赛的整个过程以及解题、构建模型的思路梳理一下。</p>\n<p>我和组队的毕业师兄都是第一次参加阅读理解的比赛，但他在自然语言方面有更多了解，先前也打过kaggle之类的比赛，比赛实际上以他打为主，我以辅助和学习的形式参加。</p>\n<p>比赛最终以Rough-L第14名，BLEU第6名的结果结束，虽然有很多想法和改进没有来得及实现，但毕竟是第一次参赛，相信之后会越来越好。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ranklist.png\" alt=\"Ranklist\"></p>","more":"<h3 id=\"Step0：了解比赛，掌握数据形式\"><a href=\"#Step0：了解比赛，掌握数据形式\" class=\"headerlink\" title=\"Step0：了解比赛，掌握数据形式\"></a>Step0：了解比赛，掌握数据形式</h3><p>题目背景：</p>\n<p>官方给出解释：</p>\n<pre><code>对于给定问题q及其对应的文本形式的候选文档集合D=d1, d2, ..., dn，要求参评阅读理解系统自动对问题及候选文档进行分析， 输出能够满足问题的文本答案a。目标是a能够正确、完整、简洁地回答问题q。\n</code></pre><p>个人详细解释：<br>    语料库包含很多问题<br>    对于每个问题，语料库中对应几篇文档和该问题的标准答案。<br>    文档来自百度搜索、百度知道的结果，文档分标题和内容。文档的标题和询问的问题相似，而内容则是和问题答案相关的内容。<br>    问题的标准答案参考给出的文档由人工提取而成。（非完全抽取式，会有些许不同）。<br>    我们要做的就是根据给出的几篇文档，回答问题的答案，根据我们给出的答案和他们给出的标准答案的相似度进行评分。</p>\n<p>评分机制：<br>    Rough-L：相同最大子串(考虑顺序)<br>    BLEU-4：预测答案和实际答案共同出现的词数(无顺序)<br>    评分以Rough-L为主，Rough-L相同以BLEU-4排名<br>在对比赛形式和目标有了了解之后，下一步还要看官方给出的数据和代码，包括训练、验证、测试集数据，预处理的代码等。不过介于这是第一个比赛，经验不足，这一步笔者是在往baseline里面加代码的时候才做的，导致很大一段时间对数据细节不了解。</p>\n<p>介于官方有给出了预处理之后的数据集，我们在这次比赛中直接使用了他们处理的数据集，没有自行对原数据集进行处理。但是后来发现预处理中间其实大有可为，对最终表现也有些影响，不过那时已经接近比赛尾声，我们只好作罢。</p>\n<h3 id=\"Step1-阅读论文，了解state-of-art-models\"><a href=\"#Step1-阅读论文，了解state-of-art-models\" class=\"headerlink\" title=\"Step1: 阅读论文，了解state-of-art models\"></a>Step1: 阅读论文，了解state-of-art models</h3><p>头两个星期的预备阶段用于看已有模型的论文和代码，因为百度提供了两个baseline系统：<a href=\"https://arxiv.org/abs/1611.01603\" target=\"_blank\" rel=\"noopener\">BIDAF</a>和<a href=\"https://arxiv.org/abs/1608.07905\" target=\"_blank\" rel=\"noopener\">Match-LSTM</a>，所以我们也主要看这两个baseline的论文，再参考先前排行榜中排名靠前且开源的微软<a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/r-net.pdf\" target=\"_blank\" rel=\"noopener\">r-net</a>。通过这些已有的较为流行的模型，我对解决阅读理解的流程和阶段有了初步的认识。</p>\n<p>阅读理解模型基本分为编码、聚合、匹配、抽取四个模块：</p>\n<pre><code>       1. 编码阶段将分好词的问题和文章分别转换成词向量，可以使用已有的词向量导入，也可以随机初始化，而后根据结果反向传播训练\n       2. 聚合阶段仍然是分别处理文章和问题，通过如双向LSTM让每个词获得上下文的信息\n       3. 匹配阶段则是将问题和文章进行交互，文章的每个词都和整个问题进行聚合，以此让每个词结合问题信息，由此得到已知问题的文章编码。也有模型进行双向的匹配，即获得已知文章的问题编码和已知问题的文章编码两种编码，而后再聚合。理论上这个阶段到这里就结束了，但是据r-net的文章提出，通过rnn的文章编码只能获得有限的上下文信息，而答案的抽取范围可能很长，因此在匹配之后通常会再加上一次聚合，让已知问题的文章编码获得自身较远距离的上下文信息。\n       4. 抽取阶段则是进行答案的抽取。在M-LSTM的论文中提到两种模型：sequence model和boundary model，sequence model不考虑词语的连续性问题，将答案词语逐个逐个抽取而后拼接起来。而boundary model仅选择答案的起始和终止位置，中间的均作为答案，而实验表明boundary模型不仅简单而且效果更好，在其它的模型中也直接沿用了boundary模型。在此次比赛中，我们做的同样是答案抽取的形式。对于有些难度较大的数据集（如微软的MS-MARCRO），答案除了部分来自给定的文章外，还需要推理及自行生成，那么抽取阶段还需要做额外的工作。如[s-net](https://arxiv.org/abs/1706.04815) 中介绍的 extraction-then-synthesis framework。\n</code></pre><h3 id=\"Step2-模型选择与改进\"><a href=\"#Step2-模型选择与改进\" class=\"headerlink\" title=\"Step2 模型选择与改进\"></a>Step2 模型选择与改进</h3><h4 id=\"挑选Baseline-System：\"><a href=\"#挑选Baseline-System：\" class=\"headerlink\" title=\"挑选Baseline System：\"></a>挑选Baseline System：</h4><pre><code>BIDAF与MLSTM区别：\n    BiDAF在Interaction 层中引入了双向注意力机制\n    首先计算一个原文和问题的 Alignment matrix，\n    基于该矩阵计算 Query2Context 和 Context2Query 两种注意力，\n    基于注意力计算 query-aware 的原文表示，\n    使用双向 LSTM 进行语义信息的聚合。\n\n    另外，BIDAF Embed 层中混合了词级 embedding 和字符级 embedding(在百度提供的baseline中没有)，\n    词级 embedding 使用预训练的词向量进行初始化，而字符级 embedding 使用 CNN 进一步编码，两种 embedding 共同经过 2 层 Highway Network 作为 Encode 层输入。\n\n通过实验对比，我们最终选择了效果更好的BIDAF作为baseline。\n</code></pre><h4 id=\"初期想法：\"><a href=\"#初期想法：\" class=\"headerlink\" title=\"初期想法：\"></a>初期想法：</h4><pre><code>师兄从知识图谱体系结构的角度提出了智能补充疑问代词的思路，鉴于给出的问题有五分之二缺少疑问词，仅仅给出名词，如“xxx的价格”，他总结出三类问题所要问题：属性、行为和状态：\n    1. 属性是不变或变得很缓慢的知识，如姓名、性别等\n    2. 行为，行为包括原因、过程、对象、时间、地点、结果，如遇到xxx怎么办\n    3. 状态，状态是属性和行为考虑时间维度后的产物，如天气\n\n但bidaf的Match层是类似于相似度计算，加上疑问代词后反而降低了相似程度导致表现变差。同时，为了补充疑问代词，我们将问题拆分为有无疑问代词两类，因此训练集的规模减小，而补充代词带来的价值填补不了本身数据小还做了切分的损失，由此我们放弃了这个想法。\n</code></pre><h4 id=\"模型改造：\"><a href=\"#模型改造：\" class=\"headerlink\" title=\"模型改造：\"></a>模型改造：</h4><h5 id=\"架构上：end-to-end-到-非-end-to-end\"><a href=\"#架构上：end-to-end-到-非-end-to-end\" class=\"headerlink\" title=\"架构上：end-to-end 到 非 end-to-end\"></a>架构上：end-to-end 到 非 end-to-end</h5><p>​    一个问题，文档集中很可能会有多个答案，而它们彼此之间相互干扰，并且降低了神经网络的学习效果，而针对这种情况，我们并没有选择在一个问题对应的整个文档集的多篇文章中只抽取一个答案，而是每篇文章抽取一个答案，构成备选答案集，之后再从备选答案集中挑选最佳的作为我们的答案。在和其他队伍交流的过程中，我们注意到他们截取的答案常常出现不完整的情况，而我们采用这种架构抽取的答案则几乎不会出现。</p>\n<p>​    对于单篇文章内答案的抽取：在一篇文章内同样可能会有多个地方可能作为答案，在使用boundary模型预测始末位置时，一旦这篇文章模型认为的最优答案和文章内其它答案的区分度不高（概率差没达到我们设定的阙值），那么我们就放弃在这篇文章中抽取答案。</p>\n<p>​    由此，模型不再是end-to-end了，它的主要功能就是抽取备选答案集，而我们通过对比我们选出的答案和标准答案，据此更新参数，训练模型从单篇文章抽取答案的能力。</p>\n<h5 id=\"实现上\"><a href=\"#实现上\" class=\"headerlink\" title=\"实现上\"></a>实现上</h5><p>在实现方面，我们做了两点变化：</p>\n<h6 id=\"问题编码作为上文流入文章编码\"><a href=\"#问题编码作为上文流入文章编码\" class=\"headerlink\" title=\"问题编码作为上文流入文章编码\"></a>问题编码作为上文流入文章编码</h6><p>第一点变化就是在编码层将问题编码作为文章上文流入文章编码。在百度知道中，大多数时候人们的回答不会正式到将问题也加入到答案里，但是问题的一部分也应该包含在答案里，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q：中国第一个乒乓球大满贯是谁？</span><br><span class=\"line\">A1：刘国梁。</span><br><span class=\"line\">A2：中国第一个乒乓球大满贯是刘国梁。</span><br><span class=\"line\">A3：中国第一个乒乓球大满贯。</span><br></pre></td></tr></table></figure>\n<p>​    人们通常只会回答A1这样的答案，虽然最正式的答案是A2。而把问题作为上文流入文章编码，则相当于自动将A1变成A2，很大程度上强化了文章对问题的匹配程度。</p>\n<h6 id=\"加入self-matching层\"><a href=\"#加入self-matching层\" class=\"headerlink\" title=\"加入self-matching层\"></a>加入self-matching层</h6><p>如同r-net和上文中提到的，理论上聚合层已经聚合了足够的上下文信息，但实际上它只能获取有限的上下文，由此我们加入了r-net中的核心：self-matching层，用来在文章和问题匹配之后，强化文章内部的信息交互。而这里，也是我首次参与到代码实现的部分。</p>\n<p>虽然笔者之前接触过tensorflow，但都是照着文档，照着书打代码，到了实际实现论文的算法时可就懵了，但是想来这么优秀的模型应当会有人去把它实现了吧，为了达到更好的效果同时也尽量减少重复造轮子，于是笔者在github上找到了几个基于tensorflow实现的r-net，在照着论文把他们的代码啃完之后，花了些功夫把其中的self-matching层结合进了我们的模型了，然而却始终在reshape的调用上出错，查找了各种解决方案后无果。</p>\n<p>考虑到维度的升降问题是无法避免的，开源的使用reshape无法正常运行，而baseline能够正常运行，它们的实现区别在哪里呢？想到这点，笔者又返回去看baseline的代码并将它和开源代码对比起来看，由此发现了区别：开源代码中使用tf.variable显式定义了各种需要训练的参数，而在baseline中使用了layer的fully_connected让tensorflow自行根据输入的size设置参数的shape，而后自行完成乘、加的运算，就无需调用reshape函数手动调整维度，更不会遇到维度无法整除的问题了。</p>\n<p>随后，笔者照着baseline实现BIDAF那样，根据r-net中self-matching的公式将self-matching实现了出来。不得不承认，哪怕把r-net的论文看了好几遍，但在实现的时候才发现，自己还有好多的细节并没有掌握，文章中可能只是在公式下面短短的一句话，却是指向上一阶段一系列公式的”指针”，而忽略了这句话就会使得变量对应不上。</p>\n<p>虽然这一系列过程很累也很恼人，但看到代码最终成功运行并在服务器上跑起来，成就感还是相当足的。遗憾的是，这一层的加入对于模型的表现没有太大的提升。</p>\n<h4 id=\"答案抽取1：-EM算法\"><a href=\"#答案抽取1：-EM算法\" class=\"headerlink\" title=\"答案抽取1： EM算法\"></a>答案抽取1： EM算法</h4><p>起初，我们使用EM算法，通过让备选答案集彼此交互信息，选出共性最大的答案作为最佳答案，但发现效果并不好，并且没有考虑到很多特征，由此仅作为一个额外的特征导入xgboost中。</p>\n<p>EM算法作为无监督算法，目的在于在没有标签的情况下，让备选答案集彼此间投票。基本思想是：首先将设置所有答案的可信度都一样，出现在越多答案中的词可信度越高（通过引入信息熵降低常用词的价值），而这些词会反过来增加某些答案的可信度，答案的可信度调整之后，在可信度高的答案的词语可信度增加，由此双方不断加强，最终选出最佳答案。</p>\n<p>这个算法在备选答案越多的情况下表现会越好，此次我们的备选答案最多有五个，虽然取得了不错的效果但还需要更好的表现。此外，最佳答案通过这个算法选取仅考虑了答案之间的交互，省略了很多特征，如答案和问题的匹配程度、答案长度、和问题的编辑距离等等。</p>\n<p>考虑到这是在五个答案中选择一个最佳答案，把这视作一个五分类问题，起初笔者对视作五分类问题有疑惑，因为笔者认为答案和标号之间没有联系，可以随意更换。但实际上，数据的来源是百度搜索和百度知道，搜索引擎通常会将最匹配问题的结果放在第一位，同样的，备选答案之间也有顺序，直接将第一个答案作为选出答案的分数比起随机选择或者把最后一个作为答案的分数高得多。</p>\n<p>在对主流模型进行实验挑选过后，我们最终选定了在kaggle中大放异彩，速度和准确率均高的xgboost。</p>\n<h4 id=\"答案抽取2：Xgboost\"><a href=\"#答案抽取2：Xgboost\" class=\"headerlink\" title=\"答案抽取2：Xgboost\"></a>答案抽取2：Xgboost</h4><p>要使用xgboost训练首先得构造训练数据</p>\n<p>答案的标签生成方面，我们通过对比五个答案和标准答案的rough-l值高低，选出最高分答案的索引作为标签。</p>\n<p>特征选择方面，除了先前提到的em分数、答案长度、问题长度、答案和问题的编辑距离外，我们还将神经网络中经过各个层之后答案编码向量同样作为特征。</p>\n<p>有了特征有了训练数据，接下来就是调参了。而这对于模型最终的分数也有相当大的影响。</p>\n<p>以下就是我们的成品模型了：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Model.jpg\" alt=\"最终模型\"></p>\n<h3 id=\"Step3-调参\"><a href=\"#Step3-调参\" class=\"headerlink\" title=\"Step3 调参\"></a>Step3 调参</h3><p>改造好模型之后，参数调整这里同样大有可为，而因为服务器性能有限，训练前面的神经网络一次就需要四天的时间，因此我们将重心放在了xgboost的参数调整上。</p>\n<p>此时到了比赛结束前两天，我也将几乎所有的时间集中到了这里。先前在实现了self-matching之后，笔者花了一段时间了解了决策树、随机森林，从基本思想到公式推导，而后再了解xgboost这个相当优秀的实现，着实拓宽了眼界。</p>\n<p>在翻阅了各种xgboost调参的教程后，对参数调整的顺序和大致范围有了基本的了解，为了不陷入手动调参的”悲惨境地”，考虑到我们既然是学计算机、学软件的，那大部分事情应当自动化让计算机完成，于是搜索并发现了<strong>gridCV</strong>这一神函数，通过自动排列组合我们选定的参数，调用xgboost并返回分数和参数组合排名，我们只需要大致选定参数范围，而后交给它去排列组合并返回结果，不过限于服务器性能，我们还是需要谨慎考虑选用的训练集规模、各种参数的间隔、排列组合的个数等等因素，着实耗费了不少精力，不过也显著将得分提了2-3个点。</p>\n<h3 id=\"未来改进点与赛后感想\"><a href=\"#未来改进点与赛后感想\" class=\"headerlink\" title=\"未来改进点与赛后感想\"></a>未来改进点与赛后感想</h3><h4 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h4><pre><code>1. 用预先训练好的词向量代替随机初始化词向量进行训练\n2. 不用xgboost抽取答案，改用更适合该模型的神经网络：xgboost使用的是答案抽取过程的伴生向量，还是没有办法很好的代表问题和答案之间的特征，而采用神经网络重新对候选答案集进行编码、匹配、融合、解码会提高表现。\n3. 单篇文章抽取答案前先通过self-match交互其他文章信息（需要试试使用词级、句子级、段落级还是文章级别的向量进行交互）\n4. 加强数据预处理，清洗噪音消息和html标签\n5. 有无疑问代词的优化\n6. EM算法嵌入同义词典：当前的EM算法使用的是词语是否相等的完全匹配，而加了同义词典之后，不同句子内的同义词彼此之间也能提升可信度。\n7. 使用dropout：让模型按照一定概率把神经网络单元暂时从网络中丢弃，不仅提高训练速度而且提高泛化能力\n8. 字符级别词嵌入：为模型提供更多特征\n9. 随机丢弃词：来自中大苏剑林苏神的建议，直接随机去掉文章或问题的词或者将词向量置为0。不使用dropout，因为dropout使用了缩放会影响到词向量。\n10. pointer-net开始和终止概率的调整：使用加减乘除、平方等等对概率的计算进行调整，同样是来自苏神的建议，不过限于时间、机器性能和经验原因，这次比赛没来得及使用上。\n</code></pre><h4 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h4><p>首次参加机器学习方面的比赛，虽然不对名次什么的抱有太大期望，不过在报名的八百多支队伍，一百多份提交中排名14还是着实令人开心的（虽然大部分都是师兄的功劳）。</p>\n<p>这次比赛给我带来最大的收获就是眼界的拓宽，而且让我对自然语言处理中阅读理解这个领域有了基本的了解，对于之后的学习也是相当有帮助的，之前再怎么学，也不过是照着书、照着教程打，没有实际应用，因此也没有真正掌握这些知识的实感。在参赛的过程中，从了解目标、了解模型、了解数据再到实地修改代码、改造模型、调整参数，当这么一个完整的流程走下来之后，感觉成长了不少呢。</p>\n<p>非常感谢极天信息给我这样一个机会，以小白的状态参加到比赛中，也感谢容福炬师兄在比赛过程中对我的指导。</p>"},{"layout":"post","title":"刷题选集（一）","date":"2017-08-17T16:00:00.000Z","comments":1,"_content":"\n## 目录\n\n第一个选集，选的比较基础比较水，主要是思维+细节\n\n\n### 贪心\n\nSDUT 2072 删数问题\nSDUT 2072 活动选择\n\n### 栈\n\nSDUT 3334 出栈序列判定\nSDUT 2132 后缀表达式转换\n\n### 动态规划\n\n最大子列和\n最大子列和及区间\n\n<!-- more -->\n\n## 贪心\n\n### 删数问题\n\n[SDUT 2072 删数问题](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072)\n\n题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小\n\n思维+细节题\n\n思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符\n\n细节：\n1.可能有前导0， 比如 9023 删掉1个数字后 -> 023 -> 23\n解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true\n2.可能剩下全是0，比如 9002 删掉2个数字后 -> 00 -> 0\n解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行\n3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n// 解题代码丑了些，见谅\nint main()\n{\n\tchar s[110];\n\tint n;\n\twhile(cin>>s>>n)\n\t{\n\t\tint l=strlen(s);\n\t\ts[l]=0;\n\t\tif(n>=l)\n\t\t{\t\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint c;\n\t\t\tfor(int j=0; j<l; j++)\n\t\t\t{\t\n\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);\n\t\t\t\tif(s[j]>c)\n\t\t\t\t{\t\n\t\t\t\t\ts[j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint firstzero=0;\n\t\tfor(int i=0; i<l; i++)\n\t\t{\t\n\t\t\tif(s[i]=='0'&&firstzero==0)\n\t\t\t\ts[i]=0;\n\t\t\tif(s[i])\n\t\t\t{\t\n\t\t\t\tfirstzero=1;\n\t\t\t\tprintf(\"%c\",s[i]);\n\t\t\t}\n\t\t}\n\t\tif(firstzero)\n\t\t\tprintf(\"\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n}\n```\n\n### 活动选择\n\n[SDUT 2072 活动选择](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html)\n\n题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。\n\n贪心题\n\n思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动\n若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。\n若后一个活动的开始时间早于当前活动，则无视，扫下一个。\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct aaa\n{\n\tint l,r;\n}a[110];\n\nbool com(aaa a1, aaa a2)\n{\n\tif(a1.r==a2.r)\n\t\treturn a1.l>a2.l;\n\treturn a1.r<a2.r;\n}\n\nint main()\n{\n\tint n;\nwhile(~scanf(\"%d\",&n))\n{\n\tmemset(a,0,sizeof(a));\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d%d\",&a[i].l,&a[i].r);\n\tsort(a,a+n,com);\n\tint nowend=a[0].r,ans=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tif(a[i].l<nowend)\n\t\t\tcontinue;\n\t\tnowend=a[i].r;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\treturn 0;\n}\n```\n\n## 栈\n\n### 栈混洗\n\n[SDUT 3334 出栈序列判定](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html)\n\n题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。\n\n栈混洗 ( 贪心 )\n\n思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint a[10010];\nint stack[10010];\nint tem[10010];\nint m=0;\nint n;\nint t;\n\nbool check ()\n{\n\tint j=0,i=0;\n\twhile(i<n&&m<n)\n\t{\n\t\tstack[m++]=a[j++];\n\t\twhile( m-1>=0 && stack[m-1]==tem[i])\n\t\t{\n\t\t\tm--;\n\t\t\ti++;\n\t\t}\n\t}\n\tif(m>0)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tm=0;\n\t\tfor(int i=0; i<n; i++)\n\t\t\tscanf(\"%d\",&tem[i]);\n\t\tif(check()==true)\n\t\t\tprintf(\"yes\\n\");\n\t\telse\n\t\t\tprintf(\"no\\n\");\n\t}\n\t\treturn 0;\n\t}\n```\n\n### 后缀表达式转换\n\n[SDUT 2132 一般算术表达式转换成后缀式](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html)\n\n题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。\n\n和[数据结构笔记（二）：栈和队列](https://zedom1.github.io/2017/08/14/stack/) 中的逆波兰表达式转换方法类似但要简单的多。\n\n1.运算符基于二元 ( “ +-*/ ()# “ )\n2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换\n3.表达式以#号结尾\n\n鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。\n\n思想是一样的，用两个栈分别保存答案和运算符。\n遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。\n\n优先级设置：\n左括号最大，但不碰到右括号不出栈\n右括号和#最小并且不入栈\n同级运算符如+和-比较时栈顶的大\n\n细节：\n左右括号和#出运算符栈后不进入答案栈\n两个#号看作一对括号，在开始人为加入一个#号和最后的配对\n\n最后答案栈保存的是要输出答案的**逆序**，但若用数组模拟的话就可以直接从头输出到尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tchar s[1000];  // 输入表达式\n\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶\n\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶\n\tint l=0;   // 记录输入表达式的长度\n\top[m++]='#';   // 栈底加入一个#用来和最后的#配对\n\twhile(scanf(\"%c\",&s[l])&&s[l++]!='#');\n\tfor(int i=0; i<l; i++)\n\t{\n\t\tif(s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!='/'&&s[i]!='('&&s[i]!=')'&&s[i]!='#')    // 该字符为变量\n\t\t{\t\n\t\t\tans[ansm++]=s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(s[i])\n\t\t{\n\t\tcase '+': \n\t\tcase '-':\n\t\t\t{\n\t\t\t\tif(op[m-1]=='('||op[m-1]=='#')\n\t\t\t\t{\t\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tcase '*': case '/': case '(':\n\t\t\t{\n\t\t\t\top[m++]=s[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase ')':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='(')  // 把左右括号之间的都依次入答案栈\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;  // 左括号出栈\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '#':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='#')\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<ansm; i++)\n\t\tprintf(\"%c\",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n## 动态规划\n\n### 最大子列和\n\n题意：给定n个数的序列，求其中和最大的连续子列\n\n网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法\n\n思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now,maxn;\n\tint tem;\n\tscanf(\"%d\",&tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况\n\tnow=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tnow=max(0,now);\n\t\tscanf(\"%d\",&tem);\n\t\tnow+=tem;\n\t\tmaxn=max(maxn,now);\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n```\n\n### 最大子列和及区间\n\n我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？\n\n在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last\n\n思路：\n\n```\n每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。\n\n一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last\n\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now=0,maxn=0;\n\tint tem;\n\tint first,last,ansfirst;\n\tscanf(\"%d\",&tem);\n\tfirst=last=ansfirst=now=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&tem);\n\t\tif(now<0)\n\t\t{ \n\t\t\tnow=0;\n\t\t\tfirst=tem;\n\t\t}\n\t\tnow+=tem;\n\t\tif(now>maxn)\n\t\t{\n\t\t\tlast=tem;\n\t\t\tmaxn=now;\n\t\t\tansfirst=first;\n\t\t}\n\t}\n\tprintf(\"%d %d %d\\n\",maxn,ansfirst,last);\n\treturn 0;\n}\n```","source":"_posts/ProblemSet1.md","raw":"---\nlayout: post\ntitle: \"刷题选集（一）\"\ndate: 2017-08-18\ncomments: true\ntags: \n\t- c++\n\t- 刷题\n---\n\n## 目录\n\n第一个选集，选的比较基础比较水，主要是思维+细节\n\n\n### 贪心\n\nSDUT 2072 删数问题\nSDUT 2072 活动选择\n\n### 栈\n\nSDUT 3334 出栈序列判定\nSDUT 2132 后缀表达式转换\n\n### 动态规划\n\n最大子列和\n最大子列和及区间\n\n<!-- more -->\n\n## 贪心\n\n### 删数问题\n\n[SDUT 2072 删数问题](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072)\n\n题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小\n\n思维+细节题\n\n思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符\n\n细节：\n1.可能有前导0， 比如 9023 删掉1个数字后 -> 023 -> 23\n解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true\n2.可能剩下全是0，比如 9002 删掉2个数字后 -> 00 -> 0\n解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行\n3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n// 解题代码丑了些，见谅\nint main()\n{\n\tchar s[110];\n\tint n;\n\twhile(cin>>s>>n)\n\t{\n\t\tint l=strlen(s);\n\t\ts[l]=0;\n\t\tif(n>=l)\n\t\t{\t\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint c;\n\t\t\tfor(int j=0; j<l; j++)\n\t\t\t{\t\n\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);\n\t\t\t\tif(s[j]>c)\n\t\t\t\t{\t\n\t\t\t\t\ts[j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint firstzero=0;\n\t\tfor(int i=0; i<l; i++)\n\t\t{\t\n\t\t\tif(s[i]=='0'&&firstzero==0)\n\t\t\t\ts[i]=0;\n\t\t\tif(s[i])\n\t\t\t{\t\n\t\t\t\tfirstzero=1;\n\t\t\t\tprintf(\"%c\",s[i]);\n\t\t\t}\n\t\t}\n\t\tif(firstzero)\n\t\t\tprintf(\"\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n}\n```\n\n### 活动选择\n\n[SDUT 2072 活动选择](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html)\n\n题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。\n\n贪心题\n\n思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动\n若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。\n若后一个活动的开始时间早于当前活动，则无视，扫下一个。\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct aaa\n{\n\tint l,r;\n}a[110];\n\nbool com(aaa a1, aaa a2)\n{\n\tif(a1.r==a2.r)\n\t\treturn a1.l>a2.l;\n\treturn a1.r<a2.r;\n}\n\nint main()\n{\n\tint n;\nwhile(~scanf(\"%d\",&n))\n{\n\tmemset(a,0,sizeof(a));\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d%d\",&a[i].l,&a[i].r);\n\tsort(a,a+n,com);\n\tint nowend=a[0].r,ans=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tif(a[i].l<nowend)\n\t\t\tcontinue;\n\t\tnowend=a[i].r;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\treturn 0;\n}\n```\n\n## 栈\n\n### 栈混洗\n\n[SDUT 3334 出栈序列判定](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html)\n\n题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。\n\n栈混洗 ( 贪心 )\n\n思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint a[10010];\nint stack[10010];\nint tem[10010];\nint m=0;\nint n;\nint t;\n\nbool check ()\n{\n\tint j=0,i=0;\n\twhile(i<n&&m<n)\n\t{\n\t\tstack[m++]=a[j++];\n\t\twhile( m-1>=0 && stack[m-1]==tem[i])\n\t\t{\n\t\t\tm--;\n\t\t\ti++;\n\t\t}\n\t}\n\tif(m>0)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tm=0;\n\t\tfor(int i=0; i<n; i++)\n\t\t\tscanf(\"%d\",&tem[i]);\n\t\tif(check()==true)\n\t\t\tprintf(\"yes\\n\");\n\t\telse\n\t\t\tprintf(\"no\\n\");\n\t}\n\t\treturn 0;\n\t}\n```\n\n### 后缀表达式转换\n\n[SDUT 2132 一般算术表达式转换成后缀式](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html)\n\n题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。\n\n和[数据结构笔记（二）：栈和队列](https://zedom1.github.io/2017/08/14/stack/) 中的逆波兰表达式转换方法类似但要简单的多。\n\n1.运算符基于二元 ( “ +-*/ ()# “ )\n2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换\n3.表达式以#号结尾\n\n鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。\n\n思想是一样的，用两个栈分别保存答案和运算符。\n遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。\n\n优先级设置：\n左括号最大，但不碰到右括号不出栈\n右括号和#最小并且不入栈\n同级运算符如+和-比较时栈顶的大\n\n细节：\n左右括号和#出运算符栈后不进入答案栈\n两个#号看作一对括号，在开始人为加入一个#号和最后的配对\n\n最后答案栈保存的是要输出答案的**逆序**，但若用数组模拟的话就可以直接从头输出到尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tchar s[1000];  // 输入表达式\n\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶\n\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶\n\tint l=0;   // 记录输入表达式的长度\n\top[m++]='#';   // 栈底加入一个#用来和最后的#配对\n\twhile(scanf(\"%c\",&s[l])&&s[l++]!='#');\n\tfor(int i=0; i<l; i++)\n\t{\n\t\tif(s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!='/'&&s[i]!='('&&s[i]!=')'&&s[i]!='#')    // 该字符为变量\n\t\t{\t\n\t\t\tans[ansm++]=s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(s[i])\n\t\t{\n\t\tcase '+': \n\t\tcase '-':\n\t\t\t{\n\t\t\t\tif(op[m-1]=='('||op[m-1]=='#')\n\t\t\t\t{\t\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t\top[m++]=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tcase '*': case '/': case '(':\n\t\t\t{\n\t\t\t\top[m++]=s[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase ')':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='(')  // 把左右括号之间的都依次入答案栈\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;  // 左括号出栈\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '#':\n\t\t\t{\n\t\t\t\twhile(op[m-1]!='#')\n\t\t\t\t{\n\t\t\t\t\tans[ansm++]=op[--m];\n\t\t\t\t}\n\t\t\t\t--m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<ansm; i++)\n\t\tprintf(\"%c\",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n## 动态规划\n\n### 最大子列和\n\n题意：给定n个数的序列，求其中和最大的连续子列\n\n网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法\n\n思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾\n\n```\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now,maxn;\n\tint tem;\n\tscanf(\"%d\",&tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况\n\tnow=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tnow=max(0,now);\n\t\tscanf(\"%d\",&tem);\n\t\tnow+=tem;\n\t\tmaxn=max(maxn,now);\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n```\n\n### 最大子列和及区间\n\n我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？\n\n在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last\n\n思路：\n\n```\n每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。\n\n一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last\n\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n#include <cstdio>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint now=0,maxn=0;\n\tint tem;\n\tint first,last,ansfirst;\n\tscanf(\"%d\",&tem);\n\tfirst=last=ansfirst=now=maxn=tem;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&tem);\n\t\tif(now<0)\n\t\t{ \n\t\t\tnow=0;\n\t\t\tfirst=tem;\n\t\t}\n\t\tnow+=tem;\n\t\tif(now>maxn)\n\t\t{\n\t\t\tlast=tem;\n\t\t\tmaxn=now;\n\t\t\tansfirst=first;\n\t\t}\n\t}\n\tprintf(\"%d %d %d\\n\",maxn,ansfirst,last);\n\treturn 0;\n}\n```","slug":"ProblemSet1","published":1,"updated":"2018-05-25T12:41:12.572Z","photos":[],"link":"","_id":"cjhvssae9000yjvfcgggejsub","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>第一个选集，选的比较基础比较水，主要是思维+细节</p>\n<h3 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h3><p>SDUT 2072 删数问题<br>SDUT 2072 活动选择</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>SDUT 3334 出栈序列判定<br>SDUT 2132 后缀表达式转换</p>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>最大子列和<br>最大子列和及区间</p>\n<a id=\"more\"></a>\n<h2 id=\"贪心-1\"><a href=\"#贪心-1\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><h3 id=\"删数问题\"><a href=\"#删数问题\" class=\"headerlink\" title=\"删数问题\"></a>删数问题</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072\" target=\"_blank\" rel=\"noopener\">SDUT 2072 删数问题</a></p>\n<p>题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小</p>\n<p>思维+细节题</p>\n<p>思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符</p>\n<p>细节：<br>1.可能有前导0， 比如 9023 删掉1个数字后 -&gt; 023 -&gt; 23<br>解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true<br>2.可能剩下全是0，比如 9002 删掉2个数字后 -&gt; 00 -&gt; 0<br>解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行<br>3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">// 解题代码丑了些，见谅</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[110];</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\twhile(cin&gt;&gt;s&gt;&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint l=strlen(s);</span><br><span class=\"line\">\t\ts[l]=0;</span><br><span class=\"line\">\t\tif(n&gt;=l)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tint c;</span><br><span class=\"line\">\t\t\tfor(int j=0; j&lt;l; j++)</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);</span><br><span class=\"line\">\t\t\t\tif(s[j]&gt;c)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\ts[j]=0;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint firstzero=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif(s[i]==&apos;0&apos;&amp;&amp;firstzero==0)</span><br><span class=\"line\">\t\t\t\ts[i]=0;</span><br><span class=\"line\">\t\t\tif(s[i])</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfirstzero=1;</span><br><span class=\"line\">\t\t\t\tprintf(&quot;%c&quot;,s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(firstzero)</span><br><span class=\"line\">\t\t\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"活动选择\"><a href=\"#活动选择\" class=\"headerlink\" title=\"活动选择\"></a>活动选择</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html\" target=\"_blank\" rel=\"noopener\">SDUT 2072 活动选择</a></p>\n<p>题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。</p>\n<p>贪心题</p>\n<p>思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动<br>若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。<br>若后一个活动的开始时间早于当前活动，则无视，扫下一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">struct aaa</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint l,r;</span><br><span class=\"line\">&#125;a[110];</span><br><span class=\"line\"></span><br><span class=\"line\">bool com(aaa a1, aaa a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(a1.r==a2.r)</span><br><span class=\"line\">\t\treturn a1.l&gt;a2.l;</span><br><span class=\"line\">\treturn a1.r&lt;a2.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(a,0,sizeof(a));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class=\"line\">\tsort(a,a+n,com);</span><br><span class=\"line\">\tint nowend=a[0].r,ans=1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(a[i].l&lt;nowend)</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tnowend=a[i].r;</span><br><span class=\"line\">\t\tans++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"栈混洗\"><a href=\"#栈混洗\" class=\"headerlink\" title=\"栈混洗\"></a>栈混洗</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html\" target=\"_blank\" rel=\"noopener\">SDUT 3334 出栈序列判定</a></p>\n<p>题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。</p>\n<p>栈混洗 ( 贪心 )</p>\n<p>思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int a[10010];</span><br><span class=\"line\">int stack[10010];</span><br><span class=\"line\">int tem[10010];</span><br><span class=\"line\">int m=0;</span><br><span class=\"line\">int n;</span><br><span class=\"line\">int t;</span><br><span class=\"line\"></span><br><span class=\"line\">bool check ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j=0,i=0;</span><br><span class=\"line\">\twhile(i&lt;n&amp;&amp;m&lt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack[m++]=a[j++];</span><br><span class=\"line\">\t\twhile( m-1&gt;=0 &amp;&amp; stack[m-1]==tem[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tm--;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(m&gt;0)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;t);</span><br><span class=\"line\">\twhile(t--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tm=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;tem[i]);</span><br><span class=\"line\">\t\tif(check()==true)</span><br><span class=\"line\">\t\t\tprintf(&quot;yes\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;no\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀表达式转换\"><a href=\"#后缀表达式转换\" class=\"headerlink\" title=\"后缀表达式转换\"></a>后缀表达式转换</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html\" target=\"_blank\" rel=\"noopener\">SDUT 2132 一般算术表达式转换成后缀式</a></p>\n<p>题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。</p>\n<p>和<a href=\"https://zedom1.github.io/2017/08/14/stack/\">数据结构笔记（二）：栈和队列</a> 中的逆波兰表达式转换方法类似但要简单的多。</p>\n<p>1.运算符基于二元 ( “ +-*/ ()# “ )<br>2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换<br>3.表达式以#号结尾</p>\n<p>鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。</p>\n<p>思想是一样的，用两个栈分别保存答案和运算符。<br>遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。</p>\n<p>优先级设置：<br>左括号最大，但不碰到右括号不出栈<br>右括号和#最小并且不入栈<br>同级运算符如+和-比较时栈顶的大</p>\n<p>细节：<br>左右括号和#出运算符栈后不进入答案栈<br>两个#号看作一对括号，在开始人为加入一个#号和最后的配对</p>\n<p>最后答案栈保存的是要输出答案的<strong>逆序</strong>，但若用数组模拟的话就可以直接从头输出到尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[1000];  // 输入表达式</span><br><span class=\"line\">\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶</span><br><span class=\"line\">\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶</span><br><span class=\"line\">\tint l=0;   // 记录输入表达式的长度</span><br><span class=\"line\">\top[m++]=&apos;#&apos;;   // 栈底加入一个#用来和最后的#配对</span><br><span class=\"line\">\twhile(scanf(&quot;%c&quot;,&amp;s[l])&amp;&amp;s[l++]!=&apos;#&apos;);</span><br><span class=\"line\">\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s[i]!=&apos;+&apos;&amp;&amp;s[i]!=&apos;-&apos;&amp;&amp;s[i]!=&apos;*&apos;&amp;&amp;s[i]!=&apos;/&apos;&amp;&amp;s[i]!=&apos;(&apos;&amp;&amp;s[i]!=&apos;)&apos;&amp;&amp;s[i]!=&apos;#&apos;)    // 该字符为变量</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tans[ansm++]=s[i];</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tswitch(s[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\tcase &apos;+&apos;: </span><br><span class=\"line\">\t\tcase &apos;-&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(op[m-1]==&apos;(&apos;||op[m-1]==&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;*&apos;: case &apos;/&apos;: case &apos;(&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;)&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;(&apos;)  // 把左右括号之间的都依次入答案栈</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;  // 左括号出栈</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;#&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i=0; i&lt;ansm; i++)</span><br><span class=\"line\">\t\tprintf(&quot;%c&quot;,ans[i]);</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"最大子列和\"><a href=\"#最大子列和\" class=\"headerlink\" title=\"最大子列和\"></a>最大子列和</h3><p>题意：给定n个数的序列，求其中和最大的连续子列</p>\n<p>网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法</p>\n<p>思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now,maxn;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况</span><br><span class=\"line\">\tnow=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnow=max(0,now);</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tmaxn=max(maxn,now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,maxn);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大子列和及区间\"><a href=\"#最大子列和及区间\" class=\"headerlink\" title=\"最大子列和及区间\"></a>最大子列和及区间</h3><p>我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？</p>\n<p>在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。</span><br><span class=\"line\"></span><br><span class=\"line\">一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now=0,maxn=0;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tint first,last,ansfirst;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\tfirst=last=ansfirst=now=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tif(now&lt;0)</span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tnow=0;</span><br><span class=\"line\">\t\t\tfirst=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tif(now&gt;maxn)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlast=tem;</span><br><span class=\"line\">\t\t\tmaxn=now;</span><br><span class=\"line\">\t\t\tansfirst=first;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d %d %d\\n&quot;,maxn,ansfirst,last);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>第一个选集，选的比较基础比较水，主要是思维+细节</p>\n<h3 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h3><p>SDUT 2072 删数问题<br>SDUT 2072 活动选择</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>SDUT 3334 出栈序列判定<br>SDUT 2132 后缀表达式转换</p>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>最大子列和<br>最大子列和及区间</p>","more":"<h2 id=\"贪心-1\"><a href=\"#贪心-1\" class=\"headerlink\" title=\"贪心\"></a>贪心</h2><h3 id=\"删数问题\"><a href=\"#删数问题\" class=\"headerlink\" title=\"删数问题\"></a>删数问题</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2187/pid/2072\" target=\"_blank\" rel=\"noopener\">SDUT 2072 删数问题</a></p>\n<p>题意：给一串100位以内的数字s和一个数字n，在s中删除n个数使得剩下的数字按原来次序自左向右排最小</p>\n<p>思维+细节题</p>\n<p>思路：自左向右扫n轮，每轮灭掉一个比它直接后继大的字符</p>\n<p>细节：<br>1.可能有前导0， 比如 9023 删掉1个数字后 -&gt; 023 -&gt; 23<br>解决：用一个bool变量firstZero判断是否有前导0,遇到非0则归true<br>2.可能剩下全是0，比如 9002 删掉2个数字后 -&gt; 00 -&gt; 0<br>解决：用细节1解决中的那个变量，若输出完整个字符串后firstZero还是false，则额外输出0加换行<br>3.如何灭掉，可以每次都让后面的字符都向前移一个，也可以直接让当前字符归’0’-‘9’之外的字符，但是每次判断时都需要找在0-9之内的字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">// 解题代码丑了些，见谅</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[110];</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\twhile(cin&gt;&gt;s&gt;&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint l=strlen(s);</span><br><span class=\"line\">\t\ts[l]=0;</span><br><span class=\"line\">\t\tif(n&gt;=l)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tint c;</span><br><span class=\"line\">\t\t\tfor(int j=0; j&lt;l; j++)</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfor(int k=j+1; (c=s[k])==0 ; k++);</span><br><span class=\"line\">\t\t\t\tif(s[j]&gt;c)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\ts[j]=0;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint firstzero=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif(s[i]==&apos;0&apos;&amp;&amp;firstzero==0)</span><br><span class=\"line\">\t\t\t\ts[i]=0;</span><br><span class=\"line\">\t\t\tif(s[i])</span><br><span class=\"line\">\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\tfirstzero=1;</span><br><span class=\"line\">\t\t\t\tprintf(&quot;%c&quot;,s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(firstzero)</span><br><span class=\"line\">\t\t\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"活动选择\"><a href=\"#活动选择\" class=\"headerlink\" title=\"活动选择\"></a>活动选择</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2073.html\" target=\"_blank\" rel=\"noopener\">SDUT 2072 活动选择</a></p>\n<p>题意：每天都有n个活动申请举办，已知每个活动的开始时间b，结束时间e，求出每天最多能举办多少活动。</p>\n<p>贪心题</p>\n<p>思路：贪心，所有活动按结束时间e自小到大排序，结束时间相同的开始时间越大越好，然后从第一个活动开始扫到最后一个活动<br>若后一个活动的开始时间晚于现在活动的结束时间，则计数器自增，允许后一个活动举办。<br>若后一个活动的开始时间早于当前活动，则无视，扫下一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">struct aaa</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint l,r;</span><br><span class=\"line\">&#125;a[110];</span><br><span class=\"line\"></span><br><span class=\"line\">bool com(aaa a1, aaa a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(a1.r==a2.r)</span><br><span class=\"line\">\t\treturn a1.l&gt;a2.l;</span><br><span class=\"line\">\treturn a1.r&lt;a2.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(a,0,sizeof(a));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class=\"line\">\tsort(a,a+n,com);</span><br><span class=\"line\">\tint nowend=a[0].r,ans=1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(a[i].l&lt;nowend)</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tnowend=a[i].r;</span><br><span class=\"line\">\t\tans++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"栈混洗\"><a href=\"#栈混洗\" class=\"headerlink\" title=\"栈混洗\"></a>栈混洗</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3334.html\" target=\"_blank\" rel=\"noopener\">SDUT 3334 出栈序列判定</a></p>\n<p>题意：给定一个初始序列，序列依次入栈，栈顶在此期间可以任意出栈，问能否构成下列给出序列。</p>\n<p>栈混洗 ( 贪心 )</p>\n<p>思路：用一个中转栈S，将初始序列依次入栈，每次比较栈顶和目标序列头，若相同，则出栈，若不同则继续入栈，最后若栈为空则匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int a[10010];</span><br><span class=\"line\">int stack[10010];</span><br><span class=\"line\">int tem[10010];</span><br><span class=\"line\">int m=0;</span><br><span class=\"line\">int n;</span><br><span class=\"line\">int t;</span><br><span class=\"line\"></span><br><span class=\"line\">bool check ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j=0,i=0;</span><br><span class=\"line\">\twhile(i&lt;n&amp;&amp;m&lt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstack[m++]=a[j++];</span><br><span class=\"line\">\t\twhile( m-1&gt;=0 &amp;&amp; stack[m-1]==tem[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tm--;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(m&gt;0)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;t);</span><br><span class=\"line\">\twhile(t--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tm=0;</span><br><span class=\"line\">\t\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;tem[i]);</span><br><span class=\"line\">\t\tif(check()==true)</span><br><span class=\"line\">\t\t\tprintf(&quot;yes\\n&quot;);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tprintf(&quot;no\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀表达式转换\"><a href=\"#后缀表达式转换\" class=\"headerlink\" title=\"后缀表达式转换\"></a>后缀表达式转换</h3><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2132.html\" target=\"_blank\" rel=\"noopener\">SDUT 2132 一般算术表达式转换成后缀式</a></p>\n<p>题意：给出一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出。</p>\n<p>和<a href=\"https://zedom1.github.io/2017/08/14/stack/\">数据结构笔记（二）：栈和队列</a> 中的逆波兰表达式转换方法类似但要简单的多。</p>\n<p>1.运算符基于二元 ( “ +-*/ ()# “ )<br>2.不涉及数字，只需要记录变量名a、b、c，默认为一个字符，无需做转换<br>3.表达式以#号结尾</p>\n<p>鉴于是在题目中碰到，我们也不好花许多时间来依次实现栈、列出优先级数组，运算符也只有加减乘除、小括号和井号，因此就直接在程序里判断好了。</p>\n<p>思想是一样的，用两个栈分别保存答案和运算符。<br>遇到变量就直接入答案栈，遇到运算符先和运算符栈的栈顶进行优先级比较，若栈顶的大，则栈顶的运算符进入答案栈，直到栈顶优先级小，则将该运算符入栈。</p>\n<p>优先级设置：<br>左括号最大，但不碰到右括号不出栈<br>右括号和#最小并且不入栈<br>同级运算符如+和-比较时栈顶的大</p>\n<p>细节：<br>左右括号和#出运算符栈后不进入答案栈<br>两个#号看作一对括号，在开始人为加入一个#号和最后的配对</p>\n<p>最后答案栈保存的是要输出答案的<strong>逆序</strong>，但若用数组模拟的话就可以直接从头输出到尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar s[1000];  // 输入表达式</span><br><span class=\"line\">\tchar op[1000]; int m=0;   // 运算符栈，用数组模拟，m为栈顶</span><br><span class=\"line\">\tchar ans[1000]; int ansm=0;  // 答案栈，用数组模拟，ansm为栈顶</span><br><span class=\"line\">\tint l=0;   // 记录输入表达式的长度</span><br><span class=\"line\">\top[m++]=&apos;#&apos;;   // 栈底加入一个#用来和最后的#配对</span><br><span class=\"line\">\twhile(scanf(&quot;%c&quot;,&amp;s[l])&amp;&amp;s[l++]!=&apos;#&apos;);</span><br><span class=\"line\">\tfor(int i=0; i&lt;l; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s[i]!=&apos;+&apos;&amp;&amp;s[i]!=&apos;-&apos;&amp;&amp;s[i]!=&apos;*&apos;&amp;&amp;s[i]!=&apos;/&apos;&amp;&amp;s[i]!=&apos;(&apos;&amp;&amp;s[i]!=&apos;)&apos;&amp;&amp;s[i]!=&apos;#&apos;)    // 该字符为变量</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tans[ansm++]=s[i];</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tswitch(s[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\tcase &apos;+&apos;: </span><br><span class=\"line\">\t\tcase &apos;-&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(op[m-1]==&apos;(&apos;||op[m-1]==&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;\t</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse  // 除非为左括号或井号，不然在这道题中其它栈内的运算符优先级都要更大</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;*&apos;: case &apos;/&apos;: case &apos;(&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\top[m++]=s[i];</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;)&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;(&apos;)  // 把左右括号之间的都依次入答案栈</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;  // 左括号出栈</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcase &apos;#&apos;:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\twhile(op[m-1]!=&apos;#&apos;)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tans[ansm++]=op[--m];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t--m;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i=0; i&lt;ansm; i++)</span><br><span class=\"line\">\t\tprintf(&quot;%c&quot;,ans[i]);</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><h3 id=\"最大子列和\"><a href=\"#最大子列和\" class=\"headerlink\" title=\"最大子列和\"></a>最大子列和</h3><p>题意：给定n个数的序列，求其中和最大的连续子列</p>\n<p>网上从O(n2)的暴力到O(nlogn)的分治再到O(n)的动态规划的优化都有，因此不再赘述，直接来O(n)的在线的动态规划方法</p>\n<p>思路：若某个元素或某段元素和为负数，那么它就不可能是最终答案的开头部分，因为它对那个最大的子序列的贡献是负的。（也可能所有数字都是负数，那么某个元素就是最终答案本身） 那么我们从最开头开始扫到最尾，用一个累加器累加沿途的值，一旦累加器超过目前的最大值，那么更新最大值，一旦累加器小于0，那么继续加下去的话，贡献是负数，还不如清空累加器从0开始，直到处理到数组末尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now,maxn;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);  // 先读入第一个数字，并把now和maxn置位tem而非0，防止出现所有数字都是负数的情况</span><br><span class=\"line\">\tnow=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnow=max(0,now);</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tmaxn=max(maxn,now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,maxn);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大子列和及区间\"><a href=\"#最大子列和及区间\" class=\"headerlink\" title=\"最大子列和及区间\"></a>最大子列和及区间</h3><p>我们在最大子列和的基础上做一点修改，现在我们不仅要得到最大的和，还需要那个最大的区间，要怎么改呢？</p>\n<p>在理解了上一题的动态规划解法之后，要求得最大区间，我们只需要增加三个变量，分别记录当前这段可能是最大子列的开头first、和最大的子列的开头ansfirst、和最大的子列的结尾last</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每当now累加器小于0时，说明前面一段将对后面没有贡献，要舍弃，那要以下一个读入的数字作为开头，以此更新first。</span><br><span class=\"line\"></span><br><span class=\"line\">一旦now累加器大于最大和maxn，说明我们找到了一个可能是答案的序列，而first此时正指着这个序列的头，因此需要把它正式保存下来给ansfirst，此时的数字tem也是当前最大序列的结尾，也把它保存下来给last</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;cstdio&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tint now=0,maxn=0;</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\tint first,last,ansfirst;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\tfirst=last=ansfirst=now=maxn=tem;</span><br><span class=\"line\">\tfor(int i=1; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem);</span><br><span class=\"line\">\t\tif(now&lt;0)</span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tnow=0;</span><br><span class=\"line\">\t\t\tfirst=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow+=tem;</span><br><span class=\"line\">\t\tif(now&gt;maxn)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlast=tem;</span><br><span class=\"line\">\t\t\tmaxn=now;</span><br><span class=\"line\">\t\t\tansfirst=first;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;%d %d %d\\n&quot;,maxn,ansfirst,last);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"JAVA笔记（一）：基础","date":"2017-09-10T16:00:00.000Z","comments":1,"_content":"\n\n## 概述\n\nJAVA学习过程中的简要笔记\n\n从已有C++基础的前提下开始学习java\n\n内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等\n\n<!-- more -->\n\n### 各版本和体系架构\n\n- J2EE\n  - JAVA 2(to) Enterprise Edition:\n  - 定位在服务器端的应用\n- J2SE\n  - JAVA 2(to) Standard Edition:\n  - 定位在个人计算机的应用\n- J2EE\n  - JAVA 2(to) Micro Edition:\n  - 定位在消费性电子产品的应用\n\n### 概念\n\n```\n- JDK\n    - Java Development Kit Java开发工具包\n- JRE\n    - Java Runtime Environment java运行环境\n- JVM\n    - Java Virtual Machine java虚拟机\n\n```\n\n### 数据类型\n\n![数据类型](http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG)\n\n### 整型变量\n\n```\n- 表示形式\n    - 十进制\n    - 八进制：以0开头\n    - 十六进制：以0x或0X开头\n\n```\n\n整型默认为int型，long型常量后加”l”或”L”\n\n| 类型    | 占用空间 | 表示范围             |\n| ----- | ---- | ---------------- |\n| byte  | 1字节  | -128~127         |\n| short | 2字节  | -$2^15$~$2^15-1$ |\n| int   | 4字节  | -$2^31$~$2^31-1$ |\n| long  | 8字节  | -$2^63$~$2^63-1$ |\n\n- 超过long的数字使用**BigInteger**类\n\n### 浮点型\n\n| 类型     | 占用空间 | 表示范围                 |\n| ------ | ---- | -------------------- |\n| float  | 4字节  | -3.403E38~3.403E38   |\n| double | 8字节  | -1.798E308~1.798E308 |\n\n- 默认为double\n- 若需要不产生舍入误差的精确计算，需要用**BigDecimal**类\n- double变float：在数字后加”f”或”F”\n\n### 字符型\n\n- char采用Unicode编码表，，占用2个字节\n- 同c++,可以和整数相互转型，可以使用转义字符\n\n### boolean\n\n- 占1位(非字节)\n- java中boolean无法和整数之间转换\n\n### 变量\n\n```\n- 变量使用前需要声明\n\n```\n\n#### final\n\n类似c++的const\n\n```\n- final修饰变量，则该变量无法修改\n- final修饰类，则说明该类不能被继承，不能有子类\n    - 如 Math、String\n- final修饰方法，则该方法不能被子类重写，但是可以被重载\n\n```\n\n**命名规范**：\n\n- 变量、方法名：\n  - 首字母小写+驼峰原则\n- 常量：\n  - 大写字母+下划线\n- 类名：\n  - 首字母大写+驼峰原则\n\n### 运算符\n\n```\n- 算术运算符： +,-,*,/,%,++,--\n    - 不同于c++, java中浮点数可以使用\"%\"运算符！\n    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串\n- 赋值运算符： =\n- 关系运算符： <,>,<=,>=,==,!=, instanceof\n    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）\n        - 返回值：boolean  true代表属于\n        - 使用： boolean ret= a instanceof A;\n- 逻辑运算符： &&,||,!\n    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算\n- 位运算符： &,|,^,~,>>,<<,>>>\n    - >> 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃\n        - 01110>>1 右移一位： 00111\n        - 10010>>1 右移一位： 11001\n    - >>> 表示无符号右移：左边以0补充，移出的部分将抛弃\n        - 01110>>>1 右移一位：00111   (正数时和\">>\"相同)\n        - 10010>>>1 右移一位：01001\n    - << 没有 \"<<<\"\n- 条件运算符：  ?:\n- 扩展赋值运算符： +=,-=,*=,/=,%=\n\n```\n\n### switch语句\n\n- 在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型\n- JDK7之后，switch表达式结果还可以是字符串\n- 使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句\n\n```\nswitch(a)\n{\n\tcase 1: break;\n\tcase 2: System.out.println(1);\n\tdefault: break;\n}\n```\n\n### 语句\n\n- if,while语句同c++\n- while中可以使用break,continue关键字\n- goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break\n- 可以使用带标签的continue和break\n  - 带标签的continue：跳转继续执行标签指向的循环\n  - 带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）\n\n### 方法 method，function\n\n[修饰符1 修饰符2..] 返回值 方法名(形参列表){\n语句\n}\n\n```\n- **Java中只有值传递！**\n- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身\n    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值\n\n```\n\n### 内存分析\n\n```\n- 栈\n    - 存放：局部变量\n    - 自动分配连续的空间\n- 堆\n    - 存放new出来的对象\n    - 空间不连续\n- 方法区\n    - 包含于堆区\n    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等\n\n```\n\n```\nclass Teacher{\n\tString name;\n\tint age;\n\tvoid teach() {}\n}\n\npublic class Student {\n\tString name;\n\tint age;\n\t\n\tvoid study() {}\n\t\n\tpublic static void main(String[] args){\n\t\tStudent st1=new Student();\n\t\tStudent st2=new Student();\n\t\tst1.age=18;\n\t\tst1.name=\"张三\";\n\t\tst2.age=30;\n\t\tst2.name=\"李四\";\n\t\t\n\t\tTeacher t1=new Teacher();\n\t\tt1.age=30;\n\t\tt1.name=\"李四\";\n\t}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG)\n\n## 包 package\n\n定义：Java的类库管理机制，借助文件系统的目录\n\n- 为什么需要使用Package\n\n  - 为了解决类的重名问题\n  - 为了便于管理类：合适的类位于合适的包\n\n- 怎么使用package\n\n  - 通常是类的第一句非注释性语句\n\n    - 规则：通常域名倒过来写，加上模块名\n\n      > com.qq.test\n\n一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字\n\n包名称内可以带有”.”，每个”.”代表文件系统的下一级目录\n\n如\n\n```\npackage p1;\npackage p1.s1;\n```\n\n则在文件系统中，p1文件夹下有个名为s1的文件夹包\n\n### 使用其它包里的类:\n\n1 . 使用**import**预先声明\n\n```\nimport package1.T;  // 引入package1包里的T\nimport package2.*   // 引入package2包里的所有类\npublic class T2\n{\n\tprivate T t1;\n}\n```\n\n2 . 每次使用时附带说明包的名\n\n```\npublic class T2\n{\n\tprivate package1.T t1;\n}\n```\n\n## API文档\n\n使用**JAVADOC**生成API文档\n\n```\n- 解决代码文档分离的问题\n\n```\n\n- 特殊的注释\n  - 文档注释： “/**”\n- 常用的java注释标签\n  - @Author 作者\n  - @version 版本\n  - @param 参数\n  - @return 返回值含义\n  - @throws 抛出异常描述\n  - @deprecated 废弃，建议用户不再使用该方法\n\n```\n/**\n * 类的描述、功能\n * @author aa\n * @version 1.0\n */\n```\n\n### 垃圾回收机制 (Garbage Collection)\n\n```\n- 对象空间的分配\n    - 使用\"new\"关键字创建对象\n- 对象空间的释放：\n    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间\n- 要点：\n    - 程序员无权调用垃圾回收器\n    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行\n    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用\n\n```\n\n## 数组\n\n### 定义数组变量\n\n1 - <类型>[]<数组名>=new <类型>[元素个数];\n\n> 例如：\n>\n> int [] grade = new int [100];\n>\n> 这样创建的数组会是默认的0值\n\n2 - <类型>[]<数组名>={元素1，元素2…};\n\n> 例如： int []a={1,2,3};\n\n3 - <类型>[]b = a; (a为同类型的数组)\n\n> 与c++中数组名的含义类似，数组名变量管理数组空间\n>\n> b和a管理同一个数组\n\n### 特点：\n\n1 - 所有元素的数据类型相同\n2 - 一旦创建则不能改变大小\n\n### 要求：\n\n- 元素个数必须是整数\n- 元素个数必须给出\n- 元素个数可以是变量\n\n### 内部成员：\n\nlength : 返回元素个数\n\n> for(int i=0; i<grade.length ; ++i)\n\n### 数组和数组变量：\n\n- 数组变量为数组的管理者，而非其本身\n- 数组创建出来后交给数组变量管理\n- 数组变量之间的赋值为管理权限的赋予\n- 数组变量的比较是判断是否管理同一个数组\n\n### 常用操作：\n\n1. 数组复制\n   System的arraycopy函数\n\n   ```\n   public static void arraycopy(Object src,\n                                int srcPos,\n                                Object dest,\n                                int destPos,\n                                int length)\n   // src 源数组\n   // srcPos 源数组开始复制的位置\n   // dest 目标数组\n   // destPos 目标数组开始复制的位置\n   // length 复制长度\n   // [srcPos,srcPos+length-1)\n   ```\n\n2. 二分查找\n   Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口\n   Arrays.binarySearch(Object obj, Object goal);\n\n3. 填充\n   Arrays.fill(Object obj, int start, int end, Object goal)\n   将目标数组[start,end)填充为goal\n\n### for-each循环：\n\n例如：for( int k: data )\n\n对于data数组的每一个元素，循环每一轮取一个元素作为k\n\n第一轮 k=data[0] , 第二轮 k=data[1]\n\n**for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值**\n\n## 包裹类型\n\n- 每种基础类型都有对应的包裹类型\n- 出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象\n\n| 基础类型    | 包裹类型      |\n| ------- | --------- |\n| boolean | Boolean   |\n| char    | Character |\n| int     | Integer   |\n| double  | Double    |\n\n### 用处：\n\n- 声明变量时包裹类型同基础类型\n\n> int a=1; <=> Integer a=1;\n\n- 可以获取该类型的信息，如最大值最小值\n\n> 如 System.out.println(Integer.MAX_VALUE);\n>\n> ( Integer.MAX_VALUE=2147483647 )\n\n- Character\n\n| 函数声明                           | 参数      | 用途            |\n| ------------------------------ | ------- | ------------- |\n| static boolean isDigit         | char ch | 判断该字符是否是数字    |\n| static boolean isLetter        | char ch | 判断该字符是否是字母    |\n| static boolean isLetterOrDigit | char ch | 判断该字符是否是数字或字母 |\n| static boolean isLowerCase     | char ch | 判断该字符是否是小写字母  |\n| static boolean isUpperCase     | char ch | 判断该字符是否是大写字母  |\n| static boolean isWhitespace    | char ch | 判断该字符是否是一种空格  |\n| static char toLowerCase        | char ch | 把该字符转换成小写     |\n| static char toUpperCase        | char ch | 把该字符转换成大写     |\n\n**转换仅体现在返回值，原变量的值没有改变**\n\n#### 自动装箱和自动拆箱 auto-boxing & unboxing\n\n- 自动装箱\n  - 基本类型自动封装到和它相同类型的包装里\n  - 本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);\n- 自动拆箱\n  - 包装类对象自动转换成基本数据类型\n  - 本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();\n\n#### **缓存处理**\n\n```\n-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）\n\n```\n\n```\nInteger d1=1234;\nInteger d2=1234;\n\nSystem.out.println(d1==d2);\nSystem.out.println(d1.equals(d2));\n\nInteger d3=123;\nInteger d4=123;\n\nSystem.out.println(d3==d4);\nSystem.out.println(d3.equals(d4));\n```\n\n结果：\n\n> false (d1==d2)\n> true (d1.equals(d2))\n> true (d3==d4)\n> true (d3.equals(d4))\n\n## 字符串 String\n\n- String是一个类，String变量是对象的管理者而非所有者\n\n### 创建：\n\n1 - String s = new String(“hello world”);\n\n2 - String s = “hello”;\n\n### 字符串连接\n\n- 用 “+” 连接两个字符串\n\n> “hello “+”world” -> “hello world”\n\n- 若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接\n\n> “I am “+18 -> “I am 18”\n>\n> 1+2+”age” -> “3age”\n>\n> “age”+1+2 -> “age12”\n\n### 字符串输入\n\n- in.next();\n  读入一个单词，以空格结束\n- in.nextLine();\n  读入一整行\n\n### 字符串比较\n\n- 用 “==” ：比较两个对象是同一个字符串\n\n> if(input == “hello”)\n\n- 用 “.equals” ：比较两个字符串的内容是否相同\n\n> if(input.equals(“hello”))\n\n### 字符串操作\n\n- 字符串是**对象**，所有操作是通过“.”进行的\n- 表示对“.”左边的字符串做右边的操作\n- 字符串可以是**变量**也可以是**常量**\n\n### 常用操作\n\n**所有操作都不会对字符串本身进行修改**\n\n- s1.compareTo(String s2)\n\n> 比较两个字符串大小\n>\n> s1>s2 返回正数\n>\n> s1<s2 返回负数\n>\n> s1和s2内容相同，返回0\n>\n> 字符串长者大\n>\n> 字符串长度相同时，从第一位开始以字典序比较\n\n- s1.length()\n\n> 获得String的长度\n\n- s1.charAt(int index)\n\n> 访问String里的字符\n>\n> 返回index上的单个字符\n>\n> 0<=index<=s1.length()-1\n>\n> **不能用for-each循环遍历字符串**\n\n- s1.substring(int begin ,int end)\n\n> 获得 s1 下标于[begin,end)的子串\n>\n> end可省略，默认为s1.length()\n\n- s1.indexOf( (char)|(String) c, int n)\n\n> 寻找c字符或字符串第一个所在位置，-1为不存在\n>\n> 从n开始找(包括n)，n可以省略，默认为0\n>\n> s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()\n>\n> 寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);\n\n- s1.startsWith( String s2)\n\n> 判断s1的前缀是否为s2\n\n- s1.endsWith( String s2)\n\n> 判断s1的后缀是否为s2\n\n- s1.trim()\n\n> 清除s1左右两端的空格\n>\n> 要保留清除可以 s1=s1.trim();\n\n- s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)\n\n> 将s1中所有字符或字符串c1替换成c2\n\n- s1.toLowerCase() s1.toUpperCase()\n\n> s1大小写切换\n\n- s1.split(char a)\n\n> 以a作为分隔符分割字符串s1，将结果作为字符串数组返回\n>\n> String [] s= s1.split(“ “);\n>\n> 多种分隔符用”|”分割，(“a”|”b”)\n>\n> 以”.””|”作为分隔符时要加”\\\\“，即(\\\\.)(\\\\|)\n\n### StringBuilder 和 StringBuffer\n\nStringBuilder：线程不安全，效率高\nStringBuffer：线程安全，效率低\n两者基本相同\n\nString无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。\n\n用StringBuffer/StringBuilder能够很好解决string的扩展问题\n\n- StringBuilder sb= new StringBuilder();\n\n- sb.append(“1”);\n\n  > 扩展字符串\n  > 其返回值为StringBuilder,因此可以连续调用\n  >\n  > ```\n  > // JDK源码\n  > @Override\n  > public StringBuilder append(String str) {\n  >     super.append(str);\n  >     return this;\n  > }\n  >\n  > // 因此可以使用\n  > sb.append(\"1\").append(\"2\");\n  > ```\n\n- sb.toString();\n\n  > 将StringBuilder形成字符串，可作为函数的String返回值\n\n- sb.delete(int start , int end);\n\n  > 删除下标为[start,end)的字符\n\n- sb.reverse();\n\n  > 反转sb\n\n#### 容量机制\n\n```\n- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）\n- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度\n- 扩容为当前容量*2+2\n\n```\n\n## 类\n\n### 创建对象\n\n对象变量是对象的**管理者**\n\n- T tem = new T();\n\n### 成员变量\n\n- 定义：类内部的变量\n- 特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数\n- 若没有初始化，则会自动被赋值(0)\n- 初始化\n  - 定义时就可以给出初始值\n  - 对象变量的0值表示没有管理任何对象，也可以主动给null值\n  - 定义初始化可以调用函数，可以使用已经定义的成员变量\n\n```\npublic class T\n{\n\tint a=1;\n\tint b=f();\n\tint f() {return 1;}\n}\n```\n\n### 构造函数\n\n- 名字和类名字完全相同，创建对象时会自动调用\n- 没有返回值\n- 调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句\n\n### 函数重载\n\n- 定义：同名但参数列表不同的函数\n- 可以有多个构造函数，但参数列表要不同\n- 构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次\n\n```\npublic class T\n{\n\tint a=1;\n\tT() {a=2;}\n\tT(int a)\n\t{\n\t\tthis();\n\t\tthis.a=a;\n\t}\n}\n```\n\n若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1->2->3，调用过程为：T(int a)->T()->int a=1;->执行T()->执行T(int a)\n\n### 访问属性\n\n- public (同c++)\n- private (同c++)\n- protected (同c++)\n- friendly\n\n#### public\n\n- 任何人都可以直接使用\n  - 任何函数或定义初始化中可以使用\n  - 使用是指调用、访问、定义变量\n- public类必须定义在自己的文件里\n- 一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)\n\n#### private\n\n- 只有类的内部能够访问\n  - 类的成员函数\n  - 定义初始化\n- 限制是针对类而非对象\n  - 对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)\n\n#### friendly\n\n- 未加private或public声明的成员 (即**默认值**)\n- 属于同一个包内的所有类都可以访问\n\n### System.out.println\n\n正常情况下，调用System.out.println直接输出类的对象，则会输出其地址\n\n若是在类中包含 public String toString 函数，则在println时自动调用该函数\n\n```\npublic class T{\n\tint c;\n\tpublic String toString () {return \"\"+c;}\n}\n```\n\n## 常用类\n\n### 时间处理：\n\n#### java.util.Date\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG)\n\n- 对象表示一个特定的瞬间，精确到毫秒\n- 时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long\n\n#### DateFormat, SimpleDateFormat\n\njava.text.*\n\n- 用来将字符串和时间相互转换\n- DateFormat 是抽象类，无法实例化对象\n- SimpleDateFormat非抽象类\n\n使用方法（详见API文档）\n\n1. 已知毫秒转相应时间和字符串\n\n   ```\n   DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日hh时mm分ss秒\");\n   DateFormat df1 = new SimpleDateFormat(\"yy-MM-dd hh:mm:ss\");\n   Date d = new Date(1321454564);\n   String str=df1.format(d);\n   System.out.println(str);\n   ```\n\n2. 已知字符串及输入格式转毫秒数\n\n   ```\n   String str2 = \"1977-07-07\";\n   DateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\n   try {\n   \tDate d2 = df2.parse(str2);\n   \tSystem.out.println(d2);\n   } catch (ParseException e) {\n   \t// TODO Auto-generated catch block\n   \te.printStackTrace();\n   }\n   ```\n\n#### Calendar，GregorianCalendar 日历类\n\njava.util.*\n\n- Calendar是抽象类，无法实例化对象\n- GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统\n- Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期\n- 注意\n  - 月份：1月是0，2月是1，…12月是11\n    - 星期：周日是1，周一是2…周六是7\n    - 可以使用 Calendar.FEBRUARY 表示数字\n\n使用方法：（详见API文档）\n\n1. 整体设置\n\n   ```\n   Calendar c = new GregorianCalendar();\n   c.set(2001, Calendar.FEBRUARY ,15);\n   Date date = c.getTime();\n   ```\n\n2. 单独设置\n\n   ```\n   c.set(Calendar.YEAR , 2001);\n   c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);\n   // 未设置参数则自动采用当前时间 (日期、时分秒等)\n   System.out.println(c.get(Calendar.YEAR));\n   ```\n\n3. 用Date赋值\n\n   ```\n   c.setTime(new Date());\n   ```\n\n4. 日期计算\n\n   ```\n   c.add(Calendar.YEAR, 30);\n   ```\n\n### File 类\n\njava.io.File:文件和目录路径名的抽象表现形式\n\n```\n- 通过File对象可以访问、修改文件属性\n- 可以创建空文件或目录\n\n```\n\n```\nFile f = new File(\"d:/aaa/bbb/ccc\");\nf.mkdir();  // 若父目录存在则创建\nf.mkdirs(); // 若父目录不存在则自动创建父目录\n```\n\n## 容器\n\n- 容器类的两个类型：\n\n  1 . 容器的类型\n\n  2 . 元素的类型\n\n### ArrayList\n\n- import java.util.ArrayList;\n\n- 特点：元素可以相同，元素以与进入的顺序排序\n\n- 基础类型：存放值\n\n- 非基础类型：作为管理者，存放地址\n\n- 定义：\n\n  ArrayList notes = new ArrayList();\n\n#### 常用操作\n\n- notes.add(int location, String s);\n\n> 向下标为location的位置中插入元素\n>\n> location可省略，默认为末尾\n\n- notes.size();\n\n> 返回容器中存放元素数目\n\n- notes.get(int index);\n\n> 返回下标为Index的元素\n\n- nodes.remove(int index);\n\n> 移除下标为Index的元素\n\n- notes.toArray(String []a);\n\n> 将notes里所有元素依次填入a中\n\n#### for-each循环\n\n若ArrayList存放的非基础类型，则for-each中可以修改值\n\n### Set\n\n- import java.util.HashSet\n- 特点：元素均不相同，不排序，与进入的顺序无关\n\n### Hash表(散列表)\n\n- import java.util.HashMap;\n- HashMap < Key, Value > a=new HashMap < Key,Value > ();\n  数据以一对值放进去，一个为键(KEY),一个为值(value)\n  值对应键\n- 键不能重复，只留相同的最后一个，元素不以先后排序\n\n#### 常用操作\n\n- a.put(Key k1, Value v1);\n\n> 向HashMap里添加元素，键k1对应值为v1\n\n- a.get(Key k);\n\n> 返回键k对应的值，若为空，则返回null\n\n- a.containsKey(Key k);\n\n> 查询是否存在键为k的数据\n\n- a.keySet();\n\n> 返回key的集合\n>\n> 可以通过 a.keySet().size()获取存放的键的数目\n>\n> 通过keySet使用for-each循环\n\n## 继承\n\n- extends\n\n  ```\n  public class son extends parent\n  ```\n\n- **java只允许单继承，一个类只能有一个父类**\n\n| 父类成员访问属性  | 在父类中的含义           | 在子类中的含义                   |                    |\n| --------- | ----------------- | ------------------------- | ------------------ |\n| public    | 对所有人开放            | 对所有人开放                    |                    |\n| protected | 只有包内其它类、自己和子类可以访问 | 只有包内其它类、自己和子类可以访问         |                    |\n| 缺省        | 只有包内其它类可以访问       | 如果子类与父类在同一个包内：只有包内其它类可以访问 | 否则：相当于private，不能访问 |\n| private   | 只有自己可以访问          | 不能访问                      |                    |\n\n子类同样继承了父类的private成员，只是子类无法访问！\n但子类可以通过调用父类的非private函数来间接修改父类的private成员变量\n\n### 继承VS组合\n\n- “is-a”关系使用继承\n  - 如：Bird类继承自Animal类\n- “has-a”关系使用组合\n  - 如：Computer类包含CPU类，每个Computer对象都有一个CPU对象\n\n### super\n\n本质：一个**关键字**，类似this(this的本质为指针),是直接父类的引用\n\n用法\n1 . 直接引用\n\n相当于指向当前对象的父类，用”.”访问父类的成员\n\n2 . 子类成员变量或方法与父类同名时，用super加以区分\n\n```\nclass son extends parent{\n\tvoid a();\n\tvoid b(){\n\t\ta();   // son的a函数\n\t\tsuper.a();  // parent的a函数\n\t}\n}\n```\n\n3 . 调用父类的构造函数\n\n规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数\n\n子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译\n\n```\nclass son extends parent{\n\tint a;\n\tson(int a1){\n\t\tsuper(a1);\n\t}\n}\n```\n\n### 同名变量\n\n若没有明确指明，则在谁的成员函数中就使用谁的成员变量\n\n### 子类和子类型\n\n- 类定义了类型\n- 子类定义了子类型 (son是parent的一个子类型)\n- 子类对象可以被当做父类的对象使用\n  - 赋值给父类变量\n  - 传递给需要父类对象的函数\n  - 放进存放分类对象的容器里\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG)\n\n```\nVehicle v1 = new Vehicle();\nVehicle v2 = new Car();\nVehicle v3 = new Bicycle();\n```\n\n## 多态\n\n主要用来实现**动态联编**\n\n即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了\n\n以此提高系统的灵活性和扩展性\n\n### 如何实现多态\n\n```\n- 引用变量的两种类型\n\n    - 编译时类型（一般是父类）\n        - 由声明时的类型决定\n\n    - 运行时类型（运行时具体的子类）\n        - 由实际对应的对象类型决定\n\n- 三个必要条件\n    - 要有继承\n    - 要有方法重写\n    - 父类引用指向子类对象\n\n```\n\n### 多态变量\n\n- 对象变量能够保存不止一种的对象\n- 可以保存声明类型的对象或是声明类型的子类的对象\n- 子类对象赋给父类变量，发生**向上造型**\n\n### 造型 cast\n\n造型(cast)：把一个类型的对象赋值给另一个类型的变量\n\n- 子类对象可以复制给父类变量\n  - 与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象\n- 父类对象不能赋值给子类变量\n- 可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行\n- 类型转换 ！= 造型\n  - 类型转换中对象发生改变，如 int i=(int)10.2;\n  - 造型中对象本身没有改变，只是改变了看待它的方式\n\n```\nVehicle v;\nCar car = new Car();\nv=car;  //可以\nc=v;   //编译错误\nc=(Car)v // 编译通过\n\n若\nVehicle v=new Vehicle();\nCar car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常\n```\n\n#### 向上造型\n\n- 子类对象当做父类对象使用\n- 向上造型是默认的，不需要运算符\n- 向上造型是安全的\n\n### 绑定\n\n同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数\n\n- 静态绑定：根据变量声明类型决定\n- 动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )\n- 默认使用动态绑定\n- 成员函数中调用其它成员函数通过this变量调用\n\n### 覆盖 override\n\n- 覆盖关系：子类和父类中存在名称和参数表完全相同的函数\n- 通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数\n\n### Object类\n\n- 所有的类都继承自Object类\n- 几乎所有OOP都有Object类（除c++）\n\n#### Object类的函数(部分)\n\n- toString()\n- equals()\n\n### 多态的内存分析\n\n1 . 基本的继承关系和方法调用\n\n```\n- 父类：Animal  有voice方法\n- 子类：Cat 重写voice方法，自己有catchMouse方法\n- 测试：分别声明父类和子类变量并指向子类对象\n\n```\n\n```\npublic class Test{\n\t\n\tpublic static void showVoice(Animal c) {\n\t\tc.voice();\n\t\tif(c instanceof Cat)\n\t\t\t((Cat) c).catchMouse();\n\t}\n\tpublic static void main(String[] args) {\n\t\tAnimal a=new Cat();\n\t\tCat cat=(Cat)a;\n\t\tTest.showVoice(cat);\n\t\tTest.showVoice(a);\n\t}\n}\n\nclass Animal{\n\tString name;\n\tint age;\n\tvoid voice() {}\n}\n\nclass Cat extends Animal{\n\tvoid voice() {\n\t\tSystem.out.println(\"miao\");\n\t};\n\tvoid catchMouse() {}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG)\n\n2 . 深化多态\n\n```\n- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法\n- 子类：MyServlet 重写了doGet方法\n- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本\n\n```\n\n```\npublic class HttpServlet {\n\tpublic void service() {\n\t\tSystem.out.println(\"HttpServlet.service()\");\n\t\tdoGet();\n\t}\n\tpublic void doGet() {\n\t\tSystem.out.println(\"HttpServlet.doGet()\");\n\t}\n}\n\n\npublic class MyServlet extends HttpServlet {\n\tpublic void doGet() {\n\t\tSystem.out.println(\"MyServlet.doGet()\");\n\t}\n}\n\npublic class Test{\n\t\n\tpublic static void main(String[] args) {\n\t\tHttpServlet s = new MyServlet();\n\t\ts.service();\n\t}\n}\n// 输出结果：\n// HttpServlet.service()\n// MyServlet.doGet()\n```\n\n原因分析：\n函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG)\n\n## 设计原则\n\n### 消除代码复制\n\n- 代码复制是不良设计的一种表现\n\n  解决方法：使用函数封装重复的代码\n\n### 增加可扩展性\n\n- 后期的可维护性\n\n  解决方法：用封装降低耦合，用接口实现聚合，借助类继承\n\n  耦合：类和类之间的关系\n\n  耦合越低越好\n\n## 抽象和接口\n\n关键词：**abstract** (抽象)\n\n> public abstract class a\n\n- 抽象函数：表达概念而**无法实现具体代码**的函数\n- 抽象类：表达概念而**无法构造出实体**的类\n- 为什么需要抽象类\n  - **模板模式**，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展\n  - **通过抽象类，可以避免子类设计的随意性**，严格限制子类的设计，使得子类之间更加通用。\n- 抽象方法的意义：**使方法的设计和实现分离！**\n- 要点：\n  - 有抽象函数的类一定是抽象类\n    - 抽象类**不能制造对象**，但可以定义变量\n  - 任何继承了抽象类的非抽象类对象可以赋值给抽象类变量\n  - 抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用\n  - 继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类\n\n### 接口\n\n关键词：**interface**\n\n> public interface a{}\n\n- 接口是纯抽象类(接口中只有常量、抽象方法)\n- 所有成员变量都是public abstract static final （默认的，可以不写）\n- 接口意义：设计和实现分离，利于大项目制作\n- 接口变量的含义为任何实现了接口的对象\n\n关键词：**implements**\n\n> public class b implements a{}\n\n- 类可以实现很多接口\n- 接口可以继承接口，不能继承类\n- 接口不能实现接口\n- 接口和抽象类\n  - 接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了**规范和具体实现的分离**\n  - **接口就是规范，定义了一组规则**\n  - **接口的本质是契约**，制定好后大家都遵守\n  - 项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要**面向接口编程**\n\n#### 面向接口的编程方式\n\n- 设计程序时先定义接口，再实现类\n- 任何需要在函数间传入传出的一定是接口而不是具体的类\n- Java成功的关键之一，极适合多人同时写一个大程序\n- Java被批评的要点之一，代码量膨胀地很快\n\n## 控制反转与MVC模式\n\n### Swing\n\n容器、部件\n\n- 容器继承自部件，因此可以作为部件被放入其它容器中\n\n- 容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整\n\n- JFrame使用BorderLayout管理部件，并且将界面划分为五个区域\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG)\n\n- 容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件\n\n### 控制反转\n\n- 按钮公布一个listener接口和一对注册、注销函数\n- 实现接口后将把listener对象注册在按钮上\n- 一旦按钮被按下，就会反过来调用listener对象的函数\n\n### 内部类 innerclasses\n\n定义在别的类内部、函数内部的类\n\n#### 作用：\n\n```\n- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问\n- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性\n\n```\n\n#### 使用场合\n\n在内部类只为所在外部类提供服务的情况优先使用\n\n#### 分类：\n\n##### 成员内部类\n\n（可以使用private,public,protected修饰）\n\n###### 非静态内部类\n\n`- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();`\n\n```\npublic class Outer {\n\tpublic static void main(String[] args) {\n\t\tFace f=new Face();\n\t\tFace.Nose n= f.new Nose();\n\t}\n}\n\nclass Face {\n\tint type;\n\t\n\tclass Nose{\n\t\tString type;\n\t\t\n\t\tvoid breath() {\n\t\t\tFace.this.type=1;\n\t\t}\n\t\t\n\t}\n}\n```\n\n###### 静态内部类\n\n```\n- 要点：\n    - 静态内部类对象存在时，不一定存在对应的外部类对象\n    - 静态内部类无法直接访问外部类实例方法\n    - 静态内部类看作**外部类的一个静态成员**\n\n```\n\n```\nFace f= new Face();\n// Nose为非静态内部类\nFace.Nose n=f.new Nose();\n// Ear为静态内部类\nFace.Ear e=new Face.Ear();\n```\n\n###### 局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\n\n```\n- 访问函数的本地变量时只能访问函数的final变量\n\n```\n\n##### 匿名内部类\n\n适用于只需要使用一次的类，例如：键盘监听操作等\n\n```\nnew 父类构造器(实参) 实现接口(){\n\t匿名内部类类体\n}\n```\n\n- 匿名类可以继承某类，也可以实现接口\n- Swing的消息机制广泛使用匿名类\n\n### MVC设计模式\n\n- 数据、表现和控制\n\n  三者分离\n\n  - M = Model 模型\n  - V = View 表现\n  - C = Control 控制\n\n- 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新\n\n- 表现：从模型获取数据，根据数据画出表现\n\n- 控制：从用户得到输入，根据输入调整数据\n\n### 异常机制 Exception\n\n#### 常见的异常\n\n```\n用户输入错误\n设备错误\n硬件问题：如打印机关掉、服务器问题\n磁盘满了\n\n```\n\n#### 异常Exception\n\n```\nJava提供的用来处理程序中错误的一种机制\n\nJava采用**面向对象** 方式来处理异常。处理过程：\n    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE\n    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置\n\n```\n\n#### 常见异常\n\n```\n1. ArithmeticException\n    例如试图除以0\n2. NullPointerException\n    对象为null但调用了对象的方法或属性\n3. ClassCastException\n    转型错误，解决：使用istanceof判断\n4. ArrayIndexOutOfBoundsException\n    访问元素超出数组长度\n5. NumberFormatException\n    数字格式异常，如把String转换成int\n\n```\n\n#### 异常的处理方法：\n\n`捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常`\n\n#### 方法重写中声明异常原则：\n\n```\n**子类声明的异常范围不能超出父类的范围**\n    - 父类没有声明异常，子类也不能\n    - 不能抛出 原有方法抛出的父类或上层类\n    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）\n\n```\n\n#### 自定义异常\n\n```\n- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类\n- 从Exception类或它的子类派生一个子类\n- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器\n\n建议：\n    - 避免使用异常机制代替错误处理\n    - 处理异常不能代替简单测试\n    - 不要进行**小力度**的异常处理（如一行一个try catch）\n    - 异常往往在**高层**处理\n\n```","source":"_posts/Java_note1.md","raw":"---\nlayout: post\ntitle: \"JAVA笔记（一）：基础\"\ndate: 2017-09-11\ncomments: true\ntags: \n  - 学习笔记\n  - JAVA\n---\n\n\n## 概述\n\nJAVA学习过程中的简要笔记\n\n从已有C++基础的前提下开始学习java\n\n内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等\n\n<!-- more -->\n\n### 各版本和体系架构\n\n- J2EE\n  - JAVA 2(to) Enterprise Edition:\n  - 定位在服务器端的应用\n- J2SE\n  - JAVA 2(to) Standard Edition:\n  - 定位在个人计算机的应用\n- J2EE\n  - JAVA 2(to) Micro Edition:\n  - 定位在消费性电子产品的应用\n\n### 概念\n\n```\n- JDK\n    - Java Development Kit Java开发工具包\n- JRE\n    - Java Runtime Environment java运行环境\n- JVM\n    - Java Virtual Machine java虚拟机\n\n```\n\n### 数据类型\n\n![数据类型](http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG)\n\n### 整型变量\n\n```\n- 表示形式\n    - 十进制\n    - 八进制：以0开头\n    - 十六进制：以0x或0X开头\n\n```\n\n整型默认为int型，long型常量后加”l”或”L”\n\n| 类型    | 占用空间 | 表示范围             |\n| ----- | ---- | ---------------- |\n| byte  | 1字节  | -128~127         |\n| short | 2字节  | -$2^15$~$2^15-1$ |\n| int   | 4字节  | -$2^31$~$2^31-1$ |\n| long  | 8字节  | -$2^63$~$2^63-1$ |\n\n- 超过long的数字使用**BigInteger**类\n\n### 浮点型\n\n| 类型     | 占用空间 | 表示范围                 |\n| ------ | ---- | -------------------- |\n| float  | 4字节  | -3.403E38~3.403E38   |\n| double | 8字节  | -1.798E308~1.798E308 |\n\n- 默认为double\n- 若需要不产生舍入误差的精确计算，需要用**BigDecimal**类\n- double变float：在数字后加”f”或”F”\n\n### 字符型\n\n- char采用Unicode编码表，，占用2个字节\n- 同c++,可以和整数相互转型，可以使用转义字符\n\n### boolean\n\n- 占1位(非字节)\n- java中boolean无法和整数之间转换\n\n### 变量\n\n```\n- 变量使用前需要声明\n\n```\n\n#### final\n\n类似c++的const\n\n```\n- final修饰变量，则该变量无法修改\n- final修饰类，则说明该类不能被继承，不能有子类\n    - 如 Math、String\n- final修饰方法，则该方法不能被子类重写，但是可以被重载\n\n```\n\n**命名规范**：\n\n- 变量、方法名：\n  - 首字母小写+驼峰原则\n- 常量：\n  - 大写字母+下划线\n- 类名：\n  - 首字母大写+驼峰原则\n\n### 运算符\n\n```\n- 算术运算符： +,-,*,/,%,++,--\n    - 不同于c++, java中浮点数可以使用\"%\"运算符！\n    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串\n- 赋值运算符： =\n- 关系运算符： <,>,<=,>=,==,!=, instanceof\n    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）\n        - 返回值：boolean  true代表属于\n        - 使用： boolean ret= a instanceof A;\n- 逻辑运算符： &&,||,!\n    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算\n- 位运算符： &,|,^,~,>>,<<,>>>\n    - >> 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃\n        - 01110>>1 右移一位： 00111\n        - 10010>>1 右移一位： 11001\n    - >>> 表示无符号右移：左边以0补充，移出的部分将抛弃\n        - 01110>>>1 右移一位：00111   (正数时和\">>\"相同)\n        - 10010>>>1 右移一位：01001\n    - << 没有 \"<<<\"\n- 条件运算符：  ?:\n- 扩展赋值运算符： +=,-=,*=,/=,%=\n\n```\n\n### switch语句\n\n- 在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型\n- JDK7之后，switch表达式结果还可以是字符串\n- 使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句\n\n```\nswitch(a)\n{\n\tcase 1: break;\n\tcase 2: System.out.println(1);\n\tdefault: break;\n}\n```\n\n### 语句\n\n- if,while语句同c++\n- while中可以使用break,continue关键字\n- goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break\n- 可以使用带标签的continue和break\n  - 带标签的continue：跳转继续执行标签指向的循环\n  - 带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）\n\n### 方法 method，function\n\n[修饰符1 修饰符2..] 返回值 方法名(形参列表){\n语句\n}\n\n```\n- **Java中只有值传递！**\n- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身\n    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值\n\n```\n\n### 内存分析\n\n```\n- 栈\n    - 存放：局部变量\n    - 自动分配连续的空间\n- 堆\n    - 存放new出来的对象\n    - 空间不连续\n- 方法区\n    - 包含于堆区\n    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等\n\n```\n\n```\nclass Teacher{\n\tString name;\n\tint age;\n\tvoid teach() {}\n}\n\npublic class Student {\n\tString name;\n\tint age;\n\t\n\tvoid study() {}\n\t\n\tpublic static void main(String[] args){\n\t\tStudent st1=new Student();\n\t\tStudent st2=new Student();\n\t\tst1.age=18;\n\t\tst1.name=\"张三\";\n\t\tst2.age=30;\n\t\tst2.name=\"李四\";\n\t\t\n\t\tTeacher t1=new Teacher();\n\t\tt1.age=30;\n\t\tt1.name=\"李四\";\n\t}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG)\n\n## 包 package\n\n定义：Java的类库管理机制，借助文件系统的目录\n\n- 为什么需要使用Package\n\n  - 为了解决类的重名问题\n  - 为了便于管理类：合适的类位于合适的包\n\n- 怎么使用package\n\n  - 通常是类的第一句非注释性语句\n\n    - 规则：通常域名倒过来写，加上模块名\n\n      > com.qq.test\n\n一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字\n\n包名称内可以带有”.”，每个”.”代表文件系统的下一级目录\n\n如\n\n```\npackage p1;\npackage p1.s1;\n```\n\n则在文件系统中，p1文件夹下有个名为s1的文件夹包\n\n### 使用其它包里的类:\n\n1 . 使用**import**预先声明\n\n```\nimport package1.T;  // 引入package1包里的T\nimport package2.*   // 引入package2包里的所有类\npublic class T2\n{\n\tprivate T t1;\n}\n```\n\n2 . 每次使用时附带说明包的名\n\n```\npublic class T2\n{\n\tprivate package1.T t1;\n}\n```\n\n## API文档\n\n使用**JAVADOC**生成API文档\n\n```\n- 解决代码文档分离的问题\n\n```\n\n- 特殊的注释\n  - 文档注释： “/**”\n- 常用的java注释标签\n  - @Author 作者\n  - @version 版本\n  - @param 参数\n  - @return 返回值含义\n  - @throws 抛出异常描述\n  - @deprecated 废弃，建议用户不再使用该方法\n\n```\n/**\n * 类的描述、功能\n * @author aa\n * @version 1.0\n */\n```\n\n### 垃圾回收机制 (Garbage Collection)\n\n```\n- 对象空间的分配\n    - 使用\"new\"关键字创建对象\n- 对象空间的释放：\n    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间\n- 要点：\n    - 程序员无权调用垃圾回收器\n    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行\n    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用\n\n```\n\n## 数组\n\n### 定义数组变量\n\n1 - <类型>[]<数组名>=new <类型>[元素个数];\n\n> 例如：\n>\n> int [] grade = new int [100];\n>\n> 这样创建的数组会是默认的0值\n\n2 - <类型>[]<数组名>={元素1，元素2…};\n\n> 例如： int []a={1,2,3};\n\n3 - <类型>[]b = a; (a为同类型的数组)\n\n> 与c++中数组名的含义类似，数组名变量管理数组空间\n>\n> b和a管理同一个数组\n\n### 特点：\n\n1 - 所有元素的数据类型相同\n2 - 一旦创建则不能改变大小\n\n### 要求：\n\n- 元素个数必须是整数\n- 元素个数必须给出\n- 元素个数可以是变量\n\n### 内部成员：\n\nlength : 返回元素个数\n\n> for(int i=0; i<grade.length ; ++i)\n\n### 数组和数组变量：\n\n- 数组变量为数组的管理者，而非其本身\n- 数组创建出来后交给数组变量管理\n- 数组变量之间的赋值为管理权限的赋予\n- 数组变量的比较是判断是否管理同一个数组\n\n### 常用操作：\n\n1. 数组复制\n   System的arraycopy函数\n\n   ```\n   public static void arraycopy(Object src,\n                                int srcPos,\n                                Object dest,\n                                int destPos,\n                                int length)\n   // src 源数组\n   // srcPos 源数组开始复制的位置\n   // dest 目标数组\n   // destPos 目标数组开始复制的位置\n   // length 复制长度\n   // [srcPos,srcPos+length-1)\n   ```\n\n2. 二分查找\n   Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口\n   Arrays.binarySearch(Object obj, Object goal);\n\n3. 填充\n   Arrays.fill(Object obj, int start, int end, Object goal)\n   将目标数组[start,end)填充为goal\n\n### for-each循环：\n\n例如：for( int k: data )\n\n对于data数组的每一个元素，循环每一轮取一个元素作为k\n\n第一轮 k=data[0] , 第二轮 k=data[1]\n\n**for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值**\n\n## 包裹类型\n\n- 每种基础类型都有对应的包裹类型\n- 出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象\n\n| 基础类型    | 包裹类型      |\n| ------- | --------- |\n| boolean | Boolean   |\n| char    | Character |\n| int     | Integer   |\n| double  | Double    |\n\n### 用处：\n\n- 声明变量时包裹类型同基础类型\n\n> int a=1; <=> Integer a=1;\n\n- 可以获取该类型的信息，如最大值最小值\n\n> 如 System.out.println(Integer.MAX_VALUE);\n>\n> ( Integer.MAX_VALUE=2147483647 )\n\n- Character\n\n| 函数声明                           | 参数      | 用途            |\n| ------------------------------ | ------- | ------------- |\n| static boolean isDigit         | char ch | 判断该字符是否是数字    |\n| static boolean isLetter        | char ch | 判断该字符是否是字母    |\n| static boolean isLetterOrDigit | char ch | 判断该字符是否是数字或字母 |\n| static boolean isLowerCase     | char ch | 判断该字符是否是小写字母  |\n| static boolean isUpperCase     | char ch | 判断该字符是否是大写字母  |\n| static boolean isWhitespace    | char ch | 判断该字符是否是一种空格  |\n| static char toLowerCase        | char ch | 把该字符转换成小写     |\n| static char toUpperCase        | char ch | 把该字符转换成大写     |\n\n**转换仅体现在返回值，原变量的值没有改变**\n\n#### 自动装箱和自动拆箱 auto-boxing & unboxing\n\n- 自动装箱\n  - 基本类型自动封装到和它相同类型的包装里\n  - 本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);\n- 自动拆箱\n  - 包装类对象自动转换成基本数据类型\n  - 本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();\n\n#### **缓存处理**\n\n```\n-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）\n\n```\n\n```\nInteger d1=1234;\nInteger d2=1234;\n\nSystem.out.println(d1==d2);\nSystem.out.println(d1.equals(d2));\n\nInteger d3=123;\nInteger d4=123;\n\nSystem.out.println(d3==d4);\nSystem.out.println(d3.equals(d4));\n```\n\n结果：\n\n> false (d1==d2)\n> true (d1.equals(d2))\n> true (d3==d4)\n> true (d3.equals(d4))\n\n## 字符串 String\n\n- String是一个类，String变量是对象的管理者而非所有者\n\n### 创建：\n\n1 - String s = new String(“hello world”);\n\n2 - String s = “hello”;\n\n### 字符串连接\n\n- 用 “+” 连接两个字符串\n\n> “hello “+”world” -> “hello world”\n\n- 若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接\n\n> “I am “+18 -> “I am 18”\n>\n> 1+2+”age” -> “3age”\n>\n> “age”+1+2 -> “age12”\n\n### 字符串输入\n\n- in.next();\n  读入一个单词，以空格结束\n- in.nextLine();\n  读入一整行\n\n### 字符串比较\n\n- 用 “==” ：比较两个对象是同一个字符串\n\n> if(input == “hello”)\n\n- 用 “.equals” ：比较两个字符串的内容是否相同\n\n> if(input.equals(“hello”))\n\n### 字符串操作\n\n- 字符串是**对象**，所有操作是通过“.”进行的\n- 表示对“.”左边的字符串做右边的操作\n- 字符串可以是**变量**也可以是**常量**\n\n### 常用操作\n\n**所有操作都不会对字符串本身进行修改**\n\n- s1.compareTo(String s2)\n\n> 比较两个字符串大小\n>\n> s1>s2 返回正数\n>\n> s1<s2 返回负数\n>\n> s1和s2内容相同，返回0\n>\n> 字符串长者大\n>\n> 字符串长度相同时，从第一位开始以字典序比较\n\n- s1.length()\n\n> 获得String的长度\n\n- s1.charAt(int index)\n\n> 访问String里的字符\n>\n> 返回index上的单个字符\n>\n> 0<=index<=s1.length()-1\n>\n> **不能用for-each循环遍历字符串**\n\n- s1.substring(int begin ,int end)\n\n> 获得 s1 下标于[begin,end)的子串\n>\n> end可省略，默认为s1.length()\n\n- s1.indexOf( (char)|(String) c, int n)\n\n> 寻找c字符或字符串第一个所在位置，-1为不存在\n>\n> 从n开始找(包括n)，n可以省略，默认为0\n>\n> s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()\n>\n> 寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);\n\n- s1.startsWith( String s2)\n\n> 判断s1的前缀是否为s2\n\n- s1.endsWith( String s2)\n\n> 判断s1的后缀是否为s2\n\n- s1.trim()\n\n> 清除s1左右两端的空格\n>\n> 要保留清除可以 s1=s1.trim();\n\n- s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)\n\n> 将s1中所有字符或字符串c1替换成c2\n\n- s1.toLowerCase() s1.toUpperCase()\n\n> s1大小写切换\n\n- s1.split(char a)\n\n> 以a作为分隔符分割字符串s1，将结果作为字符串数组返回\n>\n> String [] s= s1.split(“ “);\n>\n> 多种分隔符用”|”分割，(“a”|”b”)\n>\n> 以”.””|”作为分隔符时要加”\\\\“，即(\\\\.)(\\\\|)\n\n### StringBuilder 和 StringBuffer\n\nStringBuilder：线程不安全，效率高\nStringBuffer：线程安全，效率低\n两者基本相同\n\nString无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。\n\n用StringBuffer/StringBuilder能够很好解决string的扩展问题\n\n- StringBuilder sb= new StringBuilder();\n\n- sb.append(“1”);\n\n  > 扩展字符串\n  > 其返回值为StringBuilder,因此可以连续调用\n  >\n  > ```\n  > // JDK源码\n  > @Override\n  > public StringBuilder append(String str) {\n  >     super.append(str);\n  >     return this;\n  > }\n  >\n  > // 因此可以使用\n  > sb.append(\"1\").append(\"2\");\n  > ```\n\n- sb.toString();\n\n  > 将StringBuilder形成字符串，可作为函数的String返回值\n\n- sb.delete(int start , int end);\n\n  > 删除下标为[start,end)的字符\n\n- sb.reverse();\n\n  > 反转sb\n\n#### 容量机制\n\n```\n- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）\n- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度\n- 扩容为当前容量*2+2\n\n```\n\n## 类\n\n### 创建对象\n\n对象变量是对象的**管理者**\n\n- T tem = new T();\n\n### 成员变量\n\n- 定义：类内部的变量\n- 特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数\n- 若没有初始化，则会自动被赋值(0)\n- 初始化\n  - 定义时就可以给出初始值\n  - 对象变量的0值表示没有管理任何对象，也可以主动给null值\n  - 定义初始化可以调用函数，可以使用已经定义的成员变量\n\n```\npublic class T\n{\n\tint a=1;\n\tint b=f();\n\tint f() {return 1;}\n}\n```\n\n### 构造函数\n\n- 名字和类名字完全相同，创建对象时会自动调用\n- 没有返回值\n- 调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句\n\n### 函数重载\n\n- 定义：同名但参数列表不同的函数\n- 可以有多个构造函数，但参数列表要不同\n- 构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次\n\n```\npublic class T\n{\n\tint a=1;\n\tT() {a=2;}\n\tT(int a)\n\t{\n\t\tthis();\n\t\tthis.a=a;\n\t}\n}\n```\n\n若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1->2->3，调用过程为：T(int a)->T()->int a=1;->执行T()->执行T(int a)\n\n### 访问属性\n\n- public (同c++)\n- private (同c++)\n- protected (同c++)\n- friendly\n\n#### public\n\n- 任何人都可以直接使用\n  - 任何函数或定义初始化中可以使用\n  - 使用是指调用、访问、定义变量\n- public类必须定义在自己的文件里\n- 一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)\n\n#### private\n\n- 只有类的内部能够访问\n  - 类的成员函数\n  - 定义初始化\n- 限制是针对类而非对象\n  - 对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)\n\n#### friendly\n\n- 未加private或public声明的成员 (即**默认值**)\n- 属于同一个包内的所有类都可以访问\n\n### System.out.println\n\n正常情况下，调用System.out.println直接输出类的对象，则会输出其地址\n\n若是在类中包含 public String toString 函数，则在println时自动调用该函数\n\n```\npublic class T{\n\tint c;\n\tpublic String toString () {return \"\"+c;}\n}\n```\n\n## 常用类\n\n### 时间处理：\n\n#### java.util.Date\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG)\n\n- 对象表示一个特定的瞬间，精确到毫秒\n- 时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long\n\n#### DateFormat, SimpleDateFormat\n\njava.text.*\n\n- 用来将字符串和时间相互转换\n- DateFormat 是抽象类，无法实例化对象\n- SimpleDateFormat非抽象类\n\n使用方法（详见API文档）\n\n1. 已知毫秒转相应时间和字符串\n\n   ```\n   DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日hh时mm分ss秒\");\n   DateFormat df1 = new SimpleDateFormat(\"yy-MM-dd hh:mm:ss\");\n   Date d = new Date(1321454564);\n   String str=df1.format(d);\n   System.out.println(str);\n   ```\n\n2. 已知字符串及输入格式转毫秒数\n\n   ```\n   String str2 = \"1977-07-07\";\n   DateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\n   try {\n   \tDate d2 = df2.parse(str2);\n   \tSystem.out.println(d2);\n   } catch (ParseException e) {\n   \t// TODO Auto-generated catch block\n   \te.printStackTrace();\n   }\n   ```\n\n#### Calendar，GregorianCalendar 日历类\n\njava.util.*\n\n- Calendar是抽象类，无法实例化对象\n- GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统\n- Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期\n- 注意\n  - 月份：1月是0，2月是1，…12月是11\n    - 星期：周日是1，周一是2…周六是7\n    - 可以使用 Calendar.FEBRUARY 表示数字\n\n使用方法：（详见API文档）\n\n1. 整体设置\n\n   ```\n   Calendar c = new GregorianCalendar();\n   c.set(2001, Calendar.FEBRUARY ,15);\n   Date date = c.getTime();\n   ```\n\n2. 单独设置\n\n   ```\n   c.set(Calendar.YEAR , 2001);\n   c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);\n   // 未设置参数则自动采用当前时间 (日期、时分秒等)\n   System.out.println(c.get(Calendar.YEAR));\n   ```\n\n3. 用Date赋值\n\n   ```\n   c.setTime(new Date());\n   ```\n\n4. 日期计算\n\n   ```\n   c.add(Calendar.YEAR, 30);\n   ```\n\n### File 类\n\njava.io.File:文件和目录路径名的抽象表现形式\n\n```\n- 通过File对象可以访问、修改文件属性\n- 可以创建空文件或目录\n\n```\n\n```\nFile f = new File(\"d:/aaa/bbb/ccc\");\nf.mkdir();  // 若父目录存在则创建\nf.mkdirs(); // 若父目录不存在则自动创建父目录\n```\n\n## 容器\n\n- 容器类的两个类型：\n\n  1 . 容器的类型\n\n  2 . 元素的类型\n\n### ArrayList\n\n- import java.util.ArrayList;\n\n- 特点：元素可以相同，元素以与进入的顺序排序\n\n- 基础类型：存放值\n\n- 非基础类型：作为管理者，存放地址\n\n- 定义：\n\n  ArrayList notes = new ArrayList();\n\n#### 常用操作\n\n- notes.add(int location, String s);\n\n> 向下标为location的位置中插入元素\n>\n> location可省略，默认为末尾\n\n- notes.size();\n\n> 返回容器中存放元素数目\n\n- notes.get(int index);\n\n> 返回下标为Index的元素\n\n- nodes.remove(int index);\n\n> 移除下标为Index的元素\n\n- notes.toArray(String []a);\n\n> 将notes里所有元素依次填入a中\n\n#### for-each循环\n\n若ArrayList存放的非基础类型，则for-each中可以修改值\n\n### Set\n\n- import java.util.HashSet\n- 特点：元素均不相同，不排序，与进入的顺序无关\n\n### Hash表(散列表)\n\n- import java.util.HashMap;\n- HashMap < Key, Value > a=new HashMap < Key,Value > ();\n  数据以一对值放进去，一个为键(KEY),一个为值(value)\n  值对应键\n- 键不能重复，只留相同的最后一个，元素不以先后排序\n\n#### 常用操作\n\n- a.put(Key k1, Value v1);\n\n> 向HashMap里添加元素，键k1对应值为v1\n\n- a.get(Key k);\n\n> 返回键k对应的值，若为空，则返回null\n\n- a.containsKey(Key k);\n\n> 查询是否存在键为k的数据\n\n- a.keySet();\n\n> 返回key的集合\n>\n> 可以通过 a.keySet().size()获取存放的键的数目\n>\n> 通过keySet使用for-each循环\n\n## 继承\n\n- extends\n\n  ```\n  public class son extends parent\n  ```\n\n- **java只允许单继承，一个类只能有一个父类**\n\n| 父类成员访问属性  | 在父类中的含义           | 在子类中的含义                   |                    |\n| --------- | ----------------- | ------------------------- | ------------------ |\n| public    | 对所有人开放            | 对所有人开放                    |                    |\n| protected | 只有包内其它类、自己和子类可以访问 | 只有包内其它类、自己和子类可以访问         |                    |\n| 缺省        | 只有包内其它类可以访问       | 如果子类与父类在同一个包内：只有包内其它类可以访问 | 否则：相当于private，不能访问 |\n| private   | 只有自己可以访问          | 不能访问                      |                    |\n\n子类同样继承了父类的private成员，只是子类无法访问！\n但子类可以通过调用父类的非private函数来间接修改父类的private成员变量\n\n### 继承VS组合\n\n- “is-a”关系使用继承\n  - 如：Bird类继承自Animal类\n- “has-a”关系使用组合\n  - 如：Computer类包含CPU类，每个Computer对象都有一个CPU对象\n\n### super\n\n本质：一个**关键字**，类似this(this的本质为指针),是直接父类的引用\n\n用法\n1 . 直接引用\n\n相当于指向当前对象的父类，用”.”访问父类的成员\n\n2 . 子类成员变量或方法与父类同名时，用super加以区分\n\n```\nclass son extends parent{\n\tvoid a();\n\tvoid b(){\n\t\ta();   // son的a函数\n\t\tsuper.a();  // parent的a函数\n\t}\n}\n```\n\n3 . 调用父类的构造函数\n\n规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数\n\n子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译\n\n```\nclass son extends parent{\n\tint a;\n\tson(int a1){\n\t\tsuper(a1);\n\t}\n}\n```\n\n### 同名变量\n\n若没有明确指明，则在谁的成员函数中就使用谁的成员变量\n\n### 子类和子类型\n\n- 类定义了类型\n- 子类定义了子类型 (son是parent的一个子类型)\n- 子类对象可以被当做父类的对象使用\n  - 赋值给父类变量\n  - 传递给需要父类对象的函数\n  - 放进存放分类对象的容器里\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG)\n\n```\nVehicle v1 = new Vehicle();\nVehicle v2 = new Car();\nVehicle v3 = new Bicycle();\n```\n\n## 多态\n\n主要用来实现**动态联编**\n\n即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了\n\n以此提高系统的灵活性和扩展性\n\n### 如何实现多态\n\n```\n- 引用变量的两种类型\n\n    - 编译时类型（一般是父类）\n        - 由声明时的类型决定\n\n    - 运行时类型（运行时具体的子类）\n        - 由实际对应的对象类型决定\n\n- 三个必要条件\n    - 要有继承\n    - 要有方法重写\n    - 父类引用指向子类对象\n\n```\n\n### 多态变量\n\n- 对象变量能够保存不止一种的对象\n- 可以保存声明类型的对象或是声明类型的子类的对象\n- 子类对象赋给父类变量，发生**向上造型**\n\n### 造型 cast\n\n造型(cast)：把一个类型的对象赋值给另一个类型的变量\n\n- 子类对象可以复制给父类变量\n  - 与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象\n- 父类对象不能赋值给子类变量\n- 可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行\n- 类型转换 ！= 造型\n  - 类型转换中对象发生改变，如 int i=(int)10.2;\n  - 造型中对象本身没有改变，只是改变了看待它的方式\n\n```\nVehicle v;\nCar car = new Car();\nv=car;  //可以\nc=v;   //编译错误\nc=(Car)v // 编译通过\n\n若\nVehicle v=new Vehicle();\nCar car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常\n```\n\n#### 向上造型\n\n- 子类对象当做父类对象使用\n- 向上造型是默认的，不需要运算符\n- 向上造型是安全的\n\n### 绑定\n\n同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数\n\n- 静态绑定：根据变量声明类型决定\n- 动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )\n- 默认使用动态绑定\n- 成员函数中调用其它成员函数通过this变量调用\n\n### 覆盖 override\n\n- 覆盖关系：子类和父类中存在名称和参数表完全相同的函数\n- 通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数\n\n### Object类\n\n- 所有的类都继承自Object类\n- 几乎所有OOP都有Object类（除c++）\n\n#### Object类的函数(部分)\n\n- toString()\n- equals()\n\n### 多态的内存分析\n\n1 . 基本的继承关系和方法调用\n\n```\n- 父类：Animal  有voice方法\n- 子类：Cat 重写voice方法，自己有catchMouse方法\n- 测试：分别声明父类和子类变量并指向子类对象\n\n```\n\n```\npublic class Test{\n\t\n\tpublic static void showVoice(Animal c) {\n\t\tc.voice();\n\t\tif(c instanceof Cat)\n\t\t\t((Cat) c).catchMouse();\n\t}\n\tpublic static void main(String[] args) {\n\t\tAnimal a=new Cat();\n\t\tCat cat=(Cat)a;\n\t\tTest.showVoice(cat);\n\t\tTest.showVoice(a);\n\t}\n}\n\nclass Animal{\n\tString name;\n\tint age;\n\tvoid voice() {}\n}\n\nclass Cat extends Animal{\n\tvoid voice() {\n\t\tSystem.out.println(\"miao\");\n\t};\n\tvoid catchMouse() {}\n}\n```\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG)\n\n2 . 深化多态\n\n```\n- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法\n- 子类：MyServlet 重写了doGet方法\n- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本\n\n```\n\n```\npublic class HttpServlet {\n\tpublic void service() {\n\t\tSystem.out.println(\"HttpServlet.service()\");\n\t\tdoGet();\n\t}\n\tpublic void doGet() {\n\t\tSystem.out.println(\"HttpServlet.doGet()\");\n\t}\n}\n\n\npublic class MyServlet extends HttpServlet {\n\tpublic void doGet() {\n\t\tSystem.out.println(\"MyServlet.doGet()\");\n\t}\n}\n\npublic class Test{\n\t\n\tpublic static void main(String[] args) {\n\t\tHttpServlet s = new MyServlet();\n\t\ts.service();\n\t}\n}\n// 输出结果：\n// HttpServlet.service()\n// MyServlet.doGet()\n```\n\n原因分析：\n函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG)\n\n## 设计原则\n\n### 消除代码复制\n\n- 代码复制是不良设计的一种表现\n\n  解决方法：使用函数封装重复的代码\n\n### 增加可扩展性\n\n- 后期的可维护性\n\n  解决方法：用封装降低耦合，用接口实现聚合，借助类继承\n\n  耦合：类和类之间的关系\n\n  耦合越低越好\n\n## 抽象和接口\n\n关键词：**abstract** (抽象)\n\n> public abstract class a\n\n- 抽象函数：表达概念而**无法实现具体代码**的函数\n- 抽象类：表达概念而**无法构造出实体**的类\n- 为什么需要抽象类\n  - **模板模式**，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展\n  - **通过抽象类，可以避免子类设计的随意性**，严格限制子类的设计，使得子类之间更加通用。\n- 抽象方法的意义：**使方法的设计和实现分离！**\n- 要点：\n  - 有抽象函数的类一定是抽象类\n    - 抽象类**不能制造对象**，但可以定义变量\n  - 任何继承了抽象类的非抽象类对象可以赋值给抽象类变量\n  - 抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用\n  - 继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类\n\n### 接口\n\n关键词：**interface**\n\n> public interface a{}\n\n- 接口是纯抽象类(接口中只有常量、抽象方法)\n- 所有成员变量都是public abstract static final （默认的，可以不写）\n- 接口意义：设计和实现分离，利于大项目制作\n- 接口变量的含义为任何实现了接口的对象\n\n关键词：**implements**\n\n> public class b implements a{}\n\n- 类可以实现很多接口\n- 接口可以继承接口，不能继承类\n- 接口不能实现接口\n- 接口和抽象类\n  - 接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了**规范和具体实现的分离**\n  - **接口就是规范，定义了一组规则**\n  - **接口的本质是契约**，制定好后大家都遵守\n  - 项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要**面向接口编程**\n\n#### 面向接口的编程方式\n\n- 设计程序时先定义接口，再实现类\n- 任何需要在函数间传入传出的一定是接口而不是具体的类\n- Java成功的关键之一，极适合多人同时写一个大程序\n- Java被批评的要点之一，代码量膨胀地很快\n\n## 控制反转与MVC模式\n\n### Swing\n\n容器、部件\n\n- 容器继承自部件，因此可以作为部件被放入其它容器中\n\n- 容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整\n\n- JFrame使用BorderLayout管理部件，并且将界面划分为五个区域\n\n  ![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG)\n\n- 容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件\n\n### 控制反转\n\n- 按钮公布一个listener接口和一对注册、注销函数\n- 实现接口后将把listener对象注册在按钮上\n- 一旦按钮被按下，就会反过来调用listener对象的函数\n\n### 内部类 innerclasses\n\n定义在别的类内部、函数内部的类\n\n#### 作用：\n\n```\n- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问\n- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性\n\n```\n\n#### 使用场合\n\n在内部类只为所在外部类提供服务的情况优先使用\n\n#### 分类：\n\n##### 成员内部类\n\n（可以使用private,public,protected修饰）\n\n###### 非静态内部类\n\n`- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();`\n\n```\npublic class Outer {\n\tpublic static void main(String[] args) {\n\t\tFace f=new Face();\n\t\tFace.Nose n= f.new Nose();\n\t}\n}\n\nclass Face {\n\tint type;\n\t\n\tclass Nose{\n\t\tString type;\n\t\t\n\t\tvoid breath() {\n\t\t\tFace.this.type=1;\n\t\t}\n\t\t\n\t}\n}\n```\n\n###### 静态内部类\n\n```\n- 要点：\n    - 静态内部类对象存在时，不一定存在对应的外部类对象\n    - 静态内部类无法直接访问外部类实例方法\n    - 静态内部类看作**外部类的一个静态成员**\n\n```\n\n```\nFace f= new Face();\n// Nose为非静态内部类\nFace.Nose n=f.new Nose();\n// Ear为静态内部类\nFace.Ear e=new Face.Ear();\n```\n\n###### 局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\n\n```\n- 访问函数的本地变量时只能访问函数的final变量\n\n```\n\n##### 匿名内部类\n\n适用于只需要使用一次的类，例如：键盘监听操作等\n\n```\nnew 父类构造器(实参) 实现接口(){\n\t匿名内部类类体\n}\n```\n\n- 匿名类可以继承某类，也可以实现接口\n- Swing的消息机制广泛使用匿名类\n\n### MVC设计模式\n\n- 数据、表现和控制\n\n  三者分离\n\n  - M = Model 模型\n  - V = View 表现\n  - C = Control 控制\n\n- 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新\n\n- 表现：从模型获取数据，根据数据画出表现\n\n- 控制：从用户得到输入，根据输入调整数据\n\n### 异常机制 Exception\n\n#### 常见的异常\n\n```\n用户输入错误\n设备错误\n硬件问题：如打印机关掉、服务器问题\n磁盘满了\n\n```\n\n#### 异常Exception\n\n```\nJava提供的用来处理程序中错误的一种机制\n\nJava采用**面向对象** 方式来处理异常。处理过程：\n    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE\n    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置\n\n```\n\n#### 常见异常\n\n```\n1. ArithmeticException\n    例如试图除以0\n2. NullPointerException\n    对象为null但调用了对象的方法或属性\n3. ClassCastException\n    转型错误，解决：使用istanceof判断\n4. ArrayIndexOutOfBoundsException\n    访问元素超出数组长度\n5. NumberFormatException\n    数字格式异常，如把String转换成int\n\n```\n\n#### 异常的处理方法：\n\n`捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常`\n\n#### 方法重写中声明异常原则：\n\n```\n**子类声明的异常范围不能超出父类的范围**\n    - 父类没有声明异常，子类也不能\n    - 不能抛出 原有方法抛出的父类或上层类\n    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）\n\n```\n\n#### 自定义异常\n\n```\n- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类\n- 从Exception类或它的子类派生一个子类\n- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器\n\n建议：\n    - 避免使用异常机制代替错误处理\n    - 处理异常不能代替简单测试\n    - 不要进行**小力度**的异常处理（如一行一个try catch）\n    - 异常往往在**高层**处理\n\n```","slug":"Java_note1","published":1,"updated":"2018-05-25T12:41:12.485Z","photos":[],"link":"","_id":"cjhvssaed0010jvfcxsq86v4u","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>JAVA学习过程中的简要笔记</p>\n<p>从已有C++基础的前提下开始学习java</p>\n<p>内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等</p>\n<a id=\"more\"></a>\n<h3 id=\"各版本和体系架构\"><a href=\"#各版本和体系架构\" class=\"headerlink\" title=\"各版本和体系架构\"></a>各版本和体系架构</h3><ul>\n<li>J2EE<ul>\n<li>JAVA 2(to) Enterprise Edition:</li>\n<li>定位在服务器端的应用</li>\n</ul>\n</li>\n<li>J2SE<ul>\n<li>JAVA 2(to) Standard Edition:</li>\n<li>定位在个人计算机的应用</li>\n</ul>\n</li>\n<li>J2EE<ul>\n<li>JAVA 2(to) Micro Edition:</li>\n<li>定位在消费性电子产品的应用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- JDK</span><br><span class=\"line\">    - Java Development Kit Java开发工具包</span><br><span class=\"line\">- JRE</span><br><span class=\"line\">    - Java Runtime Environment java运行环境</span><br><span class=\"line\">- JVM</span><br><span class=\"line\">    - Java Virtual Machine java虚拟机</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG\" alt=\"数据类型\"></p>\n<h3 id=\"整型变量\"><a href=\"#整型变量\" class=\"headerlink\" title=\"整型变量\"></a>整型变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表示形式</span><br><span class=\"line\">    - 十进制</span><br><span class=\"line\">    - 八进制：以0开头</span><br><span class=\"line\">    - 十六进制：以0x或0X开头</span><br></pre></td></tr></table></figure>\n<p>整型默认为int型，long型常量后加”l”或”L”</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>1字节</td>\n<td>-128~127</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2字节</td>\n<td>-$2^15$~$2^15-1$</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4字节</td>\n<td>-$2^31$~$2^31-1$</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8字节</td>\n<td>-$2^63$~$2^63-1$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>超过long的数字使用<strong>BigInteger</strong>类</li>\n</ul>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>4字节</td>\n<td>-3.403E38~3.403E38</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>-1.798E308~1.798E308</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>默认为double</li>\n<li>若需要不产生舍入误差的精确计算，需要用<strong>BigDecimal</strong>类</li>\n<li>double变float：在数字后加”f”或”F”</li>\n</ul>\n<h3 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h3><ul>\n<li>char采用Unicode编码表，，占用2个字节</li>\n<li>同c++,可以和整数相互转型，可以使用转义字符</li>\n</ul>\n<h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><ul>\n<li>占1位(非字节)</li>\n<li>java中boolean无法和整数之间转换</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 变量使用前需要声明</span><br></pre></td></tr></table></figure>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>类似c++的const</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- final修饰变量，则该变量无法修改</span><br><span class=\"line\">- final修饰类，则说明该类不能被继承，不能有子类</span><br><span class=\"line\">    - 如 Math、String</span><br><span class=\"line\">- final修饰方法，则该方法不能被子类重写，但是可以被重载</span><br></pre></td></tr></table></figure>\n<p><strong>命名规范</strong>：</p>\n<ul>\n<li>变量、方法名：<ul>\n<li>首字母小写+驼峰原则</li>\n</ul>\n</li>\n<li>常量：<ul>\n<li>大写字母+下划线</li>\n</ul>\n</li>\n<li>类名：<ul>\n<li>首字母大写+驼峰原则</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 算术运算符： +,-,*,/,%,++,--</span><br><span class=\"line\">    - 不同于c++, java中浮点数可以使用&quot;%&quot;运算符！</span><br><span class=\"line\">    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串</span><br><span class=\"line\">- 赋值运算符： =</span><br><span class=\"line\">- 关系运算符： &lt;,&gt;,&lt;=,&gt;=,==,!=, instanceof</span><br><span class=\"line\">    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）</span><br><span class=\"line\">        - 返回值：boolean  true代表属于</span><br><span class=\"line\">        - 使用： boolean ret= a instanceof A;</span><br><span class=\"line\">- 逻辑运算符： &amp;&amp;,||,!</span><br><span class=\"line\">    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算</span><br><span class=\"line\">- 位运算符： &amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</span><br><span class=\"line\">    - &gt;&gt; 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;1 右移一位： 00111</span><br><span class=\"line\">        - 10010&gt;&gt;1 右移一位： 11001</span><br><span class=\"line\">    - &gt;&gt;&gt; 表示无符号右移：左边以0补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;&gt;1 右移一位：00111   (正数时和&quot;&gt;&gt;&quot;相同)</span><br><span class=\"line\">        - 10010&gt;&gt;&gt;1 右移一位：01001</span><br><span class=\"line\">    - &lt;&lt; 没有 &quot;&lt;&lt;&lt;&quot;</span><br><span class=\"line\">- 条件运算符：  ?:</span><br><span class=\"line\">- 扩展赋值运算符： +=,-=,*=,/=,%=</span><br></pre></td></tr></table></figure>\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><ul>\n<li>在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型</li>\n<li>JDK7之后，switch表达式结果还可以是字符串</li>\n<li>使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcase 1: break;</span><br><span class=\"line\">\tcase 2: System.out.println(1);</span><br><span class=\"line\">\tdefault: break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h3><ul>\n<li>if,while语句同c++</li>\n<li>while中可以使用break,continue关键字</li>\n<li>goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break</li>\n<li>可以使用带标签的continue和break<ul>\n<li>带标签的continue：跳转继续执行标签指向的循环</li>\n<li>带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"方法-method，function\"><a href=\"#方法-method，function\" class=\"headerlink\" title=\"方法 method，function\"></a>方法 method，function</h3><p>[修饰符1 修饰符2..] 返回值 方法名(形参列表){<br>语句<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- **Java中只有值传递！**</span><br><span class=\"line\">- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身</span><br><span class=\"line\">    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存分析\"><a href=\"#内存分析\" class=\"headerlink\" title=\"内存分析\"></a>内存分析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 栈</span><br><span class=\"line\">    - 存放：局部变量</span><br><span class=\"line\">    - 自动分配连续的空间</span><br><span class=\"line\">- 堆</span><br><span class=\"line\">    - 存放new出来的对象</span><br><span class=\"line\">    - 空间不连续</span><br><span class=\"line\">- 方法区</span><br><span class=\"line\">    - 包含于堆区</span><br><span class=\"line\">    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid teach() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid study() &#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tStudent st1=new Student();</span><br><span class=\"line\">\t\tStudent st2=new Student();</span><br><span class=\"line\">\t\tst1.age=18;</span><br><span class=\"line\">\t\tst1.name=&quot;张三&quot;;</span><br><span class=\"line\">\t\tst2.age=30;</span><br><span class=\"line\">\t\tst2.name=&quot;李四&quot;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTeacher t1=new Teacher();</span><br><span class=\"line\">\t\tt1.age=30;</span><br><span class=\"line\">\t\tt1.name=&quot;李四&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG\" alt=\"mark\"></p>\n<h2 id=\"包-package\"><a href=\"#包-package\" class=\"headerlink\" title=\"包 package\"></a>包 package</h2><p>定义：Java的类库管理机制，借助文件系统的目录</p>\n<ul>\n<li><p>为什么需要使用Package</p>\n<ul>\n<li>为了解决类的重名问题</li>\n<li>为了便于管理类：合适的类位于合适的包</li>\n</ul>\n</li>\n<li><p>怎么使用package</p>\n<ul>\n<li><p>通常是类的第一句非注释性语句</p>\n<ul>\n<li><p>规则：通常域名倒过来写，加上模块名</p>\n<blockquote>\n<p>com.qq.test</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字</p>\n<p>包名称内可以带有”.”，每个”.”代表文件系统的下一级目录</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package p1;</span><br><span class=\"line\">package p1.s1;</span><br></pre></td></tr></table></figure>\n<p>则在文件系统中，p1文件夹下有个名为s1的文件夹包</p>\n<h3 id=\"使用其它包里的类\"><a href=\"#使用其它包里的类\" class=\"headerlink\" title=\"使用其它包里的类:\"></a>使用其它包里的类:</h3><p>1 . 使用<strong>import</strong>预先声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import package1.T;  // 引入package1包里的T</span><br><span class=\"line\">import package2.*   // 引入package2包里的所有类</span><br><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2 . 每次使用时附带说明包的名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate package1.T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"API文档\"><a href=\"#API文档\" class=\"headerlink\" title=\"API文档\"></a>API文档</h2><p>使用<strong>JAVADOC</strong>生成API文档</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 解决代码文档分离的问题</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特殊的注释<ul>\n<li>文档注释： “/**”</li>\n</ul>\n</li>\n<li>常用的java注释标签<ul>\n<li>@Author 作者</li>\n<li>@version 版本</li>\n<li>@param 参数</li>\n<li>@return 返回值含义</li>\n<li>@throws 抛出异常描述</li>\n<li>@deprecated 废弃，建议用户不再使用该方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 类的描述、功能</span><br><span class=\"line\"> * @author aa</span><br><span class=\"line\"> * @version 1.0</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾回收机制-Garbage-Collection\"><a href=\"#垃圾回收机制-Garbage-Collection\" class=\"headerlink\" title=\"垃圾回收机制 (Garbage Collection)\"></a>垃圾回收机制 (Garbage Collection)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 对象空间的分配</span><br><span class=\"line\">    - 使用&quot;new&quot;关键字创建对象</span><br><span class=\"line\">- 对象空间的释放：</span><br><span class=\"line\">    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间</span><br><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 程序员无权调用垃圾回收器</span><br><span class=\"line\">    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行</span><br><span class=\"line\">    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"定义数组变量\"><a href=\"#定义数组变量\" class=\"headerlink\" title=\"定义数组变量\"></a>定义数组变量</h3><p>1 - &lt;类型&gt;[]&lt;数组名&gt;=new &lt;类型&gt;[元素个数];</p>\n<blockquote>\n<p>例如：</p>\n<p>int [] grade = new int [100];</p>\n<p>这样创建的数组会是默认的0值</p>\n</blockquote>\n<p>2 - &lt;类型&gt;[]&lt;数组名&gt;={元素1，元素2…};</p>\n<blockquote>\n<p>例如： int []a={1,2,3};</p>\n</blockquote>\n<p>3 - &lt;类型&gt;[]b = a; (a为同类型的数组)</p>\n<blockquote>\n<p>与c++中数组名的含义类似，数组名变量管理数组空间</p>\n<p>b和a管理同一个数组</p>\n</blockquote>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><p>1 - 所有元素的数据类型相同<br>2 - 一旦创建则不能改变大小</p>\n<h3 id=\"要求：\"><a href=\"#要求：\" class=\"headerlink\" title=\"要求：\"></a>要求：</h3><ul>\n<li>元素个数必须是整数</li>\n<li>元素个数必须给出</li>\n<li>元素个数可以是变量</li>\n</ul>\n<h3 id=\"内部成员：\"><a href=\"#内部成员：\" class=\"headerlink\" title=\"内部成员：\"></a>内部成员：</h3><p>length : 返回元素个数</p>\n<blockquote>\n<p>for(int i=0; i&lt;grade.length ; ++i)</p>\n</blockquote>\n<h3 id=\"数组和数组变量：\"><a href=\"#数组和数组变量：\" class=\"headerlink\" title=\"数组和数组变量：\"></a>数组和数组变量：</h3><ul>\n<li>数组变量为数组的管理者，而非其本身</li>\n<li>数组创建出来后交给数组变量管理</li>\n<li>数组变量之间的赋值为管理权限的赋予</li>\n<li>数组变量的比较是判断是否管理同一个数组</li>\n</ul>\n<h3 id=\"常用操作：\"><a href=\"#常用操作：\" class=\"headerlink\" title=\"常用操作：\"></a>常用操作：</h3><ol>\n<li><p>数组复制<br>System的arraycopy函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void arraycopy(Object src,</span><br><span class=\"line\">                             int srcPos,</span><br><span class=\"line\">                             Object dest,</span><br><span class=\"line\">                             int destPos,</span><br><span class=\"line\">                             int length)</span><br><span class=\"line\">// src 源数组</span><br><span class=\"line\">// srcPos 源数组开始复制的位置</span><br><span class=\"line\">// dest 目标数组</span><br><span class=\"line\">// destPos 目标数组开始复制的位置</span><br><span class=\"line\">// length 复制长度</span><br><span class=\"line\">// [srcPos,srcPos+length-1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>二分查找<br>Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口<br>Arrays.binarySearch(Object obj, Object goal);</p>\n</li>\n<li><p>填充<br>Arrays.fill(Object obj, int start, int end, Object goal)<br>将目标数组[start,end)填充为goal</p>\n</li>\n</ol>\n<h3 id=\"for-each循环：\"><a href=\"#for-each循环：\" class=\"headerlink\" title=\"for-each循环：\"></a>for-each循环：</h3><p>例如：for( int k: data )</p>\n<p>对于data数组的每一个元素，循环每一轮取一个元素作为k</p>\n<p>第一轮 k=data[0] , 第二轮 k=data[1]</p>\n<p><strong>for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值</strong></p>\n<h2 id=\"包裹类型\"><a href=\"#包裹类型\" class=\"headerlink\" title=\"包裹类型\"></a>包裹类型</h2><ul>\n<li>每种基础类型都有对应的包裹类型</li>\n<li>出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>基础类型</th>\n<th>包裹类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用处：\"><a href=\"#用处：\" class=\"headerlink\" title=\"用处：\"></a>用处：</h3><ul>\n<li>声明变量时包裹类型同基础类型</li>\n</ul>\n<blockquote>\n<p>int a=1; &lt;=&gt; Integer a=1;</p>\n</blockquote>\n<ul>\n<li>可以获取该类型的信息，如最大值最小值</li>\n</ul>\n<blockquote>\n<p>如 System.out.println(Integer.MAX_VALUE);</p>\n<p>( Integer.MAX_VALUE=2147483647 )</p>\n</blockquote>\n<ul>\n<li>Character</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数声明</th>\n<th>参数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static boolean isDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字</td>\n</tr>\n<tr>\n<td>static boolean isLetter</td>\n<td>char ch</td>\n<td>判断该字符是否是字母</td>\n</tr>\n<tr>\n<td>static boolean isLetterOrDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字或字母</td>\n</tr>\n<tr>\n<td>static boolean isLowerCase</td>\n<td>char ch</td>\n<td>判断该字符是否是小写字母</td>\n</tr>\n<tr>\n<td>static boolean isUpperCase</td>\n<td>char ch</td>\n<td>判断该字符是否是大写字母</td>\n</tr>\n<tr>\n<td>static boolean isWhitespace</td>\n<td>char ch</td>\n<td>判断该字符是否是一种空格</td>\n</tr>\n<tr>\n<td>static char toLowerCase</td>\n<td>char ch</td>\n<td>把该字符转换成小写</td>\n</tr>\n<tr>\n<td>static char toUpperCase</td>\n<td>char ch</td>\n<td>把该字符转换成大写</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>转换仅体现在返回值，原变量的值没有改变</strong></p>\n<h4 id=\"自动装箱和自动拆箱-auto-boxing-amp-unboxing\"><a href=\"#自动装箱和自动拆箱-auto-boxing-amp-unboxing\" class=\"headerlink\" title=\"自动装箱和自动拆箱 auto-boxing &amp; unboxing\"></a>自动装箱和自动拆箱 auto-boxing &amp; unboxing</h4><ul>\n<li>自动装箱<ul>\n<li>基本类型自动封装到和它相同类型的包装里</li>\n<li>本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);</li>\n</ul>\n</li>\n<li>自动拆箱<ul>\n<li>包装类对象自动转换成基本数据类型</li>\n<li>本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"缓存处理\"><a href=\"#缓存处理\" class=\"headerlink\" title=\"缓存处理\"></a><strong>缓存处理</strong></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer d1=1234;</span><br><span class=\"line\">Integer d2=1234;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d1==d2);</span><br><span class=\"line\">System.out.println(d1.equals(d2));</span><br><span class=\"line\"></span><br><span class=\"line\">Integer d3=123;</span><br><span class=\"line\">Integer d4=123;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d3==d4);</span><br><span class=\"line\">System.out.println(d3.equals(d4));</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<blockquote>\n<p>false (d1==d2)<br>true (d1.equals(d2))<br>true (d3==d4)<br>true (d3.equals(d4))</p>\n</blockquote>\n<h2 id=\"字符串-String\"><a href=\"#字符串-String\" class=\"headerlink\" title=\"字符串 String\"></a>字符串 String</h2><ul>\n<li>String是一个类，String变量是对象的管理者而非所有者</li>\n</ul>\n<h3 id=\"创建：\"><a href=\"#创建：\" class=\"headerlink\" title=\"创建：\"></a>创建：</h3><p>1 - String s = new String(“hello world”);</p>\n<p>2 - String s = “hello”;</p>\n<h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><ul>\n<li>用 “+” 连接两个字符串</li>\n</ul>\n<blockquote>\n<p>“hello “+”world” -&gt; “hello world”</p>\n</blockquote>\n<ul>\n<li>若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接</li>\n</ul>\n<blockquote>\n<p>“I am “+18 -&gt; “I am 18”</p>\n<p>1+2+”age” -&gt; “3age”</p>\n<p>“age”+1+2 -&gt; “age12”</p>\n</blockquote>\n<h3 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h3><ul>\n<li>in.next();<br>读入一个单词，以空格结束</li>\n<li>in.nextLine();<br>读入一整行</li>\n</ul>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><ul>\n<li>用 “==” ：比较两个对象是同一个字符串</li>\n</ul>\n<blockquote>\n<p>if(input == “hello”)</p>\n</blockquote>\n<ul>\n<li>用 “.equals” ：比较两个字符串的内容是否相同</li>\n</ul>\n<blockquote>\n<p>if(input.equals(“hello”))</p>\n</blockquote>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><ul>\n<li>字符串是<strong>对象</strong>，所有操作是通过“.”进行的</li>\n<li>表示对“.”左边的字符串做右边的操作</li>\n<li>字符串可以是<strong>变量</strong>也可以是<strong>常量</strong></li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p><strong>所有操作都不会对字符串本身进行修改</strong></p>\n<ul>\n<li>s1.compareTo(String s2)</li>\n</ul>\n<blockquote>\n<p>比较两个字符串大小</p>\n<p>s1&gt;s2 返回正数</p>\n<p>s1&lt;s2 返回负数</p>\n<p>s1和s2内容相同，返回0</p>\n<p>字符串长者大</p>\n<p>字符串长度相同时，从第一位开始以字典序比较</p>\n</blockquote>\n<ul>\n<li>s1.length()</li>\n</ul>\n<blockquote>\n<p>获得String的长度</p>\n</blockquote>\n<ul>\n<li>s1.charAt(int index)</li>\n</ul>\n<blockquote>\n<p>访问String里的字符</p>\n<p>返回index上的单个字符</p>\n<p>0&lt;=index&lt;=s1.length()-1</p>\n<p><strong>不能用for-each循环遍历字符串</strong></p>\n</blockquote>\n<ul>\n<li>s1.substring(int begin ,int end)</li>\n</ul>\n<blockquote>\n<p>获得 s1 下标于[begin,end)的子串</p>\n<p>end可省略，默认为s1.length()</p>\n</blockquote>\n<ul>\n<li>s1.indexOf( (char)|(String) c, int n)</li>\n</ul>\n<blockquote>\n<p>寻找c字符或字符串第一个所在位置，-1为不存在</p>\n<p>从n开始找(包括n)，n可以省略，默认为0</p>\n<p>s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()</p>\n<p>寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);</p>\n</blockquote>\n<ul>\n<li>s1.startsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的前缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.endsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的后缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.trim()</li>\n</ul>\n<blockquote>\n<p>清除s1左右两端的空格</p>\n<p>要保留清除可以 s1=s1.trim();</p>\n</blockquote>\n<ul>\n<li>s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)</li>\n</ul>\n<blockquote>\n<p>将s1中所有字符或字符串c1替换成c2</p>\n</blockquote>\n<ul>\n<li>s1.toLowerCase() s1.toUpperCase()</li>\n</ul>\n<blockquote>\n<p>s1大小写切换</p>\n</blockquote>\n<ul>\n<li>s1.split(char a)</li>\n</ul>\n<blockquote>\n<p>以a作为分隔符分割字符串s1，将结果作为字符串数组返回</p>\n<p>String [] s= s1.split(“ “);</p>\n<p>多种分隔符用”|”分割，(“a”|”b”)</p>\n<p>以”.””|”作为分隔符时要加”\\“，即(\\.)(\\|)</p>\n</blockquote>\n<h3 id=\"StringBuilder-和-StringBuffer\"><a href=\"#StringBuilder-和-StringBuffer\" class=\"headerlink\" title=\"StringBuilder 和 StringBuffer\"></a>StringBuilder 和 StringBuffer</h3><p>StringBuilder：线程不安全，效率高<br>StringBuffer：线程安全，效率低<br>两者基本相同</p>\n<p>String无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。</p>\n<p>用StringBuffer/StringBuilder能够很好解决string的扩展问题</p>\n<ul>\n<li><p>StringBuilder sb= new StringBuilder();</p>\n</li>\n<li><p>sb.append(“1”);</p>\n<blockquote>\n<p>扩展字符串<br>其返回值为StringBuilder,因此可以连续调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; // JDK源码</span><br><span class=\"line\">&gt; @Override</span><br><span class=\"line\">&gt; public StringBuilder append(String str) &#123;</span><br><span class=\"line\">&gt;     super.append(str);</span><br><span class=\"line\">&gt;     return this;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; // 因此可以使用</span><br><span class=\"line\">&gt; sb.append(&quot;1&quot;).append(&quot;2&quot;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>sb.toString();</p>\n<blockquote>\n<p>将StringBuilder形成字符串，可作为函数的String返回值</p>\n</blockquote>\n</li>\n<li><p>sb.delete(int start , int end);</p>\n<blockquote>\n<p>删除下标为[start,end)的字符</p>\n</blockquote>\n</li>\n<li><p>sb.reverse();</p>\n<blockquote>\n<p>反转sb</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"容量机制\"><a href=\"#容量机制\" class=\"headerlink\" title=\"容量机制\"></a>容量机制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）</span><br><span class=\"line\">- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度</span><br><span class=\"line\">- 扩容为当前容量*2+2</span><br></pre></td></tr></table></figure>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>对象变量是对象的<strong>管理者</strong></p>\n<ul>\n<li>T tem = new T();</li>\n</ul>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><ul>\n<li>定义：类内部的变量</li>\n<li>特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数</li>\n<li>若没有初始化，则会自动被赋值(0)</li>\n<li>初始化<ul>\n<li>定义时就可以给出初始值</li>\n<li>对象变量的0值表示没有管理任何对象，也可以主动给null值</li>\n<li>定义初始化可以调用函数，可以使用已经定义的成员变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tint b=f();</span><br><span class=\"line\">\tint f() &#123;return 1;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li>名字和类名字完全相同，创建对象时会自动调用</li>\n<li>没有返回值</li>\n<li>调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句</li>\n</ul>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><ul>\n<li>定义：同名但参数列表不同的函数</li>\n<li>可以有多个构造函数，但参数列表要不同</li>\n<li>构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tT() &#123;a=2;&#125;</span><br><span class=\"line\">\tT(int a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis();</span><br><span class=\"line\">\t\tthis.a=a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1-&gt;2-&gt;3，调用过程为：T(int a)-&gt;T()-&gt;int a=1;-&gt;执行T()-&gt;执行T(int a)</p>\n<h3 id=\"访问属性\"><a href=\"#访问属性\" class=\"headerlink\" title=\"访问属性\"></a>访问属性</h3><ul>\n<li>public (同c++)</li>\n<li>private (同c++)</li>\n<li>protected (同c++)</li>\n<li>friendly</li>\n</ul>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h4><ul>\n<li>任何人都可以直接使用<ul>\n<li>任何函数或定义初始化中可以使用</li>\n<li>使用是指调用、访问、定义变量</li>\n</ul>\n</li>\n<li>public类必须定义在自己的文件里</li>\n<li>一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)</li>\n</ul>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><ul>\n<li>只有类的内部能够访问<ul>\n<li>类的成员函数</li>\n<li>定义初始化</li>\n</ul>\n</li>\n<li>限制是针对类而非对象<ul>\n<li>对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"friendly\"><a href=\"#friendly\" class=\"headerlink\" title=\"friendly\"></a>friendly</h4><ul>\n<li>未加private或public声明的成员 (即<strong>默认值</strong>)</li>\n<li>属于同一个包内的所有类都可以访问</li>\n</ul>\n<h3 id=\"System-out-println\"><a href=\"#System-out-println\" class=\"headerlink\" title=\"System.out.println\"></a>System.out.println</h3><p>正常情况下，调用System.out.println直接输出类的对象，则会输出其地址</p>\n<p>若是在类中包含 public String toString 函数，则在println时自动调用该函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T&#123;</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">\tpublic String toString () &#123;return &quot;&quot;+c;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h2><h3 id=\"时间处理：\"><a href=\"#时间处理：\" class=\"headerlink\" title=\"时间处理：\"></a>时间处理：</h3><h4 id=\"java-util-Date\"><a href=\"#java-util-Date\" class=\"headerlink\" title=\"java.util.Date\"></a>java.util.Date</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG\" alt=\"mark\"></p>\n<ul>\n<li>对象表示一个特定的瞬间，精确到毫秒</li>\n<li>时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long</li>\n</ul>\n<h4 id=\"DateFormat-SimpleDateFormat\"><a href=\"#DateFormat-SimpleDateFormat\" class=\"headerlink\" title=\"DateFormat, SimpleDateFormat\"></a>DateFormat, SimpleDateFormat</h4><p>java.text.*</p>\n<ul>\n<li>用来将字符串和时间相互转换</li>\n<li>DateFormat 是抽象类，无法实例化对象</li>\n<li>SimpleDateFormat非抽象类</li>\n</ul>\n<p>使用方法（详见API文档）</p>\n<ol>\n<li><p>已知毫秒转相应时间和字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);</span><br><span class=\"line\">DateFormat df1 = new SimpleDateFormat(&quot;yy-MM-dd hh:mm:ss&quot;);</span><br><span class=\"line\">Date d = new Date(1321454564);</span><br><span class=\"line\">String str=df1.format(d);</span><br><span class=\"line\">System.out.println(str);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知字符串及输入格式转毫秒数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str2 = &quot;1977-07-07&quot;;</span><br><span class=\"line\">DateFormat df2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tDate d2 = df2.parse(str2);</span><br><span class=\"line\">\tSystem.out.println(d2);</span><br><span class=\"line\">&#125; catch (ParseException e) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated catch block</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Calendar，GregorianCalendar-日历类\"><a href=\"#Calendar，GregorianCalendar-日历类\" class=\"headerlink\" title=\"Calendar，GregorianCalendar 日历类\"></a>Calendar，GregorianCalendar 日历类</h4><p>java.util.*</p>\n<ul>\n<li>Calendar是抽象类，无法实例化对象</li>\n<li>GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统</li>\n<li>Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期</li>\n<li>注意<ul>\n<li>月份：1月是0，2月是1，…12月是11<ul>\n<li>星期：周日是1，周一是2…周六是7</li>\n<li>可以使用 Calendar.FEBRUARY 表示数字</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>使用方法：（详见API文档）</p>\n<ol>\n<li><p>整体设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c = new GregorianCalendar();</span><br><span class=\"line\">c.set(2001, Calendar.FEBRUARY ,15);</span><br><span class=\"line\">Date date = c.getTime();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单独设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.set(Calendar.YEAR , 2001);</span><br><span class=\"line\">c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);</span><br><span class=\"line\">// 未设置参数则自动采用当前时间 (日期、时分秒等)</span><br><span class=\"line\">System.out.println(c.get(Calendar.YEAR));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用Date赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.setTime(new Date());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.add(Calendar.YEAR, 30);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"File-类\"><a href=\"#File-类\" class=\"headerlink\" title=\"File 类\"></a>File 类</h3><p>java.io.File:文件和目录路径名的抽象表现形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 通过File对象可以访问、修改文件属性</span><br><span class=\"line\">- 可以创建空文件或目录</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = new File(&quot;d:/aaa/bbb/ccc&quot;);</span><br><span class=\"line\">f.mkdir();  // 若父目录存在则创建</span><br><span class=\"line\">f.mkdirs(); // 若父目录不存在则自动创建父目录</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><ul>\n<li><p>容器类的两个类型：</p>\n<p>1 . 容器的类型</p>\n<p>2 . 元素的类型</p>\n</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li><p>import java.util.ArrayList;</p>\n</li>\n<li><p>特点：元素可以相同，元素以与进入的顺序排序</p>\n</li>\n<li><p>基础类型：存放值</p>\n</li>\n<li><p>非基础类型：作为管理者，存放地址</p>\n</li>\n<li><p>定义：</p>\n<p>ArrayList notes = new ArrayList();</p>\n</li>\n</ul>\n<h4 id=\"常用操作-1\"><a href=\"#常用操作-1\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>notes.add(int location, String s);</li>\n</ul>\n<blockquote>\n<p>向下标为location的位置中插入元素</p>\n<p>location可省略，默认为末尾</p>\n</blockquote>\n<ul>\n<li>notes.size();</li>\n</ul>\n<blockquote>\n<p>返回容器中存放元素数目</p>\n</blockquote>\n<ul>\n<li>notes.get(int index);</li>\n</ul>\n<blockquote>\n<p>返回下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>nodes.remove(int index);</li>\n</ul>\n<blockquote>\n<p>移除下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>notes.toArray(String []a);</li>\n</ul>\n<blockquote>\n<p>将notes里所有元素依次填入a中</p>\n</blockquote>\n<h4 id=\"for-each循环\"><a href=\"#for-each循环\" class=\"headerlink\" title=\"for-each循环\"></a>for-each循环</h4><p>若ArrayList存放的非基础类型，则for-each中可以修改值</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><ul>\n<li>import java.util.HashSet</li>\n<li>特点：元素均不相同，不排序，与进入的顺序无关</li>\n</ul>\n<h3 id=\"Hash表-散列表\"><a href=\"#Hash表-散列表\" class=\"headerlink\" title=\"Hash表(散列表)\"></a>Hash表(散列表)</h3><ul>\n<li>import java.util.HashMap;</li>\n<li>HashMap &lt; Key, Value &gt; a=new HashMap &lt; Key,Value &gt; ();<br>数据以一对值放进去，一个为键(KEY),一个为值(value)<br>值对应键</li>\n<li>键不能重复，只留相同的最后一个，元素不以先后排序</li>\n</ul>\n<h4 id=\"常用操作-2\"><a href=\"#常用操作-2\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>a.put(Key k1, Value v1);</li>\n</ul>\n<blockquote>\n<p>向HashMap里添加元素，键k1对应值为v1</p>\n</blockquote>\n<ul>\n<li>a.get(Key k);</li>\n</ul>\n<blockquote>\n<p>返回键k对应的值，若为空，则返回null</p>\n</blockquote>\n<ul>\n<li>a.containsKey(Key k);</li>\n</ul>\n<blockquote>\n<p>查询是否存在键为k的数据</p>\n</blockquote>\n<ul>\n<li>a.keySet();</li>\n</ul>\n<blockquote>\n<p>返回key的集合</p>\n<p>可以通过 a.keySet().size()获取存放的键的数目</p>\n<p>通过keySet使用for-each循环</p>\n</blockquote>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li><p>extends</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class son extends parent</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>java只允许单继承，一个类只能有一个父类</strong></p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>父类成员访问属性</th>\n<th>在父类中的含义</th>\n<th>在子类中的含义</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>对所有人开放</td>\n<td>对所有人开放</td>\n<td></td>\n</tr>\n<tr>\n<td>protected</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td></td>\n</tr>\n<tr>\n<td>缺省</td>\n<td>只有包内其它类可以访问</td>\n<td>如果子类与父类在同一个包内：只有包内其它类可以访问</td>\n<td>否则：相当于private，不能访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>只有自己可以访问</td>\n<td>不能访问</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>子类同样继承了父类的private成员，只是子类无法访问！<br>但子类可以通过调用父类的非private函数来间接修改父类的private成员变量</p>\n<h3 id=\"继承VS组合\"><a href=\"#继承VS组合\" class=\"headerlink\" title=\"继承VS组合\"></a>继承VS组合</h3><ul>\n<li>“is-a”关系使用继承<ul>\n<li>如：Bird类继承自Animal类</li>\n</ul>\n</li>\n<li>“has-a”关系使用组合<ul>\n<li>如：Computer类包含CPU类，每个Computer对象都有一个CPU对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><p>本质：一个<strong>关键字</strong>，类似this(this的本质为指针),是直接父类的引用</p>\n<p>用法<br>1 . 直接引用</p>\n<p>相当于指向当前对象的父类，用”.”访问父类的成员</p>\n<p>2 . 子类成员变量或方法与父类同名时，用super加以区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tvoid a();</span><br><span class=\"line\">\tvoid b()&#123;</span><br><span class=\"line\">\t\ta();   // son的a函数</span><br><span class=\"line\">\t\tsuper.a();  // parent的a函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3 . 调用父类的构造函数</p>\n<p>规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数</p>\n<p>子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tson(int a1)&#123;</span><br><span class=\"line\">\t\tsuper(a1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同名变量\"><a href=\"#同名变量\" class=\"headerlink\" title=\"同名变量\"></a>同名变量</h3><p>若没有明确指明，则在谁的成员函数中就使用谁的成员变量</p>\n<h3 id=\"子类和子类型\"><a href=\"#子类和子类型\" class=\"headerlink\" title=\"子类和子类型\"></a>子类和子类型</h3><ul>\n<li>类定义了类型</li>\n<li>子类定义了子类型 (son是parent的一个子类型)</li>\n<li>子类对象可以被当做父类的对象使用<ul>\n<li>赋值给父类变量</li>\n<li>传递给需要父类对象的函数</li>\n<li>放进存放分类对象的容器里</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG\" alt=\"mark\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v1 = new Vehicle();</span><br><span class=\"line\">Vehicle v2 = new Car();</span><br><span class=\"line\">Vehicle v3 = new Bicycle();</span><br></pre></td></tr></table></figure>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>主要用来实现<strong>动态联编</strong></p>\n<p>即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了</p>\n<p>以此提高系统的灵活性和扩展性</p>\n<h3 id=\"如何实现多态\"><a href=\"#如何实现多态\" class=\"headerlink\" title=\"如何实现多态\"></a>如何实现多态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 引用变量的两种类型</span><br><span class=\"line\"></span><br><span class=\"line\">    - 编译时类型（一般是父类）</span><br><span class=\"line\">        - 由声明时的类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">    - 运行时类型（运行时具体的子类）</span><br><span class=\"line\">        - 由实际对应的对象类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">- 三个必要条件</span><br><span class=\"line\">    - 要有继承</span><br><span class=\"line\">    - 要有方法重写</span><br><span class=\"line\">    - 父类引用指向子类对象</span><br></pre></td></tr></table></figure>\n<h3 id=\"多态变量\"><a href=\"#多态变量\" class=\"headerlink\" title=\"多态变量\"></a>多态变量</h3><ul>\n<li>对象变量能够保存不止一种的对象</li>\n<li>可以保存声明类型的对象或是声明类型的子类的对象</li>\n<li>子类对象赋给父类变量，发生<strong>向上造型</strong></li>\n</ul>\n<h3 id=\"造型-cast\"><a href=\"#造型-cast\" class=\"headerlink\" title=\"造型 cast\"></a>造型 cast</h3><p>造型(cast)：把一个类型的对象赋值给另一个类型的变量</p>\n<ul>\n<li>子类对象可以复制给父类变量<ul>\n<li>与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象</li>\n</ul>\n</li>\n<li>父类对象不能赋值给子类变量</li>\n<li>可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行</li>\n<li>类型转换 ！= 造型<ul>\n<li>类型转换中对象发生改变，如 int i=(int)10.2;</li>\n<li>造型中对象本身没有改变，只是改变了看待它的方式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v;</span><br><span class=\"line\">Car car = new Car();</span><br><span class=\"line\">v=car;  //可以</span><br><span class=\"line\">c=v;   //编译错误</span><br><span class=\"line\">c=(Car)v // 编译通过</span><br><span class=\"line\"></span><br><span class=\"line\">若</span><br><span class=\"line\">Vehicle v=new Vehicle();</span><br><span class=\"line\">Car car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常</span><br></pre></td></tr></table></figure>\n<h4 id=\"向上造型\"><a href=\"#向上造型\" class=\"headerlink\" title=\"向上造型\"></a>向上造型</h4><ul>\n<li>子类对象当做父类对象使用</li>\n<li>向上造型是默认的，不需要运算符</li>\n<li>向上造型是安全的</li>\n</ul>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数</p>\n<ul>\n<li>静态绑定：根据变量声明类型决定</li>\n<li>动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )</li>\n<li>默认使用动态绑定</li>\n<li>成员函数中调用其它成员函数通过this变量调用</li>\n</ul>\n<h3 id=\"覆盖-override\"><a href=\"#覆盖-override\" class=\"headerlink\" title=\"覆盖 override\"></a>覆盖 override</h3><ul>\n<li>覆盖关系：子类和父类中存在名称和参数表完全相同的函数</li>\n<li>通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数</li>\n</ul>\n<h3 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h3><ul>\n<li>所有的类都继承自Object类</li>\n<li>几乎所有OOP都有Object类（除c++）</li>\n</ul>\n<h4 id=\"Object类的函数-部分\"><a href=\"#Object类的函数-部分\" class=\"headerlink\" title=\"Object类的函数(部分)\"></a>Object类的函数(部分)</h4><ul>\n<li>toString()</li>\n<li>equals()</li>\n</ul>\n<h3 id=\"多态的内存分析\"><a href=\"#多态的内存分析\" class=\"headerlink\" title=\"多态的内存分析\"></a>多态的内存分析</h3><p>1 . 基本的继承关系和方法调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：Animal  有voice方法</span><br><span class=\"line\">- 子类：Cat 重写voice方法，自己有catchMouse方法</span><br><span class=\"line\">- 测试：分别声明父类和子类变量并指向子类对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void showVoice(Animal c) &#123;</span><br><span class=\"line\">\t\tc.voice();</span><br><span class=\"line\">\t\tif(c instanceof Cat)</span><br><span class=\"line\">\t\t\t((Cat) c).catchMouse();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tAnimal a=new Cat();</span><br><span class=\"line\">\t\tCat cat=(Cat)a;</span><br><span class=\"line\">\t\tTest.showVoice(cat);</span><br><span class=\"line\">\t\tTest.showVoice(a);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid voice() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Cat extends Animal&#123;</span><br><span class=\"line\">\tvoid voice() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;miao&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tvoid catchMouse() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG\" alt=\"mark\"></p>\n<p>2 . 深化多态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法</span><br><span class=\"line\">- 子类：MyServlet 重写了doGet方法</span><br><span class=\"line\">- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HttpServlet &#123;</span><br><span class=\"line\">\tpublic void service() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.service()&quot;);</span><br><span class=\"line\">\t\tdoGet();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class MyServlet extends HttpServlet &#123;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;MyServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tHttpServlet s = new MyServlet();</span><br><span class=\"line\">\t\ts.service();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出结果：</span><br><span class=\"line\">// HttpServlet.service()</span><br><span class=\"line\">// MyServlet.doGet()</span><br></pre></td></tr></table></figure>\n<p>原因分析：<br>函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG\" alt=\"mark\"></p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><h3 id=\"消除代码复制\"><a href=\"#消除代码复制\" class=\"headerlink\" title=\"消除代码复制\"></a>消除代码复制</h3><ul>\n<li><p>代码复制是不良设计的一种表现</p>\n<p>解决方法：使用函数封装重复的代码</p>\n</li>\n</ul>\n<h3 id=\"增加可扩展性\"><a href=\"#增加可扩展性\" class=\"headerlink\" title=\"增加可扩展性\"></a>增加可扩展性</h3><ul>\n<li><p>后期的可维护性</p>\n<p>解决方法：用封装降低耦合，用接口实现聚合，借助类继承</p>\n<p>耦合：类和类之间的关系</p>\n<p>耦合越低越好</p>\n</li>\n</ul>\n<h2 id=\"抽象和接口\"><a href=\"#抽象和接口\" class=\"headerlink\" title=\"抽象和接口\"></a>抽象和接口</h2><p>关键词：<strong>abstract</strong> (抽象)</p>\n<blockquote>\n<p>public abstract class a</p>\n</blockquote>\n<ul>\n<li>抽象函数：表达概念而<strong>无法实现具体代码</strong>的函数</li>\n<li>抽象类：表达概念而<strong>无法构造出实体</strong>的类</li>\n<li>为什么需要抽象类<ul>\n<li><strong>模板模式</strong>，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展</li>\n<li><strong>通过抽象类，可以避免子类设计的随意性</strong>，严格限制子类的设计，使得子类之间更加通用。</li>\n</ul>\n</li>\n<li>抽象方法的意义：<strong>使方法的设计和实现分离！</strong></li>\n<li>要点：<ul>\n<li>有抽象函数的类一定是抽象类<ul>\n<li>抽象类<strong>不能制造对象</strong>，但可以定义变量</li>\n</ul>\n</li>\n<li>任何继承了抽象类的非抽象类对象可以赋值给抽象类变量</li>\n<li>抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用</li>\n<li>继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>关键词：<strong>interface</strong></p>\n<blockquote>\n<p>public interface a{}</p>\n</blockquote>\n<ul>\n<li>接口是纯抽象类(接口中只有常量、抽象方法)</li>\n<li>所有成员变量都是public abstract static final （默认的，可以不写）</li>\n<li>接口意义：设计和实现分离，利于大项目制作</li>\n<li>接口变量的含义为任何实现了接口的对象</li>\n</ul>\n<p>关键词：<strong>implements</strong></p>\n<blockquote>\n<p>public class b implements a{}</p>\n</blockquote>\n<ul>\n<li>类可以实现很多接口</li>\n<li>接口可以继承接口，不能继承类</li>\n<li>接口不能实现接口</li>\n<li>接口和抽象类<ul>\n<li>接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了<strong>规范和具体实现的分离</strong></li>\n<li><strong>接口就是规范，定义了一组规则</strong></li>\n<li><strong>接口的本质是契约</strong>，制定好后大家都遵守</li>\n<li>项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要<strong>面向接口编程</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向接口的编程方式\"><a href=\"#面向接口的编程方式\" class=\"headerlink\" title=\"面向接口的编程方式\"></a>面向接口的编程方式</h4><ul>\n<li>设计程序时先定义接口，再实现类</li>\n<li>任何需要在函数间传入传出的一定是接口而不是具体的类</li>\n<li>Java成功的关键之一，极适合多人同时写一个大程序</li>\n<li>Java被批评的要点之一，代码量膨胀地很快</li>\n</ul>\n<h2 id=\"控制反转与MVC模式\"><a href=\"#控制反转与MVC模式\" class=\"headerlink\" title=\"控制反转与MVC模式\"></a>控制反转与MVC模式</h2><h3 id=\"Swing\"><a href=\"#Swing\" class=\"headerlink\" title=\"Swing\"></a>Swing</h3><p>容器、部件</p>\n<ul>\n<li><p>容器继承自部件，因此可以作为部件被放入其它容器中</p>\n</li>\n<li><p>容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整</p>\n</li>\n<li><p>JFrame使用BorderLayout管理部件，并且将界面划分为五个区域</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG\" alt=\"mark\"></p>\n</li>\n<li><p>容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件</p>\n</li>\n</ul>\n<h3 id=\"控制反转\"><a href=\"#控制反转\" class=\"headerlink\" title=\"控制反转\"></a>控制反转</h3><ul>\n<li>按钮公布一个listener接口和一对注册、注销函数</li>\n<li>实现接口后将把listener对象注册在按钮上</li>\n<li>一旦按钮被按下，就会反过来调用listener对象的函数</li>\n</ul>\n<h3 id=\"内部类-innerclasses\"><a href=\"#内部类-innerclasses\" class=\"headerlink\" title=\"内部类 innerclasses\"></a>内部类 innerclasses</h3><p>定义在别的类内部、函数内部的类</p>\n<h4 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问</span><br><span class=\"line\">- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场合\"><a href=\"#使用场合\" class=\"headerlink\" title=\"使用场合\"></a>使用场合</h4><p>在内部类只为所在外部类提供服务的情况优先使用</p>\n<h4 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h4><h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>（可以使用private,public,protected修饰）</p>\n<h6 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h6><p><code>- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Outer &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tFace f=new Face();</span><br><span class=\"line\">\t\tFace.Nose n= f.new Nose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Face &#123;</span><br><span class=\"line\">\tint type;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass Nose&#123;</span><br><span class=\"line\">\t\tString type;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvoid breath() &#123;</span><br><span class=\"line\">\t\t\tFace.this.type=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 静态内部类对象存在时，不一定存在对应的外部类对象</span><br><span class=\"line\">    - 静态内部类无法直接访问外部类实例方法</span><br><span class=\"line\">    - 静态内部类看作**外部类的一个静态成员**</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Face f= new Face();</span><br><span class=\"line\">// Nose为非静态内部类</span><br><span class=\"line\">Face.Nose n=f.new Nose();</span><br><span class=\"line\">// Ear为静态内部类</span><br><span class=\"line\">Face.Ear e=new Face.Ear();</span><br></pre></td></tr></table></figure>\n<h6 id=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"><a href=\"#局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\" class=\"headerlink\" title=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"></a>局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 访问函数的本地变量时只能访问函数的final变量</span><br></pre></td></tr></table></figure>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>适用于只需要使用一次的类，例如：键盘监听操作等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new 父类构造器(实参) 实现接口()&#123;</span><br><span class=\"line\">\t匿名内部类类体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名类可以继承某类，也可以实现接口</li>\n<li>Swing的消息机制广泛使用匿名类</li>\n</ul>\n<h3 id=\"MVC设计模式\"><a href=\"#MVC设计模式\" class=\"headerlink\" title=\"MVC设计模式\"></a>MVC设计模式</h3><ul>\n<li><p>数据、表现和控制</p>\n<p>三者分离</p>\n<ul>\n<li>M = Model 模型</li>\n<li>V = View 表现</li>\n<li>C = Control 控制</li>\n</ul>\n</li>\n<li><p>模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新</p>\n</li>\n<li><p>表现：从模型获取数据，根据数据画出表现</p>\n</li>\n<li><p>控制：从用户得到输入，根据输入调整数据</p>\n</li>\n</ul>\n<h3 id=\"异常机制-Exception\"><a href=\"#异常机制-Exception\" class=\"headerlink\" title=\"异常机制 Exception\"></a>异常机制 Exception</h3><h4 id=\"常见的异常\"><a href=\"#常见的异常\" class=\"headerlink\" title=\"常见的异常\"></a>常见的异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户输入错误</span><br><span class=\"line\">设备错误</span><br><span class=\"line\">硬件问题：如打印机关掉、服务器问题</span><br><span class=\"line\">磁盘满了</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常Exception\"><a href=\"#异常Exception\" class=\"headerlink\" title=\"异常Exception\"></a>异常Exception</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java提供的用来处理程序中错误的一种机制</span><br><span class=\"line\"></span><br><span class=\"line\">Java采用**面向对象** 方式来处理异常。处理过程：</span><br><span class=\"line\">    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE</span><br><span class=\"line\">    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"常见异常\"><a href=\"#常见异常\" class=\"headerlink\" title=\"常见异常\"></a>常见异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. ArithmeticException</span><br><span class=\"line\">    例如试图除以0</span><br><span class=\"line\">2. NullPointerException</span><br><span class=\"line\">    对象为null但调用了对象的方法或属性</span><br><span class=\"line\">3. ClassCastException</span><br><span class=\"line\">    转型错误，解决：使用istanceof判断</span><br><span class=\"line\">4. ArrayIndexOutOfBoundsException</span><br><span class=\"line\">    访问元素超出数组长度</span><br><span class=\"line\">5. NumberFormatException</span><br><span class=\"line\">    数字格式异常，如把String转换成int</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常的处理方法：\"><a href=\"#异常的处理方法：\" class=\"headerlink\" title=\"异常的处理方法：\"></a>异常的处理方法：</h4><p><code>捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常</code></p>\n<h4 id=\"方法重写中声明异常原则：\"><a href=\"#方法重写中声明异常原则：\" class=\"headerlink\" title=\"方法重写中声明异常原则：\"></a>方法重写中声明异常原则：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**子类声明的异常范围不能超出父类的范围**</span><br><span class=\"line\">    - 父类没有声明异常，子类也不能</span><br><span class=\"line\">    - 不能抛出 原有方法抛出的父类或上层类</span><br><span class=\"line\">    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类</span><br><span class=\"line\">- 从Exception类或它的子类派生一个子类</span><br><span class=\"line\">- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">建议：</span><br><span class=\"line\">    - 避免使用异常机制代替错误处理</span><br><span class=\"line\">    - 处理异常不能代替简单测试</span><br><span class=\"line\">    - 不要进行**小力度**的异常处理（如一行一个try catch）</span><br><span class=\"line\">    - 异常往往在**高层**处理</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>JAVA学习过程中的简要笔记</p>\n<p>从已有C++基础的前提下开始学习java</p>\n<p>内容包括java的特性和机制、基本的语法、数组、几个容器、面向对象三大特性、内部类、异常处理、常见的类和简单的内存分析等</p>","more":"<h3 id=\"各版本和体系架构\"><a href=\"#各版本和体系架构\" class=\"headerlink\" title=\"各版本和体系架构\"></a>各版本和体系架构</h3><ul>\n<li>J2EE<ul>\n<li>JAVA 2(to) Enterprise Edition:</li>\n<li>定位在服务器端的应用</li>\n</ul>\n</li>\n<li>J2SE<ul>\n<li>JAVA 2(to) Standard Edition:</li>\n<li>定位在个人计算机的应用</li>\n</ul>\n</li>\n<li>J2EE<ul>\n<li>JAVA 2(to) Micro Edition:</li>\n<li>定位在消费性电子产品的应用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- JDK</span><br><span class=\"line\">    - Java Development Kit Java开发工具包</span><br><span class=\"line\">- JRE</span><br><span class=\"line\">    - Java Runtime Environment java运行环境</span><br><span class=\"line\">- JVM</span><br><span class=\"line\">    - Java Virtual Machine java虚拟机</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/gg4hmL0CDi.JPG\" alt=\"数据类型\"></p>\n<h3 id=\"整型变量\"><a href=\"#整型变量\" class=\"headerlink\" title=\"整型变量\"></a>整型变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 表示形式</span><br><span class=\"line\">    - 十进制</span><br><span class=\"line\">    - 八进制：以0开头</span><br><span class=\"line\">    - 十六进制：以0x或0X开头</span><br></pre></td></tr></table></figure>\n<p>整型默认为int型，long型常量后加”l”或”L”</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>1字节</td>\n<td>-128~127</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2字节</td>\n<td>-$2^15$~$2^15-1$</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4字节</td>\n<td>-$2^31$~$2^31-1$</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8字节</td>\n<td>-$2^63$~$2^63-1$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>超过long的数字使用<strong>BigInteger</strong>类</li>\n</ul>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>占用空间</th>\n<th>表示范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>4字节</td>\n<td>-3.403E38~3.403E38</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>-1.798E308~1.798E308</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>默认为double</li>\n<li>若需要不产生舍入误差的精确计算，需要用<strong>BigDecimal</strong>类</li>\n<li>double变float：在数字后加”f”或”F”</li>\n</ul>\n<h3 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h3><ul>\n<li>char采用Unicode编码表，，占用2个字节</li>\n<li>同c++,可以和整数相互转型，可以使用转义字符</li>\n</ul>\n<h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><ul>\n<li>占1位(非字节)</li>\n<li>java中boolean无法和整数之间转换</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 变量使用前需要声明</span><br></pre></td></tr></table></figure>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>类似c++的const</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- final修饰变量，则该变量无法修改</span><br><span class=\"line\">- final修饰类，则说明该类不能被继承，不能有子类</span><br><span class=\"line\">    - 如 Math、String</span><br><span class=\"line\">- final修饰方法，则该方法不能被子类重写，但是可以被重载</span><br></pre></td></tr></table></figure>\n<p><strong>命名规范</strong>：</p>\n<ul>\n<li>变量、方法名：<ul>\n<li>首字母小写+驼峰原则</li>\n</ul>\n</li>\n<li>常量：<ul>\n<li>大写字母+下划线</li>\n</ul>\n</li>\n<li>类名：<ul>\n<li>首字母大写+驼峰原则</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 算术运算符： +,-,*,/,%,++,--</span><br><span class=\"line\">    - 不同于c++, java中浮点数可以使用&quot;%&quot;运算符！</span><br><span class=\"line\">    - 加号两边只要有一个字符串，则为字符串连接符，整个结果为字符串</span><br><span class=\"line\">- 赋值运算符： =</span><br><span class=\"line\">- 关系运算符： &lt;,&gt;,&lt;=,&gt;=,==,!=, instanceof</span><br><span class=\"line\">    - instanceof 判断内存中实际对象是否属于某个类 （通常用于造型cast）</span><br><span class=\"line\">        - 返回值：boolean  true代表属于</span><br><span class=\"line\">        - 使用： boolean ret= a instanceof A;</span><br><span class=\"line\">- 逻辑运算符： &amp;&amp;,||,!</span><br><span class=\"line\">    - 同c++,逻辑与和或采用**短路**方式，从左至右，若确定了值则不会继续计算</span><br><span class=\"line\">- 位运算符： &amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</span><br><span class=\"line\">    - &gt;&gt; 表示有符号右移：左边以该数的符号位补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;1 右移一位： 00111</span><br><span class=\"line\">        - 10010&gt;&gt;1 右移一位： 11001</span><br><span class=\"line\">    - &gt;&gt;&gt; 表示无符号右移：左边以0补充，移出的部分将抛弃</span><br><span class=\"line\">        - 01110&gt;&gt;&gt;1 右移一位：00111   (正数时和&quot;&gt;&gt;&quot;相同)</span><br><span class=\"line\">        - 10010&gt;&gt;&gt;1 右移一位：01001</span><br><span class=\"line\">    - &lt;&lt; 没有 &quot;&lt;&lt;&lt;&quot;</span><br><span class=\"line\">- 条件运算符：  ?:</span><br><span class=\"line\">- 扩展赋值运算符： +=,-=,*=,/=,%=</span><br></pre></td></tr></table></figure>\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><ul>\n<li>在JDK7之前，switch表达式结果只能是Int(可以转Int的byte,char,short),枚举类型</li>\n<li>JDK7之后，switch表达式结果还可以是字符串</li>\n<li>使用方法同c++,进入一条语句后若未遇到break则自动执行下面的所有语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcase 1: break;</span><br><span class=\"line\">\tcase 2: System.out.println(1);</span><br><span class=\"line\">\tdefault: break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h3><ul>\n<li>if,while语句同c++</li>\n<li>while中可以使用break,continue关键字</li>\n<li>goto作为保留字无法作为变量，但也不能使用，取而代之的是带标签的continue和break</li>\n<li>可以使用带标签的continue和break<ul>\n<li>带标签的continue：跳转继续执行标签指向的循环</li>\n<li>带标签的break：停止标签指向的循环，跳至标签外的那层循环（若存在）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"方法-method，function\"><a href=\"#方法-method，function\" class=\"headerlink\" title=\"方法 method，function\"></a>方法 method，function</h3><p>[修饰符1 修饰符2..] 返回值 方法名(形参列表){<br>语句<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- **Java中只有值传递！**</span><br><span class=\"line\">- 基本类型传递数据值本身，引用类型传递对象的引用而非对象本身</span><br><span class=\"line\">    - 即：基本类型传进去副本，不改变原来的值，引用类型传进去的为引用，会改变原来的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存分析\"><a href=\"#内存分析\" class=\"headerlink\" title=\"内存分析\"></a>内存分析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 栈</span><br><span class=\"line\">    - 存放：局部变量</span><br><span class=\"line\">    - 自动分配连续的空间</span><br><span class=\"line\">- 堆</span><br><span class=\"line\">    - 存放new出来的对象</span><br><span class=\"line\">    - 空间不连续</span><br><span class=\"line\">- 方法区</span><br><span class=\"line\">    - 包含于堆区</span><br><span class=\"line\">    - 存放：类的信息(代码)、static变量、常量池(字符串常量)等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid teach() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid study() &#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tStudent st1=new Student();</span><br><span class=\"line\">\t\tStudent st2=new Student();</span><br><span class=\"line\">\t\tst1.age=18;</span><br><span class=\"line\">\t\tst1.name=&quot;张三&quot;;</span><br><span class=\"line\">\t\tst2.age=30;</span><br><span class=\"line\">\t\tst2.name=&quot;李四&quot;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTeacher t1=new Teacher();</span><br><span class=\"line\">\t\tt1.age=30;</span><br><span class=\"line\">\t\tt1.name=&quot;李四&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170908/c3j416JG4A.JPG\" alt=\"mark\"></p>\n<h2 id=\"包-package\"><a href=\"#包-package\" class=\"headerlink\" title=\"包 package\"></a>包 package</h2><p>定义：Java的类库管理机制，借助文件系统的目录</p>\n<ul>\n<li><p>为什么需要使用Package</p>\n<ul>\n<li>为了解决类的重名问题</li>\n<li>为了便于管理类：合适的类位于合适的包</li>\n</ul>\n</li>\n<li><p>怎么使用package</p>\n<ul>\n<li><p>通常是类的第一句非注释性语句</p>\n<ul>\n<li><p>规则：通常域名倒过来写，加上模块名</p>\n<blockquote>\n<p>com.qq.test</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字</p>\n<p>包名称内可以带有”.”，每个”.”代表文件系统的下一级目录</p>\n<p>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package p1;</span><br><span class=\"line\">package p1.s1;</span><br></pre></td></tr></table></figure>\n<p>则在文件系统中，p1文件夹下有个名为s1的文件夹包</p>\n<h3 id=\"使用其它包里的类\"><a href=\"#使用其它包里的类\" class=\"headerlink\" title=\"使用其它包里的类:\"></a>使用其它包里的类:</h3><p>1 . 使用<strong>import</strong>预先声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import package1.T;  // 引入package1包里的T</span><br><span class=\"line\">import package2.*   // 引入package2包里的所有类</span><br><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2 . 每次使用时附带说明包的名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate package1.T t1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"API文档\"><a href=\"#API文档\" class=\"headerlink\" title=\"API文档\"></a>API文档</h2><p>使用<strong>JAVADOC</strong>生成API文档</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 解决代码文档分离的问题</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特殊的注释<ul>\n<li>文档注释： “/**”</li>\n</ul>\n</li>\n<li>常用的java注释标签<ul>\n<li>@Author 作者</li>\n<li>@version 版本</li>\n<li>@param 参数</li>\n<li>@return 返回值含义</li>\n<li>@throws 抛出异常描述</li>\n<li>@deprecated 废弃，建议用户不再使用该方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 类的描述、功能</span><br><span class=\"line\"> * @author aa</span><br><span class=\"line\"> * @version 1.0</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾回收机制-Garbage-Collection\"><a href=\"#垃圾回收机制-Garbage-Collection\" class=\"headerlink\" title=\"垃圾回收机制 (Garbage Collection)\"></a>垃圾回收机制 (Garbage Collection)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 对象空间的分配</span><br><span class=\"line\">    - 使用&quot;new&quot;关键字创建对象</span><br><span class=\"line\">- 对象空间的释放：</span><br><span class=\"line\">    - 将对象赋值为null即可，垃圾回收器将负责回收所有不可达的对象的内存空间</span><br><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 程序员无权调用垃圾回收器</span><br><span class=\"line\">    - 程序员可以通过System.gc()通知GC运行，但JAVA规范并不能保证立刻运行</span><br><span class=\"line\">    - finalize方法是JAVA提供给程序员用来释放对象或资源的方法，但尽量少用</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"定义数组变量\"><a href=\"#定义数组变量\" class=\"headerlink\" title=\"定义数组变量\"></a>定义数组变量</h3><p>1 - &lt;类型&gt;[]&lt;数组名&gt;=new &lt;类型&gt;[元素个数];</p>\n<blockquote>\n<p>例如：</p>\n<p>int [] grade = new int [100];</p>\n<p>这样创建的数组会是默认的0值</p>\n</blockquote>\n<p>2 - &lt;类型&gt;[]&lt;数组名&gt;={元素1，元素2…};</p>\n<blockquote>\n<p>例如： int []a={1,2,3};</p>\n</blockquote>\n<p>3 - &lt;类型&gt;[]b = a; (a为同类型的数组)</p>\n<blockquote>\n<p>与c++中数组名的含义类似，数组名变量管理数组空间</p>\n<p>b和a管理同一个数组</p>\n</blockquote>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><p>1 - 所有元素的数据类型相同<br>2 - 一旦创建则不能改变大小</p>\n<h3 id=\"要求：\"><a href=\"#要求：\" class=\"headerlink\" title=\"要求：\"></a>要求：</h3><ul>\n<li>元素个数必须是整数</li>\n<li>元素个数必须给出</li>\n<li>元素个数可以是变量</li>\n</ul>\n<h3 id=\"内部成员：\"><a href=\"#内部成员：\" class=\"headerlink\" title=\"内部成员：\"></a>内部成员：</h3><p>length : 返回元素个数</p>\n<blockquote>\n<p>for(int i=0; i&lt;grade.length ; ++i)</p>\n</blockquote>\n<h3 id=\"数组和数组变量：\"><a href=\"#数组和数组变量：\" class=\"headerlink\" title=\"数组和数组变量：\"></a>数组和数组变量：</h3><ul>\n<li>数组变量为数组的管理者，而非其本身</li>\n<li>数组创建出来后交给数组变量管理</li>\n<li>数组变量之间的赋值为管理权限的赋予</li>\n<li>数组变量的比较是判断是否管理同一个数组</li>\n</ul>\n<h3 id=\"常用操作：\"><a href=\"#常用操作：\" class=\"headerlink\" title=\"常用操作：\"></a>常用操作：</h3><ol>\n<li><p>数组复制<br>System的arraycopy函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void arraycopy(Object src,</span><br><span class=\"line\">                             int srcPos,</span><br><span class=\"line\">                             Object dest,</span><br><span class=\"line\">                             int destPos,</span><br><span class=\"line\">                             int length)</span><br><span class=\"line\">// src 源数组</span><br><span class=\"line\">// srcPos 源数组开始复制的位置</span><br><span class=\"line\">// dest 目标数组</span><br><span class=\"line\">// destPos 目标数组开始复制的位置</span><br><span class=\"line\">// length 复制长度</span><br><span class=\"line\">// [srcPos,srcPos+length-1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>二分查找<br>Arrays.sort(Object obj); // 非基本类型需要实现Comparable接口<br>Arrays.binarySearch(Object obj, Object goal);</p>\n</li>\n<li><p>填充<br>Arrays.fill(Object obj, int start, int end, Object goal)<br>将目标数组[start,end)填充为goal</p>\n</li>\n</ol>\n<h3 id=\"for-each循环：\"><a href=\"#for-each循环：\" class=\"headerlink\" title=\"for-each循环：\"></a>for-each循环：</h3><p>例如：for( int k: data )</p>\n<p>对于data数组的每一个元素，循环每一轮取一个元素作为k</p>\n<p>第一轮 k=data[0] , 第二轮 k=data[1]</p>\n<p><strong>for-each循环复制基础类型数组元素，无法修改基础类型数组元素的值</strong></p>\n<h2 id=\"包裹类型\"><a href=\"#包裹类型\" class=\"headerlink\" title=\"包裹类型\"></a>包裹类型</h2><ul>\n<li>每种基础类型都有对应的包裹类型</li>\n<li>出现原因：基本数据类型不面向对象，但我们经常需要将基本数据转化成对象</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>基础类型</th>\n<th>包裹类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用处：\"><a href=\"#用处：\" class=\"headerlink\" title=\"用处：\"></a>用处：</h3><ul>\n<li>声明变量时包裹类型同基础类型</li>\n</ul>\n<blockquote>\n<p>int a=1; &lt;=&gt; Integer a=1;</p>\n</blockquote>\n<ul>\n<li>可以获取该类型的信息，如最大值最小值</li>\n</ul>\n<blockquote>\n<p>如 System.out.println(Integer.MAX_VALUE);</p>\n<p>( Integer.MAX_VALUE=2147483647 )</p>\n</blockquote>\n<ul>\n<li>Character</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数声明</th>\n<th>参数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static boolean isDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字</td>\n</tr>\n<tr>\n<td>static boolean isLetter</td>\n<td>char ch</td>\n<td>判断该字符是否是字母</td>\n</tr>\n<tr>\n<td>static boolean isLetterOrDigit</td>\n<td>char ch</td>\n<td>判断该字符是否是数字或字母</td>\n</tr>\n<tr>\n<td>static boolean isLowerCase</td>\n<td>char ch</td>\n<td>判断该字符是否是小写字母</td>\n</tr>\n<tr>\n<td>static boolean isUpperCase</td>\n<td>char ch</td>\n<td>判断该字符是否是大写字母</td>\n</tr>\n<tr>\n<td>static boolean isWhitespace</td>\n<td>char ch</td>\n<td>判断该字符是否是一种空格</td>\n</tr>\n<tr>\n<td>static char toLowerCase</td>\n<td>char ch</td>\n<td>把该字符转换成小写</td>\n</tr>\n<tr>\n<td>static char toUpperCase</td>\n<td>char ch</td>\n<td>把该字符转换成大写</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>转换仅体现在返回值，原变量的值没有改变</strong></p>\n<h4 id=\"自动装箱和自动拆箱-auto-boxing-amp-unboxing\"><a href=\"#自动装箱和自动拆箱-auto-boxing-amp-unboxing\" class=\"headerlink\" title=\"自动装箱和自动拆箱 auto-boxing &amp; unboxing\"></a>自动装箱和自动拆箱 auto-boxing &amp; unboxing</h4><ul>\n<li>自动装箱<ul>\n<li>基本类型自动封装到和它相同类型的包装里</li>\n<li>本质： Integer i=100; 编译器编译时： Integer i = new Integer(100);</li>\n</ul>\n</li>\n<li>自动拆箱<ul>\n<li>包装类对象自动转换成基本数据类型</li>\n<li>本质： int a = new Integer(100); 编译器编译：int a = new Integer(100).intValue();</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"缓存处理\"><a href=\"#缓存处理\" class=\"headerlink\" title=\"缓存处理\"></a><strong>缓存处理</strong></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  [-128,127]之间的数，仍然当做基本数据类型处理（增加效率）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer d1=1234;</span><br><span class=\"line\">Integer d2=1234;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d1==d2);</span><br><span class=\"line\">System.out.println(d1.equals(d2));</span><br><span class=\"line\"></span><br><span class=\"line\">Integer d3=123;</span><br><span class=\"line\">Integer d4=123;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(d3==d4);</span><br><span class=\"line\">System.out.println(d3.equals(d4));</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<blockquote>\n<p>false (d1==d2)<br>true (d1.equals(d2))<br>true (d3==d4)<br>true (d3.equals(d4))</p>\n</blockquote>\n<h2 id=\"字符串-String\"><a href=\"#字符串-String\" class=\"headerlink\" title=\"字符串 String\"></a>字符串 String</h2><ul>\n<li>String是一个类，String变量是对象的管理者而非所有者</li>\n</ul>\n<h3 id=\"创建：\"><a href=\"#创建：\" class=\"headerlink\" title=\"创建：\"></a>创建：</h3><p>1 - String s = new String(“hello world”);</p>\n<p>2 - String s = “hello”;</p>\n<h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><ul>\n<li>用 “+” 连接两个字符串</li>\n</ul>\n<blockquote>\n<p>“hello “+”world” -&gt; “hello world”</p>\n</blockquote>\n<ul>\n<li>若“+”一边为字符串一边非字符串，则将另一边表达为字符串而后进行连接</li>\n</ul>\n<blockquote>\n<p>“I am “+18 -&gt; “I am 18”</p>\n<p>1+2+”age” -&gt; “3age”</p>\n<p>“age”+1+2 -&gt; “age12”</p>\n</blockquote>\n<h3 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h3><ul>\n<li>in.next();<br>读入一个单词，以空格结束</li>\n<li>in.nextLine();<br>读入一整行</li>\n</ul>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><ul>\n<li>用 “==” ：比较两个对象是同一个字符串</li>\n</ul>\n<blockquote>\n<p>if(input == “hello”)</p>\n</blockquote>\n<ul>\n<li>用 “.equals” ：比较两个字符串的内容是否相同</li>\n</ul>\n<blockquote>\n<p>if(input.equals(“hello”))</p>\n</blockquote>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><ul>\n<li>字符串是<strong>对象</strong>，所有操作是通过“.”进行的</li>\n<li>表示对“.”左边的字符串做右边的操作</li>\n<li>字符串可以是<strong>变量</strong>也可以是<strong>常量</strong></li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p><strong>所有操作都不会对字符串本身进行修改</strong></p>\n<ul>\n<li>s1.compareTo(String s2)</li>\n</ul>\n<blockquote>\n<p>比较两个字符串大小</p>\n<p>s1&gt;s2 返回正数</p>\n<p>s1&lt;s2 返回负数</p>\n<p>s1和s2内容相同，返回0</p>\n<p>字符串长者大</p>\n<p>字符串长度相同时，从第一位开始以字典序比较</p>\n</blockquote>\n<ul>\n<li>s1.length()</li>\n</ul>\n<blockquote>\n<p>获得String的长度</p>\n</blockquote>\n<ul>\n<li>s1.charAt(int index)</li>\n</ul>\n<blockquote>\n<p>访问String里的字符</p>\n<p>返回index上的单个字符</p>\n<p>0&lt;=index&lt;=s1.length()-1</p>\n<p><strong>不能用for-each循环遍历字符串</strong></p>\n</blockquote>\n<ul>\n<li>s1.substring(int begin ,int end)</li>\n</ul>\n<blockquote>\n<p>获得 s1 下标于[begin,end)的子串</p>\n<p>end可省略，默认为s1.length()</p>\n</blockquote>\n<ul>\n<li>s1.indexOf( (char)|(String) c, int n)</li>\n</ul>\n<blockquote>\n<p>寻找c字符或字符串第一个所在位置，-1为不存在</p>\n<p>从n开始找(包括n)，n可以省略，默认为0</p>\n<p>s1.lastIndexOf(c,n) 从n开始向右边找，此时n默认为s1.length()</p>\n<p>寻找字符串中第二个的方法： s1.indexOf(c, s1.indexOf(c)+1);</p>\n</blockquote>\n<ul>\n<li>s1.startsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的前缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.endsWith( String s2)</li>\n</ul>\n<blockquote>\n<p>判断s1的后缀是否为s2</p>\n</blockquote>\n<ul>\n<li>s1.trim()</li>\n</ul>\n<blockquote>\n<p>清除s1左右两端的空格</p>\n<p>要保留清除可以 s1=s1.trim();</p>\n</blockquote>\n<ul>\n<li>s1.replace( (char)|(String) c1,(char)|(String) c2) (c1、c2同类型)</li>\n</ul>\n<blockquote>\n<p>将s1中所有字符或字符串c1替换成c2</p>\n</blockquote>\n<ul>\n<li>s1.toLowerCase() s1.toUpperCase()</li>\n</ul>\n<blockquote>\n<p>s1大小写切换</p>\n</blockquote>\n<ul>\n<li>s1.split(char a)</li>\n</ul>\n<blockquote>\n<p>以a作为分隔符分割字符串s1，将结果作为字符串数组返回</p>\n<p>String [] s= s1.split(“ “);</p>\n<p>多种分隔符用”|”分割，(“a”|”b”)</p>\n<p>以”.””|”作为分隔符时要加”\\“，即(\\.)(\\|)</p>\n</blockquote>\n<h3 id=\"StringBuilder-和-StringBuffer\"><a href=\"#StringBuilder-和-StringBuffer\" class=\"headerlink\" title=\"StringBuilder 和 StringBuffer\"></a>StringBuilder 和 StringBuffer</h3><p>StringBuilder：线程不安全，效率高<br>StringBuffer：线程安全，效率低<br>两者基本相同</p>\n<p>String无法进行修改，若用”+=”操作符时，系统会自动创建一个新的字符串，因此开销很大。</p>\n<p>用StringBuffer/StringBuilder能够很好解决string的扩展问题</p>\n<ul>\n<li><p>StringBuilder sb= new StringBuilder();</p>\n</li>\n<li><p>sb.append(“1”);</p>\n<blockquote>\n<p>扩展字符串<br>其返回值为StringBuilder,因此可以连续调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; // JDK源码</span><br><span class=\"line\">&gt; @Override</span><br><span class=\"line\">&gt; public StringBuilder append(String str) &#123;</span><br><span class=\"line\">&gt;     super.append(str);</span><br><span class=\"line\">&gt;     return this;</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; // 因此可以使用</span><br><span class=\"line\">&gt; sb.append(&quot;1&quot;).append(&quot;2&quot;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>sb.toString();</p>\n<blockquote>\n<p>将StringBuilder形成字符串，可作为函数的String返回值</p>\n</blockquote>\n</li>\n<li><p>sb.delete(int start , int end);</p>\n<blockquote>\n<p>删除下标为[start,end)的字符</p>\n</blockquote>\n</li>\n<li><p>sb.reverse();</p>\n<blockquote>\n<p>反转sb</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"容量机制\"><a href=\"#容量机制\" class=\"headerlink\" title=\"容量机制\"></a>容量机制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- StringBuffer和StringBuilder继承自AbstractStringBuilder，AbstractStringBuilder有非final的value字符串数组（String的value字符串数组为final）</span><br><span class=\"line\">- 默认容量为16，或是给定初始字符串长度+16或是给定初始长度</span><br><span class=\"line\">- 扩容为当前容量*2+2</span><br></pre></td></tr></table></figure>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>对象变量是对象的<strong>管理者</strong></p>\n<ul>\n<li>T tem = new T();</li>\n</ul>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><ul>\n<li>定义：类内部的变量</li>\n<li>特点：成员变量的生存期是对象的生存期，作用域为类内部的成员函数</li>\n<li>若没有初始化，则会自动被赋值(0)</li>\n<li>初始化<ul>\n<li>定义时就可以给出初始值</li>\n<li>对象变量的0值表示没有管理任何对象，也可以主动给null值</li>\n<li>定义初始化可以调用函数，可以使用已经定义的成员变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tint b=f();</span><br><span class=\"line\">\tint f() &#123;return 1;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li>名字和类名字完全相同，创建对象时会自动调用</li>\n<li>没有返回值</li>\n<li>调用时先完成外部成员变量初始化，而后再逐步执行构造函数内的语句</li>\n</ul>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><ul>\n<li>定义：同名但参数列表不同的函数</li>\n<li>可以有多个构造函数，但参数列表要不同</li>\n<li>构造函数内可以通过this()调用其它构造函数,但只能是第一句，只能在构造函数内使用，只能使用一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a=1;</span><br><span class=\"line\">\tT() &#123;a=2;&#125;</span><br><span class=\"line\">\tT(int a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis();</span><br><span class=\"line\">\t\tthis.a=a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若调用带参数a的构造函数，a的最终值为a，但赋值过程为：1-&gt;2-&gt;3，调用过程为：T(int a)-&gt;T()-&gt;int a=1;-&gt;执行T()-&gt;执行T(int a)</p>\n<h3 id=\"访问属性\"><a href=\"#访问属性\" class=\"headerlink\" title=\"访问属性\"></a>访问属性</h3><ul>\n<li>public (同c++)</li>\n<li>private (同c++)</li>\n<li>protected (同c++)</li>\n<li>friendly</li>\n</ul>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h4><ul>\n<li>任何人都可以直接使用<ul>\n<li>任何函数或定义初始化中可以使用</li>\n<li>使用是指调用、访问、定义变量</li>\n</ul>\n</li>\n<li>public类必须定义在自己的文件里</li>\n<li>一个编译单元只能有一个public类 (一个编译单元：一个.java文件，一次对这一个文件进行编译)</li>\n</ul>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><ul>\n<li>只有类的内部能够访问<ul>\n<li>类的成员函数</li>\n<li>定义初始化</li>\n</ul>\n</li>\n<li>限制是针对类而非对象<ul>\n<li>对象之间可以相互访问private成员变量(a对象的成员函数可以直接访问b对象的私有变量)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"friendly\"><a href=\"#friendly\" class=\"headerlink\" title=\"friendly\"></a>friendly</h4><ul>\n<li>未加private或public声明的成员 (即<strong>默认值</strong>)</li>\n<li>属于同一个包内的所有类都可以访问</li>\n</ul>\n<h3 id=\"System-out-println\"><a href=\"#System-out-println\" class=\"headerlink\" title=\"System.out.println\"></a>System.out.println</h3><p>正常情况下，调用System.out.println直接输出类的对象，则会输出其地址</p>\n<p>若是在类中包含 public String toString 函数，则在println时自动调用该函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class T&#123;</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">\tpublic String toString () &#123;return &quot;&quot;+c;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h2><h3 id=\"时间处理：\"><a href=\"#时间处理：\" class=\"headerlink\" title=\"时间处理：\"></a>时间处理：</h3><h4 id=\"java-util-Date\"><a href=\"#java-util-Date\" class=\"headerlink\" title=\"java.util.Date\"></a>java.util.Date</h4><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170910/197ED2Bj8D.JPG\" alt=\"mark\"></p>\n<ul>\n<li>对象表示一个特定的瞬间，精确到毫秒</li>\n<li>时间的表示为数字：从 标准纪元1970.01.01 0点开始到某个时刻的毫秒数，类型为long</li>\n</ul>\n<h4 id=\"DateFormat-SimpleDateFormat\"><a href=\"#DateFormat-SimpleDateFormat\" class=\"headerlink\" title=\"DateFormat, SimpleDateFormat\"></a>DateFormat, SimpleDateFormat</h4><p>java.text.*</p>\n<ul>\n<li>用来将字符串和时间相互转换</li>\n<li>DateFormat 是抽象类，无法实例化对象</li>\n<li>SimpleDateFormat非抽象类</li>\n</ul>\n<p>使用方法（详见API文档）</p>\n<ol>\n<li><p>已知毫秒转相应时间和字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);</span><br><span class=\"line\">DateFormat df1 = new SimpleDateFormat(&quot;yy-MM-dd hh:mm:ss&quot;);</span><br><span class=\"line\">Date d = new Date(1321454564);</span><br><span class=\"line\">String str=df1.format(d);</span><br><span class=\"line\">System.out.println(str);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知字符串及输入格式转毫秒数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str2 = &quot;1977-07-07&quot;;</span><br><span class=\"line\">DateFormat df2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">\tDate d2 = df2.parse(str2);</span><br><span class=\"line\">\tSystem.out.println(d2);</span><br><span class=\"line\">&#125; catch (ParseException e) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated catch block</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Calendar，GregorianCalendar-日历类\"><a href=\"#Calendar，GregorianCalendar-日历类\" class=\"headerlink\" title=\"Calendar，GregorianCalendar 日历类\"></a>Calendar，GregorianCalendar 日历类</h4><p>java.util.*</p>\n<ul>\n<li>Calendar是抽象类，无法实例化对象</li>\n<li>GregorianCalendar是Calendar的一个具体子类，提供了大多数国家和地区使用的标准日历系统</li>\n<li>Calendar类用来和Date类做切换，把计算机保存的时间转换成人能看懂的日期</li>\n<li>注意<ul>\n<li>月份：1月是0，2月是1，…12月是11<ul>\n<li>星期：周日是1，周一是2…周六是7</li>\n<li>可以使用 Calendar.FEBRUARY 表示数字</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>使用方法：（详见API文档）</p>\n<ol>\n<li><p>整体设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c = new GregorianCalendar();</span><br><span class=\"line\">c.set(2001, Calendar.FEBRUARY ,15);</span><br><span class=\"line\">Date date = c.getTime();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单独设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.set(Calendar.YEAR , 2001);</span><br><span class=\"line\">c.set(Calendar.MONTH , 1|Calendar.FEBRUARY);</span><br><span class=\"line\">// 未设置参数则自动采用当前时间 (日期、时分秒等)</span><br><span class=\"line\">System.out.println(c.get(Calendar.YEAR));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用Date赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.setTime(new Date());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c.add(Calendar.YEAR, 30);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"File-类\"><a href=\"#File-类\" class=\"headerlink\" title=\"File 类\"></a>File 类</h3><p>java.io.File:文件和目录路径名的抽象表现形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 通过File对象可以访问、修改文件属性</span><br><span class=\"line\">- 可以创建空文件或目录</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = new File(&quot;d:/aaa/bbb/ccc&quot;);</span><br><span class=\"line\">f.mkdir();  // 若父目录存在则创建</span><br><span class=\"line\">f.mkdirs(); // 若父目录不存在则自动创建父目录</span><br></pre></td></tr></table></figure>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><ul>\n<li><p>容器类的两个类型：</p>\n<p>1 . 容器的类型</p>\n<p>2 . 元素的类型</p>\n</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li><p>import java.util.ArrayList;</p>\n</li>\n<li><p>特点：元素可以相同，元素以与进入的顺序排序</p>\n</li>\n<li><p>基础类型：存放值</p>\n</li>\n<li><p>非基础类型：作为管理者，存放地址</p>\n</li>\n<li><p>定义：</p>\n<p>ArrayList notes = new ArrayList();</p>\n</li>\n</ul>\n<h4 id=\"常用操作-1\"><a href=\"#常用操作-1\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>notes.add(int location, String s);</li>\n</ul>\n<blockquote>\n<p>向下标为location的位置中插入元素</p>\n<p>location可省略，默认为末尾</p>\n</blockquote>\n<ul>\n<li>notes.size();</li>\n</ul>\n<blockquote>\n<p>返回容器中存放元素数目</p>\n</blockquote>\n<ul>\n<li>notes.get(int index);</li>\n</ul>\n<blockquote>\n<p>返回下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>nodes.remove(int index);</li>\n</ul>\n<blockquote>\n<p>移除下标为Index的元素</p>\n</blockquote>\n<ul>\n<li>notes.toArray(String []a);</li>\n</ul>\n<blockquote>\n<p>将notes里所有元素依次填入a中</p>\n</blockquote>\n<h4 id=\"for-each循环\"><a href=\"#for-each循环\" class=\"headerlink\" title=\"for-each循环\"></a>for-each循环</h4><p>若ArrayList存放的非基础类型，则for-each中可以修改值</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><ul>\n<li>import java.util.HashSet</li>\n<li>特点：元素均不相同，不排序，与进入的顺序无关</li>\n</ul>\n<h3 id=\"Hash表-散列表\"><a href=\"#Hash表-散列表\" class=\"headerlink\" title=\"Hash表(散列表)\"></a>Hash表(散列表)</h3><ul>\n<li>import java.util.HashMap;</li>\n<li>HashMap &lt; Key, Value &gt; a=new HashMap &lt; Key,Value &gt; ();<br>数据以一对值放进去，一个为键(KEY),一个为值(value)<br>值对应键</li>\n<li>键不能重复，只留相同的最后一个，元素不以先后排序</li>\n</ul>\n<h4 id=\"常用操作-2\"><a href=\"#常用操作-2\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h4><ul>\n<li>a.put(Key k1, Value v1);</li>\n</ul>\n<blockquote>\n<p>向HashMap里添加元素，键k1对应值为v1</p>\n</blockquote>\n<ul>\n<li>a.get(Key k);</li>\n</ul>\n<blockquote>\n<p>返回键k对应的值，若为空，则返回null</p>\n</blockquote>\n<ul>\n<li>a.containsKey(Key k);</li>\n</ul>\n<blockquote>\n<p>查询是否存在键为k的数据</p>\n</blockquote>\n<ul>\n<li>a.keySet();</li>\n</ul>\n<blockquote>\n<p>返回key的集合</p>\n<p>可以通过 a.keySet().size()获取存放的键的数目</p>\n<p>通过keySet使用for-each循环</p>\n</blockquote>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li><p>extends</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class son extends parent</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>java只允许单继承，一个类只能有一个父类</strong></p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>父类成员访问属性</th>\n<th>在父类中的含义</th>\n<th>在子类中的含义</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>对所有人开放</td>\n<td>对所有人开放</td>\n<td></td>\n</tr>\n<tr>\n<td>protected</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td>只有包内其它类、自己和子类可以访问</td>\n<td></td>\n</tr>\n<tr>\n<td>缺省</td>\n<td>只有包内其它类可以访问</td>\n<td>如果子类与父类在同一个包内：只有包内其它类可以访问</td>\n<td>否则：相当于private，不能访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>只有自己可以访问</td>\n<td>不能访问</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>子类同样继承了父类的private成员，只是子类无法访问！<br>但子类可以通过调用父类的非private函数来间接修改父类的private成员变量</p>\n<h3 id=\"继承VS组合\"><a href=\"#继承VS组合\" class=\"headerlink\" title=\"继承VS组合\"></a>继承VS组合</h3><ul>\n<li>“is-a”关系使用继承<ul>\n<li>如：Bird类继承自Animal类</li>\n</ul>\n</li>\n<li>“has-a”关系使用组合<ul>\n<li>如：Computer类包含CPU类，每个Computer对象都有一个CPU对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><p>本质：一个<strong>关键字</strong>，类似this(this的本质为指针),是直接父类的引用</p>\n<p>用法<br>1 . 直接引用</p>\n<p>相当于指向当前对象的父类，用”.”访问父类的成员</p>\n<p>2 . 子类成员变量或方法与父类同名时，用super加以区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tvoid a();</span><br><span class=\"line\">\tvoid b()&#123;</span><br><span class=\"line\">\t\ta();   // son的a函数</span><br><span class=\"line\">\t\tsuper.a();  // parent的a函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3 . 调用父类的构造函数</p>\n<p>规定：必须写在子类构造的第一行，不能和this同时出现在一个构造函数</p>\n<p>子类的构造函数第一行都会隐含地包含super()函数，若此时父类没有不含参数的构造函数，则无法通过编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class son extends parent&#123;</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tson(int a1)&#123;</span><br><span class=\"line\">\t\tsuper(a1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同名变量\"><a href=\"#同名变量\" class=\"headerlink\" title=\"同名变量\"></a>同名变量</h3><p>若没有明确指明，则在谁的成员函数中就使用谁的成员变量</p>\n<h3 id=\"子类和子类型\"><a href=\"#子类和子类型\" class=\"headerlink\" title=\"子类和子类型\"></a>子类和子类型</h3><ul>\n<li>类定义了类型</li>\n<li>子类定义了子类型 (son是parent的一个子类型)</li>\n<li>子类对象可以被当做父类的对象使用<ul>\n<li>赋值给父类变量</li>\n<li>传递给需要父类对象的函数</li>\n<li>放进存放分类对象的容器里</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170903/gfj3geAc0f.JPG\" alt=\"mark\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v1 = new Vehicle();</span><br><span class=\"line\">Vehicle v2 = new Car();</span><br><span class=\"line\">Vehicle v3 = new Bicycle();</span><br></pre></td></tr></table></figure>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>主要用来实现<strong>动态联编</strong></p>\n<p>即程序的最终状态只有在执行过程中才被决定而非在编译时期就决定了</p>\n<p>以此提高系统的灵活性和扩展性</p>\n<h3 id=\"如何实现多态\"><a href=\"#如何实现多态\" class=\"headerlink\" title=\"如何实现多态\"></a>如何实现多态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 引用变量的两种类型</span><br><span class=\"line\"></span><br><span class=\"line\">    - 编译时类型（一般是父类）</span><br><span class=\"line\">        - 由声明时的类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">    - 运行时类型（运行时具体的子类）</span><br><span class=\"line\">        - 由实际对应的对象类型决定</span><br><span class=\"line\"></span><br><span class=\"line\">- 三个必要条件</span><br><span class=\"line\">    - 要有继承</span><br><span class=\"line\">    - 要有方法重写</span><br><span class=\"line\">    - 父类引用指向子类对象</span><br></pre></td></tr></table></figure>\n<h3 id=\"多态变量\"><a href=\"#多态变量\" class=\"headerlink\" title=\"多态变量\"></a>多态变量</h3><ul>\n<li>对象变量能够保存不止一种的对象</li>\n<li>可以保存声明类型的对象或是声明类型的子类的对象</li>\n<li>子类对象赋给父类变量，发生<strong>向上造型</strong></li>\n</ul>\n<h3 id=\"造型-cast\"><a href=\"#造型-cast\" class=\"headerlink\" title=\"造型 cast\"></a>造型 cast</h3><p>造型(cast)：把一个类型的对象赋值给另一个类型的变量</p>\n<ul>\n<li>子类对象可以复制给父类变量<ul>\n<li>与C++不同：java不存在对象与对象的赋值，只能是管理者修改指向的对象</li>\n</ul>\n</li>\n<li>父类对象不能赋值给子类变量</li>\n<li>可以使用造型强制赋值，但只有当父类变量实际管理的是子类的对象才行</li>\n<li>类型转换 ！= 造型<ul>\n<li>类型转换中对象发生改变，如 int i=(int)10.2;</li>\n<li>造型中对象本身没有改变，只是改变了看待它的方式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vehicle v;</span><br><span class=\"line\">Car car = new Car();</span><br><span class=\"line\">v=car;  //可以</span><br><span class=\"line\">c=v;   //编译错误</span><br><span class=\"line\">c=(Car)v // 编译通过</span><br><span class=\"line\"></span><br><span class=\"line\">若</span><br><span class=\"line\">Vehicle v=new Vehicle();</span><br><span class=\"line\">Car car=(Car)v; // 编辑器不报错，但会出现ClassCastException异常</span><br></pre></td></tr></table></figure>\n<h4 id=\"向上造型\"><a href=\"#向上造型\" class=\"headerlink\" title=\"向上造型\"></a>向上造型</h4><ul>\n<li>子类对象当做父类对象使用</li>\n<li>向上造型是默认的，不需要运算符</li>\n<li>向上造型是安全的</li>\n</ul>\n<h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><p>同名函数调用父类对象时，会根据实际管理对象的类型调用相应的函数</p>\n<ul>\n<li>静态绑定：根据变量声明类型决定</li>\n<li>动态绑定：根据变量的动态类型决定 ( 实际管理的类型 )</li>\n<li>默认使用动态绑定</li>\n<li>成员函数中调用其它成员函数通过this变量调用</li>\n</ul>\n<h3 id=\"覆盖-override\"><a href=\"#覆盖-override\" class=\"headerlink\" title=\"覆盖 override\"></a>覆盖 override</h3><ul>\n<li>覆盖关系：子类和父类中存在名称和参数表完全相同的函数</li>\n<li>通过父类变量调用存在覆盖关系的函数时，会调用变量当前所管理的对象所属的类的函数</li>\n</ul>\n<h3 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h3><ul>\n<li>所有的类都继承自Object类</li>\n<li>几乎所有OOP都有Object类（除c++）</li>\n</ul>\n<h4 id=\"Object类的函数-部分\"><a href=\"#Object类的函数-部分\" class=\"headerlink\" title=\"Object类的函数(部分)\"></a>Object类的函数(部分)</h4><ul>\n<li>toString()</li>\n<li>equals()</li>\n</ul>\n<h3 id=\"多态的内存分析\"><a href=\"#多态的内存分析\" class=\"headerlink\" title=\"多态的内存分析\"></a>多态的内存分析</h3><p>1 . 基本的继承关系和方法调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：Animal  有voice方法</span><br><span class=\"line\">- 子类：Cat 重写voice方法，自己有catchMouse方法</span><br><span class=\"line\">- 测试：分别声明父类和子类变量并指向子类对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void showVoice(Animal c) &#123;</span><br><span class=\"line\">\t\tc.voice();</span><br><span class=\"line\">\t\tif(c instanceof Cat)</span><br><span class=\"line\">\t\t\t((Cat) c).catchMouse();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tAnimal a=new Cat();</span><br><span class=\"line\">\t\tCat cat=(Cat)a;</span><br><span class=\"line\">\t\tTest.showVoice(cat);</span><br><span class=\"line\">\t\tTest.showVoice(a);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tvoid voice() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Cat extends Animal&#123;</span><br><span class=\"line\">\tvoid voice() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;miao&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tvoid catchMouse() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/Jd69EhEaBa.JPG\" alt=\"mark\"></p>\n<p>2 . 深化多态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 父类：HttpServlet 有service方法和doGet方法，其中service方法中调用doGet方法</span><br><span class=\"line\">- 子类：MyServlet 重写了doGet方法</span><br><span class=\"line\">- 测试：父类变量指向子类对象，调用父类的service方法观察doGet执行的版本</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HttpServlet &#123;</span><br><span class=\"line\">\tpublic void service() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.service()&quot;);</span><br><span class=\"line\">\t\tdoGet();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;HttpServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class MyServlet extends HttpServlet &#123;</span><br><span class=\"line\">\tpublic void doGet() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;MyServlet.doGet()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tHttpServlet s = new MyServlet();</span><br><span class=\"line\">\t\ts.service();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出结果：</span><br><span class=\"line\">// HttpServlet.service()</span><br><span class=\"line\">// MyServlet.doGet()</span><br></pre></td></tr></table></figure>\n<p>原因分析：<br>函数调用本身隐含着 this 引用， 在service中实际是 this.doGet()，此时this指向的为MyServlet即是子类的对象，因此调用子类重写的doGet函数</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170909/70jHJ3hJEi.JPG\" alt=\"mark\"></p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><h3 id=\"消除代码复制\"><a href=\"#消除代码复制\" class=\"headerlink\" title=\"消除代码复制\"></a>消除代码复制</h3><ul>\n<li><p>代码复制是不良设计的一种表现</p>\n<p>解决方法：使用函数封装重复的代码</p>\n</li>\n</ul>\n<h3 id=\"增加可扩展性\"><a href=\"#增加可扩展性\" class=\"headerlink\" title=\"增加可扩展性\"></a>增加可扩展性</h3><ul>\n<li><p>后期的可维护性</p>\n<p>解决方法：用封装降低耦合，用接口实现聚合，借助类继承</p>\n<p>耦合：类和类之间的关系</p>\n<p>耦合越低越好</p>\n</li>\n</ul>\n<h2 id=\"抽象和接口\"><a href=\"#抽象和接口\" class=\"headerlink\" title=\"抽象和接口\"></a>抽象和接口</h2><p>关键词：<strong>abstract</strong> (抽象)</p>\n<blockquote>\n<p>public abstract class a</p>\n</blockquote>\n<ul>\n<li>抽象函数：表达概念而<strong>无法实现具体代码</strong>的函数</li>\n<li>抽象类：表达概念而<strong>无法构造出实体</strong>的类</li>\n<li>为什么需要抽象类<ul>\n<li><strong>模板模式</strong>，抽象类为子类提供了一个通用模板，子类可以在模板基础上进行扩展</li>\n<li><strong>通过抽象类，可以避免子类设计的随意性</strong>，严格限制子类的设计，使得子类之间更加通用。</li>\n</ul>\n</li>\n<li>抽象方法的意义：<strong>使方法的设计和实现分离！</strong></li>\n<li>要点：<ul>\n<li>有抽象函数的类一定是抽象类<ul>\n<li>抽象类<strong>不能制造对象</strong>，但可以定义变量</li>\n</ul>\n</li>\n<li>任何继承了抽象类的非抽象类对象可以赋值给抽象类变量</li>\n<li>抽象类可以拥有非抽象函数、属性和构造方法，但构造方法只能用来被子类调用</li>\n<li>继承自抽象类的子类必须覆盖父类的抽象函数，不然也成为抽象类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>关键词：<strong>interface</strong></p>\n<blockquote>\n<p>public interface a{}</p>\n</blockquote>\n<ul>\n<li>接口是纯抽象类(接口中只有常量、抽象方法)</li>\n<li>所有成员变量都是public abstract static final （默认的，可以不写）</li>\n<li>接口意义：设计和实现分离，利于大项目制作</li>\n<li>接口变量的含义为任何实现了接口的对象</li>\n</ul>\n<p>关键词：<strong>implements</strong></p>\n<blockquote>\n<p>public class b implements a{}</p>\n</blockquote>\n<ul>\n<li>类可以实现很多接口</li>\n<li>接口可以继承接口，不能继承类</li>\n<li>接口不能实现接口</li>\n<li>接口和抽象类<ul>\n<li>接口是比”抽象类”还要”抽象”的”抽象类”，全面地专业地实现了<strong>规范和具体实现的分离</strong></li>\n<li><strong>接口就是规范，定义了一组规则</strong></li>\n<li><strong>接口的本质是契约</strong>，制定好后大家都遵守</li>\n<li>项目的具体需求是多变的，我们需要以不变应万变，这就是规范，因此需要<strong>面向接口编程</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"面向接口的编程方式\"><a href=\"#面向接口的编程方式\" class=\"headerlink\" title=\"面向接口的编程方式\"></a>面向接口的编程方式</h4><ul>\n<li>设计程序时先定义接口，再实现类</li>\n<li>任何需要在函数间传入传出的一定是接口而不是具体的类</li>\n<li>Java成功的关键之一，极适合多人同时写一个大程序</li>\n<li>Java被批评的要点之一，代码量膨胀地很快</li>\n</ul>\n<h2 id=\"控制反转与MVC模式\"><a href=\"#控制反转与MVC模式\" class=\"headerlink\" title=\"控制反转与MVC模式\"></a>控制反转与MVC模式</h2><h3 id=\"Swing\"><a href=\"#Swing\" class=\"headerlink\" title=\"Swing\"></a>Swing</h3><p>容器、部件</p>\n<ul>\n<li><p>容器继承自部件，因此可以作为部件被放入其它容器中</p>\n</li>\n<li><p>容器使用布局管理器管理内部的部件,能够根据不同的环境自动调整</p>\n</li>\n<li><p>JFrame使用BorderLayout管理部件，并且将界面划分为五个区域</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170907/8B7I3088Hh.JPG\" alt=\"mark\"></p>\n</li>\n<li><p>容器使用 add 函数添加部件，JFrame中若不指定放置区域，则默认为BorderLayout.CENTER,后添加的部件会覆盖前面的部件</p>\n</li>\n</ul>\n<h3 id=\"控制反转\"><a href=\"#控制反转\" class=\"headerlink\" title=\"控制反转\"></a>控制反转</h3><ul>\n<li>按钮公布一个listener接口和一对注册、注销函数</li>\n<li>实现接口后将把listener对象注册在按钮上</li>\n<li>一旦按钮被按下，就会反过来调用listener对象的函数</li>\n</ul>\n<h3 id=\"内部类-innerclasses\"><a href=\"#内部类-innerclasses\" class=\"headerlink\" title=\"内部类 innerclasses\"></a>内部类 innerclasses</h3><p>定义在别的类内部、函数内部的类</p>\n<h4 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 提供了更好的封装，只能让外部类直接访问，不允许同一个包中其它类直接访问</span><br><span class=\"line\">- 内部类可以访问外部类的所有成员，但外部类不能访问内部类的内部属性</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场合\"><a href=\"#使用场合\" class=\"headerlink\" title=\"使用场合\"></a>使用场合</h4><p>在内部类只为所在外部类提供服务的情况优先使用</p>\n<h4 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h4><h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>（可以使用private,public,protected修饰）</p>\n<h6 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h6><p><code>- 外部类使用非静态内部类和使用其它类相同 - 非静态内部类必须寄存在外部类的对象里，相当于外部类的一个属性。**非静态内部类对象单独属于外部类的某个对象**- 非静态内部类不能有静态方法、静态属性、静态初始化块- 静态成员不能访问非静态成员：外部类的静态方法、静态代码块补鞥呢访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例- 成员变量访问要点：    1. 内部类里方法的局部变量：变量名    2. 内部类属性：this.变量名    3. 外部类属性：外部类名.this.变量名- 内部类的访问：    - 外部类中定义内部类： new innerClass()    - 外部类以外的地方使用非静态内部类        Outer.inner n = OuterObject.new Inner();</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Outer &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tFace f=new Face();</span><br><span class=\"line\">\t\tFace.Nose n= f.new Nose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Face &#123;</span><br><span class=\"line\">\tint type;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass Nose&#123;</span><br><span class=\"line\">\t\tString type;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvoid breath() &#123;</span><br><span class=\"line\">\t\t\tFace.this.type=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 要点：</span><br><span class=\"line\">    - 静态内部类对象存在时，不一定存在对应的外部类对象</span><br><span class=\"line\">    - 静态内部类无法直接访问外部类实例方法</span><br><span class=\"line\">    - 静态内部类看作**外部类的一个静态成员**</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Face f= new Face();</span><br><span class=\"line\">// Nose为非静态内部类</span><br><span class=\"line\">Face.Nose n=f.new Nose();</span><br><span class=\"line\">// Ear为静态内部类</span><br><span class=\"line\">Face.Ear e=new Face.Ear();</span><br></pre></td></tr></table></figure>\n<h6 id=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"><a href=\"#局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\" class=\"headerlink\" title=\"局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少\"></a>局部内部类：定义在方法内部，作用于仅限于本方法，但用的极少</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 访问函数的本地变量时只能访问函数的final变量</span><br></pre></td></tr></table></figure>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>适用于只需要使用一次的类，例如：键盘监听操作等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new 父类构造器(实参) 实现接口()&#123;</span><br><span class=\"line\">\t匿名内部类类体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>匿名类可以继承某类，也可以实现接口</li>\n<li>Swing的消息机制广泛使用匿名类</li>\n</ul>\n<h3 id=\"MVC设计模式\"><a href=\"#MVC设计模式\" class=\"headerlink\" title=\"MVC设计模式\"></a>MVC设计模式</h3><ul>\n<li><p>数据、表现和控制</p>\n<p>三者分离</p>\n<ul>\n<li>M = Model 模型</li>\n<li>V = View 表现</li>\n<li>C = Control 控制</li>\n</ul>\n</li>\n<li><p>模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新</p>\n</li>\n<li><p>表现：从模型获取数据，根据数据画出表现</p>\n</li>\n<li><p>控制：从用户得到输入，根据输入调整数据</p>\n</li>\n</ul>\n<h3 id=\"异常机制-Exception\"><a href=\"#异常机制-Exception\" class=\"headerlink\" title=\"异常机制 Exception\"></a>异常机制 Exception</h3><h4 id=\"常见的异常\"><a href=\"#常见的异常\" class=\"headerlink\" title=\"常见的异常\"></a>常见的异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户输入错误</span><br><span class=\"line\">设备错误</span><br><span class=\"line\">硬件问题：如打印机关掉、服务器问题</span><br><span class=\"line\">磁盘满了</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常Exception\"><a href=\"#异常Exception\" class=\"headerlink\" title=\"异常Exception\"></a>异常Exception</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java提供的用来处理程序中错误的一种机制</span><br><span class=\"line\"></span><br><span class=\"line\">Java采用**面向对象** 方式来处理异常。处理过程：</span><br><span class=\"line\">    抛出异常：执行方法时若发生异常，则这个方法生成代表异常的一个对象，停止当前执行路径，把异常对象提交给JRE</span><br><span class=\"line\">    捕获异常：JRE得到异常后寻找相应代码处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"常见异常\"><a href=\"#常见异常\" class=\"headerlink\" title=\"常见异常\"></a>常见异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. ArithmeticException</span><br><span class=\"line\">    例如试图除以0</span><br><span class=\"line\">2. NullPointerException</span><br><span class=\"line\">    对象为null但调用了对象的方法或属性</span><br><span class=\"line\">3. ClassCastException</span><br><span class=\"line\">    转型错误，解决：使用istanceof判断</span><br><span class=\"line\">4. ArrayIndexOutOfBoundsException</span><br><span class=\"line\">    访问元素超出数组长度</span><br><span class=\"line\">5. NumberFormatException</span><br><span class=\"line\">    数字格式异常，如把String转换成int</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常的处理方法：\"><a href=\"#异常的处理方法：\" class=\"headerlink\" title=\"异常的处理方法：\"></a>异常的处理方法：</h4><p><code>捕获异常（try，catch，finally）    try{// 可能出现异常的语句}catch(Exception e){// }finally{// }    未遇到异常时，执行完try内的语句后不执行catch，而后执行finally    出现异常时，跳转至catch，执行catch后，执行finally        try             try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理            一个try语句必须带有至少一个catch语句块或一个finally语句块 。。                当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。        catch            每个try可以搭配多个catch，用来处理不同的异常            捕获异常时：越是顶层的类越是放在下面            常用方法：                toString() 显示异常类名和异常原因                getMessage() 只显示异常原因                printStackTrace() 跟踪异常发生时堆栈内容        finally            不管是否发生异常都需要执行的语句，一般是关闭资源            不要在finally中使用return        执行顺序：            1. 执行try、catch，给返回值赋值            2. 执行finally            3. return抛出异常 throws    方法声明中加throws，则谁调用该方法谁用try catch处理异常    可以throws多个异常    用**throw**(没有s)手动new异常对象并抛出异常</code></p>\n<h4 id=\"方法重写中声明异常原则：\"><a href=\"#方法重写中声明异常原则：\" class=\"headerlink\" title=\"方法重写中声明异常原则：\"></a>方法重写中声明异常原则：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**子类声明的异常范围不能超出父类的范围**</span><br><span class=\"line\">    - 父类没有声明异常，子类也不能</span><br><span class=\"line\">    - 不能抛出 原有方法抛出的父类或上层类</span><br><span class=\"line\">    - 抛出的异常类型数目不能比原有方法多（类型多 非 个数多）</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题，这时候可以创建自己的异常类</span><br><span class=\"line\">- 从Exception类或它的子类派生一个子类</span><br><span class=\"line\">- 习惯上，定义的类应该包含2个构造器，一个是默认构造器，一个是带有详细信息的构造器</span><br><span class=\"line\"></span><br><span class=\"line\">建议：</span><br><span class=\"line\">    - 避免使用异常机制代替错误处理</span><br><span class=\"line\">    - 处理异常不能代替简单测试</span><br><span class=\"line\">    - 不要进行**小力度**的异常处理（如一行一个try catch）</span><br><span class=\"line\">    - 异常往往在**高层**处理</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"题目小结：二叉树 ( 建树和遍历 )","date":"2017-08-17T16:00:00.000Z","comments":1,"_content":"\n\n# 二叉树练习：\n\n分为：\n树的构建\n树的同构\n子树节点数\n自定义遍历顺序\n子树相同\nTree Travels again\n\n<!-- more -->\n\n## 1. 树的构建\n\n有关二叉树的题目有以下几种输入建树方式：\n1.前序+中序遍历序列\n2.中序+后序遍历序列\n3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数\n4.每个节点子节点数目以及子节点编号\n5.先序序列，空节点以’,’代替\n\n### 1. 前序+中序遍历序列\n\n![前序+中序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG)\n\n从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。\n\n用流程表述如下：\n在前序中确定根节点->在中序中确定根节点->得知左右序列的长度->递归左右序列\n\n你可能会疑惑，那左右节点呢？不是能够确定吗？\n没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。\n\n```\nnode *build( char *pre, char * ins, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*pre ; i++);\n\ts= new node (*pre);\n\ts->lc=build(pre+1,ins,i);\n\ts->rc=build(pre+i+1,ins+i+1,n-i-1);\n\treturn s;\n}\n```\n\n### 2. 中序+后序遍历序列\n\n![中序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG)\n\n和前序+中序一般，这次不过是根节点在最后，流程是类似的。\n\n```\nnode *build(char *ins, char *post, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node (*(post+n-1));\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+n-1); i++);\n\ts=new node (*(post+n-1));\n\ts->lc=build(ins,post,i);\n\ts->rc=build(ins+i+1,post+i,n-i-1);\n\treturn s;\n}\n```\n\n### 3. 前序+后序序列\n\n![前序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG)\n\n那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？\n这时候就靠左孩子了。而根据给出的性质：**所有节点的子节点数均为偶数**可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）\n\n明确思路后修改一下细节就可以得到如下代码\n\n```\nnode * build( char *pre , char *post, int len )\n{ \n\tnode *s=NULL;\n\tif(len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new node (*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new node (*pre);\n\ts->lc=build(pre+1,post,i+1);\n\ts->rc=build(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n### 4. 子节点编号\n\n假设题目的输入如下：\n第一行为节点总数n，节点编号1-n\n紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。\n范例如下：\n\n```\n7 \n1 6 3\n2 0 4\n1 7 0\n3 0 0\n1 2 1\n2 0 0\n2 0 0\n```\n\n显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：**没有给出根节点编号！**，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。\n\n我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组\n3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。\n1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。\n\nbuild函数很简单，若有孩子则递归构建。\n\n```\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n```\n\n那输入要怎么处理？\n\n```\nmemset(isroot,0,sizeof(isroot)); // 数组归零，很重要！\nfor(int i=1; i<=n; i++)\n{\n\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理\n}\nfor(nroot=1; isroot[nroot]==1; nroot++);\ntree=build(nroot);\n```\n\n### 5. 先序序列\n\n还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）\n如\n\n```\nabc,,de,g,,f,,,\n```\n\n很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩\n\n```\nnode *build( int &fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据\n// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir>=n)方便\n{\n\tnode *s=NULL;\n\tif(fir>=n) return s;\n\tif(pre[fir]==',' ) return s;\n\ts=new node(pre[fir]);\n\ts->lc=build(++fir,n);\n\ts->rc=build(++fir,n);\n\treturn s;\n}\n```\n\n## 2. 树的同构\n\n[SDUT 3340: 数据结构实验之二叉树一：树的同构](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html)\n\n题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。\n\n例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。\n\n![图1](http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim)\n\n![图2](http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim)\n\n难点：\n\n1. 树的构建\n2. 同构判断\n\n坑：\n\n1. n和m可能不同\n   在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。\n2. n和m可能为0 (分别或同时)\n\n判等思路：\n1.粗糙版：贪心同构tree1，看看能不能变成tree2。\ntree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样\n\n2.递归巧妙版：判断当前节点数值是否相等\n若两个节点都不存在，返回正确。\n若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&&（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&&（tree1右孩子+tree2左孩子）。\n若不等或者只有其中一个存在，返回错。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n\nchar a[15];\nint llc[15],rrc[15];\nint n,m;\nchar tem1,tem2;\nbool isroot[15];\nint nroot;\n\nstruct node\n{\n\tchar data;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL;}\n\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){}\n};\n\nnode * build(int i)\n{\n\tnode *s=new node (a[i]);\n\tif(llc[i]!=-1)\n\t\ts->lc=build(llc[i]);\n\tif(rrc[i]!=-1)\n\t\ts->rc=build(rrc[i]);\n\treturn s;\n}\n\nnode * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等\n{\n\tnroot=0;\n\tmemset(isroot,0,sizeof(isroot));\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=0; i<n1; i++)\n\t{\t\n\t\tcin>>a[i]>>tem1>>tem2;\n\t\tif(tem1=='-') \n\t\t\tllc[i]=-1;\n\t\telse\n\t\t{\n\t\t\tllc[i]=tem1-'0';\n\t\t\tisroot[llc[i]]=1;\n\t\t}\n\t\tif(tem2=='-') \n\t\t\trrc[i]=-1;\n\t\telse\n\t\t{\n\t\t\trrc[i]=tem2-'0';\n\t\t\tisroot[rrc[i]]=1;\n\t\t}\n\t}\n\tfor( nroot=0; nroot<n1; nroot++)\n\t\tif(isroot[nroot]==0)\n\t\t\tbreak;\n\treturn build(nroot);\n}\n\nbool change(node*r1, node *r2)\n{\n\tif(!r1 && !r2) \n\t\treturn 1;\n\tif(r1&&r2)\n\t{\n\t\tif(r1->data==r2->data)\n\t\t{\n\t\t\tif( (change(r1->rc,r2->rc))&&(change(r1->lc,r2->lc))  || (change(r1->lc,r2->rc))&&(change(r1->rc,r2->lc))   )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\nwhile(cin>>n)\n{\n\tnode* tree1,*tree2;\n\tif(n)\n\t\ttree1=rebuild(n);\n\tcin>>m;\n\tif(m)\n\t\ttree2=rebuild(m);\n\tif(change(tree1,tree2))\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n}\n\treturn 0;\n}\n```\n\n## 3. 子树节点数\n\n[九度OJ 1113：二叉树](http://ac.jobdu.com/problem.php?pid=1113)\n\n题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数\n\n一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。\n\n个人想法（不一定为最简）：\n先求得m和n所在二叉树的高度lenm和lenn，求得’<’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count*po个节点，最后一层的节点数减去count*po后，剩下在po范围里的则是最后一层m可以加上的节点数。\n\n![解法图示](http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim)\n\ncmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n \nint getheight(int num)\n{\n    return (int)(log(num)*1.0/(log(2)*1.0));\n}\n \nint main()\n{   \n    int m,n;\n\twhile(  scanf(\"%d%d\",&m,&n)&& m+n  )\n\t{   \n\t\tint lenm=getheight(m),lenn=getheight(n);\n\t\tint count=0;\n\t\tint po=1;\n\t\tint ans=0;\n\t\tfor(int i=m-1; ; i--)\n\t\t{\n\t\t\tif(getheight(i)!=lenm)\n\t\t\t\tbreak;\n\t\t\tcount++;  // 找出同层中m左边有多少个节点\n\t\t}\n    \n\t\tfor(int i=lenm; i<lenn; i++)\n\t\t{\n\t\t\tans+=po;   // 在lenn层前的子树节点总数\n\t\t\tpo*=2;\n\t\t}\n\t\tcount*=po;\n\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号\n\t\tif(n<=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围\n\t\t\tprintf(\"%d\\n\",ans);\n\t\telse\n\t\t{\n\t\t\tn-= count+fir-1;\n\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围\n\t\t\tans+=n;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n    return 0;\n}\n```\n\n## 4. 自定义遍历顺序\n\n[SDUT 3133: C要–二叉树中的秘密](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html)\n\n题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。\n\n遍历顺序：\n若根节点只有左子树或右子树，则遍历子树。\n若左右子树均没有，则返回父节点\n若左右子树均有\n若左右节点高度不同，优先遍历高度小的\n若左右节点高度相同，优先遍历储存的数据较小的\n\n难点：\n1.建树\n2.按规则实现遍历\n\n思路：\n跟着题意走就行，注意细节。\n每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *pa,*lc,*rc;\n\tnode(){ pa=lc=rc=NULL; size=1;}\n\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc){size=1;}\n};\nint x;\nint llc[3010],rrc[3010];\nint a[3010];\nbool hasfound;\nint ans;\n\nint updateh(node *s)\n{\n\tif(!s) return 0;\n\treturn s->size=updateh(s->lc)+updateh(s->rc)+1;\n}\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[a[n]])\n\t{\t\n\t\ts->lc=build(llc[a[n]]);\n\t\tif(s->lc)\n\t\t\ts->lc->pa=s;\n\t}\n\tif(rrc[a[n]])\n\t{\t\n\t\ts->rc=build(rrc[a[n]]);\n\t\tif(s->rc)\n\t\t\ts->rc->pa=s;\n\t}\n\treturn s;\n}\n\nvoid found(node *s)\n{\n\tif(hasfound==true) return;\n\tans++;\n\tif(s->data==x)\n\t{\n\t\thasfound=true;\n\t\treturn;\n\t}\n\tif( !s->lc&&s->rc )\n\t\tfound(s->rc);\n\telse if( !s->rc && s->lc )\n\t\tfound(s->lc);\n\telse if( !s->rc && !s->lc)\n\t\treturn;\n\telse\n\t{\n\t\tif(s->rc->size < s->lc->size || (s->rc->size==s->lc->size && s->rc->data < s->lc->data) )\n\t\t{\n\t\t\tfound(s->rc);\n\t\t\tfound(s->lc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfound(s->lc);\n\t\t\tfound(s->rc);\n\t\t}\n\t}\n}\n\n\nint main()\n{   \n\tint n;\n\tnode *tree;\n\tint tem1;\nwhile(~scanf(\"%d%d\",&n,&x))\n{\n\thasfound=false;\n\tans=0;\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\ta[i]=i;\n\t\tscanf(\"%d\",&tem1);\n\t\tif(tem1==0) continue;\n\t\telse if(tem1==1) \n\t\t{\t\n\t\t\tscanf(\"%d\",&llc[i]);\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\t}\n\t}\n\ttree=build(1);\n\tupdateh(tree);\n\tfound(tree);\n\tprintf(\"%d\\n\",ans);\n}\n    return 0;\n}\n```\n\n## 5. 子树相同\n\n[SDUT 3926: bLue的二叉树](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html)\n\n题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。\n\n思路：\n显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。\n在判断时，\n若tree1中当前节点的size和tree2的根节点size不等或者data不等\n若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点\n若子树的size小于tree2的size，就不判断了\n若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL; size=1;}\n\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){size=1; }\n};\n\nint llc[100010],rrc[100010];\nint a[100010];\nbool isroot[100010];\nint nroot;\nint ans;\nint pre1[100010],pre2[100010];\nint npre1,npre2;\n\nnode *tree1,*tree2;\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n\nvoid bbb(node *&tree, int n)\n{\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tmemset(isroot,0,sizeof(isroot));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\tisroot[llc[i]]=isroot[rrc[i]]=1;\n\t}\n\tfor(nroot=1; isroot[nroot]==1; nroot++);\n\ttree=build(nroot);\n}\n\nint update(node *tree)\n{\n\tif(!tree) return 0;\n\treturn tree->size=1+update(tree->lc)+update(tree->rc);\n}\n\nint n,m;\n\nbool equal(node *tree1, node *tree2)\n{\n\tif( !tree1 && !tree2 ) return true;\n\tif( (!tree1 && tree2) || ( tree1&&!tree2 ) ) return false; \n\tif(tree1->size!=tree2->size || tree1->data!=tree2->data)\n\t\treturn false;\n\treturn equal(tree1->lc,tree2->lc)&&equal(tree1->rc,tree2->rc);\n}\n\nvoid com(node *tree)\n{\n\tif(tree->size!=tree2->size || tree->data!=tree2->data)\n\t{\n\t\t\n\t\tif( tree->lc && tree->lc->size>=tree2->size)\n\t\t\tcom(tree->lc);\n\t\tif( tree->rc && tree->rc->size>=tree2->size)\n\t\t\tcom(tree->rc);\n\t}\n\telse\n\t\tif(equal(tree,tree2)==true)\n\t\t\tans++;\n\treturn;\n}\n\nvoid release(node *tree)\n{\n\tif(!tree) return;\n\trelease(tree->lc);\n\trelease(tree->rc);\n\tdelete tree;\n}\n\nint main()\n{   \nwhile(~scanf(\"%d%d\",&n,&m))\n{\n\tans=0;\n\tnpre1=npre2=0;\n\tmemset(pre1,0,sizeof(pre1));\n\tmemset(pre2,0,sizeof(pre2));\n\tbbb(tree1,n);\n\tbbb(tree2,m);\n\tif(m>n)\n\t{\n\t\tprintf(\"0\\n\");\n\t\tcontinue;\n\t}\n\tupdate(tree1);\n\tupdate(tree2);\n\tcom(tree1);\n\tprintf(\"%d\\n\",ans);\n\trelease(tree1);\n\trelease(tree2);\n}\n    return 0;\n}\n```\n\n\n## 6. Tree Travels again\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG)\n\n题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列\n\n思路：经过观察可以发现，入栈的顺序其实就是**先序遍历的序列**，出栈顺序就是**中序遍历的序列**，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了\n\n优化：\n在得到序列后，可以不用建树，直接根据序列得到后序序列\n思路：分治\n先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可\n\n代码：\n\n```\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <stdio.h>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n\nstruct Node\n{\n\tint data;\n\tNode * left,* right;\n\tNode() {left=right=NULL;}\n\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r){}\n};\n\nint pre[100],in[100];\nint stack[100];\nint top=0;\nint npre=0,nin=0;\nint ans[100];\n\nvoid solve(int prei , int ini , int posti, int n)\n{\n\tif(n<=0) return ; \n\tif(n==1)\n\t{\n\t\tans[posti]=pre[prei];\n\t\treturn;\n\t}\n\tans[posti+n-1]=pre[prei];\n\tint i;\n\tfor(i=0; in[i+ini]!=pre[prei] ; i++);\n\tsolve( prei+1 , ini , posti , i );\n\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tchar c[10];\n\tint tem;\n\t// 根据出入栈构造序列\n\twhile(cin>>c)\n\t{\n\t\tif(c[1]=='u')\n\t\t{\n\t\t\tcin>>tem;\n\t\t\tstack[top++]=tem;\n\t\t\tpre[npre++]=tem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin[nin++]=stack[--top];\n\t\t}\n\t}\n\tsolve(0,0,0,n);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```","source":"_posts/ProblemSet_Tree.md","raw":"---\nlayout: post\ntitle: \"题目小结：二叉树 ( 建树和遍历 )\"\ndate: 2017-08-18\ncomments: true\ntags: \n\t- c++\n\t- 数据结构\n\t- 刷题\n---\n\n\n# 二叉树练习：\n\n分为：\n树的构建\n树的同构\n子树节点数\n自定义遍历顺序\n子树相同\nTree Travels again\n\n<!-- more -->\n\n## 1. 树的构建\n\n有关二叉树的题目有以下几种输入建树方式：\n1.前序+中序遍历序列\n2.中序+后序遍历序列\n3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数\n4.每个节点子节点数目以及子节点编号\n5.先序序列，空节点以’,’代替\n\n### 1. 前序+中序遍历序列\n\n![前序+中序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG)\n\n从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。\n\n用流程表述如下：\n在前序中确定根节点->在中序中确定根节点->得知左右序列的长度->递归左右序列\n\n你可能会疑惑，那左右节点呢？不是能够确定吗？\n没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。\n\n```\nnode *build( char *pre, char * ins, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*pre ; i++);\n\ts= new node (*pre);\n\ts->lc=build(pre+1,ins,i);\n\ts->rc=build(pre+i+1,ins+i+1,n-i-1);\n\treturn s;\n}\n```\n\n### 2. 中序+后序遍历序列\n\n![中序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG)\n\n和前序+中序一般，这次不过是根节点在最后，流程是类似的。\n\n```\nnode *build(char *ins, char *post, int n)\n{\n\tnode *s=NULL;\n\tif(n<=0) return s;\n\tif(n==1)\n\t{\n\t\ts=new node (*(post+n-1));\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+n-1); i++);\n\ts=new node (*(post+n-1));\n\ts->lc=build(ins,post,i);\n\ts->rc=build(ins+i+1,post+i,n-i-1);\n\treturn s;\n}\n```\n\n### 3. 前序+后序序列\n\n![前序+后序](http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG)\n\n那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？\n这时候就靠左孩子了。而根据给出的性质：**所有节点的子节点数均为偶数**可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）\n\n明确思路后修改一下细节就可以得到如下代码\n\n```\nnode * build( char *pre , char *post, int len )\n{ \n\tnode *s=NULL;\n\tif(len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new node (*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new node (*pre);\n\ts->lc=build(pre+1,post,i+1);\n\ts->rc=build(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n### 4. 子节点编号\n\n假设题目的输入如下：\n第一行为节点总数n，节点编号1-n\n紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。\n范例如下：\n\n```\n7 \n1 6 3\n2 0 4\n1 7 0\n3 0 0\n1 2 1\n2 0 0\n2 0 0\n```\n\n显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：**没有给出根节点编号！**，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。\n\n我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组\n3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。\n1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。\n\nbuild函数很简单，若有孩子则递归构建。\n\n```\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n```\n\n那输入要怎么处理？\n\n```\nmemset(isroot,0,sizeof(isroot)); // 数组归零，很重要！\nfor(int i=1; i<=n; i++)\n{\n\tscanf(\"%d\",&a[i]);\n\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理\n}\nfor(nroot=1; isroot[nroot]==1; nroot++);\ntree=build(nroot);\n```\n\n### 5. 先序序列\n\n还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）\n如\n\n```\nabc,,de,g,,f,,,\n```\n\n很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩\n\n```\nnode *build( int &fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据\n// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir>=n)方便\n{\n\tnode *s=NULL;\n\tif(fir>=n) return s;\n\tif(pre[fir]==',' ) return s;\n\ts=new node(pre[fir]);\n\ts->lc=build(++fir,n);\n\ts->rc=build(++fir,n);\n\treturn s;\n}\n```\n\n## 2. 树的同构\n\n[SDUT 3340: 数据结构实验之二叉树一：树的同构](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html)\n\n题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。\n\n例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。\n\n![图1](http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim)\n\n![图2](http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim)\n\n难点：\n\n1. 树的构建\n2. 同构判断\n\n坑：\n\n1. n和m可能不同\n   在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。\n2. n和m可能为0 (分别或同时)\n\n判等思路：\n1.粗糙版：贪心同构tree1，看看能不能变成tree2。\ntree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样\n\n2.递归巧妙版：判断当前节点数值是否相等\n若两个节点都不存在，返回正确。\n若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&&（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&&（tree1右孩子+tree2左孩子）。\n若不等或者只有其中一个存在，返回错。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n\nchar a[15];\nint llc[15],rrc[15];\nint n,m;\nchar tem1,tem2;\nbool isroot[15];\nint nroot;\n\nstruct node\n{\n\tchar data;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL;}\n\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){}\n};\n\nnode * build(int i)\n{\n\tnode *s=new node (a[i]);\n\tif(llc[i]!=-1)\n\t\ts->lc=build(llc[i]);\n\tif(rrc[i]!=-1)\n\t\ts->rc=build(rrc[i]);\n\treturn s;\n}\n\nnode * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等\n{\n\tnroot=0;\n\tmemset(isroot,0,sizeof(isroot));\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=0; i<n1; i++)\n\t{\t\n\t\tcin>>a[i]>>tem1>>tem2;\n\t\tif(tem1=='-') \n\t\t\tllc[i]=-1;\n\t\telse\n\t\t{\n\t\t\tllc[i]=tem1-'0';\n\t\t\tisroot[llc[i]]=1;\n\t\t}\n\t\tif(tem2=='-') \n\t\t\trrc[i]=-1;\n\t\telse\n\t\t{\n\t\t\trrc[i]=tem2-'0';\n\t\t\tisroot[rrc[i]]=1;\n\t\t}\n\t}\n\tfor( nroot=0; nroot<n1; nroot++)\n\t\tif(isroot[nroot]==0)\n\t\t\tbreak;\n\treturn build(nroot);\n}\n\nbool change(node*r1, node *r2)\n{\n\tif(!r1 && !r2) \n\t\treturn 1;\n\tif(r1&&r2)\n\t{\n\t\tif(r1->data==r2->data)\n\t\t{\n\t\t\tif( (change(r1->rc,r2->rc))&&(change(r1->lc,r2->lc))  || (change(r1->lc,r2->rc))&&(change(r1->rc,r2->lc))   )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\nwhile(cin>>n)\n{\n\tnode* tree1,*tree2;\n\tif(n)\n\t\ttree1=rebuild(n);\n\tcin>>m;\n\tif(m)\n\t\ttree2=rebuild(m);\n\tif(change(tree1,tree2))\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n}\n\treturn 0;\n}\n```\n\n## 3. 子树节点数\n\n[九度OJ 1113：二叉树](http://ac.jobdu.com/problem.php?pid=1113)\n\n题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数\n\n一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。\n\n个人想法（不一定为最简）：\n先求得m和n所在二叉树的高度lenm和lenn，求得’<’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count*po个节点，最后一层的节点数减去count*po后，剩下在po范围里的则是最后一层m可以加上的节点数。\n\n![解法图示](http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim)\n\ncmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\nusing namespace std;\n \nint getheight(int num)\n{\n    return (int)(log(num)*1.0/(log(2)*1.0));\n}\n \nint main()\n{   \n    int m,n;\n\twhile(  scanf(\"%d%d\",&m,&n)&& m+n  )\n\t{   \n\t\tint lenm=getheight(m),lenn=getheight(n);\n\t\tint count=0;\n\t\tint po=1;\n\t\tint ans=0;\n\t\tfor(int i=m-1; ; i--)\n\t\t{\n\t\t\tif(getheight(i)!=lenm)\n\t\t\t\tbreak;\n\t\t\tcount++;  // 找出同层中m左边有多少个节点\n\t\t}\n    \n\t\tfor(int i=lenm; i<lenn; i++)\n\t\t{\n\t\t\tans+=po;   // 在lenn层前的子树节点总数\n\t\t\tpo*=2;\n\t\t}\n\t\tcount*=po;\n\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号\n\t\tif(n<=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围\n\t\t\tprintf(\"%d\\n\",ans);\n\t\telse\n\t\t{\n\t\t\tn-= count+fir-1;\n\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围\n\t\t\tans+=n;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n    return 0;\n}\n```\n\n## 4. 自定义遍历顺序\n\n[SDUT 3133: C要–二叉树中的秘密](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html)\n\n题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。\n\n遍历顺序：\n若根节点只有左子树或右子树，则遍历子树。\n若左右子树均没有，则返回父节点\n若左右子树均有\n若左右节点高度不同，优先遍历高度小的\n若左右节点高度相同，优先遍历储存的数据较小的\n\n难点：\n1.建树\n2.按规则实现遍历\n\n思路：\n跟着题意走就行，注意细节。\n每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *pa,*lc,*rc;\n\tnode(){ pa=lc=rc=NULL; size=1;}\n\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc){size=1;}\n};\nint x;\nint llc[3010],rrc[3010];\nint a[3010];\nbool hasfound;\nint ans;\n\nint updateh(node *s)\n{\n\tif(!s) return 0;\n\treturn s->size=updateh(s->lc)+updateh(s->rc)+1;\n}\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[a[n]])\n\t{\t\n\t\ts->lc=build(llc[a[n]]);\n\t\tif(s->lc)\n\t\t\ts->lc->pa=s;\n\t}\n\tif(rrc[a[n]])\n\t{\t\n\t\ts->rc=build(rrc[a[n]]);\n\t\tif(s->rc)\n\t\t\ts->rc->pa=s;\n\t}\n\treturn s;\n}\n\nvoid found(node *s)\n{\n\tif(hasfound==true) return;\n\tans++;\n\tif(s->data==x)\n\t{\n\t\thasfound=true;\n\t\treturn;\n\t}\n\tif( !s->lc&&s->rc )\n\t\tfound(s->rc);\n\telse if( !s->rc && s->lc )\n\t\tfound(s->lc);\n\telse if( !s->rc && !s->lc)\n\t\treturn;\n\telse\n\t{\n\t\tif(s->rc->size < s->lc->size || (s->rc->size==s->lc->size && s->rc->data < s->lc->data) )\n\t\t{\n\t\t\tfound(s->rc);\n\t\t\tfound(s->lc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfound(s->lc);\n\t\t\tfound(s->rc);\n\t\t}\n\t}\n}\n\n\nint main()\n{   \n\tint n;\n\tnode *tree;\n\tint tem1;\nwhile(~scanf(\"%d%d\",&n,&x))\n{\n\thasfound=false;\n\tans=0;\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\ta[i]=i;\n\t\tscanf(\"%d\",&tem1);\n\t\tif(tem1==0) continue;\n\t\telse if(tem1==1) \n\t\t{\t\n\t\t\tscanf(\"%d\",&llc[i]);\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\t}\n\t}\n\ttree=build(1);\n\tupdateh(tree);\n\tfound(tree);\n\tprintf(\"%d\\n\",ans);\n}\n    return 0;\n}\n```\n\n## 5. 子树相同\n\n[SDUT 3926: bLue的二叉树](http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html)\n\n题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。\n\n思路：\n显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。\n在判断时，\n若tree1中当前节点的size和tree2的根节点size不等或者data不等\n若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点\n若子树的size小于tree2的size，就不判断了\n若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。\n\n```\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<stdlib.h>\n#include<cstring>\n#include<ctime>\n#include<cmath>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n \nstruct node\n{\n\tint data;\n\tint size;\n\tnode *lc,*rc;\n\tnode(){ lc=rc=NULL; size=1;}\n\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc){size=1; }\n};\n\nint llc[100010],rrc[100010];\nint a[100010];\nbool isroot[100010];\nint nroot;\nint ans;\nint pre1[100010],pre2[100010];\nint npre1,npre2;\n\nnode *tree1,*tree2;\n\nnode * build(int n)\n{\n\tnode *s=new node(a[n]);\n\tif(llc[n])\n\t\ts->lc=build(llc[n]);\n\tif(rrc[n])\n\t\ts->rc=build(rrc[n]);\n\treturn s;\n}\n\nvoid bbb(node *&tree, int n)\n{\n\tmemset(llc,0,sizeof(llc));\n\tmemset(rrc,0,sizeof(rrc));\n\tmemset(isroot,0,sizeof(isroot));\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tscanf(\"%d%d\",&llc[i],&rrc[i]);\n\t\tisroot[llc[i]]=isroot[rrc[i]]=1;\n\t}\n\tfor(nroot=1; isroot[nroot]==1; nroot++);\n\ttree=build(nroot);\n}\n\nint update(node *tree)\n{\n\tif(!tree) return 0;\n\treturn tree->size=1+update(tree->lc)+update(tree->rc);\n}\n\nint n,m;\n\nbool equal(node *tree1, node *tree2)\n{\n\tif( !tree1 && !tree2 ) return true;\n\tif( (!tree1 && tree2) || ( tree1&&!tree2 ) ) return false; \n\tif(tree1->size!=tree2->size || tree1->data!=tree2->data)\n\t\treturn false;\n\treturn equal(tree1->lc,tree2->lc)&&equal(tree1->rc,tree2->rc);\n}\n\nvoid com(node *tree)\n{\n\tif(tree->size!=tree2->size || tree->data!=tree2->data)\n\t{\n\t\t\n\t\tif( tree->lc && tree->lc->size>=tree2->size)\n\t\t\tcom(tree->lc);\n\t\tif( tree->rc && tree->rc->size>=tree2->size)\n\t\t\tcom(tree->rc);\n\t}\n\telse\n\t\tif(equal(tree,tree2)==true)\n\t\t\tans++;\n\treturn;\n}\n\nvoid release(node *tree)\n{\n\tif(!tree) return;\n\trelease(tree->lc);\n\trelease(tree->rc);\n\tdelete tree;\n}\n\nint main()\n{   \nwhile(~scanf(\"%d%d\",&n,&m))\n{\n\tans=0;\n\tnpre1=npre2=0;\n\tmemset(pre1,0,sizeof(pre1));\n\tmemset(pre2,0,sizeof(pre2));\n\tbbb(tree1,n);\n\tbbb(tree2,m);\n\tif(m>n)\n\t{\n\t\tprintf(\"0\\n\");\n\t\tcontinue;\n\t}\n\tupdate(tree1);\n\tupdate(tree2);\n\tcom(tree1);\n\tprintf(\"%d\\n\",ans);\n\trelease(tree1);\n\trelease(tree2);\n}\n    return 0;\n}\n```\n\n\n## 6. Tree Travels again\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG)\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG)\n\n题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列\n\n思路：经过观察可以发现，入栈的顺序其实就是**先序遍历的序列**，出栈顺序就是**中序遍历的序列**，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了\n\n优化：\n在得到序列后，可以不用建树，直接根据序列得到后序序列\n思路：分治\n先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可\n\n代码：\n\n```\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <stdio.h>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n\nstruct Node\n{\n\tint data;\n\tNode * left,* right;\n\tNode() {left=right=NULL;}\n\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r){}\n};\n\nint pre[100],in[100];\nint stack[100];\nint top=0;\nint npre=0,nin=0;\nint ans[100];\n\nvoid solve(int prei , int ini , int posti, int n)\n{\n\tif(n<=0) return ; \n\tif(n==1)\n\t{\n\t\tans[posti]=pre[prei];\n\t\treturn;\n\t}\n\tans[posti+n-1]=pre[prei];\n\tint i;\n\tfor(i=0; in[i+ini]!=pre[prei] ; i++);\n\tsolve( prei+1 , ini , posti , i );\n\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tchar c[10];\n\tint tem;\n\t// 根据出入栈构造序列\n\twhile(cin>>c)\n\t{\n\t\tif(c[1]=='u')\n\t\t{\n\t\t\tcin>>tem;\n\t\t\tstack[top++]=tem;\n\t\t\tpre[npre++]=tem;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin[nin++]=stack[--top];\n\t\t}\n\t}\n\tsolve(0,0,0,n);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```","slug":"ProblemSet_Tree","published":1,"updated":"2018-05-25T12:41:12.805Z","photos":[],"link":"","_id":"cjhvssaef0013jvfcsjvzoivx","content":"<h1 id=\"二叉树练习：\"><a href=\"#二叉树练习：\" class=\"headerlink\" title=\"二叉树练习：\"></a>二叉树练习：</h1><p>分为：<br>树的构建<br>树的同构<br>子树节点数<br>自定义遍历顺序<br>子树相同<br>Tree Travels again</p>\n<a id=\"more\"></a>\n<h2 id=\"1-树的构建\"><a href=\"#1-树的构建\" class=\"headerlink\" title=\"1. 树的构建\"></a>1. 树的构建</h2><p>有关二叉树的题目有以下几种输入建树方式：<br>1.前序+中序遍历序列<br>2.中序+后序遍历序列<br>3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数<br>4.每个节点子节点数目以及子节点编号<br>5.先序序列，空节点以’,’代替</p>\n<h3 id=\"1-前序-中序遍历序列\"><a href=\"#1-前序-中序遍历序列\" class=\"headerlink\" title=\"1. 前序+中序遍历序列\"></a>1. 前序+中序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG\" alt=\"前序+中序\"></p>\n<p>从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。</p>\n<p>用流程表述如下：<br>在前序中确定根节点-&gt;在中序中确定根节点-&gt;得知左右序列的长度-&gt;递归左右序列</p>\n<p>你可能会疑惑，那左右节点呢？不是能够确定吗？<br>没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( char *pre, char * ins, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*pre ; i++);</span><br><span class=\"line\">\ts= new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,ins,i);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+1,ins+i+1,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序-后序遍历序列\"><a href=\"#2-中序-后序遍历序列\" class=\"headerlink\" title=\"2. 中序+后序遍历序列\"></a>2. 中序+后序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG\" alt=\"中序+后序\"></p>\n<p>和前序+中序一般，这次不过是根节点在最后，流程是类似的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build(char *ins, char *post, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*(post+n-1));</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+n-1); i++);</span><br><span class=\"line\">\ts=new node (*(post+n-1));</span><br><span class=\"line\">\ts-&gt;lc=build(ins,post,i);</span><br><span class=\"line\">\ts-&gt;rc=build(ins+i+1,post+i,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-前序-后序序列\"><a href=\"#3-前序-后序序列\" class=\"headerlink\" title=\"3. 前序+后序序列\"></a>3. 前序+后序序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG\" alt=\"前序+后序\"></p>\n<p>那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？<br>这时候就靠左孩子了。而根据给出的性质：<strong>所有节点的子节点数均为偶数</strong>可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）</p>\n<p>明确思路后修改一下细节就可以得到如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build( char *pre , char *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-子节点编号\"><a href=\"#4-子节点编号\" class=\"headerlink\" title=\"4. 子节点编号\"></a>4. 子节点编号</h3><p>假设题目的输入如下：<br>第一行为节点总数n，节点编号1-n<br>紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。<br>范例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 </span><br><span class=\"line\">1 6 3</span><br><span class=\"line\">2 0 4</span><br><span class=\"line\">1 7 0</span><br><span class=\"line\">3 0 0</span><br><span class=\"line\">1 2 1</span><br><span class=\"line\">2 0 0</span><br><span class=\"line\">2 0 0</span><br></pre></td></tr></table></figure>\n<p>显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：<strong>没有给出根节点编号！</strong>，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。</p>\n<p>我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组<br>3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。<br>1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。</p>\n<p>build函数很简单，若有孩子则递归构建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那输入要怎么处理？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memset(isroot,0,sizeof(isroot)); // 数组归零，很重要！</span><br><span class=\"line\">for(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">tree=build(nroot);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-先序序列\"><a href=\"#5-先序序列\" class=\"headerlink\" title=\"5. 先序序列\"></a>5. 先序序列</h3><p>还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）<br>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abc,,de,g,,f,,,</span><br></pre></td></tr></table></figure>\n<p>很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( int &amp;fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据</span><br><span class=\"line\">// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir&gt;=n)方便</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(fir&gt;=n) return s;</span><br><span class=\"line\">\tif(pre[fir]==&apos;,&apos; ) return s;</span><br><span class=\"line\">\ts=new node(pre[fir]);</span><br><span class=\"line\">\ts-&gt;lc=build(++fir,n);</span><br><span class=\"line\">\ts-&gt;rc=build(++fir,n);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-树的同构\"><a href=\"#2-树的同构\" class=\"headerlink\" title=\"2. 树的同构\"></a>2. 树的同构</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html\" target=\"_blank\" rel=\"noopener\">SDUT 3340: 数据结构实验之二叉树一：树的同构</a></p>\n<p>题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p>\n<p>例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim\" alt=\"图1\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim\" alt=\"图2\"></p>\n<p>难点：</p>\n<ol>\n<li>树的构建</li>\n<li>同构判断</li>\n</ol>\n<p>坑：</p>\n<ol>\n<li>n和m可能不同<br>在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。</li>\n<li>n和m可能为0 (分别或同时)</li>\n</ol>\n<p>判等思路：<br>1.粗糙版：贪心同构tree1，看看能不能变成tree2。<br>tree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样</p>\n<p>2.递归巧妙版：判断当前节点数值是否相等<br>若两个节点都不存在，返回正确。<br>若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&amp;&amp;（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&amp;&amp;（tree1右孩子+tree2左孩子）。<br>若不等或者只有其中一个存在，返回错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">char a[15];</span><br><span class=\"line\">int llc[15],rrc[15];</span><br><span class=\"line\">int n,m;</span><br><span class=\"line\">char tem1,tem2;</span><br><span class=\"line\">bool isroot[15];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\"></span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar data;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL;&#125;</span><br><span class=\"line\">\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node (a[i]);</span><br><span class=\"line\">\tif(llc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[i]);</span><br><span class=\"line\">\tif(rrc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[i]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnroot=0;</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n1; i++)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i]&gt;&gt;tem1&gt;&gt;tem2;</span><br><span class=\"line\">\t\tif(tem1==&apos;-&apos;) </span><br><span class=\"line\">\t\t\tllc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tllc[i]=tem1-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[llc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(tem2==&apos;-&apos;) </span><br><span class=\"line\">\t\t\trrc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\trrc[i]=tem2-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[rrc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( nroot=0; nroot&lt;n1; nroot++)</span><br><span class=\"line\">\t\tif(isroot[nroot]==0)</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\treturn build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool change(node*r1, node *r2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!r1 &amp;&amp; !r2) </span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tif(r1&amp;&amp;r2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(r1-&gt;data==r2-&gt;data)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( (change(r1-&gt;rc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;lc,r2-&gt;lc))  || (change(r1-&gt;lc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;rc,r2-&gt;lc))   )</span><br><span class=\"line\">\t\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">while(cin&gt;&gt;n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode* tree1,*tree2;</span><br><span class=\"line\">\tif(n)</span><br><span class=\"line\">\t\ttree1=rebuild(n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\tif(m)</span><br><span class=\"line\">\t\ttree2=rebuild(m);</span><br><span class=\"line\">\tif(change(tree1,tree2))</span><br><span class=\"line\">\t\tprintf(&quot;Yes\\n&quot;);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tprintf(&quot;No\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-子树节点数\"><a href=\"#3-子树节点数\" class=\"headerlink\" title=\"3. 子树节点数\"></a>3. 子树节点数</h2><p><a href=\"http://ac.jobdu.com/problem.php?pid=1113\" target=\"_blank\" rel=\"noopener\">九度OJ 1113：二叉树</a></p>\n<p>题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数</p>\n<p>一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。</p>\n<p>个人想法（不一定为最简）：<br>先求得m和n所在二叉树的高度lenm和lenn，求得’&lt;’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count<em>po个节点，最后一层的节点数减去count</em>po后，剩下在po范围里的则是最后一层m可以加上的节点数。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim\" alt=\"解法图示\"></p>\n<p>cmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">int getheight(int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (int)(log(num)*1.0/(log(2)*1.0));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    int m,n;</span><br><span class=\"line\">\twhile(  scanf(&quot;%d%d&quot;,&amp;m,&amp;n)&amp;&amp; m+n  )</span><br><span class=\"line\">\t&#123;   </span><br><span class=\"line\">\t\tint lenm=getheight(m),lenn=getheight(n);</span><br><span class=\"line\">\t\tint count=0;</span><br><span class=\"line\">\t\tint po=1;</span><br><span class=\"line\">\t\tint ans=0;</span><br><span class=\"line\">\t\tfor(int i=m-1; ; i--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif(getheight(i)!=lenm)</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcount++;  // 找出同层中m左边有多少个节点</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\tfor(int i=lenm; i&lt;lenn; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tans+=po;   // 在lenn层前的子树节点总数</span><br><span class=\"line\">\t\t\tpo*=2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount*=po;</span><br><span class=\"line\">\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号</span><br><span class=\"line\">\t\tif(n&lt;=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tn-= count+fir-1;</span><br><span class=\"line\">\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围</span><br><span class=\"line\">\t\t\tans+=n;</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-自定义遍历顺序\"><a href=\"#4-自定义遍历顺序\" class=\"headerlink\" title=\"4. 自定义遍历顺序\"></a>4. 自定义遍历顺序</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html\" target=\"_blank\" rel=\"noopener\">SDUT 3133: C要–二叉树中的秘密</a></p>\n<p>题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。</p>\n<p>遍历顺序：<br>若根节点只有左子树或右子树，则遍历子树。<br>若左右子树均没有，则返回父节点<br>若左右子树均有<br>若左右节点高度不同，优先遍历高度小的<br>若左右节点高度相同，优先遍历储存的数据较小的</p>\n<p>难点：<br>1.建树<br>2.按规则实现遍历</p>\n<p>思路：<br>跟着题意走就行，注意细节。<br>每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *pa,*lc,*rc;</span><br><span class=\"line\">\tnode()&#123; pa=lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc)&#123;size=1;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int x;</span><br><span class=\"line\">int llc[3010],rrc[3010];</span><br><span class=\"line\">int a[3010];</span><br><span class=\"line\">bool hasfound;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\"></span><br><span class=\"line\">int updateh(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!s) return 0;</span><br><span class=\"line\">\treturn s-&gt;size=updateh(s-&gt;lc)+updateh(s-&gt;rc)+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;lc)</span><br><span class=\"line\">\t\t\ts-&gt;lc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(rrc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;rc)</span><br><span class=\"line\">\t\t\ts-&gt;rc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void found(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(hasfound==true) return;</span><br><span class=\"line\">\tans++;</span><br><span class=\"line\">\tif(s-&gt;data==x)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thasfound=true;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s-&gt;lc&amp;&amp;s-&gt;rc )</span><br><span class=\"line\">\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; s-&gt;lc )</span><br><span class=\"line\">\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; !s-&gt;lc)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s-&gt;rc-&gt;size &lt; s-&gt;lc-&gt;size || (s-&gt;rc-&gt;size==s-&gt;lc-&gt;size &amp;&amp; s-&gt;rc-&gt;data &lt; s-&gt;lc-&gt;data) )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tnode *tree;</span><br><span class=\"line\">\tint tem1;</span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;x))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\thasfound=false;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[i]=i;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem1);</span><br><span class=\"line\">\t\tif(tem1==0) continue;</span><br><span class=\"line\">\t\telse if(tem1==1) </span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;llc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttree=build(1);</span><br><span class=\"line\">\tupdateh(tree);</span><br><span class=\"line\">\tfound(tree);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-子树相同\"><a href=\"#5-子树相同\" class=\"headerlink\" title=\"5. 子树相同\"></a>5. 子树相同</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html\" target=\"_blank\" rel=\"noopener\">SDUT 3926: bLue的二叉树</a></p>\n<p>题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。</p>\n<p>思路：<br>显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。<br>在判断时，<br>若tree1中当前节点的size和tree2的根节点size不等或者data不等<br>若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点<br>若子树的size小于tree2的size，就不判断了<br>若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;size=1; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int llc[100010],rrc[100010];</span><br><span class=\"line\">int a[100010];</span><br><span class=\"line\">bool isroot[100010];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\">int pre1[100010],pre2[100010];</span><br><span class=\"line\">int npre1,npre2;</span><br><span class=\"line\"></span><br><span class=\"line\">node *tree1,*tree2;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void bbb(node *&amp;tree, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\tisroot[llc[i]]=isroot[rrc[i]]=1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">\ttree=build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int update(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return 0;</span><br><span class=\"line\">\treturn tree-&gt;size=1+update(tree-&gt;lc)+update(tree-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int n,m;</span><br><span class=\"line\"></span><br><span class=\"line\">bool equal(node *tree1, node *tree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( !tree1 &amp;&amp; !tree2 ) return true;</span><br><span class=\"line\">\tif( (!tree1 &amp;&amp; tree2) || ( tree1&amp;&amp;!tree2 ) ) return false; </span><br><span class=\"line\">\tif(tree1-&gt;size!=tree2-&gt;size || tree1-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn equal(tree1-&gt;lc,tree2-&gt;lc)&amp;&amp;equal(tree1-&gt;rc,tree2-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void com(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(tree-&gt;size!=tree2-&gt;size || tree-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tif( tree-&gt;lc &amp;&amp; tree-&gt;lc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;lc);</span><br><span class=\"line\">\t\tif( tree-&gt;rc &amp;&amp; tree-&gt;rc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;rc);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif(equal(tree,tree2)==true)</span><br><span class=\"line\">\t\t\tans++;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void release(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return;</span><br><span class=\"line\">\trelease(tree-&gt;lc);</span><br><span class=\"line\">\trelease(tree-&gt;rc);</span><br><span class=\"line\">\tdelete tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tnpre1=npre2=0;</span><br><span class=\"line\">\tmemset(pre1,0,sizeof(pre1));</span><br><span class=\"line\">\tmemset(pre2,0,sizeof(pre2));</span><br><span class=\"line\">\tbbb(tree1,n);</span><br><span class=\"line\">\tbbb(tree2,m);</span><br><span class=\"line\">\tif(m&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tupdate(tree1);</span><br><span class=\"line\">\tupdate(tree2);</span><br><span class=\"line\">\tcom(tree1);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\trelease(tree1);</span><br><span class=\"line\">\trelease(tree2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-Tree-Travels-again\"><a href=\"#6-Tree-Travels-again\" class=\"headerlink\" title=\"6. Tree Travels again\"></a>6. Tree Travels again</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG\" alt=\"mark\"></p>\n<p>题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列</p>\n<p>思路：经过观察可以发现，入栈的顺序其实就是<strong>先序遍历的序列</strong>，出栈顺序就是<strong>中序遍历的序列</strong>，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了</p>\n<p>优化：<br>在得到序列后，可以不用建树，直接根据序列得到后序序列<br>思路：分治<br>先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctime&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tNode * left,* right;</span><br><span class=\"line\">\tNode() &#123;left=right=NULL;&#125;</span><br><span class=\"line\">\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int pre[100],in[100];</span><br><span class=\"line\">int stack[100];</span><br><span class=\"line\">int top=0;</span><br><span class=\"line\">int npre=0,nin=0;</span><br><span class=\"line\">int ans[100];</span><br><span class=\"line\"></span><br><span class=\"line\">void solve(int prei , int ini , int posti, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(n&lt;=0) return ; </span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans[posti]=pre[prei];</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans[posti+n-1]=pre[prei];</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; in[i+ini]!=pre[prei] ; i++);</span><br><span class=\"line\">\tsolve( prei+1 , ini , posti , i );</span><br><span class=\"line\">\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tchar c[10];</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\t// 根据出入栈构造序列</span><br><span class=\"line\">\twhile(cin&gt;&gt;c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(c[1]==&apos;u&apos;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;tem;</span><br><span class=\"line\">\t\t\tstack[top++]=tem;</span><br><span class=\"line\">\t\t\tpre[npre++]=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tin[nin++]=stack[--top];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsolve(0,0,0,n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(i) printf(&quot; &quot;);</span><br><span class=\"line\">\t\tprintf(&quot;%d&quot;,ans[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"二叉树练习：\"><a href=\"#二叉树练习：\" class=\"headerlink\" title=\"二叉树练习：\"></a>二叉树练习：</h1><p>分为：<br>树的构建<br>树的同构<br>子树节点数<br>自定义遍历顺序<br>子树相同<br>Tree Travels again</p>","more":"<h2 id=\"1-树的构建\"><a href=\"#1-树的构建\" class=\"headerlink\" title=\"1. 树的构建\"></a>1. 树的构建</h2><p>有关二叉树的题目有以下几种输入建树方式：<br>1.前序+中序遍历序列<br>2.中序+后序遍历序列<br>3.前序+后序序列，同时说明该二叉树的所有节点子节点数为偶数<br>4.每个节点子节点数目以及子节点编号<br>5.先序序列，空节点以’,’代替</p>\n<h3 id=\"1-前序-中序遍历序列\"><a href=\"#1-前序-中序遍历序列\" class=\"headerlink\" title=\"1. 前序+中序遍历序列\"></a>1. 前序+中序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/hCiffgFFLD.JPG\" alt=\"前序+中序\"></p>\n<p>从图中可以看出，前序的第一个节点为根节点，第二个为左孩子，通过拿根节点在中序中搜索，可以将中序的序列分成左右两部分，由此可以得到左序列的长度，进而能够在前序中确定右孩子，而后在递归构建左子树和右子树。</p>\n<p>用流程表述如下：<br>在前序中确定根节点-&gt;在中序中确定根节点-&gt;得知左右序列的长度-&gt;递归左右序列</p>\n<p>你可能会疑惑，那左右节点呢？不是能够确定吗？<br>没错，但是会额外增加判断和细节确定，不如一次递归确定根节点，然后递归左右子树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( char *pre, char * ins, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*pre ; i++);</span><br><span class=\"line\">\ts= new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,ins,i);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+1,ins+i+1,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序-后序遍历序列\"><a href=\"#2-中序-后序遍历序列\" class=\"headerlink\" title=\"2. 中序+后序遍历序列\"></a>2. 中序+后序遍历序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/lJ1GBIf81b.JPG\" alt=\"中序+后序\"></p>\n<p>和前序+中序一般，这次不过是根节点在最后，流程是类似的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build(char *ins, char *post, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(n&lt;=0) return s;</span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*(post+n-1));</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+n-1); i++);</span><br><span class=\"line\">\ts=new node (*(post+n-1));</span><br><span class=\"line\">\ts-&gt;lc=build(ins,post,i);</span><br><span class=\"line\">\ts-&gt;rc=build(ins+i+1,post+i,n-i-1);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-前序-后序序列\"><a href=\"#3-前序-后序序列\" class=\"headerlink\" title=\"3. 前序+后序序列\"></a>3. 前序+后序序列</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/miHddAiGEf.JPG\" alt=\"前序+后序\"></p>\n<p>那在前序+后序中，根节点不是最前就是最后，怎么确定左右序列长度呢？<br>这时候就靠左孩子了。而根据给出的性质：<strong>所有节点的子节点数均为偶数</strong>可以判断，一个节点要么没有孩子，要么就有两个孩子，这也是我们能够大胆判定序列第二个是左孩子而不用担心只有左孩子而没有右孩子的情况。（没有左右孩子，只有根节点就直接返回了）</p>\n<p>明确思路后修改一下细节就可以得到如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build( char *pre , char *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new node (*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new node (*pre);</span><br><span class=\"line\">\ts-&gt;lc=build(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rc=build(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-子节点编号\"><a href=\"#4-子节点编号\" class=\"headerlink\" title=\"4. 子节点编号\"></a>4. 子节点编号</h3><p>假设题目的输入如下：<br>第一行为节点总数n，节点编号1-n<br>紧接n行，每行三个数字，第一个数字代表该节点权值，第二三为左右孩子的编号，若无孩子，以0代替。<br>范例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 </span><br><span class=\"line\">1 6 3</span><br><span class=\"line\">2 0 4</span><br><span class=\"line\">1 7 0</span><br><span class=\"line\">3 0 0</span><br><span class=\"line\">1 2 1</span><br><span class=\"line\">2 0 0</span><br><span class=\"line\">2 0 0</span><br></pre></td></tr></table></figure>\n<p>显然，我们有四种数据需要处理：该节点编号，该节点权值，该节点左右孩子编号。而最重要的一点是：<strong>没有给出根节点编号！</strong>，除非题目明确表示几号为根节点，否则默认将1号当做根节点那可就从开始就错了。</p>\n<p>我个人的做法是：用3个int数组(视情况可能1个char+2个int) +1个bool数组<br>3个int数组a[i],llc[i],rrc[i]分别保存编号为i的权值、左孩子编号、右孩子编号。<br>1个bool数组isroot用来确定根节点。题目保证必定能够构造一棵合法的二叉树，那么就不会出现1棵树+1个孤立节点的情况，那么，不被任何节点当做左右孩子的节点就自然是根节点了。只需要在输入左右孩子编号时额外在isroot里维护一下，最后扫描一遍isroot数组就能够确定root的编号了。</p>\n<p>build函数很简单，若有孩子则递归构建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那输入要怎么处理？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memset(isroot,0,sizeof(isroot)); // 数组归零，很重要！</span><br><span class=\"line\">for(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\tisroot[llc[i]]=isroot[rrc[i]]=1;   // 此处题目已经说若无孩子则为0，而编号从1开始，因此无关紧要，若是规定为-1，则需要额外处理</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">tree=build(nroot);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-先序序列\"><a href=\"#5-先序序列\" class=\"headerlink\" title=\"5. 先序序列\"></a>5. 先序序列</h3><p>还有的时候，题目只给出先序序列，但是额外表明了空节点（一般以’,’标明）<br>如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abc,,de,g,,f,,,</span><br></pre></td></tr></table></figure>\n<p>很简单，只需要模仿先序遍历的过程即可，重要的在于要确定数组的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node *build( int &amp;fir , int n) // 用引用很重要！否则在递归中会丢失自增的数据</span><br><span class=\"line\">// 而之所以不把传fir改为把数组的首地址传进来，因为判断是否到达数组尾部需要额外的功夫，不如一句if(fir&gt;=n)方便</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=NULL;</span><br><span class=\"line\">\tif(fir&gt;=n) return s;</span><br><span class=\"line\">\tif(pre[fir]==&apos;,&apos; ) return s;</span><br><span class=\"line\">\ts=new node(pre[fir]);</span><br><span class=\"line\">\ts-&gt;lc=build(++fir,n);</span><br><span class=\"line\">\ts-&gt;rc=build(++fir,n);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-树的同构\"><a href=\"#2-树的同构\" class=\"headerlink\" title=\"2. 树的同构\"></a>2. 树的同构</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3340.html\" target=\"_blank\" rel=\"noopener\">SDUT 3340: 数据结构实验之二叉树一：树的同构</a></p>\n<p>题意：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p>\n<p>例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/5aAHAglgKi.png?imageslim\" alt=\"图1\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170818/dha1ah025f.png?imageslim\" alt=\"图2\"></p>\n<p>难点：</p>\n<ol>\n<li>树的构建</li>\n<li>同构判断</li>\n</ol>\n<p>坑：</p>\n<ol>\n<li>n和m可能不同<br>在n、m不等的情况下，你还是必须要把数据录入完，不然像这样连续输入的数据，上一组不录完直接出结果会影响下一组的录入。</li>\n<li>n和m可能为0 (分别或同时)</li>\n</ol>\n<p>判等思路：<br>1.粗糙版：贪心同构tree1，看看能不能变成tree2。<br>tree1和tree2同步递归，每到一个节点判断左右节点是否相同（可能不存在），若不同就交换左右节点。最后两棵树都出先序遍历的序列判断是不是一模一样</p>\n<p>2.递归巧妙版：判断当前节点数值是否相等<br>若两个节点都不存在，返回正确。<br>若均存在且相等，递归查询（tree1左孩子+tree2左孩子）&amp;&amp;（tree1右孩子+tree2右孩子） 或者 （tree1左孩子+tree2右孩子）&amp;&amp;（tree1右孩子+tree2左孩子）。<br>若不等或者只有其中一个存在，返回错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">char a[15];</span><br><span class=\"line\">int llc[15],rrc[15];</span><br><span class=\"line\">int n,m;</span><br><span class=\"line\">char tem1,tem2;</span><br><span class=\"line\">bool isroot[15];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\"></span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar data;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL;&#125;</span><br><span class=\"line\">\tnode(char d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node (a[i]);</span><br><span class=\"line\">\tif(llc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[i]);</span><br><span class=\"line\">\tif(rrc[i]!=-1)</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[i]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * rebuild(int n1)  // 坑点！ 需要把节点数传进去，若用全局的n或者m会错，因为nm不一定相等</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnroot=0;</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=0; i&lt;n1; i++)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i]&gt;&gt;tem1&gt;&gt;tem2;</span><br><span class=\"line\">\t\tif(tem1==&apos;-&apos;) </span><br><span class=\"line\">\t\t\tllc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tllc[i]=tem1-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[llc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(tem2==&apos;-&apos;) </span><br><span class=\"line\">\t\t\trrc[i]=-1;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\trrc[i]=tem2-&apos;0&apos;;</span><br><span class=\"line\">\t\t\tisroot[rrc[i]]=1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor( nroot=0; nroot&lt;n1; nroot++)</span><br><span class=\"line\">\t\tif(isroot[nroot]==0)</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\treturn build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool change(node*r1, node *r2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!r1 &amp;&amp; !r2) </span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tif(r1&amp;&amp;r2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(r1-&gt;data==r2-&gt;data)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( (change(r1-&gt;rc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;lc,r2-&gt;lc))  || (change(r1-&gt;lc,r2-&gt;rc))&amp;&amp;(change(r1-&gt;rc,r2-&gt;lc))   )</span><br><span class=\"line\">\t\t\t\treturn 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">while(cin&gt;&gt;n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode* tree1,*tree2;</span><br><span class=\"line\">\tif(n)</span><br><span class=\"line\">\t\ttree1=rebuild(n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\tif(m)</span><br><span class=\"line\">\t\ttree2=rebuild(m);</span><br><span class=\"line\">\tif(change(tree1,tree2))</span><br><span class=\"line\">\t\tprintf(&quot;Yes\\n&quot;);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tprintf(&quot;No\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-子树节点数\"><a href=\"#3-子树节点数\" class=\"headerlink\" title=\"3. 子树节点数\"></a>3. 子树节点数</h2><p><a href=\"http://ac.jobdu.com/problem.php?pid=1113\" target=\"_blank\" rel=\"noopener\">九度OJ 1113：二叉树</a></p>\n<p>题意：一棵完全二叉树，层次遍历为1-n。给定一节点数值m和最后一个节点数值n，求m的子树节点数</p>\n<p>一道数学题，不需要构造二叉树，但是需要对二叉树的各种性质比较了解。</p>\n<p>个人想法（不一定为最简）：<br>先求得m和n所在二叉树的高度lenm和lenn，求得’&lt;’lenn时的总子树节点数，问题就在于最后一层。我的做法是通过n求得最后一层有多少个节点，然后看m同层左边有多少个节点(count)，假设在最后一层m可以加上po个节点，那左边还有count<em>po个节点，最后一层的节点数减去count</em>po后，剩下在po范围里的则是最后一层m可以加上的节点数。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170822/BEacbGD51k.png?imageslim\" alt=\"解法图示\"></p>\n<p>cmath里的log函数是以e为底，因此需要手动用换底公式换成以2为底。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">int getheight(int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (int)(log(num)*1.0/(log(2)*1.0));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    int m,n;</span><br><span class=\"line\">\twhile(  scanf(&quot;%d%d&quot;,&amp;m,&amp;n)&amp;&amp; m+n  )</span><br><span class=\"line\">\t&#123;   </span><br><span class=\"line\">\t\tint lenm=getheight(m),lenn=getheight(n);</span><br><span class=\"line\">\t\tint count=0;</span><br><span class=\"line\">\t\tint po=1;</span><br><span class=\"line\">\t\tint ans=0;</span><br><span class=\"line\">\t\tfor(int i=m-1; ; i--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif(getheight(i)!=lenm)</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcount++;  // 找出同层中m左边有多少个节点</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\tfor(int i=lenm; i&lt;lenn; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tans+=po;   // 在lenn层前的子树节点总数</span><br><span class=\"line\">\t\t\tpo*=2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount*=po;</span><br><span class=\"line\">\t\tint fir=pow(2,lenn);  // 第lenn层第一个节点的编号</span><br><span class=\"line\">\t\tif(n&lt;=count+fir-1)   // n数目很少，都没有进入m在这层的子树范围</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tn-= count+fir-1;</span><br><span class=\"line\">\t\t\tn=min(n,po);    // 也可能n很大，超出了m的子树范围</span><br><span class=\"line\">\t\t\tans+=n;</span><br><span class=\"line\">\t\t\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-自定义遍历顺序\"><a href=\"#4-自定义遍历顺序\" class=\"headerlink\" title=\"4. 自定义遍历顺序\"></a>4. 自定义遍历顺序</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3133.html\" target=\"_blank\" rel=\"noopener\">SDUT 3133: C要–二叉树中的秘密</a></p>\n<p>题意：在给定的二叉树中遍历查找某个点，给定遍历顺序，输出从根节点开始遍历到目标点需要多少步。</p>\n<p>遍历顺序：<br>若根节点只有左子树或右子树，则遍历子树。<br>若左右子树均没有，则返回父节点<br>若左右子树均有<br>若左右节点高度不同，优先遍历高度小的<br>若左右节点高度相同，优先遍历储存的数据较小的</p>\n<p>难点：<br>1.建树<br>2.按规则实现遍历</p>\n<p>思路：<br>跟着题意走就行，注意细节。<br>每个节点储存数据外还维护一个值size，size为以该节点为根节点的子树的总结点数，用update函数递归地自顶向下求size</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *pa,*lc,*rc;</span><br><span class=\"line\">\tnode()&#123; pa=lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node*ppa=NULL,node * llc = NULL, node * rrc=NULL):data(d),pa(ppa),lc(llc),rc(rrc)&#123;size=1;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int x;</span><br><span class=\"line\">int llc[3010],rrc[3010];</span><br><span class=\"line\">int a[3010];</span><br><span class=\"line\">bool hasfound;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\"></span><br><span class=\"line\">int updateh(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!s) return 0;</span><br><span class=\"line\">\treturn s-&gt;size=updateh(s-&gt;lc)+updateh(s-&gt;rc)+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;lc)</span><br><span class=\"line\">\t\t\ts-&gt;lc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(rrc[a[n]])</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[a[n]]);</span><br><span class=\"line\">\t\tif(s-&gt;rc)</span><br><span class=\"line\">\t\t\ts-&gt;rc-&gt;pa=s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void found(node *s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(hasfound==true) return;</span><br><span class=\"line\">\tans++;</span><br><span class=\"line\">\tif(s-&gt;data==x)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thasfound=true;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s-&gt;lc&amp;&amp;s-&gt;rc )</span><br><span class=\"line\">\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; s-&gt;lc )</span><br><span class=\"line\">\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\telse if( !s-&gt;rc &amp;&amp; !s-&gt;lc)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s-&gt;rc-&gt;size &lt; s-&gt;lc-&gt;size || (s-&gt;rc-&gt;size==s-&gt;lc-&gt;size &amp;&amp; s-&gt;rc-&gt;data &lt; s-&gt;lc-&gt;data) )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tfound(s-&gt;lc);</span><br><span class=\"line\">\t\t\tfound(s-&gt;rc);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tnode *tree;</span><br><span class=\"line\">\tint tem1;</span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;x))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\thasfound=false;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[i]=i;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;tem1);</span><br><span class=\"line\">\t\tif(tem1==0) continue;</span><br><span class=\"line\">\t\telse if(tem1==1) </span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;,&amp;llc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttree=build(1);</span><br><span class=\"line\">\tupdateh(tree);</span><br><span class=\"line\">\tfound(tree);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-子树相同\"><a href=\"#5-子树相同\" class=\"headerlink\" title=\"5. 子树相同\"></a>5. 子树相同</h2><p><a href=\"http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3926.html\" target=\"_blank\" rel=\"noopener\">SDUT 3926: bLue的二叉树</a></p>\n<p>题意：给定两棵二叉树tree1和tree2，求tree1中有多少子树和tree2完全相同。</p>\n<p>思路：<br>显然，直接暴力递归求等必定超时，我的简化方法是每个节点维护一个size值，如上题所示，size为以该节点为根节点的子树总节点数目。<br>在判断时，<br>若tree1中当前节点的size和tree2的根节点size不等或者data不等<br>若子树（左右均可）的size大于等于根节点的size，递归判断子树根节点<br>若子树的size小于tree2的size，就不判断了<br>若当前节点和tree2的根节点size相同并且数据相同，那就可以开始递归判断是否完全相等了，相等的话ans计数器自增，不等就返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;cstring&gt;</span><br><span class=\"line\">#include&lt;ctime&gt;</span><br><span class=\"line\">#include&lt;cmath&gt;</span><br><span class=\"line\">#include&lt;math.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\">\tnode *lc,*rc;</span><br><span class=\"line\">\tnode()&#123; lc=rc=NULL; size=1;&#125;</span><br><span class=\"line\">\tnode(int d, node * llc = NULL, node * rrc=NULL):data(d),lc(llc),rc(rrc)&#123;size=1; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int llc[100010],rrc[100010];</span><br><span class=\"line\">int a[100010];</span><br><span class=\"line\">bool isroot[100010];</span><br><span class=\"line\">int nroot;</span><br><span class=\"line\">int ans;</span><br><span class=\"line\">int pre1[100010],pre2[100010];</span><br><span class=\"line\">int npre1,npre2;</span><br><span class=\"line\"></span><br><span class=\"line\">node *tree1,*tree2;</span><br><span class=\"line\"></span><br><span class=\"line\">node * build(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnode *s=new node(a[n]);</span><br><span class=\"line\">\tif(llc[n])</span><br><span class=\"line\">\t\ts-&gt;lc=build(llc[n]);</span><br><span class=\"line\">\tif(rrc[n])</span><br><span class=\"line\">\t\ts-&gt;rc=build(rrc[n]);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void bbb(node *&amp;tree, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmemset(llc,0,sizeof(llc));</span><br><span class=\"line\">\tmemset(rrc,0,sizeof(rrc));</span><br><span class=\"line\">\tmemset(isroot,0,sizeof(isroot));</span><br><span class=\"line\">\tfor(int i=1; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class=\"line\">\t\tscanf(&quot;%d%d&quot;,&amp;llc[i],&amp;rrc[i]);</span><br><span class=\"line\">\t\tisroot[llc[i]]=isroot[rrc[i]]=1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(nroot=1; isroot[nroot]==1; nroot++);</span><br><span class=\"line\">\ttree=build(nroot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int update(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return 0;</span><br><span class=\"line\">\treturn tree-&gt;size=1+update(tree-&gt;lc)+update(tree-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int n,m;</span><br><span class=\"line\"></span><br><span class=\"line\">bool equal(node *tree1, node *tree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( !tree1 &amp;&amp; !tree2 ) return true;</span><br><span class=\"line\">\tif( (!tree1 &amp;&amp; tree2) || ( tree1&amp;&amp;!tree2 ) ) return false; </span><br><span class=\"line\">\tif(tree1-&gt;size!=tree2-&gt;size || tree1-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn equal(tree1-&gt;lc,tree2-&gt;lc)&amp;&amp;equal(tree1-&gt;rc,tree2-&gt;rc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void com(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(tree-&gt;size!=tree2-&gt;size || tree-&gt;data!=tree2-&gt;data)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tif( tree-&gt;lc &amp;&amp; tree-&gt;lc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;lc);</span><br><span class=\"line\">\t\tif( tree-&gt;rc &amp;&amp; tree-&gt;rc-&gt;size&gt;=tree2-&gt;size)</span><br><span class=\"line\">\t\t\tcom(tree-&gt;rc);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif(equal(tree,tree2)==true)</span><br><span class=\"line\">\t\t\tans++;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void release(node *tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!tree) return;</span><br><span class=\"line\">\trelease(tree-&gt;lc);</span><br><span class=\"line\">\trelease(tree-&gt;rc);</span><br><span class=\"line\">\tdelete tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tans=0;</span><br><span class=\"line\">\tnpre1=npre2=0;</span><br><span class=\"line\">\tmemset(pre1,0,sizeof(pre1));</span><br><span class=\"line\">\tmemset(pre2,0,sizeof(pre2));</span><br><span class=\"line\">\tbbb(tree1,n);</span><br><span class=\"line\">\tbbb(tree2,m);</span><br><span class=\"line\">\tif(m&gt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;0\\n&quot;);</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tupdate(tree1);</span><br><span class=\"line\">\tupdate(tree2);</span><br><span class=\"line\">\tcom(tree1);</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,ans);</span><br><span class=\"line\">\trelease(tree1);</span><br><span class=\"line\">\trelease(tree2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-Tree-Travels-again\"><a href=\"#6-Tree-Travels-again\" class=\"headerlink\" title=\"6. Tree Travels again\"></a>6. Tree Travels again</h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/Ha2JdKll9I.JPG\" alt=\"mark\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170919/5e15450KD0.JPG\" alt=\"mark\"></p>\n<p>题意：给定一棵二叉树迭代版中序遍历中栈的操作，求该二叉树的后序遍历序列</p>\n<p>思路：经过观察可以发现，入栈的顺序其实就是<strong>先序遍历的序列</strong>，出栈顺序就是<strong>中序遍历的序列</strong>，那么就把题目化归成：已知二叉树先序和中序遍历序列求后序序列了</p>\n<p>优化：<br>在得到序列后，可以不用建树，直接根据序列得到后序序列<br>思路：分治<br>先序序列首元素即是后序序列的尾元素，而后递归划分左右子树的序列即可</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\">#include &lt;cmath&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctime&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint data;</span><br><span class=\"line\">\tNode * left,* right;</span><br><span class=\"line\">\tNode() &#123;left=right=NULL;&#125;</span><br><span class=\"line\">\tNode(int d , Node * l = NULL, Node * r = NULL ):data(d),left(l),right(r)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int pre[100],in[100];</span><br><span class=\"line\">int stack[100];</span><br><span class=\"line\">int top=0;</span><br><span class=\"line\">int npre=0,nin=0;</span><br><span class=\"line\">int ans[100];</span><br><span class=\"line\"></span><br><span class=\"line\">void solve(int prei , int ini , int posti, int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(n&lt;=0) return ; </span><br><span class=\"line\">\tif(n==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans[posti]=pre[prei];</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans[posti+n-1]=pre[prei];</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; in[i+ini]!=pre[prei] ; i++);</span><br><span class=\"line\">\tsolve( prei+1 , ini , posti , i );</span><br><span class=\"line\">\tsolve( prei+i+1 , ini+i+1 , posti+i , n-i-1 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tchar c[10];</span><br><span class=\"line\">\tint tem;</span><br><span class=\"line\">\t// 根据出入栈构造序列</span><br><span class=\"line\">\twhile(cin&gt;&gt;c)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(c[1]==&apos;u&apos;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;tem;</span><br><span class=\"line\">\t\t\tstack[top++]=tem;</span><br><span class=\"line\">\t\t\tpre[npre++]=tem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tin[nin++]=stack[--top];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsolve(0,0,0,n);</span><br><span class=\"line\">\tfor(int i=0; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(i) printf(&quot; &quot;);</span><br><span class=\"line\">\t\tprintf(&quot;%d&quot;,ans[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;\\n&quot;);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"浅析基于分离轴原理的碰撞检测及分离算法","date":"2017-07-14T16:00:00.000Z","comments":1,"_content":"\n\n# **导言**\n\n分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。\n\n想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。\n\n以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。\n\n> 适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离\n>\n> 非凸多边形的改进办法：\n>\n> > 1. 将物体划分成多个凸多边形\n> > 2. 将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。\n\n<!-- more -->\n\n# **原理介绍**\n\n## **什么是碰撞？**\n\n首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。\n\n## **光线检测法**\n\n![光线检测法](http://ot1c7ttzm.bkt.clouddn.com/sat1.png)\n\n假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：\n\n> 1. 一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。\n> 2. 为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 ![非凸多边形](http://ot1c7ttzm.bkt.clouddn.com/sat2.png)\n\n## **投影**\n\n现在介绍一下一个非常关键的概念，也是整个算法的基础：**投影**。 两个物体未发生碰撞 -> 两个物体之间有空隙 -> 可以找到一条穿过它们中间的一条直线。 那么，**两个物体在垂直这条线的投影轴上的投影也必定存在空隙**。 ![投影1](http://ot1c7ttzm.bkt.clouddn.com/sat3.png)\n\n## **进一步优化**\n\n若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：**以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。**\n\n# **实现步骤**\n\n1.取第一个凸多边形相邻的两个点，得到向量a\n\n> $$Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)$$\n\n2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴\n\n> $$Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})$$\n\n3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影$$ 投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b} $$,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。\n\n以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1\n\n![投影2](http://ot1c7ttzm.bkt.clouddn.com/sat4.png)\n\n4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2\n\n5.判断是否碰撞\n\n> - 未发生碰撞\n>\n> > min2 > max1或 min1 > max2 两者中间有空隙，未发生碰撞\n>\n> - 发生碰撞（若不需分离可直接跳至下一步）\n>\n> > - min2 <= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n> >\n> > > 因向量方向任意，因此在计算距离时要记得加上绝对值abs\n> >\n> > - min1 <= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n\n6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。\n\n7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。\n\n8.得出判断\n\n# **分离**\n\n在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 $$ x-=min \\times \\vec{bmin}.x; $$ $$ y-=min \\times \\vec{bmin}.y; $$\n\n(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)\n\n# **圆的碰撞检测及分离**\n\n圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 ![投影3](http://ot1c7ttzm.bkt.clouddn.com/sat5.png)\n\n# **完整实现代码**\n\n[碰撞检测完整实现(两凸多边形版和圆形凸多边形版)](https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6)\n\n- ​","source":"_posts/SAT.md","raw":"---\nlayout: post\ntitle: \"浅析基于分离轴原理的碰撞检测及分离算法\"\ndate: 2017-07-15\ncomments: true\ntags: \n\t- 游戏\n\t- 算法\n---\n\n\n# **导言**\n\n分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。\n\n想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。\n\n以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。\n\n> 适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离\n>\n> 非凸多边形的改进办法：\n>\n> > 1. 将物体划分成多个凸多边形\n> > 2. 将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。\n\n<!-- more -->\n\n# **原理介绍**\n\n## **什么是碰撞？**\n\n首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。\n\n## **光线检测法**\n\n![光线检测法](http://ot1c7ttzm.bkt.clouddn.com/sat1.png)\n\n假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：\n\n> 1. 一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。\n> 2. 为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 ![非凸多边形](http://ot1c7ttzm.bkt.clouddn.com/sat2.png)\n\n## **投影**\n\n现在介绍一下一个非常关键的概念，也是整个算法的基础：**投影**。 两个物体未发生碰撞 -> 两个物体之间有空隙 -> 可以找到一条穿过它们中间的一条直线。 那么，**两个物体在垂直这条线的投影轴上的投影也必定存在空隙**。 ![投影1](http://ot1c7ttzm.bkt.clouddn.com/sat3.png)\n\n## **进一步优化**\n\n若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：**以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。**\n\n# **实现步骤**\n\n1.取第一个凸多边形相邻的两个点，得到向量a\n\n> $$Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)$$\n\n2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴\n\n> $$Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})$$\n\n3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影$$ 投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b} $$,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。\n\n以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1\n\n![投影2](http://ot1c7ttzm.bkt.clouddn.com/sat4.png)\n\n4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2\n\n5.判断是否碰撞\n\n> - 未发生碰撞\n>\n> > min2 > max1或 min1 > max2 两者中间有空隙，未发生碰撞\n>\n> - 发生碰撞（若不需分离可直接跳至下一步）\n>\n> > - min2 <= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n> >\n> > > 因向量方向任意，因此在计算距离时要记得加上绝对值abs\n> >\n> > - min1 <= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向\n\n6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。\n\n7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。\n\n8.得出判断\n\n# **分离**\n\n在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 $$ x-=min \\times \\vec{bmin}.x; $$ $$ y-=min \\times \\vec{bmin}.y; $$\n\n(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)\n\n# **圆的碰撞检测及分离**\n\n圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 ![投影3](http://ot1c7ttzm.bkt.clouddn.com/sat5.png)\n\n# **完整实现代码**\n\n[碰撞检测完整实现(两凸多边形版和圆形凸多边形版)](https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6)\n\n- ​","slug":"SAT","published":1,"updated":"2018-05-25T12:41:12.646Z","photos":[],"link":"","_id":"cjhvssaeg0014jvfcsk6w3t01","content":"<h1 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a><strong>导言</strong></h1><p>分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。</p>\n<p>想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。</p>\n<p>以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。</p>\n<blockquote>\n<p>适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离</p>\n<p>非凸多边形的改进办法：</p>\n<blockquote>\n<ol>\n<li>将物体划分成多个凸多边形</li>\n<li>将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。</li>\n</ol>\n</blockquote>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a><strong>原理介绍</strong></h1><h2 id=\"什么是碰撞？\"><a href=\"#什么是碰撞？\" class=\"headerlink\" title=\"什么是碰撞？\"></a><strong>什么是碰撞？</strong></h2><p>首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。</p>\n<h2 id=\"光线检测法\"><a href=\"#光线检测法\" class=\"headerlink\" title=\"光线检测法\"></a><strong>光线检测法</strong></h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat1.png\" alt=\"光线检测法\"></p>\n<p>假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：</p>\n<blockquote>\n<ol>\n<li>一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。</li>\n<li>为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat2.png\" alt=\"非凸多边形\"></li>\n</ol>\n</blockquote>\n<h2 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a><strong>投影</strong></h2><p>现在介绍一下一个非常关键的概念，也是整个算法的基础：<strong>投影</strong>。 两个物体未发生碰撞 -&gt; 两个物体之间有空隙 -&gt; 可以找到一条穿过它们中间的一条直线。 那么，<strong>两个物体在垂直这条线的投影轴上的投影也必定存在空隙</strong>。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat3.png\" alt=\"投影1\"></p>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a><strong>进一步优化</strong></h2><p>若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：<strong>以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。</strong></p>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a><strong>实现步骤</strong></h1><p>1.取第一个凸多边形相邻的两个点，得到向量a</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)</script></blockquote>\n<p>2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})</script></blockquote>\n<p>3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影<script type=\"math/tex\">投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b}</script>,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。</p>\n<p>以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat4.png\" alt=\"投影2\"></p>\n<p>4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2</p>\n<p>5.判断是否碰撞</p>\n<blockquote>\n<ul>\n<li>未发生碰撞</li>\n</ul>\n<blockquote>\n<p>min2 &gt; max1或 min1 &gt; max2 两者中间有空隙，未发生碰撞</p>\n</blockquote>\n<ul>\n<li>发生碰撞（若不需分离可直接跳至下一步）</li>\n</ul>\n<blockquote>\n<ul>\n<li>min2 &lt;= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n<blockquote>\n<p>因向量方向任意，因此在计算距离时要记得加上绝对值abs</p>\n</blockquote>\n<ul>\n<li>min1 &lt;= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。</p>\n<p>7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。</p>\n<p>8.得出判断</p>\n<h1 id=\"分离\"><a href=\"#分离\" class=\"headerlink\" title=\"分离\"></a><strong>分离</strong></h1><p>在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 <script type=\"math/tex\">x-=min \\times \\vec{bmin}.x;</script> <script type=\"math/tex\">y-=min \\times \\vec{bmin}.y;</script></p>\n<p>(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)</p>\n<h1 id=\"圆的碰撞检测及分离\"><a href=\"#圆的碰撞检测及分离\" class=\"headerlink\" title=\"圆的碰撞检测及分离\"></a><strong>圆的碰撞检测及分离</strong></h1><p>圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat5.png\" alt=\"投影3\"></p>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6\" target=\"_blank\" rel=\"noopener\">碰撞检测完整实现(两凸多边形版和圆形凸多边形版)</a></p>\n<ul>\n<li>​</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a><strong>导言</strong></h1><p>分离轴原理（SAT）是一个能用于2d游戏中凸多边形碰撞检测的算法，在自制游戏中我将其作为玩家、怪物、子弹和墙壁碰撞检测及分离的核心算法。</p>\n<p>想要实现分离轴原理首先需要有一定的向量知识以及算法实现能力，在实现过程中我自行实现了一个Vector向量类作为基本函数、向量对象的提供者。</p>\n<p>以下是个人对这个算法的理解，若有不当之处，还请指正，不胜感激。</p>\n<blockquote>\n<p>适用范围： 2D游戏，凸多边形（常见的三角形、四边形等），碰撞检测，分离</p>\n<p>非凸多边形的改进办法：</p>\n<blockquote>\n<ol>\n<li>将物体划分成多个凸多边形</li>\n<li>将物体看作一个凸多边形，前提是对碰撞检测的精度要求并不高。</li>\n</ol>\n</blockquote>\n</blockquote>","more":"<h1 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a><strong>原理介绍</strong></h1><h2 id=\"什么是碰撞？\"><a href=\"#什么是碰撞？\" class=\"headerlink\" title=\"什么是碰撞？\"></a><strong>什么是碰撞？</strong></h2><p>首先来看这个问题：什么是碰撞？什么才叫发生了碰撞？ 最简单的解释就足够了：两个物体之间没有间隙，或者它们的图像之间有重叠，由此我们可以想到一个最常规的判断方法：光线检测法（自编名词，仅为帮助理解）。</p>\n<h2 id=\"光线检测法\"><a href=\"#光线检测法\" class=\"headerlink\" title=\"光线检测法\"></a><strong>光线检测法</strong></h2><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat1.png\" alt=\"光线检测法\"></p>\n<p>假设我们手上拿着手电筒，360°绕着这两个物体照射，当有一束光能够从两个物体中间穿过去，那么这两个物体之间就存在间隙，也就是说它们没有发生碰撞。 到此我们可以得到：</p>\n<blockquote>\n<ol>\n<li>一个非常简单粗暴的检测方法：枚举360个角度，判断能否找到存在有这么一个角度，有条直线能够从两个物体之间穿过。</li>\n<li>为什么说这个方法仅适用于凸多边形，如下图，无法找到存在这么一条直线能够从两者之间穿过去，但这两个物体本身并没有发生碰撞。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat2.png\" alt=\"非凸多边形\"></li>\n</ol>\n</blockquote>\n<h2 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a><strong>投影</strong></h2><p>现在介绍一下一个非常关键的概念，也是整个算法的基础：<strong>投影</strong>。 两个物体未发生碰撞 -&gt; 两个物体之间有空隙 -&gt; 可以找到一条穿过它们中间的一条直线。 那么，<strong>两个物体在垂直这条线的投影轴上的投影也必定存在空隙</strong>。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat3.png\" alt=\"投影1\"></p>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a><strong>进一步优化</strong></h2><p>若要枚举所有角度所有直线，需要大量的时间用于计算，最直接的影响就是游戏卡顿。所幸，这是两个凸多边形，基于多边形的性质，我们可以把检测的角度数量缩减为两个多边形边数之和，也就是这个算法的核心：<strong>以两个凸多边形边的法线作为投影轴，将两个凸多边形投影至投影轴上，判断是否相交。</strong></p>\n<h1 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a><strong>实现步骤</strong></h1><p>1.取第一个凸多边形相邻的两个点，得到向量a</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{a}=(first.x1-first.x2,first.y1-first.y2)</script></blockquote>\n<p>2.求取向量a的法向量b并化为单位向量（为方便求取投影），b即为投影轴</p>\n<blockquote>\n<script type=\"math/tex; mode=display\">Vector\\ \\vec{b}=(\\frac{-\\vec{a}.y}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}},\\frac{\\vec{a}.x}{\\sqrt{\\vec{a}.y^2+\\vec{a}.x^2}})</script></blockquote>\n<p>3.任取第一个多边形上一点，作从原点指向该点的向量c(first.x,first.y)，计算c在b上的投影<script type=\"math/tex\">投影=|\\vec{c}|cos\\theta=\\frac{\\vec{c} \\cdot \\vec{b}}{|\\vec{b}|}=\\vec{c} \\cdot \\vec{b}</script>,又因为b已经化为单位向量，因此c在b上的投影就是b和c的点乘值。</p>\n<p>以此枚举第一个多边形上所有的点，记录下最大值max1和最小值min1</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat4.png\" alt=\"投影2\"></p>\n<p>4.同样枚举第二个多边形上所有点，得到最大值max2,最小值min2</p>\n<p>5.判断是否碰撞</p>\n<blockquote>\n<ul>\n<li>未发生碰撞</li>\n</ul>\n<blockquote>\n<p>min2 &gt; max1或 min1 &gt; max2 两者中间有空隙，未发生碰撞</p>\n</blockquote>\n<ul>\n<li>发生碰撞（若不需分离可直接跳至下一步）</li>\n</ul>\n<blockquote>\n<ul>\n<li>min2 &lt;= max1 分离最小距离与 abs(min2-max1)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n<blockquote>\n<p>因向量方向任意，因此在计算距离时要记得加上绝对值abs</p>\n</blockquote>\n<ul>\n<li>min1 &lt;= max2 分离最小距离与 abs(min1-max2)（此为两物体重叠距离） 比较，保留较小值并保留投影轴方向</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>6.只要在任意一轴上检测到没发生碰撞，则可立刻得到未发生碰撞的结论！无需继续检测其它轴。</p>\n<p>7.回到步骤1，枚举第一、第二个多边形所有边作为投影轴，重复步骤1-5。</p>\n<p>8.得出判断</p>\n<h1 id=\"分离\"><a href=\"#分离\" class=\"headerlink\" title=\"分离\"></a><strong>分离</strong></h1><p>在检测到碰撞基础上进行分离： 在第五步中我们得到了最小分离距离和投影轴方向，又因为投影轴向量已经单位化，因此向量分别乘以距离即是坐标需要移动的距离，至于分离谁则需要自行根据情况决定。 <script type=\"math/tex\">x-=min \\times \\vec{bmin}.x;</script> <script type=\"math/tex\">y-=min \\times \\vec{bmin}.y;</script></p>\n<p>(（x，y）为物体中心坐标，bmin为保留的投影轴，min为最小分离距离)</p>\n<h1 id=\"圆的碰撞检测及分离\"><a href=\"#圆的碰撞检测及分离\" class=\"headerlink\" title=\"圆的碰撞检测及分离\"></a><strong>圆的碰撞检测及分离</strong></h1><p>圆与其它凸多边形又有些许不同，它没有可以用于生成投影轴的边，于是乎我们用圆心和另一个凸多边形距离圆心最近的点的连线作为投影轴，再结合枚举第二个凸多边形的各边的法线，就可以按老方法进行检测和分离了。 至于圆投影到投影轴上，只需要作原点到圆心的向量，将该向量投影到投影轴上然后加减半径就好了。 <img src=\"http://ot1c7ttzm.bkt.clouddn.com/sat5.png\" alt=\"投影3\"></p>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://gist.github.com/zedom1/8c5aa61a92e6c077307586303f30f0c6\" target=\"_blank\" rel=\"noopener\">碰撞检测完整实现(两凸多边形版和圆形凸多边形版)</a></p>\n<ul>\n<li>​</li>\n</ul>"},{"layout":"post","title":"数据结构笔记（三）：树","date":"2017-08-14T16:00:00.000Z","comments":1,"_content":"\n# **树**\n\n## **概述**\n\n### 出现原因：\n\n向量在静态操作速度快O(1)，在动态操作速度慢O(n)\n列表在静态操作速度慢O(n)，在动态操作速度快O(1)\n树结合了两者的优点，可看作是一种**半线性的结构**\n应用：组织层次关系，如文件系统、学院层级关系等\n\n<!-- more -->\n\n### 树的分类：\n\n![树的分类](http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim)\n\n### 概念1. 有根树rooted tree\n\n指定任一结点为根\n可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树\n\n![子树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim)\n\nri 为r的孩子( child )， ri之间互为兄弟( sibling )\nr为父亲( parent ),\nd=degree(r)为r的度=一结点拥有的孩子的数目\n任何一棵树中边数e和结点数目n同阶\n\n![边数和结点数同阶](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim)\n\n### 概念2. 有序树\n\n指定Ti为T的第i棵子树，ri为r的第i个孩子\n\n即是：兄弟之间有明显**次序**\n\n### 概念3. 连通性和无环性：\n\n任何两结点之间都有路径，则称为**连通图**（connected）\n不含环路则称为**无环图**（acyclic）\n\n树的特点：\n\n> 1 .无环连通图：在无环性和连通性之间平衡\n> 2 .极小连通图：在连通的情况下边数尽可能少\n> 3 .极大无环图：在无环的情况下边数尽可能多\n\n结论： 任何结点和根之间存在**唯一一条**路径\n即 $path(v,r)=path(v)$\n我们用一个指标 **深度( depth )** 记录下每个结点到根的距离\npath(v)上的结点均为v的**祖先**( ancestor )\nv是它们的**后代** ( descendent )\n对于v而言，若**祖先存在，则必定唯一**。若**后代存在，却未必唯一**，因此是半线性结构。\n而对于图而言，祖先和后代都未必唯一，因此图为非线性结构\n**叶子结点**（leaf）：没有后代的结点\n\n叶子深度最大的称为**树的高度**\n**深度**是**结点v到总树根结点r**的距离\n即height（v）=max( height (v_son) ) +1\n结点v的**高度**为**以结点v为根结点**的子树的高度\n即 height（v）=height（subtree（v））\n约定俗成：空树的高度取作**-1**，一个结点的树高度取作**0**\n对于任一结点：depth（v）+height（v）<=height(T)\n（高度向下看，深度向上看）\n![树的深度和高度](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim)\n\n## **表示**\n\n### 1. 接口\n\n| 返回值   | 结点            | 功能            |\n| ----- | ------------- | ------------- |\n| node* | root()        | 根结点           |\n| node* | parent()      | 父结点           |\n| node* | firstchild()  | 长子            |\n| node* | nextSibling() | 兄弟            |\n| void  | insert( i,e ) | 将e作为第i个孩子插入   |\n| int   | remove(i)     | 删除第i个孩子(及其后代) |\n| void  | traverse      | 遍历            |\n\n### 2. 构造方法\n\n不妨用数组进行模拟\n\n**长子兄弟法**：\n\n每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩\n\n```\ntemplate <typename T>\nstruct node\n{\n\tT data;\n\tint father, child, nextSibling;\n};\nnode  *tree;\n```\n\n# **二叉树**\n\n## **概念**\n\n结点度数**不超过2**（孩子数目<=2）的树\n\n同一结点的孩子和子树以**左右**区分\n\n二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。\n\n基于二叉树的概念，我们可以得到下列关系：\n1.深度为k的结点最多有$2^k$个\n2.高度为h的二叉树的结点数n满足$h’<’n’<’2^(h+1)$\n1.当n=h+1时，二叉树退化为一条单链\n2.当$n=2^(h+1)-1$时，二叉树为满二叉树\n\n二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点\n\n而高度h涨得很慢，与结点n的关系为$h=logn$\n\n## **真二叉树(Proper binary tree)**\n\n定义：所有结点的度数均为偶数的二叉树。\n\n很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点**虚拟地**补上孩子。\n\n## **完全二叉树(complete binary tree)**\n\n定义：叶结点只出现在**最后两层**，并且最底层的叶结点均在次底层叶结点的**左侧**。\n\n![完全二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG)\n\n## **满二叉树(full binary tree)**\n\n定义：所有叶结点都在**最后一层**，每层结点都达到饱和。\n\n特性：\n1.结点数目n和高度h的关系：$n=2^(h+1)-1$\n2.叶子结点数=内部结点数+1\n3.满二叉树是**特殊**的**完全二叉树**\n\n![满二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG)\n\n## **用二叉树描述多叉树**\n\n先上结论：**凡是有根且有序的树，均可以用二叉树实现**\n\n为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG)\n\n可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG)\n\n这就将一棵树变成了二叉树！\n\n这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。\n\n## **基本定义**\n\n**结点类的基本定义：**\n\n```\ntemplate <typename T>\nstruct BinNode\n{\n\tT data;\n\tBinNode<T>* lChild,*rChild,*parent;\n\tint height;\n\n\tBinNode() { lChild=rChild=parent= NULL ; height=0; }\n\tBinNode( T e , BinNode<T>* pa=NULL , BinNode<T>* lc=NULL, BinNode<T>* rc=NULL)\n\t\t:data(e),parent(pa),lChild(lc),rChild(rc) {}\n\tint size() const ;\n\tBinNode<T> * insertAsLC( T const & e ) //作为左孩子插入\n\t{ return lChild=new BinNode(e,this); }\n\tBinNode<T> * insertAsRC( T const & e ) //作为右孩子插入\n\t{ return rChild=new BinNode(e,this); }\n\t\n\tBinNode<T> * succ();   // 中序遍历时的直接后继\n\t\n\ttemplate <typename V>\n\tvoid travLevel( V & visit );  // 子树层级遍历\n\ttemplate <typename V>\n\tvoid travPre( V & visit );   // 子树先序遍历\n\ttemplate <typename V>\n\tvoid travIn( V & visit );    // 子树中序遍历\n\ttemplate <typename V>\n\tvoid travPost( V & visit );   // 子树后序遍历\n};\n\ntemplate <typename T>\nint BinNode<T>::size()\n{\n\tint s=1;\n\tif(lChild)\n\t\ts+=lChild->size();\n\tif(rChild)\n\t\ts+=rChild->size();\n\treturn s;\n}\n```\n\n每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。\n\nsize函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。\n\n**树的基础定义：**\n\n```\ntemplate <typename T>\nstruct BinTree\n{\nprotected:\n\tint _size;\n\tBinNode<T>* _root;\n\tvirtual int updateHeight( BinNode<T>* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）\n\tvoid updateHeightAbove( BinNode<T>* x);  // 更新x及x的祖先的高度\n\npublic:\n\tBinTree() {_size=0; _root=NULL;}\n\t~BinTree() { remove(_root); }\n\tBinTree( T const& e) {_size=1; _root=new BinNode<T> (e);}\n\tint size() const {return _size;}\n\tbool empty() const {return !_root;}\n\tBinNode<T> * root() const {return _root;}\n\tBinNode<T> * insertAsRC ( BinNode<T>* x , T const& e );  // 构造右孩子\n\tBinNode<T> * insertAsLC ( BinNode<T>* x , T const& e );  // 构造左孩子\n\tBinNode<T> * attachAsLC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为左孩子\n\tBinNode<T> * attachAsRC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为右孩子\n\tint remove( BinNode<T>* x );   // 删除某个结点（及其子树）\n\tvoid removeAt( BinNode<T>* x );\n\tBinTree<T> * secede( BinNode<T>* x );    // 分离子树，返回子树头\n\n\ttemplate <typename V>\n\tvoid travLevel( V & visit )  // 层级遍历\n\t{ _root->travLevel(visit); }\n\ttemplate <typename V>\n\tvoid travPre( V & visit )  // 先序遍历\n\t{ _root->travPre(visit); }\n\ttemplate <typename V>\n\tvoid travIn( V & visit )  // 中序遍历\n\t{ _root->travIn(visit); }\n\ttemplate <typename V>\n\tvoid travPost( V & visit )   // 后序遍历\n\t{ _root->travPost(visit); }\n};\n```\n\n## **遍历**\n\n定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次\n\n**遍历方式：**\n\n> 1. 先序遍历( preorder )：中->左->右\n> 2. 中序遍历( inorder )：左->中->右\n> 3. 后序遍历( postorder )：左->右->中\n> 4. 层次遍历：自上而下，自左而右\n>\n> 先序中序后序原则：必定先左后右，根结点访问次序如名字所示\n\n### **1. 先序遍历( 中 左 右 )**\n\n#### **1. 递归版本**\n\n根据先序遍历的定义，我们很容易写出递归版本的遍历函数：\n\n```\n// V为函数模板类  visit是相应的函数对象\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_R( V & visit )\n{\n\tvisit(data);\n\tif(lChild) lChild->travPre_R(visit);\n\tif(rChild) rChild->travPre_R(visit);\n}\n```\n\n然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。\n\n因此如果能够将**递归版**改成**迭代版**，就能够提高很多效率。\n\n#### **2. 迭代版本1**\n\n因为在递归版本中，向左右子树的递归出现在最后，即是**尾递归**，那么我们只需要引入一个**栈**，把左右子树的递归改成将左右子树入栈即可。\n\n值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要**先让右子树入栈，再让左子树入栈**\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_V1( V & visit )\n{\n\tStack <BinNode<T> *> s;\n\tBinNode<T>* x=this;\n\tif(x) \n\t\ts.push(x);\n\twhile(!s.empty())\n\t{\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tif(x->rChild) s.push(x->rChild); // 先入后出\n\t\tif(x->lChild) s.push(x->lChild);\n\t}\n}\n```\n\n#### **3. 迭代版本2**\n\n看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。\n\n通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子->它父亲的右孩子->父亲的父亲的右孩子…->根结点的右孩子。\n\n于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。\n\n![左侧链示意图](http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG)\n\n这样，我们就有了如下算法流程：\n\n1.访问该结点\n2.将右孩子入栈\n3.目光转向它的左孩子\n若左孩子存在，回到步骤1\n4.若栈不为空，取出栈顶元素，回到步骤1\n\n代码实现如下\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\twhile( !s.empty() )\n\t{\n\t\tx=s.pop();\n\t\twhile(x)\n\t\t{\n\t\t\tvisit(x->data);\n\t\t\tif(x->rChild) \n\t\t\t\ts.push(x->rChild);\n\t\t\tx=x->lChild;\n\t\t}\n\t}\n}\n```\n\n### **2. 中序遍历( 左 中 右 )**\n\n#### **1. 迭代版本1**\n\n先来观察一下中序遍历的流程：\n\n每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。\n\n中序和先序不同在于：**父结点不是立即被访问**，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。\n\n那右结点怎么办呢？\n\n右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。\n\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG)\n\n算法的流程如下：\n\n1.将该结点入栈\n2.转向该结点的左孩子\n若左孩子存在，返回步骤1\n3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子\n若右孩子存在，返回步骤1\n若右孩子不存在，重新开始步骤3\n\n现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\twhile(1)\n\t{\n\t\twhile(x)\n\t\t{\n\t\t\ts.push(x);\n\t\t\tx=x->lChild;\n\t\t}\n\t\tif(s.empty()) \n\t\t\tbreak;\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tx=x->rChild;\n\t} \n}\n```\n\n此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本\n\n#### **2. 迭代版本2**\n\n当把二叉树横向伸展地足够开后，如下图所示\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim)\n从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序\n左右规则如下:\n\n左子树左孩子>左子树根结点>左子树右孩子>根结点>右子树左孩子>右子树根结点>右子树右孩子\n\n根据这个规则，我们就可以得到每个结点在中序遍历时的**直接后继**，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)\n\n那么要怎么得到这个直接后继呢？\n显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。\n而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个**结点是它父结点左孩子**的结点，直接后继就是这个结点的父结点。\n简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。\n\n将上述流程翻译成代码就是\n\n```\ntemplate <typename T>\nBinNode<T> *BinNode<T>::succ()\n{\n\tBinNode<T>* s=this;\n\tif(rChild)   // 若有右孩子\n\t{\n\t\ts=rChild;\n\t\twhile(s->lChild)   // 在右子树的左侧链一路到底\n\t\t\ts=s->lChild;\n\t}\n\telse\n\t{\n\t\twhile( s->parent && s==s->parent->rChild )\n\t\t\ts=s->parent;    // 此时是左子树的根结点\n\t\ts=s->parent;   // 再向上到左子树的父亲结点(也可能是NULL)\n\t}\n\treturn s;\n}\n```\n\n有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_S(  V & visit )\n{\n\tBinNode<T>* x=this;\n\twhile(x->lChild)\n\t\tx=x->lChild;\n\tdo\n\t{\n\t\tvisit(x->data);\n\t\tx=x->succ();\n\t}\n\twhile(x);\n}\n```\n\n### **3. 后序遍历( 左 右 中 )**\n\n基于后序遍历的定义，我们可以导出如下流程：\n1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。\n2.访问结点\n3.若右兄弟存在，转向右兄弟，返回步骤1\n4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程\n\n可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPost_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\tBinNode<T> * c=s.top();\n\twhile(1)\n\t{\n\t\tif(s.empty()) break;\n\t\tif(s.top()!=x->parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树\n\t\t{\n\t\t\tc=s.top();\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(c->rChild) \n\t\t\t\t\ts.push(c->rChild);\n\t\t\t\tif(c->lChild) \n\t\t\t\t{\n\t\t\t\t\ts.push(c->lChild);\n\t\t\t\t\tc=c->lChild;   // 尽可能向左走\n\t\t\t\t}\n\t\t\t\telse if(c->rChild)  // 如果实在只有右孩子，那就向右\n\t\t\t\t\tc=c->rChild;\n\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t}\n}\n```\n\n### **4. 层次遍历**\n\n层次遍历的规则很简单：自上而下，自左而右\n\n![层次遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim)\n\n对此，我们可以引入**队列**来解决它。\n\n每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travLevel( V & e )\n{\n\tQueue<BinNode<T>*> q;\n\tBinNode<T>* x=this;\n\tq.enqueue(x);\n\twhile( !q.empty() )\n\t{\n\t\tx=q.dequeue();\n\t\tif(x->lChild)  q.enqueue(x->lChild);\n\t\tif(x->rChild)  q.enqueue(x->rChild);\n\t\te(x->data);\n\t}\n\treturn;\n}\n```\n\n## **重构**\n\n如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？\n\n### **一. 中序+(先序|后序)**\n\n结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。\n\n现在我们来用数学归纳法证明一下：\n假设结论在结点数n’<’N的情况下都成立\n在n==N时\n先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。\n那么在先序遍历和中序遍历中分别如下图所示：\n\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG)\n\n可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。\n这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’<’N的左右子树中结论均成立，由此n==N时结论也成立。\n\n而有后续和中序遍历的序列的证明也同理可得了。\n\n```\n// 先序+中序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PI( T* pre, T* ins, int len )\n{\n\t_root=rebuildSub_PI(pre,ins,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PI( T* pre, T* ins, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(pre); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PI( pre+1, ins, i );\n\ts->rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );\n\treturn s;\n}\n```\n\n```\n// 中序+后序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_IP( T* ins, T* post, int len )\n{\n\t_root=rebuildSub_IP(ins,post,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_IP( T* ins, T* post, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(* (post+len-1) );\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+len-1); i++);\n\ts=new BinNode<T>(*(post+len-1));\n\ts->lChild=rebuildSub_IP( ins, post, i );\n\ts->rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );\n\treturn s;\n}\n```\n\n### **二. (先序+后序)\\*真二叉树**\n\n结论二：在只有先序和后序序列时，若是该二叉树是一棵**真二叉树**(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。\n\n那么要怎么做呢？\n\n在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。\n在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。\n这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG)\n\n```\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PP( T *pre,T *post,int len )\n{\n\t_root=new BinNode<T> (pre[0]);\n\trebuildSub_PP( _root,pre,post,len );\n\treturn;\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PP( T *pre , T *post, int len )\n{ \n\tBinNode<T> *s=NULL;\n\tif( len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PP(pre+1,post,i+1);\n\ts->rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n# **完整实现代码**\n\n[二叉树的完整实现 ( 附带遍历和重构 )](https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp)\n\n# 二叉搜索树BST ( Binary Search Tree )\n\n## 概述\n\n### 循关键码访问 call-by-key\n\n数据项之间，依照各自的关键码(key)彼此区分\n\n条件：关键码之间支持**大小比较**和**相等比对**\n\n### 性质\n\n二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：\n\n```\n1. 非空左子树所有键值小于根结点的键值\n2. 非空右子树所有键值大于根结点的键值\n3. 左右子树都是二叉搜索树\n\n```\n\n基本框架：\n\n```\ntemplate <typename T>\nstruct TreeNode\n{\n\tT data;\n\tTreeNode<T> * left;\n\tTreeNode<T> * right;\n};\n```\n\n## 接口\n\n```\n1. BinTree Find( T x , BinTree BST);\n\n```\n\n> 从BST中查找元素x,返回所在结点的地址\n\n```\n2. BinTree FindMin(BinTree BST);\n\n```\n\n> 从BST中查找并返回最小元素所在结点的地址\n\n```\n3. BinTree FindMax(BinTree BST);\n\n```\n\n> 从BST中查找并返回最大元素所在结点的地址\n\n```\n4. BinTree Insert( T x , BinTree BST);\n\n```\n\n> 将元素x插入BST中，返回插入后的BST\n\n```\n5. BinTree Delete( T x , BinTree BST);\n\n```\n\n> 从BST中删除元素x\n\n### 查找操作： Find\n\n```\n- 查找从根结点开始，若树为空则返回NULL\n- 若树非空，则将根结点键值和x比较：\n    - 若 x < root.data ，在左子树中搜索\n    - 若 x > root.data ，在右子树中搜索\n    - 若两者相等，则返回指向该结点的指针\n- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式\n- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**\n\n```\n\n代码实现：\n\n```\ntemplate <typename T>\nTreeNode<T> * Find(T x , TreeNode<T> * BST)\n{\n\twhile(BST)\n\t{\n\t\tif(x>BST->data)\n\t\t\tBST=BST->right;\n\t\telse if(x<BST->data)\n\t\t\tBST=BST->left;\n\t\telse\n\t\t\treturn BST;\n\t}\n\treturn NULL;\n}\n```\n\n### 查找最大和最小元素\n\n根据二叉搜索树的性质：\n\n```\n- 最大元素一定在树的最右分支的端结点上\n- 最小元素一定在树的最左分支的端结点上\n\n```\n\n同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本\n\n```\ntemplate <typename T>\nTreeNode<T> * FindMax( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->right)\n\t\t\tBST=BST->right;\n\treturn BST;\n}\ntemplate <typename T>\nTreeNode<T> * FindMin( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->left)\n\t\t\tBST=BST->left;\n\treturn BST;\n}\n```\n\n### 插入结点\n\n关键：要找到元素应该插入的位置，可以采用和Find类似的方法\n\n思路：\n\n```\ntemplate <typename T>\nTreeNode<T> * Insert( T x , TreeNode<T> * BST)\n{\n\tif(!BST)\n\t{\n\t\tBST = new TreeNode<T>();\n\t\tBST->data=x;\n\t\tBST->left=BST->right=NULL;\n\t}\n\telse\n\t{\n\t\tif(x<BST->data)\n\t\t\tBST->left=Insert(x,BST->left);\n\t\telse if(x>BST->data)\n\t\t\tBST->right=Insert(x,BST->right);\n\t}\n\treturn BST;\n}\n```\n\n### 删除结点\n\n考虑情况\n\n```\n1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL\n2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子\n3. 要删除的结点有左右两棵子树\n    用另一结点代替被删除结点：左子树最大元素或右子树最小元素\n\n```\n\n```\ntemplate <typename T>\nTreeNode<T> * Delete( T x , TreeNode<T> * BST)\n{\n\tTreeNode<T> *tmp;\n\tif(!BST) return NULL;\n\telse if(x<BST->data)\n\t\tBST->left=Delete(x,BST->left);\n\telse if(x>BST->data)\n\t\tBST->right=Delete(x,BST->right);\n\telse\n\t{\n\t\tif(BST->left && BST->right)\n\t\t{\n\t\t\ttmp=FindMin(BST->right);\n\t\t\tBST->data=tmp->data;\n\t\t\tBST->right=delete(BST->data,BST->right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=BST;\n\t\t\tif(!BST->left)\n\t\t\t\tBST=BST->right;\n\t\t\telse if(!BST->right)\n\t\t\t\tBST=BST->left;\n\t\t\tdelete tmp;\n\t\t}\n\t}\n\treturn BST;\n}\n```\n\n# 平衡二叉树 AVL树 (Balanced Binary Tree)\n\n定义：\n空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|<=1\n\n**平衡因子（BF:Balance Factor）**: BF(T)=Hl - Hr\nHl和Hr分别为T的左右子树的高度\n\n推算高度为h的平衡二叉树最少结点数：\n\n```\n高度为1时 h(1)=1;\n高度为2时 h(2)=2;\n高度为3时 h(3)=h(1)+h(2)+1=4;\n...\n高度为n时 h(n)=h(n-1)+h(n-2)+1;\n原因：\n    > 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值<=1\n    > 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )\n由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$\n\n```\n\n结点数为n的平衡二叉树的最大高度为O(logn)\n\n## 平衡二叉树的调整\n\n**核心思想：选择中间值作为根结点**\n\n**RR插入**：插入结点在右子树的右边，需要RR旋转（右单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG)\n\n大小关系为： 根结点 < 右子树根结点 < 右子树的右边\n\n因此选取右子树的根结点作为新的平衡二叉树的根结点\n\n**LL插入**：插入结点在左子树的左边，需要LL旋转（左单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG)\n\n大小关系为： 左子树的左边 < 左子树根结点 < 根结点\n\n因此选取左子树的根结点作为新的平衡二叉树的根结点\n\n**LR插入**：插入结点在左子树的右边，需要LR旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG)\n\n大小关系为： 左子树的根结点 < 左子树的右边 < 根结点\n\n因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点\n\n**RL插入**：插入结点在右子树的左边，需要RL旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG)\n\n大小关系为： 根结点 < 右子树的左边 < 右子树的根结点\n\n因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点\n\n# 堆 heap\n\n## 概述\n\n**优先队列( Priority Queue )**\n特殊的队列，取出元素的顺序是依照元素的**优先权（关键字）**的大小，而不是元素进入队列的先后顺序\n\n堆的特性：\n**结构性**：用数组表示的完全二叉树\n**有序性**：任一结点的关键字是其子树所有结点的最大值（或最小值）\n从根结点到任意结点路径上结点序列的有序性\n最大堆（MaxHeap）：根结点为最大值\n最小堆（MinHeap）：根结点为最小值\n\n## 接口\n\n数据对象集：完全二叉树\n\n接口：\nMaxHeap Create( int Maxsize );\n创建一个空的最大堆\nBoolean IsFull( MaxHeap H );\n判断最大堆H是否满\nvoid Insert( MaxHeap H , T data );\n将data插入最大堆H\nBoolean IsEmpty( MaxHeap H );\n判断最大堆H是否为空\nT DeleteMax( MaxHeap H );\n返回H中最大元素（高优先级）\n\n### Insert\n\n思路：\n\n> 将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点\n\n```\ntemplate <typename T>\nvoid Insert( Heap<T>* h, T item)\n{\n\tint i;\n\tif( IsFull(h) ) // 若堆已满，则不做插入操作\n\t\treturn;\n\ti = ++h->size;\n\tfor( ; h->data[i/2]<item ; i/=2 )\n\t\th->data[i] = h->data[i/2];\n\th->data[i] = item;\n}\n```\n\n### Delete\n\n思路：\n\n> 取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作\n\n```\ntemplate <typename T>\nvoid Delete( Heap<T>* h , T item )\n{\n\tint parent , child;\n\tT maxn,tem;\n\tif( IsEmpty(h) ) \n\t\treturn;\n\tmaxn = h->data[1];\n\ttem = h->data[h->size--];\n\tfor( parent=1 ; parent*2<= h->size ; parent = child )\n\t{\n\t\tchild = parent *2;\n\t\tif( child != h->size  && h->data[child]<h.data[child+1])\n\t\t\tchild++;   // 寻找左右孩子中较大的那个\n\t\tif( tem>= h->data[child] ) \n\t\t\tbreak;\n\t\telse\n\t\t\th->data[parent] = h->data[child];\n\t}\n\th->data[parent]=tem;\n}\n```\n\n### 建立最大堆\n\n将已经存在的N个元素按最大堆的要求存放在一个一维数组\n\n方法1：\n通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)\n\n方法2：\n\n```\n1. n个元素按输入顺序存入，先满足完全二叉树\n2. 调整各结点位置\n\n```\n\n#### 方法二：\n\n自底向上调整\n\n从倒数第二行的结点开始自右向左调整\n\n而后再到倒数第三行、倒数第四行…直到根结点\n\n这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可\n\n这样就只需要O(n)的时间即可完成建堆\n\n# 哈夫曼树\n\n带权路径长度（WPL）\n设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk\n\n哈夫曼树（最优二叉树）：WPL值最小的二叉树\n\n## 哈夫曼树的构造\n\n每次把**权值最小**的两棵二叉树合并\n\n## 特点\n\n```\n1. 没有度为1的结点\n2. n个叶子结点的哈夫曼树有2n-1个结点\n    设 n0: 叶子结点总数\n    设 n1: 只有一个儿子的结点总数\n    设 n2: 有2个儿子的结点总数\n    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1\n3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树\n4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）\n\n```\n\n## 哈夫曼编码\n\n```\n给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少\n\n避免二义性：\n    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀\n\n利用二叉树进行编码：\n    1. 左右分支：0、1\n    2. 字符只在叶结点上\n\n构造方法：根据字符的权值构造哈夫曼树\n\n```\n\n# 集合\n\n```\n集合运算：交、并、补、差、判定一个元素是否属于某个集合\n并查集：集合并、查某元素属于什么集合\n并查集实现：\n    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）\n    2. 利用数组存储，两个一维数组分别存储数据和父亲下标\n\n```\n\n利用数组存储的定义：\n\n```\ntemplate <typename T>\nstruct Node\n{\n\tT data;\n\tint parent;\n\tNode( T d , int parent = -1 ):data(d){}\n\tNode(){parent=-1;}\n};\n```\n\n每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标\n\n## 查找当前结点所属集合\n\n思路：\n首先在数组中找到目标结点\n而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );   // 在数组中寻找值为x的结点\n\tif( i>=MaxSize ) return -1;    // 没找到，返回-1\n\tfor( ; s[i].parent>=0; i=s[i].parent );  // 顺着父结点指针一路向上找\n\treturn i;\n}\n```\n\n优化：\n通过**路径压缩**，每次查找时把沿途所有节点的parent都设为根节点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );\n\tif( i>=MaxSize ) return -1;\n\tint tem=i,tem1=s[tem].parent;\n\tfor( ; s[i].parent>=0; i=s[i].parent );\n\twhile( tem1!=-1 && tem1!=i )\n\t{\n\t\ts[tem].parent = i;\n\t\ttem=tem1;\n\t\ttem1=s[tem].parent;\n\t}\n\treturn i;\n}\n```\n\n## 集合的并运算\n\n思路：\n首先分别找到两个元素所在的集合树的根结点\n若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标\n\n```\ntemplate <typename T>\nvoid Union( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t\ts[root2].parent = root1;\n}\n```\n\n优化：\n为了改善合并后的查找效率，把小的集合并入大的集合\n方法1：每个结点额外维护一个值：以该结点为根的结点总数\n缺点：只有根节点才需要用到该值，造成大量空间浪费\n方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数\n\n```\ntemplate <typename T>\nvoid Union1( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t{\t\n\t\tif( s[root1].parent<s[root2].parent )\n\t\t{\t\n\t\t\ts[root1].parent += s[root2].parent;\n\t\t\ts[root2].parent = root1;\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\ts[root2].parent += s[root1].parent;\n\t\t\ts[root1].parent = root2;\n\t\t}\n\t}\n}\n```","source":"_posts/DataStructure_Tree.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（三）：树\"\ndate: 2017-08-15\ncomments: true\ntags: \n\t- 学习笔记\n\t- c++\n\t- 数据结构\n---\n\n# **树**\n\n## **概述**\n\n### 出现原因：\n\n向量在静态操作速度快O(1)，在动态操作速度慢O(n)\n列表在静态操作速度慢O(n)，在动态操作速度快O(1)\n树结合了两者的优点，可看作是一种**半线性的结构**\n应用：组织层次关系，如文件系统、学院层级关系等\n\n<!-- more -->\n\n### 树的分类：\n\n![树的分类](http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim)\n\n### 概念1. 有根树rooted tree\n\n指定任一结点为根\n可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树\n\n![子树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim)\n\nri 为r的孩子( child )， ri之间互为兄弟( sibling )\nr为父亲( parent ),\nd=degree(r)为r的度=一结点拥有的孩子的数目\n任何一棵树中边数e和结点数目n同阶\n\n![边数和结点数同阶](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim)\n\n### 概念2. 有序树\n\n指定Ti为T的第i棵子树，ri为r的第i个孩子\n\n即是：兄弟之间有明显**次序**\n\n### 概念3. 连通性和无环性：\n\n任何两结点之间都有路径，则称为**连通图**（connected）\n不含环路则称为**无环图**（acyclic）\n\n树的特点：\n\n> 1 .无环连通图：在无环性和连通性之间平衡\n> 2 .极小连通图：在连通的情况下边数尽可能少\n> 3 .极大无环图：在无环的情况下边数尽可能多\n\n结论： 任何结点和根之间存在**唯一一条**路径\n即 $path(v,r)=path(v)$\n我们用一个指标 **深度( depth )** 记录下每个结点到根的距离\npath(v)上的结点均为v的**祖先**( ancestor )\nv是它们的**后代** ( descendent )\n对于v而言，若**祖先存在，则必定唯一**。若**后代存在，却未必唯一**，因此是半线性结构。\n而对于图而言，祖先和后代都未必唯一，因此图为非线性结构\n**叶子结点**（leaf）：没有后代的结点\n\n叶子深度最大的称为**树的高度**\n**深度**是**结点v到总树根结点r**的距离\n即height（v）=max( height (v_son) ) +1\n结点v的**高度**为**以结点v为根结点**的子树的高度\n即 height（v）=height（subtree（v））\n约定俗成：空树的高度取作**-1**，一个结点的树高度取作**0**\n对于任一结点：depth（v）+height（v）<=height(T)\n（高度向下看，深度向上看）\n![树的深度和高度](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim)\n\n## **表示**\n\n### 1. 接口\n\n| 返回值   | 结点            | 功能            |\n| ----- | ------------- | ------------- |\n| node* | root()        | 根结点           |\n| node* | parent()      | 父结点           |\n| node* | firstchild()  | 长子            |\n| node* | nextSibling() | 兄弟            |\n| void  | insert( i,e ) | 将e作为第i个孩子插入   |\n| int   | remove(i)     | 删除第i个孩子(及其后代) |\n| void  | traverse      | 遍历            |\n\n### 2. 构造方法\n\n不妨用数组进行模拟\n\n**长子兄弟法**：\n\n每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩\n\n```\ntemplate <typename T>\nstruct node\n{\n\tT data;\n\tint father, child, nextSibling;\n};\nnode  *tree;\n```\n\n# **二叉树**\n\n## **概念**\n\n结点度数**不超过2**（孩子数目<=2）的树\n\n同一结点的孩子和子树以**左右**区分\n\n二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。\n\n基于二叉树的概念，我们可以得到下列关系：\n1.深度为k的结点最多有$2^k$个\n2.高度为h的二叉树的结点数n满足$h’<’n’<’2^(h+1)$\n1.当n=h+1时，二叉树退化为一条单链\n2.当$n=2^(h+1)-1$时，二叉树为满二叉树\n\n二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点\n\n而高度h涨得很慢，与结点n的关系为$h=logn$\n\n## **真二叉树(Proper binary tree)**\n\n定义：所有结点的度数均为偶数的二叉树。\n\n很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点**虚拟地**补上孩子。\n\n## **完全二叉树(complete binary tree)**\n\n定义：叶结点只出现在**最后两层**，并且最底层的叶结点均在次底层叶结点的**左侧**。\n\n![完全二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG)\n\n## **满二叉树(full binary tree)**\n\n定义：所有叶结点都在**最后一层**，每层结点都达到饱和。\n\n特性：\n1.结点数目n和高度h的关系：$n=2^(h+1)-1$\n2.叶子结点数=内部结点数+1\n3.满二叉树是**特殊**的**完全二叉树**\n\n![满二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG)\n\n## **用二叉树描述多叉树**\n\n先上结论：**凡是有根且有序的树，均可以用二叉树实现**\n\n为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG)\n\n可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来\n\n![树到二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG)\n\n这就将一棵树变成了二叉树！\n\n这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。\n\n## **基本定义**\n\n**结点类的基本定义：**\n\n```\ntemplate <typename T>\nstruct BinNode\n{\n\tT data;\n\tBinNode<T>* lChild,*rChild,*parent;\n\tint height;\n\n\tBinNode() { lChild=rChild=parent= NULL ; height=0; }\n\tBinNode( T e , BinNode<T>* pa=NULL , BinNode<T>* lc=NULL, BinNode<T>* rc=NULL)\n\t\t:data(e),parent(pa),lChild(lc),rChild(rc) {}\n\tint size() const ;\n\tBinNode<T> * insertAsLC( T const & e ) //作为左孩子插入\n\t{ return lChild=new BinNode(e,this); }\n\tBinNode<T> * insertAsRC( T const & e ) //作为右孩子插入\n\t{ return rChild=new BinNode(e,this); }\n\t\n\tBinNode<T> * succ();   // 中序遍历时的直接后继\n\t\n\ttemplate <typename V>\n\tvoid travLevel( V & visit );  // 子树层级遍历\n\ttemplate <typename V>\n\tvoid travPre( V & visit );   // 子树先序遍历\n\ttemplate <typename V>\n\tvoid travIn( V & visit );    // 子树中序遍历\n\ttemplate <typename V>\n\tvoid travPost( V & visit );   // 子树后序遍历\n};\n\ntemplate <typename T>\nint BinNode<T>::size()\n{\n\tint s=1;\n\tif(lChild)\n\t\ts+=lChild->size();\n\tif(rChild)\n\t\ts+=rChild->size();\n\treturn s;\n}\n```\n\n每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。\n\nsize函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。\n\n**树的基础定义：**\n\n```\ntemplate <typename T>\nstruct BinTree\n{\nprotected:\n\tint _size;\n\tBinNode<T>* _root;\n\tvirtual int updateHeight( BinNode<T>* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）\n\tvoid updateHeightAbove( BinNode<T>* x);  // 更新x及x的祖先的高度\n\npublic:\n\tBinTree() {_size=0; _root=NULL;}\n\t~BinTree() { remove(_root); }\n\tBinTree( T const& e) {_size=1; _root=new BinNode<T> (e);}\n\tint size() const {return _size;}\n\tbool empty() const {return !_root;}\n\tBinNode<T> * root() const {return _root;}\n\tBinNode<T> * insertAsRC ( BinNode<T>* x , T const& e );  // 构造右孩子\n\tBinNode<T> * insertAsLC ( BinNode<T>* x , T const& e );  // 构造左孩子\n\tBinNode<T> * attachAsLC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为左孩子\n\tBinNode<T> * attachAsRC ( BinNode<T>* x , BinTree<T>*& subtree ); // 接入子树作为右孩子\n\tint remove( BinNode<T>* x );   // 删除某个结点（及其子树）\n\tvoid removeAt( BinNode<T>* x );\n\tBinTree<T> * secede( BinNode<T>* x );    // 分离子树，返回子树头\n\n\ttemplate <typename V>\n\tvoid travLevel( V & visit )  // 层级遍历\n\t{ _root->travLevel(visit); }\n\ttemplate <typename V>\n\tvoid travPre( V & visit )  // 先序遍历\n\t{ _root->travPre(visit); }\n\ttemplate <typename V>\n\tvoid travIn( V & visit )  // 中序遍历\n\t{ _root->travIn(visit); }\n\ttemplate <typename V>\n\tvoid travPost( V & visit )   // 后序遍历\n\t{ _root->travPost(visit); }\n};\n```\n\n## **遍历**\n\n定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次\n\n**遍历方式：**\n\n> 1. 先序遍历( preorder )：中->左->右\n> 2. 中序遍历( inorder )：左->中->右\n> 3. 后序遍历( postorder )：左->右->中\n> 4. 层次遍历：自上而下，自左而右\n>\n> 先序中序后序原则：必定先左后右，根结点访问次序如名字所示\n\n### **1. 先序遍历( 中 左 右 )**\n\n#### **1. 递归版本**\n\n根据先序遍历的定义，我们很容易写出递归版本的遍历函数：\n\n```\n// V为函数模板类  visit是相应的函数对象\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_R( V & visit )\n{\n\tvisit(data);\n\tif(lChild) lChild->travPre_R(visit);\n\tif(rChild) rChild->travPre_R(visit);\n}\n```\n\n然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。\n\n因此如果能够将**递归版**改成**迭代版**，就能够提高很多效率。\n\n#### **2. 迭代版本1**\n\n因为在递归版本中，向左右子树的递归出现在最后，即是**尾递归**，那么我们只需要引入一个**栈**，把左右子树的递归改成将左右子树入栈即可。\n\n值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要**先让右子树入栈，再让左子树入栈**\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_V1( V & visit )\n{\n\tStack <BinNode<T> *> s;\n\tBinNode<T>* x=this;\n\tif(x) \n\t\ts.push(x);\n\twhile(!s.empty())\n\t{\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tif(x->rChild) s.push(x->rChild); // 先入后出\n\t\tif(x->lChild) s.push(x->lChild);\n\t}\n}\n```\n\n#### **3. 迭代版本2**\n\n看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。\n\n通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子->它父亲的右孩子->父亲的父亲的右孩子…->根结点的右孩子。\n\n于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。\n\n![左侧链示意图](http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG)\n\n这样，我们就有了如下算法流程：\n\n1.访问该结点\n2.将右孩子入栈\n3.目光转向它的左孩子\n若左孩子存在，回到步骤1\n4.若栈不为空，取出栈顶元素，回到步骤1\n\n代码实现如下\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPre_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\twhile( !s.empty() )\n\t{\n\t\tx=s.pop();\n\t\twhile(x)\n\t\t{\n\t\t\tvisit(x->data);\n\t\t\tif(x->rChild) \n\t\t\t\ts.push(x->rChild);\n\t\t\tx=x->lChild;\n\t\t}\n\t}\n}\n```\n\n### **2. 中序遍历( 左 中 右 )**\n\n#### **1. 迭代版本1**\n\n先来观察一下中序遍历的流程：\n\n每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。\n\n中序和先序不同在于：**父结点不是立即被访问**，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。\n\n那右结点怎么办呢？\n\n右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。\n\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG)\n\n算法的流程如下：\n\n1.将该结点入栈\n2.转向该结点的左孩子\n若左孩子存在，返回步骤1\n3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子\n若右孩子存在，返回步骤1\n若右孩子不存在，重新开始步骤3\n\n现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\twhile(1)\n\t{\n\t\twhile(x)\n\t\t{\n\t\t\ts.push(x);\n\t\t\tx=x->lChild;\n\t\t}\n\t\tif(s.empty()) \n\t\t\tbreak;\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t\tx=x->rChild;\n\t} \n}\n```\n\n此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本\n\n#### **2. 迭代版本2**\n\n当把二叉树横向伸展地足够开后，如下图所示\n![中序遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim)\n从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序\n左右规则如下:\n\n左子树左孩子>左子树根结点>左子树右孩子>根结点>右子树左孩子>右子树根结点>右子树右孩子\n\n根据这个规则，我们就可以得到每个结点在中序遍历时的**直接后继**，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)\n\n那么要怎么得到这个直接后继呢？\n显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。\n而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个**结点是它父结点左孩子**的结点，直接后继就是这个结点的父结点。\n简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。\n\n将上述流程翻译成代码就是\n\n```\ntemplate <typename T>\nBinNode<T> *BinNode<T>::succ()\n{\n\tBinNode<T>* s=this;\n\tif(rChild)   // 若有右孩子\n\t{\n\t\ts=rChild;\n\t\twhile(s->lChild)   // 在右子树的左侧链一路到底\n\t\t\ts=s->lChild;\n\t}\n\telse\n\t{\n\t\twhile( s->parent && s==s->parent->rChild )\n\t\t\ts=s->parent;    // 此时是左子树的根结点\n\t\ts=s->parent;   // 再向上到左子树的父亲结点(也可能是NULL)\n\t}\n\treturn s;\n}\n```\n\n有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travIn_S(  V & visit )\n{\n\tBinNode<T>* x=this;\n\twhile(x->lChild)\n\t\tx=x->lChild;\n\tdo\n\t{\n\t\tvisit(x->data);\n\t\tx=x->succ();\n\t}\n\twhile(x);\n}\n```\n\n### **3. 后序遍历( 左 右 中 )**\n\n基于后序遍历的定义，我们可以导出如下流程：\n1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。\n2.访问结点\n3.若右兄弟存在，转向右兄弟，返回步骤1\n4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程\n\n可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travPost_I( V & visit )\n{\n\tStack<BinNode<T> *> s;\n\tBinNode<T> * x=this;\n\ts.push(x);\n\tBinNode<T> * c=s.top();\n\twhile(1)\n\t{\n\t\tif(s.empty()) break;\n\t\tif(s.top()!=x->parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树\n\t\t{\n\t\t\tc=s.top();\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(c->rChild) \n\t\t\t\t\ts.push(c->rChild);\n\t\t\t\tif(c->lChild) \n\t\t\t\t{\n\t\t\t\t\ts.push(c->lChild);\n\t\t\t\t\tc=c->lChild;   // 尽可能向左走\n\t\t\t\t}\n\t\t\t\telse if(c->rChild)  // 如果实在只有右孩子，那就向右\n\t\t\t\t\tc=c->rChild;\n\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx=s.pop();\n\t\tvisit(x->data);\n\t}\n}\n```\n\n### **4. 层次遍历**\n\n层次遍历的规则很简单：自上而下，自左而右\n\n![层次遍历](http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim)\n\n对此，我们可以引入**队列**来解决它。\n\n每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。\n\n```\ntemplate <typename T> template <typename V>\nvoid BinNode<T>::travLevel( V & e )\n{\n\tQueue<BinNode<T>*> q;\n\tBinNode<T>* x=this;\n\tq.enqueue(x);\n\twhile( !q.empty() )\n\t{\n\t\tx=q.dequeue();\n\t\tif(x->lChild)  q.enqueue(x->lChild);\n\t\tif(x->rChild)  q.enqueue(x->rChild);\n\t\te(x->data);\n\t}\n\treturn;\n}\n```\n\n## **重构**\n\n如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？\n\n### **一. 中序+(先序|后序)**\n\n结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。\n\n现在我们来用数学归纳法证明一下：\n假设结论在结点数n’<’N的情况下都成立\n在n==N时\n先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。\n那么在先序遍历和中序遍历中分别如下图所示：\n\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG)\n\n可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。\n这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’<’N的左右子树中结论均成立，由此n==N时结论也成立。\n\n而有后续和中序遍历的序列的证明也同理可得了。\n\n```\n// 先序+中序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PI( T* pre, T* ins, int len )\n{\n\t_root=rebuildSub_PI(pre,ins,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PI( T* pre, T* ins, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(pre); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PI( pre+1, ins, i );\n\ts->rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );\n\treturn s;\n}\n```\n\n```\n// 中序+后序重构\ntemplate <typename T>\nvoid BinTree<T>::rebuild_IP( T* ins, T* post, int len )\n{\n\t_root=rebuildSub_IP(ins,post,len);\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_IP( T* ins, T* post, int len ) \n{\n\tBinNode<T> *s=NULL;\n\tif(len<=0) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(* (post+len-1) );\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(ins+i)!=*(post+len-1); i++);\n\ts=new BinNode<T>(*(post+len-1));\n\ts->lChild=rebuildSub_IP( ins, post, i );\n\ts->rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );\n\treturn s;\n}\n```\n\n### **二. (先序+后序)\\*真二叉树**\n\n结论二：在只有先序和后序序列时，若是该二叉树是一棵**真二叉树**(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。\n\n那么要怎么做呢？\n\n在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。\n在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。\n这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。\n![重构二叉树](http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG)\n\n```\ntemplate <typename T>\nvoid BinTree<T>::rebuild_PP( T *pre,T *post,int len )\n{\n\t_root=new BinNode<T> (pre[0]);\n\trebuildSub_PP( _root,pre,post,len );\n\treturn;\n}\ntemplate <typename T>\nBinNode<T> * rebuildSub_PP( T *pre , T *post, int len )\n{ \n\tBinNode<T> *s=NULL;\n\tif( len<=0 ) return s;\n\tif(len==1)\n\t{\n\t\ts=new BinNode<T>(*pre);\n\t\treturn s;\n\t}\n\tint i;\n\tfor(i=0; *(post+i)!=*(pre+1); i++);\n\ts=new BinNode<T>(*pre);\n\ts->lChild=rebuildSub_PP(pre+1,post,i+1);\n\ts->rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);\n\treturn s;\n}\n```\n\n# **完整实现代码**\n\n[二叉树的完整实现 ( 附带遍历和重构 )](https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp)\n\n# 二叉搜索树BST ( Binary Search Tree )\n\n## 概述\n\n### 循关键码访问 call-by-key\n\n数据项之间，依照各自的关键码(key)彼此区分\n\n条件：关键码之间支持**大小比较**和**相等比对**\n\n### 性质\n\n二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：\n\n```\n1. 非空左子树所有键值小于根结点的键值\n2. 非空右子树所有键值大于根结点的键值\n3. 左右子树都是二叉搜索树\n\n```\n\n基本框架：\n\n```\ntemplate <typename T>\nstruct TreeNode\n{\n\tT data;\n\tTreeNode<T> * left;\n\tTreeNode<T> * right;\n};\n```\n\n## 接口\n\n```\n1. BinTree Find( T x , BinTree BST);\n\n```\n\n> 从BST中查找元素x,返回所在结点的地址\n\n```\n2. BinTree FindMin(BinTree BST);\n\n```\n\n> 从BST中查找并返回最小元素所在结点的地址\n\n```\n3. BinTree FindMax(BinTree BST);\n\n```\n\n> 从BST中查找并返回最大元素所在结点的地址\n\n```\n4. BinTree Insert( T x , BinTree BST);\n\n```\n\n> 将元素x插入BST中，返回插入后的BST\n\n```\n5. BinTree Delete( T x , BinTree BST);\n\n```\n\n> 从BST中删除元素x\n\n### 查找操作： Find\n\n```\n- 查找从根结点开始，若树为空则返回NULL\n- 若树非空，则将根结点键值和x比较：\n    - 若 x < root.data ，在左子树中搜索\n    - 若 x > root.data ，在右子树中搜索\n    - 若两者相等，则返回指向该结点的指针\n- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式\n- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**\n\n```\n\n代码实现：\n\n```\ntemplate <typename T>\nTreeNode<T> * Find(T x , TreeNode<T> * BST)\n{\n\twhile(BST)\n\t{\n\t\tif(x>BST->data)\n\t\t\tBST=BST->right;\n\t\telse if(x<BST->data)\n\t\t\tBST=BST->left;\n\t\telse\n\t\t\treturn BST;\n\t}\n\treturn NULL;\n}\n```\n\n### 查找最大和最小元素\n\n根据二叉搜索树的性质：\n\n```\n- 最大元素一定在树的最右分支的端结点上\n- 最小元素一定在树的最左分支的端结点上\n\n```\n\n同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本\n\n```\ntemplate <typename T>\nTreeNode<T> * FindMax( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->right)\n\t\t\tBST=BST->right;\n\treturn BST;\n}\ntemplate <typename T>\nTreeNode<T> * FindMin( TreeNode<T> * BST)\n{\n\tif(BST)\n\t\twhile(BST->left)\n\t\t\tBST=BST->left;\n\treturn BST;\n}\n```\n\n### 插入结点\n\n关键：要找到元素应该插入的位置，可以采用和Find类似的方法\n\n思路：\n\n```\ntemplate <typename T>\nTreeNode<T> * Insert( T x , TreeNode<T> * BST)\n{\n\tif(!BST)\n\t{\n\t\tBST = new TreeNode<T>();\n\t\tBST->data=x;\n\t\tBST->left=BST->right=NULL;\n\t}\n\telse\n\t{\n\t\tif(x<BST->data)\n\t\t\tBST->left=Insert(x,BST->left);\n\t\telse if(x>BST->data)\n\t\t\tBST->right=Insert(x,BST->right);\n\t}\n\treturn BST;\n}\n```\n\n### 删除结点\n\n考虑情况\n\n```\n1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL\n2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子\n3. 要删除的结点有左右两棵子树\n    用另一结点代替被删除结点：左子树最大元素或右子树最小元素\n\n```\n\n```\ntemplate <typename T>\nTreeNode<T> * Delete( T x , TreeNode<T> * BST)\n{\n\tTreeNode<T> *tmp;\n\tif(!BST) return NULL;\n\telse if(x<BST->data)\n\t\tBST->left=Delete(x,BST->left);\n\telse if(x>BST->data)\n\t\tBST->right=Delete(x,BST->right);\n\telse\n\t{\n\t\tif(BST->left && BST->right)\n\t\t{\n\t\t\ttmp=FindMin(BST->right);\n\t\t\tBST->data=tmp->data;\n\t\t\tBST->right=delete(BST->data,BST->right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=BST;\n\t\t\tif(!BST->left)\n\t\t\t\tBST=BST->right;\n\t\t\telse if(!BST->right)\n\t\t\t\tBST=BST->left;\n\t\t\tdelete tmp;\n\t\t}\n\t}\n\treturn BST;\n}\n```\n\n# 平衡二叉树 AVL树 (Balanced Binary Tree)\n\n定义：\n空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|<=1\n\n**平衡因子（BF:Balance Factor）**: BF(T)=Hl - Hr\nHl和Hr分别为T的左右子树的高度\n\n推算高度为h的平衡二叉树最少结点数：\n\n```\n高度为1时 h(1)=1;\n高度为2时 h(2)=2;\n高度为3时 h(3)=h(1)+h(2)+1=4;\n...\n高度为n时 h(n)=h(n-1)+h(n-2)+1;\n原因：\n    > 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值<=1\n    > 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )\n由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$\n\n```\n\n结点数为n的平衡二叉树的最大高度为O(logn)\n\n## 平衡二叉树的调整\n\n**核心思想：选择中间值作为根结点**\n\n**RR插入**：插入结点在右子树的右边，需要RR旋转（右单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG)\n\n大小关系为： 根结点 < 右子树根结点 < 右子树的右边\n\n因此选取右子树的根结点作为新的平衡二叉树的根结点\n\n**LL插入**：插入结点在左子树的左边，需要LL旋转（左单旋）\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG)\n\n大小关系为： 左子树的左边 < 左子树根结点 < 根结点\n\n因此选取左子树的根结点作为新的平衡二叉树的根结点\n\n**LR插入**：插入结点在左子树的右边，需要LR旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG)\n\n大小关系为： 左子树的根结点 < 左子树的右边 < 根结点\n\n因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点\n\n**RL插入**：插入结点在右子树的左边，需要RL旋转\n\n![mark](http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG)\n\n大小关系为： 根结点 < 右子树的左边 < 右子树的根结点\n\n因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点\n\n# 堆 heap\n\n## 概述\n\n**优先队列( Priority Queue )**\n特殊的队列，取出元素的顺序是依照元素的**优先权（关键字）**的大小，而不是元素进入队列的先后顺序\n\n堆的特性：\n**结构性**：用数组表示的完全二叉树\n**有序性**：任一结点的关键字是其子树所有结点的最大值（或最小值）\n从根结点到任意结点路径上结点序列的有序性\n最大堆（MaxHeap）：根结点为最大值\n最小堆（MinHeap）：根结点为最小值\n\n## 接口\n\n数据对象集：完全二叉树\n\n接口：\nMaxHeap Create( int Maxsize );\n创建一个空的最大堆\nBoolean IsFull( MaxHeap H );\n判断最大堆H是否满\nvoid Insert( MaxHeap H , T data );\n将data插入最大堆H\nBoolean IsEmpty( MaxHeap H );\n判断最大堆H是否为空\nT DeleteMax( MaxHeap H );\n返回H中最大元素（高优先级）\n\n### Insert\n\n思路：\n\n> 将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点\n\n```\ntemplate <typename T>\nvoid Insert( Heap<T>* h, T item)\n{\n\tint i;\n\tif( IsFull(h) ) // 若堆已满，则不做插入操作\n\t\treturn;\n\ti = ++h->size;\n\tfor( ; h->data[i/2]<item ; i/=2 )\n\t\th->data[i] = h->data[i/2];\n\th->data[i] = item;\n}\n```\n\n### Delete\n\n思路：\n\n> 取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作\n\n```\ntemplate <typename T>\nvoid Delete( Heap<T>* h , T item )\n{\n\tint parent , child;\n\tT maxn,tem;\n\tif( IsEmpty(h) ) \n\t\treturn;\n\tmaxn = h->data[1];\n\ttem = h->data[h->size--];\n\tfor( parent=1 ; parent*2<= h->size ; parent = child )\n\t{\n\t\tchild = parent *2;\n\t\tif( child != h->size  && h->data[child]<h.data[child+1])\n\t\t\tchild++;   // 寻找左右孩子中较大的那个\n\t\tif( tem>= h->data[child] ) \n\t\t\tbreak;\n\t\telse\n\t\t\th->data[parent] = h->data[child];\n\t}\n\th->data[parent]=tem;\n}\n```\n\n### 建立最大堆\n\n将已经存在的N个元素按最大堆的要求存放在一个一维数组\n\n方法1：\n通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)\n\n方法2：\n\n```\n1. n个元素按输入顺序存入，先满足完全二叉树\n2. 调整各结点位置\n\n```\n\n#### 方法二：\n\n自底向上调整\n\n从倒数第二行的结点开始自右向左调整\n\n而后再到倒数第三行、倒数第四行…直到根结点\n\n这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可\n\n这样就只需要O(n)的时间即可完成建堆\n\n# 哈夫曼树\n\n带权路径长度（WPL）\n设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk\n\n哈夫曼树（最优二叉树）：WPL值最小的二叉树\n\n## 哈夫曼树的构造\n\n每次把**权值最小**的两棵二叉树合并\n\n## 特点\n\n```\n1. 没有度为1的结点\n2. n个叶子结点的哈夫曼树有2n-1个结点\n    设 n0: 叶子结点总数\n    设 n1: 只有一个儿子的结点总数\n    设 n2: 有2个儿子的结点总数\n    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1\n3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树\n4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）\n\n```\n\n## 哈夫曼编码\n\n```\n给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少\n\n避免二义性：\n    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀\n\n利用二叉树进行编码：\n    1. 左右分支：0、1\n    2. 字符只在叶结点上\n\n构造方法：根据字符的权值构造哈夫曼树\n\n```\n\n# 集合\n\n```\n集合运算：交、并、补、差、判定一个元素是否属于某个集合\n并查集：集合并、查某元素属于什么集合\n并查集实现：\n    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）\n    2. 利用数组存储，两个一维数组分别存储数据和父亲下标\n\n```\n\n利用数组存储的定义：\n\n```\ntemplate <typename T>\nstruct Node\n{\n\tT data;\n\tint parent;\n\tNode( T d , int parent = -1 ):data(d){}\n\tNode(){parent=-1;}\n};\n```\n\n每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标\n\n## 查找当前结点所属集合\n\n思路：\n首先在数组中找到目标结点\n而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );   // 在数组中寻找值为x的结点\n\tif( i>=MaxSize ) return -1;    // 没找到，返回-1\n\tfor( ; s[i].parent>=0; i=s[i].parent );  // 顺着父结点指针一路向上找\n\treturn i;\n}\n```\n\n优化：\n通过**路径压缩**，每次查找时把沿途所有节点的parent都设为根节点\n\n```\ntemplate <typename T>\nint Find( Node<T>* s , T x )\n{\n\t/* 在s中查找值为x的元素所属的集合 */\n\t/* Maxsize为全局变量，s的最大长度 */\n\tint i;\n\tfor( i=0; i<MaxSize&& s[i].data!=x; i++ );\n\tif( i>=MaxSize ) return -1;\n\tint tem=i,tem1=s[tem].parent;\n\tfor( ; s[i].parent>=0; i=s[i].parent );\n\twhile( tem1!=-1 && tem1!=i )\n\t{\n\t\ts[tem].parent = i;\n\t\ttem=tem1;\n\t\ttem1=s[tem].parent;\n\t}\n\treturn i;\n}\n```\n\n## 集合的并运算\n\n思路：\n首先分别找到两个元素所在的集合树的根结点\n若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标\n\n```\ntemplate <typename T>\nvoid Union( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t\ts[root2].parent = root1;\n}\n```\n\n优化：\n为了改善合并后的查找效率，把小的集合并入大的集合\n方法1：每个结点额外维护一个值：以该结点为根的结点总数\n缺点：只有根节点才需要用到该值，造成大量空间浪费\n方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数\n\n```\ntemplate <typename T>\nvoid Union1( Node<T>* s, T x1 , T x2)\n{\n\tint root1,root2;\n\troot1=Find(s,x1);\n\troot2=Find(s,x2);\n\tif(root1!=root2)\n\t{\t\n\t\tif( s[root1].parent<s[root2].parent )\n\t\t{\t\n\t\t\ts[root1].parent += s[root2].parent;\n\t\t\ts[root2].parent = root1;\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\ts[root2].parent += s[root1].parent;\n\t\t\ts[root1].parent = root2;\n\t\t}\n\t}\n}\n```","slug":"DataStructure_Tree","published":1,"updated":"2018-05-25T12:41:12.394Z","photos":[],"link":"","_id":"cjhvssaej0016jvfcqsyrejbe","content":"<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a><strong>树</strong></h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h2><h3 id=\"出现原因：\"><a href=\"#出现原因：\" class=\"headerlink\" title=\"出现原因：\"></a>出现原因：</h3><p>向量在静态操作速度快O(1)，在动态操作速度慢O(n)<br>列表在静态操作速度慢O(n)，在动态操作速度快O(1)<br>树结合了两者的优点，可看作是一种<strong>半线性的结构</strong><br>应用：组织层次关系，如文件系统、学院层级关系等</p>\n<a id=\"more\"></a>\n<h3 id=\"树的分类：\"><a href=\"#树的分类：\" class=\"headerlink\" title=\"树的分类：\"></a>树的分类：</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim\" alt=\"树的分类\"></p>\n<h3 id=\"概念1-有根树rooted-tree\"><a href=\"#概念1-有根树rooted-tree\" class=\"headerlink\" title=\"概念1. 有根树rooted tree\"></a>概念1. 有根树rooted tree</h3><p>指定任一结点为根<br>可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim\" alt=\"子树\"></p>\n<p>ri 为r的孩子( child )， ri之间互为兄弟( sibling )<br>r为父亲( parent ),<br>d=degree(r)为r的度=一结点拥有的孩子的数目<br>任何一棵树中边数e和结点数目n同阶</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim\" alt=\"边数和结点数同阶\"></p>\n<h3 id=\"概念2-有序树\"><a href=\"#概念2-有序树\" class=\"headerlink\" title=\"概念2. 有序树\"></a>概念2. 有序树</h3><p>指定Ti为T的第i棵子树，ri为r的第i个孩子</p>\n<p>即是：兄弟之间有明显<strong>次序</strong></p>\n<h3 id=\"概念3-连通性和无环性：\"><a href=\"#概念3-连通性和无环性：\" class=\"headerlink\" title=\"概念3. 连通性和无环性：\"></a>概念3. 连通性和无环性：</h3><p>任何两结点之间都有路径，则称为<strong>连通图</strong>（connected）<br>不含环路则称为<strong>无环图</strong>（acyclic）</p>\n<p>树的特点：</p>\n<blockquote>\n<p>1 .无环连通图：在无环性和连通性之间平衡<br>2 .极小连通图：在连通的情况下边数尽可能少<br>3 .极大无环图：在无环的情况下边数尽可能多</p>\n</blockquote>\n<p>结论： 任何结点和根之间存在<strong>唯一一条</strong>路径<br>即 $path(v,r)=path(v)$<br>我们用一个指标 <strong>深度( depth )</strong> 记录下每个结点到根的距离<br>path(v)上的结点均为v的<strong>祖先</strong>( ancestor )<br>v是它们的<strong>后代</strong> ( descendent )<br>对于v而言，若<strong>祖先存在，则必定唯一</strong>。若<strong>后代存在，却未必唯一</strong>，因此是半线性结构。<br>而对于图而言，祖先和后代都未必唯一，因此图为非线性结构<br><strong>叶子结点</strong>（leaf）：没有后代的结点</p>\n<p>叶子深度最大的称为<strong>树的高度</strong><br><strong>深度</strong>是<strong>结点v到总树根结点r</strong>的距离<br>即height（v）=max( height (v_son) ) +1<br>结点v的<strong>高度</strong>为<strong>以结点v为根结点</strong>的子树的高度<br>即 height（v）=height（subtree（v））<br>约定俗成：空树的高度取作<strong>-1</strong>，一个结点的树高度取作<strong>0</strong><br>对于任一结点：depth（v）+height（v）&lt;=height(T)<br>（高度向下看，深度向上看）<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim\" alt=\"树的深度和高度\"></p>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a><strong>表示</strong></h2><h3 id=\"1-接口\"><a href=\"#1-接口\" class=\"headerlink\" title=\"1. 接口\"></a>1. 接口</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>结点</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>node*</td>\n<td>root()</td>\n<td>根结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>parent()</td>\n<td>父结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>firstchild()</td>\n<td>长子</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>nextSibling()</td>\n<td>兄弟</td>\n</tr>\n<tr>\n<td>void</td>\n<td>insert( i,e )</td>\n<td>将e作为第i个孩子插入</td>\n</tr>\n<tr>\n<td>int</td>\n<td>remove(i)</td>\n<td>删除第i个孩子(及其后代)</td>\n</tr>\n<tr>\n<td>void</td>\n<td>traverse</td>\n<td>遍历</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-构造方法\"><a href=\"#2-构造方法\" class=\"headerlink\" title=\"2. 构造方法\"></a>2. 构造方法</h3><p>不妨用数组进行模拟</p>\n<p><strong>长子兄弟法</strong>：</p>\n<p>每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint father, child, nextSibling;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node  *tree;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a><strong>二叉树</strong></h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>结点度数<strong>不超过2</strong>（孩子数目&lt;=2）的树</p>\n<p>同一结点的孩子和子树以<strong>左右</strong>区分</p>\n<p>二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。</p>\n<p>基于二叉树的概念，我们可以得到下列关系：<br>1.深度为k的结点最多有$2^k$个<br>2.高度为h的二叉树的结点数n满足$h’&lt;’n’&lt;’2^(h+1)$<br>1.当n=h+1时，二叉树退化为一条单链<br>2.当$n=2^(h+1)-1$时，二叉树为满二叉树</p>\n<p>二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点</p>\n<p>而高度h涨得很慢，与结点n的关系为$h=logn$</p>\n<h2 id=\"真二叉树-Proper-binary-tree\"><a href=\"#真二叉树-Proper-binary-tree\" class=\"headerlink\" title=\"真二叉树(Proper binary tree)\"></a><strong>真二叉树(Proper binary tree)</strong></h2><p>定义：所有结点的度数均为偶数的二叉树。</p>\n<p>很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点<strong>虚拟地</strong>补上孩子。</p>\n<h2 id=\"完全二叉树-complete-binary-tree\"><a href=\"#完全二叉树-complete-binary-tree\" class=\"headerlink\" title=\"完全二叉树(complete binary tree)\"></a><strong>完全二叉树(complete binary tree)</strong></h2><p>定义：叶结点只出现在<strong>最后两层</strong>，并且最底层的叶结点均在次底层叶结点的<strong>左侧</strong>。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG\" alt=\"完全二叉树\"></p>\n<h2 id=\"满二叉树-full-binary-tree\"><a href=\"#满二叉树-full-binary-tree\" class=\"headerlink\" title=\"满二叉树(full binary tree)\"></a><strong>满二叉树(full binary tree)</strong></h2><p>定义：所有叶结点都在<strong>最后一层</strong>，每层结点都达到饱和。</p>\n<p>特性：<br>1.结点数目n和高度h的关系：$n=2^(h+1)-1$<br>2.叶子结点数=内部结点数+1<br>3.满二叉树是<strong>特殊</strong>的<strong>完全二叉树</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG\" alt=\"满二叉树\"></p>\n<h2 id=\"用二叉树描述多叉树\"><a href=\"#用二叉树描述多叉树\" class=\"headerlink\" title=\"用二叉树描述多叉树\"></a><strong>用二叉树描述多叉树</strong></h2><p>先上结论：<strong>凡是有根且有序的树，均可以用二叉树实现</strong></p>\n<p>为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG\" alt=\"树到二叉树\"></p>\n<p>可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG\" alt=\"树到二叉树\"></p>\n<p>这就将一棵树变成了二叉树！</p>\n<p>这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。</p>\n<h2 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a><strong>基本定义</strong></h2><p><strong>结点类的基本定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* lChild,*rChild,*parent;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBinNode() &#123; lChild=rChild=parent= NULL ; height=0; &#125;</span><br><span class=\"line\">\tBinNode( T e , BinNode&lt;T&gt;* pa=NULL , BinNode&lt;T&gt;* lc=NULL, BinNode&lt;T&gt;* rc=NULL)</span><br><span class=\"line\">\t\t:data(e),parent(pa),lChild(lc),rChild(rc) &#123;&#125;</span><br><span class=\"line\">\tint size() const ;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC( T const &amp; e ) //作为左孩子插入</span><br><span class=\"line\">\t&#123; return lChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC( T const &amp; e ) //作为右孩子插入</span><br><span class=\"line\">\t&#123; return rChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBinNode&lt;T&gt; * succ();   // 中序遍历时的直接后继</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit );  // 子树层级遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit );   // 子树先序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit );    // 子树中序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit );   // 子树后序遍历</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int BinNode&lt;T&gt;::size()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint s=1;</span><br><span class=\"line\">\tif(lChild)</span><br><span class=\"line\">\t\ts+=lChild-&gt;size();</span><br><span class=\"line\">\tif(rChild)</span><br><span class=\"line\">\t\ts+=rChild-&gt;size();</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。</p>\n<p>size函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。</p>\n<p><strong>树的基础定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint _size;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* _root;</span><br><span class=\"line\">\tvirtual int updateHeight( BinNode&lt;T&gt;* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）</span><br><span class=\"line\">\tvoid updateHeightAbove( BinNode&lt;T&gt;* x);  // 更新x及x的祖先的高度</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBinTree() &#123;_size=0; _root=NULL;&#125;</span><br><span class=\"line\">\t~BinTree() &#123; remove(_root); &#125;</span><br><span class=\"line\">\tBinTree( T const&amp; e) &#123;_size=1; _root=new BinNode&lt;T&gt; (e);&#125;</span><br><span class=\"line\">\tint size() const &#123;return _size;&#125;</span><br><span class=\"line\">\tbool empty() const &#123;return !_root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * root() const &#123;return _root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造右孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsLC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsRC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为右孩子</span><br><span class=\"line\">\tint remove( BinNode&lt;T&gt;* x );   // 删除某个结点（及其子树）</span><br><span class=\"line\">\tvoid removeAt( BinNode&lt;T&gt;* x );</span><br><span class=\"line\">\tBinTree&lt;T&gt; * secede( BinNode&lt;T&gt;* x );    // 分离子树，返回子树头</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit )  // 层级遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travLevel(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit )  // 先序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPre(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit )  // 中序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travIn(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit )   // 后序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPost(visit); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a><strong>遍历</strong></h2><p>定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次</p>\n<p><strong>遍历方式：</strong></p>\n<blockquote>\n<ol>\n<li>先序遍历( preorder )：中-&gt;左-&gt;右</li>\n<li>中序遍历( inorder )：左-&gt;中-&gt;右</li>\n<li>后序遍历( postorder )：左-&gt;右-&gt;中</li>\n<li>层次遍历：自上而下，自左而右</li>\n</ol>\n<p>先序中序后序原则：必定先左后右，根结点访问次序如名字所示</p>\n</blockquote>\n<h3 id=\"1-先序遍历-中-左-右\"><a href=\"#1-先序遍历-中-左-右\" class=\"headerlink\" title=\"1. 先序遍历( 中 左 右 )\"></a><strong>1. 先序遍历( 中 左 右 )</strong></h3><h4 id=\"1-递归版本\"><a href=\"#1-递归版本\" class=\"headerlink\" title=\"1. 递归版本\"></a><strong>1. 递归版本</strong></h4><p>根据先序遍历的定义，我们很容易写出递归版本的遍历函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V为函数模板类  visit是相应的函数对象</span><br><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_R( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisit(data);</span><br><span class=\"line\">\tif(lChild) lChild-&gt;travPre_R(visit);</span><br><span class=\"line\">\tif(rChild) rChild-&gt;travPre_R(visit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。</p>\n<p>因此如果能够将<strong>递归版</strong>改成<strong>迭代版</strong>，就能够提高很多效率。</p>\n<h4 id=\"2-迭代版本1\"><a href=\"#2-迭代版本1\" class=\"headerlink\" title=\"2. 迭代版本1\"></a><strong>2. 迭代版本1</strong></h4><p>因为在递归版本中，向左右子树的递归出现在最后，即是<strong>尾递归</strong>，那么我们只需要引入一个<strong>栈</strong>，把左右子树的递归改成将左右子树入栈即可。</p>\n<p>值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要<strong>先让右子树入栈，再让左子树入栈</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_V1( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack &lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tif(x) </span><br><span class=\"line\">\t\ts.push(x);</span><br><span class=\"line\">\twhile(!s.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tif(x-&gt;rChild) s.push(x-&gt;rChild); // 先入后出</span><br><span class=\"line\">\t\tif(x-&gt;lChild) s.push(x-&gt;lChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-迭代版本2\"><a href=\"#3-迭代版本2\" class=\"headerlink\" title=\"3. 迭代版本2\"></a><strong>3. 迭代版本2</strong></h4><p>看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。</p>\n<p>通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子-&gt;它父亲的右孩子-&gt;父亲的父亲的右孩子…-&gt;根结点的右孩子。</p>\n<p>于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG\" alt=\"左侧链示意图\"></p>\n<p>这样，我们就有了如下算法流程：</p>\n<p>1.访问该结点<br>2.将右孩子入栈<br>3.目光转向它的左孩子<br>若左孩子存在，回到步骤1<br>4.若栈不为空，取出栈顶元素，回到步骤1</p>\n<p>代码实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\t\tif(x-&gt;rChild) </span><br><span class=\"line\">\t\t\t\ts.push(x-&gt;rChild);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序遍历-左-中-右\"><a href=\"#2-中序遍历-左-中-右\" class=\"headerlink\" title=\"2. 中序遍历( 左 中 右 )\"></a><strong>2. 中序遍历( 左 中 右 )</strong></h3><h4 id=\"1-迭代版本1\"><a href=\"#1-迭代版本1\" class=\"headerlink\" title=\"1. 迭代版本1\"></a><strong>1. 迭代版本1</strong></h4><p>先来观察一下中序遍历的流程：</p>\n<p>每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。</p>\n<p>中序和先序不同在于：<strong>父结点不是立即被访问</strong>，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。</p>\n<p>那右结点怎么办呢？</p>\n<p>右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG\" alt=\"中序遍历\"></p>\n<p>算法的流程如下：</p>\n<p>1.将该结点入栈<br>2.转向该结点的左孩子<br>若左孩子存在，返回步骤1<br>3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子<br>若右孩子存在，返回步骤1<br>若右孩子不存在，重新开始步骤3</p>\n<p>现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ts.push(x);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(s.empty()) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;rChild;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本</p>\n<h4 id=\"2-迭代版本2\"><a href=\"#2-迭代版本2\" class=\"headerlink\" title=\"2. 迭代版本2\"></a><strong>2. 迭代版本2</strong></h4><p>当把二叉树横向伸展地足够开后，如下图所示<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim\" alt=\"中序遍历\"><br>从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序<br>左右规则如下:</p>\n<p>左子树左孩子&gt;左子树根结点&gt;左子树右孩子&gt;根结点&gt;右子树左孩子&gt;右子树根结点&gt;右子树右孩子</p>\n<p>根据这个规则，我们就可以得到每个结点在中序遍历时的<strong>直接后继</strong>，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)</p>\n<p>那么要怎么得到这个直接后继呢？<br>显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。<br>而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个<strong>结点是它父结点左孩子</strong>的结点，直接后继就是这个结点的父结点。<br>简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。</p>\n<p>将上述流程翻译成代码就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; *BinNode&lt;T&gt;::succ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* s=this;</span><br><span class=\"line\">\tif(rChild)   // 若有右孩子</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=rChild;</span><br><span class=\"line\">\t\twhile(s-&gt;lChild)   // 在右子树的左侧链一路到底</span><br><span class=\"line\">\t\t\ts=s-&gt;lChild;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile( s-&gt;parent &amp;&amp; s==s-&gt;parent-&gt;rChild )</span><br><span class=\"line\">\t\t\ts=s-&gt;parent;    // 此时是左子树的根结点</span><br><span class=\"line\">\t\ts=s-&gt;parent;   // 再向上到左子树的父亲结点(也可能是NULL)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_S(  V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\twhile(x-&gt;lChild)</span><br><span class=\"line\">\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;succ();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-后序遍历-左-右-中\"><a href=\"#3-后序遍历-左-右-中\" class=\"headerlink\" title=\"3. 后序遍历( 左 右 中 )\"></a><strong>3. 后序遍历( 左 右 中 )</strong></h3><p>基于后序遍历的定义，我们可以导出如下流程：<br>1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。<br>2.访问结点<br>3.若右兄弟存在，转向右兄弟，返回步骤1<br>4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程</p>\n<p>可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPost_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\tBinNode&lt;T&gt; * c=s.top();</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s.empty()) break;</span><br><span class=\"line\">\t\tif(s.top()!=x-&gt;parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tc=s.top();</span><br><span class=\"line\">\t\t\twhile(1)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(c-&gt;rChild) </span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;rChild);</span><br><span class=\"line\">\t\t\t\tif(c-&gt;lChild) </span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;lChild);</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;lChild;   // 尽可能向左走</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse if(c-&gt;rChild)  // 如果实在只有右孩子，那就向右</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;rChild;</span><br><span class=\"line\">\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-层次遍历\"><a href=\"#4-层次遍历\" class=\"headerlink\" title=\"4. 层次遍历\"></a><strong>4. 层次遍历</strong></h3><p>层次遍历的规则很简单：自上而下，自左而右</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim\" alt=\"层次遍历\"></p>\n<p>对此，我们可以引入<strong>队列</strong>来解决它。</p>\n<p>每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travLevel( V &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueue&lt;BinNode&lt;T&gt;*&gt; q;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tq.enqueue(x);</span><br><span class=\"line\">\twhile( !q.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=q.dequeue();</span><br><span class=\"line\">\t\tif(x-&gt;lChild)  q.enqueue(x-&gt;lChild);</span><br><span class=\"line\">\t\tif(x-&gt;rChild)  q.enqueue(x-&gt;rChild);</span><br><span class=\"line\">\t\te(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a><strong>重构</strong></h2><p>如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？</p>\n<h3 id=\"一-中序-先序-后序\"><a href=\"#一-中序-先序-后序\" class=\"headerlink\" title=\"一. 中序+(先序|后序)\"></a><strong>一. 中序+(先序|后序)</strong></h3><p>结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。</p>\n<p>现在我们来用数学归纳法证明一下：<br>假设结论在结点数n’&lt;’N的情况下都成立<br>在n==N时<br>先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。<br>那么在先序遍历和中序遍历中分别如下图所示：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG\" alt=\"重构二叉树\"></p>\n<p>可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。<br>这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’&lt;’N的左右子树中结论均成立，由此n==N时结论也成立。</p>\n<p>而有后续和中序遍历的序列的证明也同理可得了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先序+中序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PI( T* pre, T* ins, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_PI(pre,ins,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PI( T* pre, T* ins, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(pre); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PI( pre+1, ins, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 中序+后序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_IP( T* ins, T* post, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_IP(ins,post,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_IP( T* ins, T* post, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(* (post+len-1) );</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+len-1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*(post+len-1));</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_IP( ins, post, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-先序-后序-真二叉树\"><a href=\"#二-先序-后序-真二叉树\" class=\"headerlink\" title=\"二. (先序+后序)*真二叉树\"></a><strong>二. (先序+后序)*真二叉树</strong></h3><p>结论二：在只有先序和后序序列时，若是该二叉树是一棵<strong>真二叉树</strong>(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。</p>\n<p>那么要怎么做呢？</p>\n<p>在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。<br>在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。<br>这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG\" alt=\"重构二叉树\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PP( T *pre,T *post,int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=new BinNode&lt;T&gt; (pre[0]);</span><br><span class=\"line\">\trebuildSub_PP( _root,pre,post,len );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PP( T *pre , T *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif( len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PP(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的完整实现 ( 附带遍历和重构 )</a></p>\n<h1 id=\"二叉搜索树BST-Binary-Search-Tree\"><a href=\"#二叉搜索树BST-Binary-Search-Tree\" class=\"headerlink\" title=\"二叉搜索树BST ( Binary Search Tree )\"></a>二叉搜索树BST ( Binary Search Tree )</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"循关键码访问-call-by-key\"><a href=\"#循关键码访问-call-by-key\" class=\"headerlink\" title=\"循关键码访问 call-by-key\"></a>循关键码访问 call-by-key</h3><p>数据项之间，依照各自的关键码(key)彼此区分</p>\n<p>条件：关键码之间支持<strong>大小比较</strong>和<strong>相等比对</strong></p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 非空左子树所有键值小于根结点的键值</span><br><span class=\"line\">2. 非空右子树所有键值大于根结点的键值</span><br><span class=\"line\">3. 左右子树都是二叉搜索树</span><br></pre></td></tr></table></figure>\n<p>基本框架：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct TreeNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * left;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. BinTree Find( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找元素x,返回所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. BinTree FindMin(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最小元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. BinTree FindMax(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最大元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. BinTree Insert( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将元素x插入BST中，返回插入后的BST</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. BinTree Delete( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中删除元素x</p>\n</blockquote>\n<h3 id=\"查找操作：-Find\"><a href=\"#查找操作：-Find\" class=\"headerlink\" title=\"查找操作： Find\"></a>查找操作： Find</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 查找从根结点开始，若树为空则返回NULL</span><br><span class=\"line\">- 若树非空，则将根结点键值和x比较：</span><br><span class=\"line\">    - 若 x &lt; root.data ，在左子树中搜索</span><br><span class=\"line\">    - 若 x &gt; root.data ，在右子树中搜索</span><br><span class=\"line\">    - 若两者相等，则返回指向该结点的指针</span><br><span class=\"line\">- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式</span><br><span class=\"line\">- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**</span><br></pre></td></tr></table></figure>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Find(T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\treturn BST;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找最大和最小元素\"><a href=\"#查找最大和最小元素\" class=\"headerlink\" title=\"查找最大和最小元素\"></a>查找最大和最小元素</h3><p>根据二叉搜索树的性质：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 最大元素一定在树的最右分支的端结点上</span><br><span class=\"line\">- 最小元素一定在树的最左分支的端结点上</span><br></pre></td></tr></table></figure>\n<p>同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMax( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;right)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMin( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;left)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h3><p>关键：要找到元素应该插入的位置，可以采用和Find类似的方法</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Insert( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tBST = new TreeNode&lt;T&gt;();</span><br><span class=\"line\">\t\tBST-&gt;data=x;</span><br><span class=\"line\">\t\tBST-&gt;left=BST-&gt;right=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;left=Insert(x,BST-&gt;left);</span><br><span class=\"line\">\t\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;right=Insert(x,BST-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h3><p>考虑情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL</span><br><span class=\"line\">2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子</span><br><span class=\"line\">3. 要删除的结点有左右两棵子树</span><br><span class=\"line\">    用另一结点代替被删除结点：左子树最大元素或右子树最小元素</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Delete( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; *tmp;</span><br><span class=\"line\">\tif(!BST) return NULL;</span><br><span class=\"line\">\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;left=Delete(x,BST-&gt;left);</span><br><span class=\"line\">\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;right=Delete(x,BST-&gt;right);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(BST-&gt;left &amp;&amp; BST-&gt;right)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=FindMin(BST-&gt;right);</span><br><span class=\"line\">\t\t\tBST-&gt;data=tmp-&gt;data;</span><br><span class=\"line\">\t\t\tBST-&gt;right=delete(BST-&gt;data,BST-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=BST;</span><br><span class=\"line\">\t\t\tif(!BST-&gt;left)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\t\telse if(!BST-&gt;right)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\t\tdelete tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"平衡二叉树-AVL树-Balanced-Binary-Tree\"><a href=\"#平衡二叉树-AVL树-Balanced-Binary-Tree\" class=\"headerlink\" title=\"平衡二叉树 AVL树 (Balanced Binary Tree)\"></a>平衡二叉树 AVL树 (Balanced Binary Tree)</h1><p>定义：<br>空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|&lt;=1</p>\n<p><strong>平衡因子（BF:Balance Factor）</strong>: BF(T)=Hl - Hr<br>Hl和Hr分别为T的左右子树的高度</p>\n<p>推算高度为h的平衡二叉树最少结点数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高度为1时 h(1)=1;</span><br><span class=\"line\">高度为2时 h(2)=2;</span><br><span class=\"line\">高度为3时 h(3)=h(1)+h(2)+1=4;</span><br><span class=\"line\">...</span><br><span class=\"line\">高度为n时 h(n)=h(n-1)+h(n-2)+1;</span><br><span class=\"line\">原因：</span><br><span class=\"line\">    &gt; 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值&lt;=1</span><br><span class=\"line\">    &gt; 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )</span><br><span class=\"line\">由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$</span><br></pre></td></tr></table></figure>\n<p>结点数为n的平衡二叉树的最大高度为O(logn)</p>\n<h2 id=\"平衡二叉树的调整\"><a href=\"#平衡二叉树的调整\" class=\"headerlink\" title=\"平衡二叉树的调整\"></a>平衡二叉树的调整</h2><p><strong>核心思想：选择中间值作为根结点</strong></p>\n<p><strong>RR插入</strong>：插入结点在右子树的右边，需要RR旋转（右单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树根结点 &lt; 右子树的右边</p>\n<p>因此选取右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LL插入</strong>：插入结点在左子树的左边，需要LL旋转（左单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的左边 &lt; 左子树根结点 &lt; 根结点</p>\n<p>因此选取左子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LR插入</strong>：插入结点在左子树的右边，需要LR旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的根结点 &lt; 左子树的右边 &lt; 根结点</p>\n<p>因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>RL插入</strong>：插入结点在右子树的左边，需要RL旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树的左边 &lt; 右子树的根结点</p>\n<p>因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点</p>\n<h1 id=\"堆-heap\"><a href=\"#堆-heap\" class=\"headerlink\" title=\"堆 heap\"></a>堆 heap</h1><h2 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><strong>优先队列( Priority Queue )</strong><br>特殊的队列，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>的大小，而不是元素进入队列的先后顺序</p>\n<p>堆的特性：<br><strong>结构性</strong>：用数组表示的完全二叉树<br><strong>有序性</strong>：任一结点的关键字是其子树所有结点的最大值（或最小值）<br>从根结点到任意结点路径上结点序列的有序性<br>最大堆（MaxHeap）：根结点为最大值<br>最小堆（MinHeap）：根结点为最小值</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>数据对象集：完全二叉树</p>\n<p>接口：<br>MaxHeap Create( int Maxsize );<br>创建一个空的最大堆<br>Boolean IsFull( MaxHeap H );<br>判断最大堆H是否满<br>void Insert( MaxHeap H , T data );<br>将data插入最大堆H<br>Boolean IsEmpty( MaxHeap H );<br>判断最大堆H是否为空<br>T DeleteMax( MaxHeap H );<br>返回H中最大元素（高优先级）</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>思路：</p>\n<blockquote>\n<p>将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Insert( Heap&lt;T&gt;* h, T item)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tif( IsFull(h) ) // 若堆已满，则不做插入操作</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\ti = ++h-&gt;size;</span><br><span class=\"line\">\tfor( ; h-&gt;data[i/2]&lt;item ; i/=2 )</span><br><span class=\"line\">\t\th-&gt;data[i] = h-&gt;data[i/2];</span><br><span class=\"line\">\th-&gt;data[i] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>思路：</p>\n<blockquote>\n<p>取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Delete( Heap&lt;T&gt;* h , T item )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint parent , child;</span><br><span class=\"line\">\tT maxn,tem;</span><br><span class=\"line\">\tif( IsEmpty(h) ) </span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tmaxn = h-&gt;data[1];</span><br><span class=\"line\">\ttem = h-&gt;data[h-&gt;size--];</span><br><span class=\"line\">\tfor( parent=1 ; parent*2&lt;= h-&gt;size ; parent = child )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tchild = parent *2;</span><br><span class=\"line\">\t\tif( child != h-&gt;size  &amp;&amp; h-&gt;data[child]&lt;h.data[child+1])</span><br><span class=\"line\">\t\t\tchild++;   // 寻找左右孩子中较大的那个</span><br><span class=\"line\">\t\tif( tem&gt;= h-&gt;data[child] ) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\th-&gt;data[parent] = h-&gt;data[child];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\th-&gt;data[parent]=tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建立最大堆\"><a href=\"#建立最大堆\" class=\"headerlink\" title=\"建立最大堆\"></a>建立最大堆</h3><p>将已经存在的N个元素按最大堆的要求存放在一个一维数组</p>\n<p>方法1：<br>通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)</p>\n<p>方法2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. n个元素按输入顺序存入，先满足完全二叉树</span><br><span class=\"line\">2. 调整各结点位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><p>自底向上调整</p>\n<p>从倒数第二行的结点开始自右向左调整</p>\n<p>而后再到倒数第三行、倒数第四行…直到根结点</p>\n<p>这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可</p>\n<p>这样就只需要O(n)的时间即可完成建堆</p>\n<h1 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h1><p>带权路径长度（WPL）<br>设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk</p>\n<p>哈夫曼树（最优二叉树）：WPL值最小的二叉树</p>\n<h2 id=\"哈夫曼树的构造\"><a href=\"#哈夫曼树的构造\" class=\"headerlink\" title=\"哈夫曼树的构造\"></a>哈夫曼树的构造</h2><p>每次把<strong>权值最小</strong>的两棵二叉树合并</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 没有度为1的结点</span><br><span class=\"line\">2. n个叶子结点的哈夫曼树有2n-1个结点</span><br><span class=\"line\">    设 n0: 叶子结点总数</span><br><span class=\"line\">    设 n1: 只有一个儿子的结点总数</span><br><span class=\"line\">    设 n2: 有2个儿子的结点总数</span><br><span class=\"line\">    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1</span><br><span class=\"line\">3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树</span><br><span class=\"line\">4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）</span><br></pre></td></tr></table></figure>\n<h2 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少</span><br><span class=\"line\"></span><br><span class=\"line\">避免二义性：</span><br><span class=\"line\">    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</span><br><span class=\"line\"></span><br><span class=\"line\">利用二叉树进行编码：</span><br><span class=\"line\">    1. 左右分支：0、1</span><br><span class=\"line\">    2. 字符只在叶结点上</span><br><span class=\"line\"></span><br><span class=\"line\">构造方法：根据字符的权值构造哈夫曼树</span><br></pre></td></tr></table></figure>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">集合运算：交、并、补、差、判定一个元素是否属于某个集合</span><br><span class=\"line\">并查集：集合并、查某元素属于什么集合</span><br><span class=\"line\">并查集实现：</span><br><span class=\"line\">    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）</span><br><span class=\"line\">    2. 利用数组存储，两个一维数组分别存储数据和父亲下标</span><br></pre></td></tr></table></figure>\n<p>利用数组存储的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint parent;</span><br><span class=\"line\">\tNode( T d , int parent = -1 ):data(d)&#123;&#125;</span><br><span class=\"line\">\tNode()&#123;parent=-1;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标</p>\n<h2 id=\"查找当前结点所属集合\"><a href=\"#查找当前结点所属集合\" class=\"headerlink\" title=\"查找当前结点所属集合\"></a>查找当前结点所属集合</h2><p>思路：<br>首先在数组中找到目标结点<br>而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );   // 在数组中寻找值为x的结点</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;    // 没找到，返回-1</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );  // 顺着父结点指针一路向上找</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>通过<strong>路径压缩</strong>，每次查找时把沿途所有节点的parent都设为根节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;</span><br><span class=\"line\">\tint tem=i,tem1=s[tem].parent;</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );</span><br><span class=\"line\">\twhile( tem1!=-1 &amp;&amp; tem1!=i )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts[tem].parent = i;</span><br><span class=\"line\">\t\ttem=tem1;</span><br><span class=\"line\">\t\ttem1=s[tem].parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合的并运算\"><a href=\"#集合的并运算\" class=\"headerlink\" title=\"集合的并运算\"></a>集合的并运算</h2><p>思路：<br>首先分别找到两个元素所在的集合树的根结点<br>若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t\ts[root2].parent = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>为了改善合并后的查找效率，把小的集合并入大的集合<br>方法1：每个结点额外维护一个值：以该结点为根的结点总数<br>缺点：只有根节点才需要用到该值，造成大量空间浪费<br>方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union1( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s[root1].parent&lt;s[root2].parent )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root1].parent += s[root2].parent;</span><br><span class=\"line\">\t\t\ts[root2].parent = root1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root2].parent += s[root1].parent;</span><br><span class=\"line\">\t\t\ts[root1].parent = root2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a><strong>树</strong></h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h2><h3 id=\"出现原因：\"><a href=\"#出现原因：\" class=\"headerlink\" title=\"出现原因：\"></a>出现原因：</h3><p>向量在静态操作速度快O(1)，在动态操作速度慢O(n)<br>列表在静态操作速度慢O(n)，在动态操作速度快O(1)<br>树结合了两者的优点，可看作是一种<strong>半线性的结构</strong><br>应用：组织层次关系，如文件系统、学院层级关系等</p>","more":"<h3 id=\"树的分类：\"><a href=\"#树的分类：\" class=\"headerlink\" title=\"树的分类：\"></a>树的分类：</h3><p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170820/B1l8I45KkG.png?imageslim\" alt=\"树的分类\"></p>\n<h3 id=\"概念1-有根树rooted-tree\"><a href=\"#概念1-有根树rooted-tree\" class=\"headerlink\" title=\"概念1. 有根树rooted tree\"></a>概念1. 有根树rooted tree</h3><p>指定任一结点为根<br>可以为一系列有根树指定一个结点并连接所有有根树，从而形成一棵更大的有根树，此时各有根树称为子树</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/5hgCeKb8ed.jpg?imageslim\" alt=\"子树\"></p>\n<p>ri 为r的孩子( child )， ri之间互为兄弟( sibling )<br>r为父亲( parent ),<br>d=degree(r)为r的度=一结点拥有的孩子的数目<br>任何一棵树中边数e和结点数目n同阶</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CB0aKme08c.jpg?imageslim\" alt=\"边数和结点数同阶\"></p>\n<h3 id=\"概念2-有序树\"><a href=\"#概念2-有序树\" class=\"headerlink\" title=\"概念2. 有序树\"></a>概念2. 有序树</h3><p>指定Ti为T的第i棵子树，ri为r的第i个孩子</p>\n<p>即是：兄弟之间有明显<strong>次序</strong></p>\n<h3 id=\"概念3-连通性和无环性：\"><a href=\"#概念3-连通性和无环性：\" class=\"headerlink\" title=\"概念3. 连通性和无环性：\"></a>概念3. 连通性和无环性：</h3><p>任何两结点之间都有路径，则称为<strong>连通图</strong>（connected）<br>不含环路则称为<strong>无环图</strong>（acyclic）</p>\n<p>树的特点：</p>\n<blockquote>\n<p>1 .无环连通图：在无环性和连通性之间平衡<br>2 .极小连通图：在连通的情况下边数尽可能少<br>3 .极大无环图：在无环的情况下边数尽可能多</p>\n</blockquote>\n<p>结论： 任何结点和根之间存在<strong>唯一一条</strong>路径<br>即 $path(v,r)=path(v)$<br>我们用一个指标 <strong>深度( depth )</strong> 记录下每个结点到根的距离<br>path(v)上的结点均为v的<strong>祖先</strong>( ancestor )<br>v是它们的<strong>后代</strong> ( descendent )<br>对于v而言，若<strong>祖先存在，则必定唯一</strong>。若<strong>后代存在，却未必唯一</strong>，因此是半线性结构。<br>而对于图而言，祖先和后代都未必唯一，因此图为非线性结构<br><strong>叶子结点</strong>（leaf）：没有后代的结点</p>\n<p>叶子深度最大的称为<strong>树的高度</strong><br><strong>深度</strong>是<strong>结点v到总树根结点r</strong>的距离<br>即height（v）=max( height (v_son) ) +1<br>结点v的<strong>高度</strong>为<strong>以结点v为根结点</strong>的子树的高度<br>即 height（v）=height（subtree（v））<br>约定俗成：空树的高度取作<strong>-1</strong>，一个结点的树高度取作<strong>0</strong><br>对于任一结点：depth（v）+height（v）&lt;=height(T)<br>（高度向下看，深度向上看）<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Lgcj768L1E.png?imageslim\" alt=\"树的深度和高度\"></p>\n<h2 id=\"表示\"><a href=\"#表示\" class=\"headerlink\" title=\"表示\"></a><strong>表示</strong></h2><h3 id=\"1-接口\"><a href=\"#1-接口\" class=\"headerlink\" title=\"1. 接口\"></a>1. 接口</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>结点</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>node*</td>\n<td>root()</td>\n<td>根结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>parent()</td>\n<td>父结点</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>firstchild()</td>\n<td>长子</td>\n</tr>\n<tr>\n<td>node*</td>\n<td>nextSibling()</td>\n<td>兄弟</td>\n</tr>\n<tr>\n<td>void</td>\n<td>insert( i,e )</td>\n<td>将e作为第i个孩子插入</td>\n</tr>\n<tr>\n<td>int</td>\n<td>remove(i)</td>\n<td>删除第i个孩子(及其后代)</td>\n</tr>\n<tr>\n<td>void</td>\n<td>traverse</td>\n<td>遍历</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-构造方法\"><a href=\"#2-构造方法\" class=\"headerlink\" title=\"2. 构造方法\"></a>2. 构造方法</h3><p>不妨用数组进行模拟</p>\n<p><strong>长子兄弟法</strong>：</p>\n<p>每个结点除了储存数据外，还额外记录下父亲，长子和下一个兄弟的秩</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint father, child, nextSibling;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node  *tree;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a><strong>二叉树</strong></h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a><strong>概念</strong></h2><p>结点度数<strong>不超过2</strong>（孩子数目&lt;=2）的树</p>\n<p>同一结点的孩子和子树以<strong>左右</strong>区分</p>\n<p>二叉树是一种特殊的树。然而，二叉树却能够描述所有类型的树。</p>\n<p>基于二叉树的概念，我们可以得到下列关系：<br>1.深度为k的结点最多有$2^k$个<br>2.高度为h的二叉树的结点数n满足$h’&lt;’n’&lt;’2^(h+1)$<br>1.当n=h+1时，二叉树退化为一条单链<br>2.当$n=2^(h+1)-1$时，二叉树为满二叉树</p>\n<p>二叉树的宽度涨得非常快，高度为h的满二叉树总共有$2^(h+1)-1$个结点，第h层有$2^h$个结点</p>\n<p>而高度h涨得很慢，与结点n的关系为$h=logn$</p>\n<h2 id=\"真二叉树-Proper-binary-tree\"><a href=\"#真二叉树-Proper-binary-tree\" class=\"headerlink\" title=\"真二叉树(Proper binary tree)\"></a><strong>真二叉树(Proper binary tree)</strong></h2><p>定义：所有结点的度数均为偶数的二叉树。</p>\n<p>很多时候，一棵二叉树每个结点的度数可能在0、1、2中随机分布，为了对后续算法的简洁实现，我们给度数不足2的结点<strong>虚拟地</strong>补上孩子。</p>\n<h2 id=\"完全二叉树-complete-binary-tree\"><a href=\"#完全二叉树-complete-binary-tree\" class=\"headerlink\" title=\"完全二叉树(complete binary tree)\"></a><strong>完全二叉树(complete binary tree)</strong></h2><p>定义：叶结点只出现在<strong>最后两层</strong>，并且最底层的叶结点均在次底层叶结点的<strong>左侧</strong>。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/I01506Gi5h.JPG\" alt=\"完全二叉树\"></p>\n<h2 id=\"满二叉树-full-binary-tree\"><a href=\"#满二叉树-full-binary-tree\" class=\"headerlink\" title=\"满二叉树(full binary tree)\"></a><strong>满二叉树(full binary tree)</strong></h2><p>定义：所有叶结点都在<strong>最后一层</strong>，每层结点都达到饱和。</p>\n<p>特性：<br>1.结点数目n和高度h的关系：$n=2^(h+1)-1$<br>2.叶子结点数=内部结点数+1<br>3.满二叉树是<strong>特殊</strong>的<strong>完全二叉树</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JFcg7DgIHi.JPG\" alt=\"满二叉树\"></p>\n<h2 id=\"用二叉树描述多叉树\"><a href=\"#用二叉树描述多叉树\" class=\"headerlink\" title=\"用二叉树描述多叉树\"></a><strong>用二叉树描述多叉树</strong></h2><p>先上结论：<strong>凡是有根且有序的树，均可以用二叉树实现</strong></p>\n<p>为什么呢？让我们先来将一棵树用上文提及的长子兄弟法表示出来：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/CF0IK1A4aB.JPG\" alt=\"树到二叉树\"></p>\n<p>可以看到，左侧为树，右侧为长子兄弟表示法，在右侧中，竖直方向的是长子侧，而垂直方向的是兄弟侧，若是将长子和兄弟分别看作一个结点的左右子树，形象地说，就是将它提溜一下提起来</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/b7h5KJBHaH.JPG\" alt=\"树到二叉树\"></p>\n<p>这就将一棵树变成了二叉树！</p>\n<p>这也正是为什么研究二叉树就够了，因为它足以代表树这一类型。</p>\n<h2 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a><strong>基本定义</strong></h2><p><strong>结点类的基本定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* lChild,*rChild,*parent;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBinNode() &#123; lChild=rChild=parent= NULL ; height=0; &#125;</span><br><span class=\"line\">\tBinNode( T e , BinNode&lt;T&gt;* pa=NULL , BinNode&lt;T&gt;* lc=NULL, BinNode&lt;T&gt;* rc=NULL)</span><br><span class=\"line\">\t\t:data(e),parent(pa),lChild(lc),rChild(rc) &#123;&#125;</span><br><span class=\"line\">\tint size() const ;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC( T const &amp; e ) //作为左孩子插入</span><br><span class=\"line\">\t&#123; return lChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC( T const &amp; e ) //作为右孩子插入</span><br><span class=\"line\">\t&#123; return rChild=new BinNode(e,this); &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBinNode&lt;T&gt; * succ();   // 中序遍历时的直接后继</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit );  // 子树层级遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit );   // 子树先序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit );    // 子树中序遍历</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit );   // 子树后序遍历</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int BinNode&lt;T&gt;::size()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint s=1;</span><br><span class=\"line\">\tif(lChild)</span><br><span class=\"line\">\t\ts+=lChild-&gt;size();</span><br><span class=\"line\">\tif(rChild)</span><br><span class=\"line\">\t\ts+=rChild-&gt;size();</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了有自己的数据之外，还维护三个指针：父结点地址，左右孩子的地址，还有一个高度数据。此外，结点应维护的其它数据视情况而定。</p>\n<p>size函数中，需要递归调用左右孩子的size，即是沿着树枝向下走，走到底后一路返回。</p>\n<p><strong>树的基础定义：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct BinTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint _size;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* _root;</span><br><span class=\"line\">\tvirtual int updateHeight( BinNode&lt;T&gt;* x); // 更新x结点的高度（用virtual适应不同树对高度的定义）</span><br><span class=\"line\">\tvoid updateHeightAbove( BinNode&lt;T&gt;* x);  // 更新x及x的祖先的高度</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBinTree() &#123;_size=0; _root=NULL;&#125;</span><br><span class=\"line\">\t~BinTree() &#123; remove(_root); &#125;</span><br><span class=\"line\">\tBinTree( T const&amp; e) &#123;_size=1; _root=new BinNode&lt;T&gt; (e);&#125;</span><br><span class=\"line\">\tint size() const &#123;return _size;&#125;</span><br><span class=\"line\">\tbool empty() const &#123;return !_root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * root() const &#123;return _root;&#125;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsRC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造右孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * insertAsLC ( BinNode&lt;T&gt;* x , T const&amp; e );  // 构造左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsLC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为左孩子</span><br><span class=\"line\">\tBinNode&lt;T&gt; * attachAsRC ( BinNode&lt;T&gt;* x , BinTree&lt;T&gt;*&amp; subtree ); // 接入子树作为右孩子</span><br><span class=\"line\">\tint remove( BinNode&lt;T&gt;* x );   // 删除某个结点（及其子树）</span><br><span class=\"line\">\tvoid removeAt( BinNode&lt;T&gt;* x );</span><br><span class=\"line\">\tBinTree&lt;T&gt; * secede( BinNode&lt;T&gt;* x );    // 分离子树，返回子树头</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travLevel( V &amp; visit )  // 层级遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travLevel(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPre( V &amp; visit )  // 先序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPre(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travIn( V &amp; visit )  // 中序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travIn(visit); &#125;</span><br><span class=\"line\">\ttemplate &lt;typename V&gt;</span><br><span class=\"line\">\tvoid travPost( V &amp; visit )   // 后序遍历</span><br><span class=\"line\">\t&#123; _root-&gt;travPost(visit); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a><strong>遍历</strong></h2><p>定义：按照某种次序访问所有的结点，使得所有结点恰好被访问一次</p>\n<p><strong>遍历方式：</strong></p>\n<blockquote>\n<ol>\n<li>先序遍历( preorder )：中-&gt;左-&gt;右</li>\n<li>中序遍历( inorder )：左-&gt;中-&gt;右</li>\n<li>后序遍历( postorder )：左-&gt;右-&gt;中</li>\n<li>层次遍历：自上而下，自左而右</li>\n</ol>\n<p>先序中序后序原则：必定先左后右，根结点访问次序如名字所示</p>\n</blockquote>\n<h3 id=\"1-先序遍历-中-左-右\"><a href=\"#1-先序遍历-中-左-右\" class=\"headerlink\" title=\"1. 先序遍历( 中 左 右 )\"></a><strong>1. 先序遍历( 中 左 右 )</strong></h3><h4 id=\"1-递归版本\"><a href=\"#1-递归版本\" class=\"headerlink\" title=\"1. 递归版本\"></a><strong>1. 递归版本</strong></h4><p>根据先序遍历的定义，我们很容易写出递归版本的遍历函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V为函数模板类  visit是相应的函数对象</span><br><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_R( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvisit(data);</span><br><span class=\"line\">\tif(lChild) lChild-&gt;travPre_R(visit);</span><br><span class=\"line\">\tif(rChild) rChild-&gt;travPre_R(visit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，虽然递归和迭代的实现均是O(n)级的，但是它们在常数级所消耗的时间却不同，递归所要消耗的时间远远大，就如O(1)和O(100)均是O(1)，但还是有100倍的差距一般。</p>\n<p>因此如果能够将<strong>递归版</strong>改成<strong>迭代版</strong>，就能够提高很多效率。</p>\n<h4 id=\"2-迭代版本1\"><a href=\"#2-迭代版本1\" class=\"headerlink\" title=\"2. 迭代版本1\"></a><strong>2. 迭代版本1</strong></h4><p>因为在递归版本中，向左右子树的递归出现在最后，即是<strong>尾递归</strong>，那么我们只需要引入一个<strong>栈</strong>，把左右子树的递归改成将左右子树入栈即可。</p>\n<p>值得注意的是，由于栈的先进后出特性，在递归中我们先递归左子树，在迭代中入栈操作需要<strong>先让右子树入栈，再让左子树入栈</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_V1( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack &lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tif(x) </span><br><span class=\"line\">\t\ts.push(x);</span><br><span class=\"line\">\twhile(!s.empty())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tif(x-&gt;rChild) s.push(x-&gt;rChild); // 先入后出</span><br><span class=\"line\">\t\tif(x-&gt;lChild) s.push(x-&gt;lChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-迭代版本2\"><a href=\"#3-迭代版本2\" class=\"headerlink\" title=\"3. 迭代版本2\"></a><strong>3. 迭代版本2</strong></h4><p>看起来迭代版本1很好地完成了任务。然而，它借助了尾递归的特性却不易推广到中序和后序遍历的版本，由此我们需要回顾整个遍历的过程，通过观察找出规律，用另一种易于推广的方式进行迭代。</p>\n<p>通过对先序遍历过程的观察，我们可以发现，每当指向一个根结点时，在自己被访问后，它会让目光转向自己的左孩子，而左孩子也同样会在被访问后让目光继续转向自己的左孩子。到最后，最小的左孩子无法转让，只好转到它的右孩子-&gt;它父亲的右孩子-&gt;父亲的父亲的右孩子…-&gt;根结点的右孩子。</p>\n<p>于是乎，我们只需要每访问一个根结点时，一边沿着它的左侧链向下走，一边将沿途的右孩子入栈即可，当左孩子访问完后，就取栈中的右孩子访问。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/Jj0H03H434.JPG\" alt=\"左侧链示意图\"></p>\n<p>这样，我们就有了如下算法流程：</p>\n<p>1.访问该结点<br>2.将右孩子入栈<br>3.目光转向它的左孩子<br>若左孩子存在，回到步骤1<br>4.若栈不为空，取出栈顶元素，回到步骤1</p>\n<p>代码实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPre_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\t\tif(x-&gt;rChild) </span><br><span class=\"line\">\t\t\t\ts.push(x-&gt;rChild);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-中序遍历-左-中-右\"><a href=\"#2-中序遍历-左-中-右\" class=\"headerlink\" title=\"2. 中序遍历( 左 中 右 )\"></a><strong>2. 中序遍历( 左 中 右 )</strong></h3><h4 id=\"1-迭代版本1\"><a href=\"#1-迭代版本1\" class=\"headerlink\" title=\"1. 迭代版本1\"></a><strong>1. 迭代版本1</strong></h4><p>先来观察一下中序遍历的流程：</p>\n<p>每当指向一个根结点，它会立刻把目光转向自己的左孩子（自己不先被访问），左孩子也同样转向自己的左孩子。。最后的左孩子无法转让，只好让自己被访问，然后将目光转向自己的右孩子，右孩子访问完后返回自己的父亲结点，这时父亲只能被访问，然后转向它的右孩子。。。</p>\n<p>中序和先序不同在于：<strong>父结点不是立即被访问</strong>，它要等自己的左子树访问完之后才会被访问，那么这一层层传递下来的左侧链，就跟一个个结点入栈一般。没错，在这个过程中，我们需要将根结点一个个入栈。访问完左结点之后，我们就把根取出来访问。</p>\n<p>那右结点怎么办呢？</p>\n<p>右结点在根访问完之后受到关注时，它就是自己子树的根结点了，它同样也要继续左侧链入栈的流程。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170816/amHbf583EI.JPG\" alt=\"中序遍历\"></p>\n<p>算法的流程如下：</p>\n<p>1.将该结点入栈<br>2.转向该结点的左孩子<br>若左孩子存在，返回步骤1<br>3.若栈不为空，取出栈顶元素，访问后，转向它的右孩子<br>若右孩子存在，返回步骤1<br>若右孩子不存在，重新开始步骤3</p>\n<p>现在，我们就可以在观察之后，将先序的迭代2版本沿用到中序遍历中了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ts.push(x);</span><br><span class=\"line\">\t\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(s.empty()) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;rChild;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，中序遍历还有一个特性，由此我们可以得到一个连栈都不需要用到(但时间消耗会上升)的迭代版本</p>\n<h4 id=\"2-迭代版本2\"><a href=\"#2-迭代版本2\" class=\"headerlink\" title=\"2. 迭代版本2\"></a><strong>2. 迭代版本2</strong></h4><p>当把二叉树横向伸展地足够开后，如下图所示<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/JEkGbFc4E4.png?imageslim\" alt=\"中序遍历\"><br>从左向右扫过去，各个结点被访问的次序就是中序遍历的顺序<br>左右规则如下:</p>\n<p>左子树左孩子&gt;左子树根结点&gt;左子树右孩子&gt;根结点&gt;右子树左孩子&gt;右子树根结点&gt;右子树右孩子</p>\n<p>根据这个规则，我们就可以得到每个结点在中序遍历时的<strong>直接后继</strong>，即是在空间上在其右边的第一个结点。(最右边的直接后继为NULL)</p>\n<p>那么要怎么得到这个直接后继呢？<br>显然，如果一个结点有右子树，那么它的直接后继必然在右子树中，只需要沿着右子树的左侧链一直向下到底即可。<br>而要是它没有右子树，就要麻烦一些了，这时我们需要向上找，如果这个结点是它父结点的右孩子，那就还需要继续向上，直到找到一个<strong>结点是它父结点左孩子</strong>的结点，直接后继就是这个结点的父结点。<br>简单来说，这个没有右子树的结点不是最右边的结点，就必然是某棵左子树最右边的结点，它的直接后继自然是这棵左子树的父亲了。</p>\n<p>将上述流程翻译成代码就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; *BinNode&lt;T&gt;::succ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* s=this;</span><br><span class=\"line\">\tif(rChild)   // 若有右孩子</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=rChild;</span><br><span class=\"line\">\t\twhile(s-&gt;lChild)   // 在右子树的左侧链一路到底</span><br><span class=\"line\">\t\t\ts=s-&gt;lChild;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile( s-&gt;parent &amp;&amp; s==s-&gt;parent-&gt;rChild )</span><br><span class=\"line\">\t\t\ts=s-&gt;parent;    // 此时是左子树的根结点</span><br><span class=\"line\">\t\ts=s-&gt;parent;   // 再向上到左子树的父亲结点(也可能是NULL)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了直接后继函数之后，剩下的事情就简单了，我们只需要在最开始找到最左边的结点(左侧链最深的结点),然后把这火车开下去就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travIn_S(  V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\twhile(x-&gt;lChild)</span><br><span class=\"line\">\t\tx=x-&gt;lChild;</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t\tx=x-&gt;succ();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-后序遍历-左-右-中\"><a href=\"#3-后序遍历-左-右-中\" class=\"headerlink\" title=\"3. 后序遍历( 左 右 中 )\"></a><strong>3. 后序遍历( 左 右 中 )</strong></h3><p>基于后序遍历的定义，我们可以导出如下流程：<br>1.先尽可能沿着左走，若是结点实在没有左孩子，只有右孩子，那么向右走一次也行，直到走到叶结点。<br>2.访问结点<br>3.若右兄弟存在，转向右兄弟，返回步骤1<br>4.向上回溯到父结点，返回步骤2，若无父结点，说明已经遍历完毕，退出流程</p>\n<p>可以看到，在向当前结点的左孩子走时，我们需要记录下当前的结点以及它的右孩子（而且右孩子先），左孩子访问完后，取出右孩子遍历并访问，再取出父亲结点访问。由此我们需要一个栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travPost_I( V &amp; visit )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;BinNode&lt;T&gt; *&gt; s;</span><br><span class=\"line\">\tBinNode&lt;T&gt; * x=this;</span><br><span class=\"line\">\ts.push(x);</span><br><span class=\"line\">\tBinNode&lt;T&gt; * c=s.top();</span><br><span class=\"line\">\twhile(1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(s.empty()) break;</span><br><span class=\"line\">\t\tif(s.top()!=x-&gt;parent) // 不是父结点说明是栈顶是右兄弟，需要遍历它的子树</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tc=s.top();</span><br><span class=\"line\">\t\t\twhile(1)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif(c-&gt;rChild) </span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;rChild);</span><br><span class=\"line\">\t\t\t\tif(c-&gt;lChild) </span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\ts.push(c-&gt;lChild);</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;lChild;   // 尽可能向左走</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse if(c-&gt;rChild)  // 如果实在只有右孩子，那就向右</span><br><span class=\"line\">\t\t\t\t\tc=c-&gt;rChild;</span><br><span class=\"line\">\t\t\t\telse  // 左右孩子都没有，走到底了，退出循环</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx=s.pop();</span><br><span class=\"line\">\t\tvisit(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-层次遍历\"><a href=\"#4-层次遍历\" class=\"headerlink\" title=\"4. 层次遍历\"></a><strong>4. 层次遍历</strong></h3><p>层次遍历的规则很简单：自上而下，自左而右</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170817/a6h1hlafBm.jpg?imageslim\" alt=\"层次遍历\"></p>\n<p>对此，我们可以引入<strong>队列</strong>来解决它。</p>\n<p>每当遇到一个结点，我们在访问它后将它的左右孩子(若存在)入栈，然后再取队首元素重复操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; template &lt;typename V&gt;</span><br><span class=\"line\">void BinNode&lt;T&gt;::travLevel( V &amp; e )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueue&lt;BinNode&lt;T&gt;*&gt; q;</span><br><span class=\"line\">\tBinNode&lt;T&gt;* x=this;</span><br><span class=\"line\">\tq.enqueue(x);</span><br><span class=\"line\">\twhile( !q.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx=q.dequeue();</span><br><span class=\"line\">\t\tif(x-&gt;lChild)  q.enqueue(x-&gt;lChild);</span><br><span class=\"line\">\t\tif(x-&gt;rChild)  q.enqueue(x-&gt;rChild);</span><br><span class=\"line\">\t\te(x-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a><strong>重构</strong></h2><p>如果我们已经有了按某种方式遍历出的序列，那么如何通过序列重新构造出原本的二叉树？</p>\n<h3 id=\"一-中序-先序-后序\"><a href=\"#一-中序-先序-后序\" class=\"headerlink\" title=\"一. 中序+(先序|后序)\"></a><strong>一. 中序+(先序|后序)</strong></h3><p>结论一：我们只需要 中序+(先序|后序)，即是中序遍历的序列加上先序或后序的任一序列即可构造出原本的二叉树。</p>\n<p>现在我们来用数学归纳法证明一下：<br>假设结论在结点数n’&lt;’N的情况下都成立<br>在n==N时<br>先假设我们有先序和中序遍历的序列，根结点为r，左右子树分别为L和R。<br>那么在先序遍历和中序遍历中分别如下图所示：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/Hci6Ijk2bg.JPG\" alt=\"重构二叉树\"></p>\n<p>可以看到，我们可以根据r来成功划分L和R序列，在中序遍历的序列中我们可以知道左右子树分别有哪些结点，进而在先序的序列中将它们划分开。<br>这时就形成了已知两棵子树的先序和中序遍历的序列来重构二叉树了，而因为结点数在n’&lt;’N的左右子树中结论均成立，由此n==N时结论也成立。</p>\n<p>而有后续和中序遍历的序列的证明也同理可得了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先序+中序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PI( T* pre, T* ins, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_PI(pre,ins,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PI( T* pre, T* ins, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(pre); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PI( pre+1, ins, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PI( pre+1+i, ins+i+1, len-i-1 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 中序+后序重构</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_IP( T* ins, T* post, int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=rebuildSub_IP(ins,post,len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_IP( T* ins, T* post, int len ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif(len&lt;=0) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(* (post+len-1) );</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(ins+i)!=*(post+len-1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*(post+len-1));</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_IP( ins, post, i );</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_IP( ins+1+i, post+i, len-i-2 );</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-先序-后序-真二叉树\"><a href=\"#二-先序-后序-真二叉树\" class=\"headerlink\" title=\"二. (先序+后序)*真二叉树\"></a><strong>二. (先序+后序)*真二叉树</strong></h3><p>结论二：在只有先序和后序序列时，若是该二叉树是一棵<strong>真二叉树</strong>(所有结点的度数都是偶数),那么也可以构造出原本的二叉树来。</p>\n<p>那么要怎么做呢？</p>\n<p>在先序遍历中，若根结点有孩子，则必定左右都有。那么这个序列第一个必然是根结点，而第二个必然是左子树的根。<br>在后序遍历中，序列的最后必然是根，倒数第二个是右子树的根。<br>这样我们就知道了左右子树根结点是什么样的，进而可以完整分割出左右子树分别在先序和后序遍历的序列。而在这之后，不过是问题规模缩小的两个 (先序+后序)*真二叉树问题罢了。<br><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170815/C89dHdbAkF.JPG\" alt=\"重构二叉树\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void BinTree&lt;T&gt;::rebuild_PP( T *pre,T *post,int len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t_root=new BinNode&lt;T&gt; (pre[0]);</span><br><span class=\"line\">\trebuildSub_PP( _root,pre,post,len );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BinNode&lt;T&gt; * rebuildSub_PP( T *pre , T *post, int len )</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tBinNode&lt;T&gt; *s=NULL;</span><br><span class=\"line\">\tif( len&lt;=0 ) return s;</span><br><span class=\"line\">\tif(len==1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor(i=0; *(post+i)!=*(pre+1); i++);</span><br><span class=\"line\">\ts=new BinNode&lt;T&gt;(*pre);</span><br><span class=\"line\">\ts-&gt;lChild=rebuildSub_PP(pre+1,post,i+1);</span><br><span class=\"line\">\ts-&gt;rChild=rebuildSub_PP(pre+i+2,post+i+1,len-i-2);</span><br><span class=\"line\">\treturn s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/tree/binary%20tree.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的完整实现 ( 附带遍历和重构 )</a></p>\n<h1 id=\"二叉搜索树BST-Binary-Search-Tree\"><a href=\"#二叉搜索树BST-Binary-Search-Tree\" class=\"headerlink\" title=\"二叉搜索树BST ( Binary Search Tree )\"></a>二叉搜索树BST ( Binary Search Tree )</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"循关键码访问-call-by-key\"><a href=\"#循关键码访问-call-by-key\" class=\"headerlink\" title=\"循关键码访问 call-by-key\"></a>循关键码访问 call-by-key</h3><p>数据项之间，依照各自的关键码(key)彼此区分</p>\n<p>条件：关键码之间支持<strong>大小比较</strong>和<strong>相等比对</strong></p>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>二叉搜索树（又叫二叉排序树或二叉查找树），是一棵二叉树，可以为空，若不为空，则满足：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 非空左子树所有键值小于根结点的键值</span><br><span class=\"line\">2. 非空右子树所有键值大于根结点的键值</span><br><span class=\"line\">3. 左右子树都是二叉搜索树</span><br></pre></td></tr></table></figure>\n<p>基本框架：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct TreeNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * left;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; * right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. BinTree Find( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找元素x,返回所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. BinTree FindMin(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最小元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. BinTree FindMax(BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中查找并返回最大元素所在结点的地址</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4. BinTree Insert( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将元素x插入BST中，返回插入后的BST</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5. BinTree Delete( T x , BinTree BST);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从BST中删除元素x</p>\n</blockquote>\n<h3 id=\"查找操作：-Find\"><a href=\"#查找操作：-Find\" class=\"headerlink\" title=\"查找操作： Find\"></a>查找操作： Find</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 查找从根结点开始，若树为空则返回NULL</span><br><span class=\"line\">- 若树非空，则将根结点键值和x比较：</span><br><span class=\"line\">    - 若 x &lt; root.data ，在左子树中搜索</span><br><span class=\"line\">    - 若 x &gt; root.data ，在右子树中搜索</span><br><span class=\"line\">    - 若两者相等，则返回指向该结点的指针</span><br><span class=\"line\">- 实现方式可以采用递归或迭代，因为是尾递归，因此很容易将递归形式改造成迭代形式</span><br><span class=\"line\">- 当树退化成链时，查找效率退为O(n)，因此最好组织成**平衡二叉树**</span><br></pre></td></tr></table></figure>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Find(T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile(BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\treturn BST;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找最大和最小元素\"><a href=\"#查找最大和最小元素\" class=\"headerlink\" title=\"查找最大和最小元素\"></a>查找最大和最小元素</h3><p>根据二叉搜索树的性质：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 最大元素一定在树的最右分支的端结点上</span><br><span class=\"line\">- 最小元素一定在树的最左分支的端结点上</span><br></pre></td></tr></table></figure>\n<p>同样的，查找最大最小元素也可以用递归和迭代的形式实现，鉴于递归同样也是尾递归，因此可以轻松地转化成迭代的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMax( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;right)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * FindMin( TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(BST)</span><br><span class=\"line\">\t\twhile(BST-&gt;left)</span><br><span class=\"line\">\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h3><p>关键：要找到元素应该插入的位置，可以采用和Find类似的方法</p>\n<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Insert( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(!BST)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tBST = new TreeNode&lt;T&gt;();</span><br><span class=\"line\">\t\tBST-&gt;data=x;</span><br><span class=\"line\">\t\tBST-&gt;left=BST-&gt;right=NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;left=Insert(x,BST-&gt;left);</span><br><span class=\"line\">\t\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\t\tBST-&gt;right=Insert(x,BST-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h3><p>考虑情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 删除的是叶结点，则直接删除结点并将父结点指向该结点的指针修改为NULL</span><br><span class=\"line\">2. 要删除的结点只有一个孩子，则将父结点指向该结点的指针指向要删除结点的孩子</span><br><span class=\"line\">3. 要删除的结点有左右两棵子树</span><br><span class=\"line\">    用另一结点代替被删除结点：左子树最大元素或右子树最小元素</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">TreeNode&lt;T&gt; * Delete( T x , TreeNode&lt;T&gt; * BST)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTreeNode&lt;T&gt; *tmp;</span><br><span class=\"line\">\tif(!BST) return NULL;</span><br><span class=\"line\">\telse if(x&lt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;left=Delete(x,BST-&gt;left);</span><br><span class=\"line\">\telse if(x&gt;BST-&gt;data)</span><br><span class=\"line\">\t\tBST-&gt;right=Delete(x,BST-&gt;right);</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(BST-&gt;left &amp;&amp; BST-&gt;right)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=FindMin(BST-&gt;right);</span><br><span class=\"line\">\t\t\tBST-&gt;data=tmp-&gt;data;</span><br><span class=\"line\">\t\t\tBST-&gt;right=delete(BST-&gt;data,BST-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp=BST;</span><br><span class=\"line\">\t\t\tif(!BST-&gt;left)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;right;</span><br><span class=\"line\">\t\t\telse if(!BST-&gt;right)</span><br><span class=\"line\">\t\t\t\tBST=BST-&gt;left;</span><br><span class=\"line\">\t\t\tdelete tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"平衡二叉树-AVL树-Balanced-Binary-Tree\"><a href=\"#平衡二叉树-AVL树-Balanced-Binary-Tree\" class=\"headerlink\" title=\"平衡二叉树 AVL树 (Balanced Binary Tree)\"></a>平衡二叉树 AVL树 (Balanced Binary Tree)</h1><p>定义：<br>空树，或者任一结点左右子树高度差绝对值不超过1，即 |BF(T)|&lt;=1</p>\n<p><strong>平衡因子（BF:Balance Factor）</strong>: BF(T)=Hl - Hr<br>Hl和Hr分别为T的左右子树的高度</p>\n<p>推算高度为h的平衡二叉树最少结点数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高度为1时 h(1)=1;</span><br><span class=\"line\">高度为2时 h(2)=2;</span><br><span class=\"line\">高度为3时 h(3)=h(1)+h(2)+1=4;</span><br><span class=\"line\">...</span><br><span class=\"line\">高度为n时 h(n)=h(n-1)+h(n-2)+1;</span><br><span class=\"line\">原因：</span><br><span class=\"line\">    &gt; 一个平衡二叉树的左右子树均是平衡二叉树，并且左右子树的高度差的绝对值&lt;=1</span><br><span class=\"line\">    &gt; 因此一棵高度为n的平衡二叉树可以由两棵高度为n-1的平衡二叉树构成或是一棵n-1+一棵n-2（不然不符合高度差的规则），又因为需要最少结点数，因此选择n-1 + n-2的组合，即高度为n的平衡二叉树的结点数 h(n)=h(n-1)+h(n-2)+1 ( 1是根结点本身 )</span><br><span class=\"line\">由此得到结论：高度为h的平衡二叉树的最少结点数为 $$ h(n) = h(n-1) + h(n-2) + 1 $$</span><br></pre></td></tr></table></figure>\n<p>结点数为n的平衡二叉树的最大高度为O(logn)</p>\n<h2 id=\"平衡二叉树的调整\"><a href=\"#平衡二叉树的调整\" class=\"headerlink\" title=\"平衡二叉树的调整\"></a>平衡二叉树的调整</h2><p><strong>核心思想：选择中间值作为根结点</strong></p>\n<p><strong>RR插入</strong>：插入结点在右子树的右边，需要RR旋转（右单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/dlLJlGI0dh.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树根结点 &lt; 右子树的右边</p>\n<p>因此选取右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LL插入</strong>：插入结点在左子树的左边，需要LL旋转（左单旋）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/57fehe3J04.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的左边 &lt; 左子树根结点 &lt; 根结点</p>\n<p>因此选取左子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>LR插入</strong>：插入结点在左子树的右边，需要LR旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/E1l83GHjKg.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 左子树的根结点 &lt; 左子树的右边 &lt; 根结点</p>\n<p>因此选取左子树的右子树的根结点作为新的平衡二叉树的根结点</p>\n<p><strong>RL插入</strong>：插入结点在右子树的左边，需要RL旋转</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/image/170915/FEGfD0A16g.JPG\" alt=\"mark\"></p>\n<p>大小关系为： 根结点 &lt; 右子树的左边 &lt; 右子树的根结点</p>\n<p>因此选取右子树的左子树的根结点作为新的平衡二叉树的根结点</p>\n<h1 id=\"堆-heap\"><a href=\"#堆-heap\" class=\"headerlink\" title=\"堆 heap\"></a>堆 heap</h1><h2 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><strong>优先队列( Priority Queue )</strong><br>特殊的队列，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>的大小，而不是元素进入队列的先后顺序</p>\n<p>堆的特性：<br><strong>结构性</strong>：用数组表示的完全二叉树<br><strong>有序性</strong>：任一结点的关键字是其子树所有结点的最大值（或最小值）<br>从根结点到任意结点路径上结点序列的有序性<br>最大堆（MaxHeap）：根结点为最大值<br>最小堆（MinHeap）：根结点为最小值</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>数据对象集：完全二叉树</p>\n<p>接口：<br>MaxHeap Create( int Maxsize );<br>创建一个空的最大堆<br>Boolean IsFull( MaxHeap H );<br>判断最大堆H是否满<br>void Insert( MaxHeap H , T data );<br>将data插入最大堆H<br>Boolean IsEmpty( MaxHeap H );<br>判断最大堆H是否为空<br>T DeleteMax( MaxHeap H );<br>返回H中最大元素（高优先级）</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p>思路：</p>\n<blockquote>\n<p>将元素插入到数组最后，而后不断与其父结点进行比较，若新元素大于父结点，则与父结点互换，直至到根结点</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Insert( Heap&lt;T&gt;* h, T item)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tif( IsFull(h) ) // 若堆已满，则不做插入操作</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\ti = ++h-&gt;size;</span><br><span class=\"line\">\tfor( ; h-&gt;data[i/2]&lt;item ; i/=2 )</span><br><span class=\"line\">\t\th-&gt;data[i] = h-&gt;data[i/2];</span><br><span class=\"line\">\th-&gt;data[i] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>思路：</p>\n<blockquote>\n<p>取出根结点元素后，将最后一个结点移至根结点，而后不断与左右结点进行比较及互换，最后完成删除操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Delete( Heap&lt;T&gt;* h , T item )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint parent , child;</span><br><span class=\"line\">\tT maxn,tem;</span><br><span class=\"line\">\tif( IsEmpty(h) ) </span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tmaxn = h-&gt;data[1];</span><br><span class=\"line\">\ttem = h-&gt;data[h-&gt;size--];</span><br><span class=\"line\">\tfor( parent=1 ; parent*2&lt;= h-&gt;size ; parent = child )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tchild = parent *2;</span><br><span class=\"line\">\t\tif( child != h-&gt;size  &amp;&amp; h-&gt;data[child]&lt;h.data[child+1])</span><br><span class=\"line\">\t\t\tchild++;   // 寻找左右孩子中较大的那个</span><br><span class=\"line\">\t\tif( tem&gt;= h-&gt;data[child] ) </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\th-&gt;data[parent] = h-&gt;data[child];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\th-&gt;data[parent]=tem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"建立最大堆\"><a href=\"#建立最大堆\" class=\"headerlink\" title=\"建立最大堆\"></a>建立最大堆</h3><p>将已经存在的N个元素按最大堆的要求存放在一个一维数组</p>\n<p>方法1：<br>通过Insert函数把n个元素一个个插入堆中，时间代价为O(nlogn)</p>\n<p>方法2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. n个元素按输入顺序存入，先满足完全二叉树</span><br><span class=\"line\">2. 调整各结点位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><p>自底向上调整</p>\n<p>从倒数第二行的结点开始自右向左调整</p>\n<p>而后再到倒数第三行、倒数第四行…直到根结点</p>\n<p>这样每个结点在调整时它的左右均是堆，如同删除操作中那样不断比较即可</p>\n<p>这样就只需要O(n)的时间即可完成建堆</p>\n<h1 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h1><p>带权路径长度（WPL）<br>设二叉树有n个叶子结点，每个叶子结点带有权值wk,从根结点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 WPL = $ \\sum $ wk*lk</p>\n<p>哈夫曼树（最优二叉树）：WPL值最小的二叉树</p>\n<h2 id=\"哈夫曼树的构造\"><a href=\"#哈夫曼树的构造\" class=\"headerlink\" title=\"哈夫曼树的构造\"></a>哈夫曼树的构造</h2><p>每次把<strong>权值最小</strong>的两棵二叉树合并</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 没有度为1的结点</span><br><span class=\"line\">2. n个叶子结点的哈夫曼树有2n-1个结点</span><br><span class=\"line\">    设 n0: 叶子结点总数</span><br><span class=\"line\">    设 n1: 只有一个儿子的结点总数</span><br><span class=\"line\">    设 n2: 有2个儿子的结点总数</span><br><span class=\"line\">    则 n2=n0-1, 因为不存在只有一个儿子的结点，因此总结点数 n0+n2=2n0-1</span><br><span class=\"line\">3. 哈夫曼树任意非叶结点的左右子树交换后仍然是哈夫曼树</span><br><span class=\"line\">4. 对同一组权值，存在不同构的两棵哈夫曼树 （但WPL值一样）</span><br></pre></td></tr></table></figure>\n<h2 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一段字符串，对字符进行编码，使得该字符串编码的存储空间最少</span><br><span class=\"line\"></span><br><span class=\"line\">避免二义性：</span><br><span class=\"line\">    使用前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</span><br><span class=\"line\"></span><br><span class=\"line\">利用二叉树进行编码：</span><br><span class=\"line\">    1. 左右分支：0、1</span><br><span class=\"line\">    2. 字符只在叶结点上</span><br><span class=\"line\"></span><br><span class=\"line\">构造方法：根据字符的权值构造哈夫曼树</span><br></pre></td></tr></table></figure>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">集合运算：交、并、补、差、判定一个元素是否属于某个集合</span><br><span class=\"line\">并查集：集合并、查某元素属于什么集合</span><br><span class=\"line\">并查集实现：</span><br><span class=\"line\">    1. 利用树结构表示集合，每个结点代表一个集合元素（双亲表示法）</span><br><span class=\"line\">    2. 利用数组存储，两个一维数组分别存储数据和父亲下标</span><br></pre></td></tr></table></figure>\n<p>利用数组存储的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT data;</span><br><span class=\"line\">\tint parent;</span><br><span class=\"line\">\tNode( T d , int parent = -1 ):data(d)&#123;&#125;</span><br><span class=\"line\">\tNode()&#123;parent=-1;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个结点除了维护自己的数据外，还额外维护了父结点在数组中的下标</p>\n<h2 id=\"查找当前结点所属集合\"><a href=\"#查找当前结点所属集合\" class=\"headerlink\" title=\"查找当前结点所属集合\"></a>查找当前结点所属集合</h2><p>思路：<br>首先在数组中找到目标结点<br>而后顺着父结点下标这条链一直向上直到找到某个没有父结点的结点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );   // 在数组中寻找值为x的结点</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;    // 没找到，返回-1</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );  // 顺着父结点指针一路向上找</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>通过<strong>路径压缩</strong>，每次查找时把沿途所有节点的parent都设为根节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Find( Node&lt;T&gt;* s , T x )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* 在s中查找值为x的元素所属的集合 */</span><br><span class=\"line\">\t/* Maxsize为全局变量，s的最大长度 */</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tfor( i=0; i&lt;MaxSize&amp;&amp; s[i].data!=x; i++ );</span><br><span class=\"line\">\tif( i&gt;=MaxSize ) return -1;</span><br><span class=\"line\">\tint tem=i,tem1=s[tem].parent;</span><br><span class=\"line\">\tfor( ; s[i].parent&gt;=0; i=s[i].parent );</span><br><span class=\"line\">\twhile( tem1!=-1 &amp;&amp; tem1!=i )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts[tem].parent = i;</span><br><span class=\"line\">\t\ttem=tem1;</span><br><span class=\"line\">\t\ttem1=s[tem].parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合的并运算\"><a href=\"#集合的并运算\" class=\"headerlink\" title=\"集合的并运算\"></a>集合的并运算</h2><p>思路：<br>首先分别找到两个元素所在的集合树的根结点<br>若根结点不同，则把其中一个根结点的父结点指针设置成另一个根结点数组下标</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t\ts[root2].parent = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：<br>为了改善合并后的查找效率，把小的集合并入大的集合<br>方法1：每个结点额外维护一个值：以该结点为根的结点总数<br>缺点：只有根节点才需要用到该值，造成大量空间浪费<br>方法2：已知根节点的parent为-1，那么我们可以用负数来代表节点总数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Union1( Node&lt;T&gt;* s, T x1 , T x2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint root1,root2;</span><br><span class=\"line\">\troot1=Find(s,x1);</span><br><span class=\"line\">\troot2=Find(s,x2);</span><br><span class=\"line\">\tif(root1!=root2)</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s[root1].parent&lt;s[root2].parent )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root1].parent += s[root2].parent;</span><br><span class=\"line\">\t\t\ts[root2].parent = root1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\ts[root2].parent += s[root1].parent;</span><br><span class=\"line\">\t\t\ts[root1].parent = root2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"复现Entropy-based Term Weighting Schemes for Text Categorization in VSM小结","date":"2018-05-31T16:00:00.000Z","comments":1,"_content":"\n\n论文 [Entropy-based Term Weighting Schemes for Text Categorization in VSM](https://ieeexplore.ieee.org/document/7372153/) 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。\n\n在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。\n\n复现基于python2.7，KNN使用[sklearn](http://scikit-learn.org/)包，SVM和原论文同样使用[liblinear](https://www.csie.ntu.edu.tw/~cjlin/liblinear/)，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。\n\n<!-- more -->\n\n## 理论介绍\n\n### VSM向量空间模型\n\n在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：\n\n假设词汇表有  ['one', 'apple','a','day','an'], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率\n\n文章a = \"one day\". 那么 它的向量则是 [1,0,0,1,0]\n\n文章b = \"an apple\"， 则代表b的向量是[0,1,0,0,1]\n\none hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出**一个词的辨别能力**。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 \"算法\" 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。\n\n就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。\n\n由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。\n\n### 旧方法\n\n为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：\n\n大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：\n\n1. PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。\n2. NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了\n3. 计算权重得基于标签，但测试文档本身就不具备标签\n\n对于非监督的计算方法，就拿tf-idf来说，其能力在于**将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来**。\n\n文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。\n\n#### tf·idf\n\n作为最流行的权重计算方法，其计算方法分为两个部分\n\n一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n_{i,j}}{\\sum_{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可\n\n另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一\n\n最终的 tf-idf就等于两者相乘。\n\n#### tf·chi\n\n基于统计的卡方检验和下面一些计算方法都基于以下这个表格：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/abcd.png)\n\nA：类别k中出现了词j的文档数目\n\nB：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可\n\nC：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A\n\nD：其它类别不包含词j的数目，用其它类文档总数 - B\n\n卡方检验的原始公式和近似公式：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png)\n\n#### tf·ig\n\nInformation Gain 信息增益：增加了这个信息使得系统的熵降低了多少。\n\n在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ig.png)\n\nP(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 \n\nP(t)：词语T出现的概率，用出现过T的文档数除以总文档数 \n\nP(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 \n\nP(～t)：词语T不出现的概率，用 1 - P(t) 即可\n\nP(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 \n\n#### tf·eccd\n\n论文 [Entropy based feature selection for text categorization](https://hal.archives-ouvertes.fr/hal-00617969/document) 同样提出了一种基于熵的权重计算方法\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd0.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd1.png)\n\n#### tf·rf\n\n由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/rf.png)\n\n#### iqf·qf·icf\n\n这篇论文  [Term weighting schemes for question categorization](https://www.ncbi.nlm.nih.gov/pubmed/20733219) 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf\\*qf\\*icf、qf\\*icf 和 vrf。\n\n和rf相比，iqf\\*qf\\*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf1.png)\n\n### 新的权重计算方法\n\n#### tf·dc\n\n论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。\n\n思想基于两点：\n\n1. 辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高\n2. 集中程度越高的词，具有的熵越小\n\n![](http://ot1c7ttzm.bkt.clouddn.com/dc.png)\n\nH(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目\n\n由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。\n\n#### tf·bdc\n\n考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。\n\n为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/bdc.png)\n\n## 复现过程\n\n### 用特征权重进行文本分类的思路\n\n文本分类的整个过程如下：\n\n1. 通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：\n   1. 词语权重表\n   2. 词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。\n   3. 模型参数\n2. 对于每篇测试文档：\n   1. 根据词汇表删去无关词汇\n   2. 查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示\n   3. 将文档向量作为特征输入分类模型中，得到预测结果\n\n### 数据处理\n\n语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：[Reuters-21578 R8](http://ana.cachopo.org/datasets-for-single-label-text-categorization)，[TrainingSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0)， [TestSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0) .\n\n获得语料之后，一个比较重要的地方在于制作特征向量和标签。\n\n我的特征向量和标签制作方法是：\n\n1. 对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。\n2. 对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。\n\n### 维度压缩\n\n在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。\n\n解决方法就是删去频率过高和过低的词：\n\n1. 统计训练语料中的词语频率得到词频表和词汇表\n2. 使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考\n3. 根据长度、频率分布挑选阈值，根据上下界删减词汇表\n4. 根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。\n\n通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png)\n\n<center>删减前</center>\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png)\n\n<center>删减后</center>\n\n### KNN中的cos近似\n\n下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条[stackoverflow上的回答](https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier)：\n\n回答分为两个方面：\n\n1. 指出为什么cosine相似度没有在sklearn包中：\n\n   cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。\n\n2. 给出了解决方法：\n\n   1. 可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。\n   2. 第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 \n\n![](http://ot1c7ttzm.bkt.clouddn.com/cosine.png)\n\n看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。\n\n### 论文细节\n\n论文中的实验部分有这么一句话：\n\n> To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.\n\n鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。\n\n权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  \n\n```python\ntf[document][word] = frequency[document][word] / doclength[document]\n```\n\n另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。\n\n```python\ntf_idf[document][word] = tf[document][word] * idf[word]\n```\n\n而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：\n\n```python\ntf_chi[document][word] = tf[document][word] * chi[label][word]\n```\n\n那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：\n\n```python\nif weights[labell].has_key(word):\n\ttf_chi[doc][word] *= weights[labell][word]\nelse:\n\ttf_chi[doc][word] *= max([ weights[x][word]  for x in weights if weights[x].has_key(word)])\n```\n\n由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。\n\n### 衡量标准\n\n根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：\n\n1. MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数\n\n2. MacroF1 就是通常的F1的均值：\n\n   1. $ MacroF1 = avg(F1)$ \n\n   2. $ F1(C) = \\frac{2\\*precision\\*recall}{(precision + recall)}$ \n\n   3. $ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数\n      $ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目\n\n   4. TP: true positive  属于C被分到C（预测正确）\n      TN: true nagative  属于C被分到其它类（预测错误）\n      FP: false positive 不属于C被正确分类（预测正确）\n      FN: false nagative 不属于C被分到C（预测错误）\n\n## 复现结果\n\n下面是复现之后的结果：\n\n笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/result.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/Result.png)\n\n论文给出的最终结果：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png)\n\n笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/knn.png)\n\n论文给出的关系图：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png)\n\n可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。\n\n## 小结\n\n通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。\n\n## 源代码\n\n原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：[我的github](https://github.com/zedom1/nlp/tree/master/VSM)","source":"_posts/VSM.md","raw":"---\nlayout: post\ntitle: \"复现Entropy-based Term Weighting Schemes for Text Categorization in VSM小结\"\ndate: 2018-06-01\ncomments: true\ntags: \n   - 机器学习\n   - NLP\n   - VSM\n---\n\n\n论文 [Entropy-based Term Weighting Schemes for Text Categorization in VSM](https://ieeexplore.ieee.org/document/7372153/) 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。\n\n在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。\n\n复现基于python2.7，KNN使用[sklearn](http://scikit-learn.org/)包，SVM和原论文同样使用[liblinear](https://www.csie.ntu.edu.tw/~cjlin/liblinear/)，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。\n\n<!-- more -->\n\n## 理论介绍\n\n### VSM向量空间模型\n\n在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：\n\n假设词汇表有  ['one', 'apple','a','day','an'], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率\n\n文章a = \"one day\". 那么 它的向量则是 [1,0,0,1,0]\n\n文章b = \"an apple\"， 则代表b的向量是[0,1,0,0,1]\n\none hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出**一个词的辨别能力**。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 \"算法\" 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。\n\n就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。\n\n由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。\n\n### 旧方法\n\n为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：\n\n大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：\n\n1. PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。\n2. NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了\n3. 计算权重得基于标签，但测试文档本身就不具备标签\n\n对于非监督的计算方法，就拿tf-idf来说，其能力在于**将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来**。\n\n文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。\n\n#### tf·idf\n\n作为最流行的权重计算方法，其计算方法分为两个部分\n\n一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n_{i,j}}{\\sum_{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可\n\n另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一\n\n最终的 tf-idf就等于两者相乘。\n\n#### tf·chi\n\n基于统计的卡方检验和下面一些计算方法都基于以下这个表格：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/abcd.png)\n\nA：类别k中出现了词j的文档数目\n\nB：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可\n\nC：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A\n\nD：其它类别不包含词j的数目，用其它类文档总数 - B\n\n卡方检验的原始公式和近似公式：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png)\n\n#### tf·ig\n\nInformation Gain 信息增益：增加了这个信息使得系统的熵降低了多少。\n\n在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/ig.png)\n\nP(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 \n\nP(t)：词语T出现的概率，用出现过T的文档数除以总文档数 \n\nP(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 \n\nP(～t)：词语T不出现的概率，用 1 - P(t) 即可\n\nP(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 \n\n#### tf·eccd\n\n论文 [Entropy based feature selection for text categorization](https://hal.archives-ouvertes.fr/hal-00617969/document) 同样提出了一种基于熵的权重计算方法\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd0.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/eccd1.png)\n\n#### tf·rf\n\n由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/rf.png)\n\n#### iqf·qf·icf\n\n这篇论文  [Term weighting schemes for question categorization](https://www.ncbi.nlm.nih.gov/pubmed/20733219) 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf\\*qf\\*icf、qf\\*icf 和 vrf。\n\n和rf相比，iqf\\*qf\\*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/iqf1.png)\n\n### 新的权重计算方法\n\n#### tf·dc\n\n论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。\n\n思想基于两点：\n\n1. 辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高\n2. 集中程度越高的词，具有的熵越小\n\n![](http://ot1c7ttzm.bkt.clouddn.com/dc.png)\n\nH(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目\n\n由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。\n\n#### tf·bdc\n\n考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。\n\n为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/bdc.png)\n\n## 复现过程\n\n### 用特征权重进行文本分类的思路\n\n文本分类的整个过程如下：\n\n1. 通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：\n   1. 词语权重表\n   2. 词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。\n   3. 模型参数\n2. 对于每篇测试文档：\n   1. 根据词汇表删去无关词汇\n   2. 查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示\n   3. 将文档向量作为特征输入分类模型中，得到预测结果\n\n### 数据处理\n\n语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：[Reuters-21578 R8](http://ana.cachopo.org/datasets-for-single-label-text-categorization)，[TrainingSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0)， [TestSet](http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0) .\n\n获得语料之后，一个比较重要的地方在于制作特征向量和标签。\n\n我的特征向量和标签制作方法是：\n\n1. 对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。\n2. 对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。\n\n### 维度压缩\n\n在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。\n\n解决方法就是删去频率过高和过低的词：\n\n1. 统计训练语料中的词语频率得到词频表和词汇表\n2. 使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考\n3. 根据长度、频率分布挑选阈值，根据上下界删减词汇表\n4. 根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。\n\n通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png)\n\n<center>删减前</center>\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png)\n\n<center>删减后</center>\n\n### KNN中的cos近似\n\n下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条[stackoverflow上的回答](https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier)：\n\n回答分为两个方面：\n\n1. 指出为什么cosine相似度没有在sklearn包中：\n\n   cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。\n\n2. 给出了解决方法：\n\n   1. 可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。\n   2. 第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 \n\n![](http://ot1c7ttzm.bkt.clouddn.com/cosine.png)\n\n看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。\n\n### 论文细节\n\n论文中的实验部分有这么一句话：\n\n> To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.\n\n鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。\n\n权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  \n\n```python\ntf[document][word] = frequency[document][word] / doclength[document]\n```\n\n另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。\n\n```python\ntf_idf[document][word] = tf[document][word] * idf[word]\n```\n\n而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：\n\n```python\ntf_chi[document][word] = tf[document][word] * chi[label][word]\n```\n\n那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：\n\n```python\nif weights[labell].has_key(word):\n\ttf_chi[doc][word] *= weights[labell][word]\nelse:\n\ttf_chi[doc][word] *= max([ weights[x][word]  for x in weights if weights[x].has_key(word)])\n```\n\n由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。\n\n### 衡量标准\n\n根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：\n\n1. MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数\n\n2. MacroF1 就是通常的F1的均值：\n\n   1. $ MacroF1 = avg(F1)$ \n\n   2. $ F1(C) = \\frac{2\\*precision\\*recall}{(precision + recall)}$ \n\n   3. $ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数\n      $ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目\n\n   4. TP: true positive  属于C被分到C（预测正确）\n      TN: true nagative  属于C被分到其它类（预测错误）\n      FP: false positive 不属于C被正确分类（预测正确）\n      FN: false nagative 不属于C被分到C（预测错误）\n\n## 复现结果\n\n下面是复现之后的结果：\n\n笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/result.png)\n\n![](http://ot1c7ttzm.bkt.clouddn.com/Result.png)\n\n论文给出的最终结果：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png)\n\n笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/knn.png)\n\n论文给出的关系图：\n\n![](http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png)\n\n可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。\n\n## 小结\n\n通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。\n\n## 源代码\n\n原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：[我的github](https://github.com/zedom1/nlp/tree/master/VSM)","slug":"VSM","published":1,"updated":"2018-06-02T02:59:52.474Z","_id":"cjhvssaek0017jvfco3f4904d","photos":[],"link":"","content":"<p>论文 <a href=\"https://ieeexplore.ieee.org/document/7372153/\" target=\"_blank\" rel=\"noopener\">Entropy-based Term Weighting Schemes for Text Categorization in VSM</a> 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。</p>\n<p>在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。</p>\n<p>复现基于python2.7，KNN使用<a href=\"http://scikit-learn.org/\" target=\"_blank\" rel=\"noopener\">sklearn</a>包，SVM和原论文同样使用<a href=\"https://www.csie.ntu.edu.tw/~cjlin/liblinear/\" target=\"_blank\" rel=\"noopener\">liblinear</a>，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。</p>\n<a id=\"more\"></a>\n<h2 id=\"理论介绍\"><a href=\"#理论介绍\" class=\"headerlink\" title=\"理论介绍\"></a>理论介绍</h2><h3 id=\"VSM向量空间模型\"><a href=\"#VSM向量空间模型\" class=\"headerlink\" title=\"VSM向量空间模型\"></a>VSM向量空间模型</h3><p>在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：</p>\n<p>假设词汇表有  [‘one’, ‘apple’,’a’,’day’,’an’], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率</p>\n<p>文章a = “one day”. 那么 它的向量则是 [1,0,0,1,0]</p>\n<p>文章b = “an apple”， 则代表b的向量是[0,1,0,0,1]</p>\n<p>one hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出<strong>一个词的辨别能力</strong>。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 “算法” 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。</p>\n<p>就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。</p>\n<p>由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。</p>\n<h3 id=\"旧方法\"><a href=\"#旧方法\" class=\"headerlink\" title=\"旧方法\"></a>旧方法</h3><p>为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：</p>\n<p>大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：</p>\n<ol>\n<li>PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。</li>\n<li>NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了</li>\n<li>计算权重得基于标签，但测试文档本身就不具备标签</li>\n</ol>\n<p>对于非监督的计算方法，就拿tf-idf来说，其能力在于<strong>将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来</strong>。</p>\n<p>文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。</p>\n<h4 id=\"tf·idf\"><a href=\"#tf·idf\" class=\"headerlink\" title=\"tf·idf\"></a>tf·idf</h4><p>作为最流行的权重计算方法，其计算方法分为两个部分</p>\n<p>一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n<em>{i,j}}{\\sum</em>{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可</p>\n<p>另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一</p>\n<p>最终的 tf-idf就等于两者相乘。</p>\n<h4 id=\"tf·chi\"><a href=\"#tf·chi\" class=\"headerlink\" title=\"tf·chi\"></a>tf·chi</h4><p>基于统计的卡方检验和下面一些计算方法都基于以下这个表格：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/abcd.png\" alt=\"\"></p>\n<p>A：类别k中出现了词j的文档数目</p>\n<p>B：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可</p>\n<p>C：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A</p>\n<p>D：其它类别不包含词j的数目，用其它类文档总数 - B</p>\n<p>卡方检验的原始公式和近似公式：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png\" alt=\"\"></p>\n<h4 id=\"tf·ig\"><a href=\"#tf·ig\" class=\"headerlink\" title=\"tf·ig\"></a>tf·ig</h4><p>Information Gain 信息增益：增加了这个信息使得系统的熵降低了多少。</p>\n<p>在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ig.png\" alt=\"\"></p>\n<p>P(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 </p>\n<p>P(t)：词语T出现的概率，用出现过T的文档数除以总文档数 </p>\n<p>P(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 </p>\n<p>P(～t)：词语T不出现的概率，用 1 - P(t) 即可</p>\n<p>P(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 </p>\n<h4 id=\"tf·eccd\"><a href=\"#tf·eccd\" class=\"headerlink\" title=\"tf·eccd\"></a>tf·eccd</h4><p>论文 <a href=\"https://hal.archives-ouvertes.fr/hal-00617969/document\" target=\"_blank\" rel=\"noopener\">Entropy based feature selection for text categorization</a> 同样提出了一种基于熵的权重计算方法</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd0.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd1.png\" alt=\"\"></p>\n<h4 id=\"tf·rf\"><a href=\"#tf·rf\" class=\"headerlink\" title=\"tf·rf\"></a>tf·rf</h4><p>由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rf.png\" alt=\"\"></p>\n<h4 id=\"iqf·qf·icf\"><a href=\"#iqf·qf·icf\" class=\"headerlink\" title=\"iqf·qf·icf\"></a>iqf·qf·icf</h4><p>这篇论文  <a href=\"https://www.ncbi.nlm.nih.gov/pubmed/20733219\" target=\"_blank\" rel=\"noopener\">Term weighting schemes for question categorization</a> 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf*qf*icf、qf*icf 和 vrf。</p>\n<p>和rf相比，iqf*qf*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf1.png\" alt=\"\"></p>\n<h3 id=\"新的权重计算方法\"><a href=\"#新的权重计算方法\" class=\"headerlink\" title=\"新的权重计算方法\"></a>新的权重计算方法</h3><h4 id=\"tf·dc\"><a href=\"#tf·dc\" class=\"headerlink\" title=\"tf·dc\"></a>tf·dc</h4><p>论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。</p>\n<p>思想基于两点：</p>\n<ol>\n<li>辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高</li>\n<li>集中程度越高的词，具有的熵越小</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/dc.png\" alt=\"\"></p>\n<p>H(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目</p>\n<p>由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。</p>\n<h4 id=\"tf·bdc\"><a href=\"#tf·bdc\" class=\"headerlink\" title=\"tf·bdc\"></a>tf·bdc</h4><p>考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。</p>\n<p>为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/bdc.png\" alt=\"\"></p>\n<h2 id=\"复现过程\"><a href=\"#复现过程\" class=\"headerlink\" title=\"复现过程\"></a>复现过程</h2><h3 id=\"用特征权重进行文本分类的思路\"><a href=\"#用特征权重进行文本分类的思路\" class=\"headerlink\" title=\"用特征权重进行文本分类的思路\"></a>用特征权重进行文本分类的思路</h3><p>文本分类的整个过程如下：</p>\n<ol>\n<li>通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：<ol>\n<li>词语权重表</li>\n<li>词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。</li>\n<li>模型参数</li>\n</ol>\n</li>\n<li>对于每篇测试文档：<ol>\n<li>根据词汇表删去无关词汇</li>\n<li>查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示</li>\n<li>将文档向量作为特征输入分类模型中，得到预测结果</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><p>语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization\" target=\"_blank\" rel=\"noopener\">Reuters-21578 R8</a>，<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TrainingSet</a>， <a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TestSet</a> .</p>\n<p>获得语料之后，一个比较重要的地方在于制作特征向量和标签。</p>\n<p>我的特征向量和标签制作方法是：</p>\n<ol>\n<li>对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。</li>\n<li>对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。</li>\n</ol>\n<h3 id=\"维度压缩\"><a href=\"#维度压缩\" class=\"headerlink\" title=\"维度压缩\"></a>维度压缩</h3><p>在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。</p>\n<p>解决方法就是删去频率过高和过低的词：</p>\n<ol>\n<li>统计训练语料中的词语频率得到词频表和词汇表</li>\n<li>使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考</li>\n<li>根据长度、频率分布挑选阈值，根据上下界删减词汇表</li>\n<li>根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。</li>\n</ol>\n<p>通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png\" alt=\"\"></p>\n<center>删减前</center>\n\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png\" alt=\"\"></p>\n<center>删减后</center>\n\n<h3 id=\"KNN中的cos近似\"><a href=\"#KNN中的cos近似\" class=\"headerlink\" title=\"KNN中的cos近似\"></a>KNN中的cos近似</h3><p>下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条<a href=\"https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier\" target=\"_blank\" rel=\"noopener\">stackoverflow上的回答</a>：</p>\n<p>回答分为两个方面：</p>\n<ol>\n<li><p>指出为什么cosine相似度没有在sklearn包中：</p>\n<p>cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。</p>\n</li>\n<li><p>给出了解决方法：</p>\n<ol>\n<li>可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。</li>\n<li>第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 </li>\n</ol>\n</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/cosine.png\" alt=\"\"></p>\n<p>看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。</p>\n<h3 id=\"论文细节\"><a href=\"#论文细节\" class=\"headerlink\" title=\"论文细节\"></a>论文细节</h3><p>论文中的实验部分有这么一句话：</p>\n<blockquote>\n<p>To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.</p>\n</blockquote>\n<p>鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。</p>\n<p>权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf[document][word] = frequency[document][word] / doclength[document]</span><br></pre></td></tr></table></figure>\n<p>另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_idf[document][word] = tf[document][word] * idf[word]</span><br></pre></td></tr></table></figure>\n<p>而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_chi[document][word] = tf[document][word] * chi[label][word]</span><br></pre></td></tr></table></figure>\n<p>那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> weights[labell].has_key(word):</span><br><span class=\"line\">\ttf_chi[doc][word] *= weights[labell][word]</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\ttf_chi[doc][word] *= max([ weights[x][word]  <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> weights <span class=\"keyword\">if</span> weights[x].has_key(word)])</span><br></pre></td></tr></table></figure>\n<p>由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。</p>\n<h3 id=\"衡量标准\"><a href=\"#衡量标准\" class=\"headerlink\" title=\"衡量标准\"></a>衡量标准</h3><p>根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：</p>\n<ol>\n<li><p>MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数</p>\n</li>\n<li><p>MacroF1 就是通常的F1的均值：</p>\n<ol>\n<li><p>$ MacroF1 = avg(F1)$ </p>\n</li>\n<li><p>$ F1(C) = \\frac{2*precision*recall}{(precision + recall)}$ </p>\n</li>\n<li><p>$ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数<br>$ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目</p>\n</li>\n<li><p>TP: true positive  属于C被分到C（预测正确）<br>TN: true nagative  属于C被分到其它类（预测错误）<br>FP: false positive 不属于C被正确分类（预测正确）<br>FN: false nagative 不属于C被分到C（预测错误）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"复现结果\"><a href=\"#复现结果\" class=\"headerlink\" title=\"复现结果\"></a>复现结果</h2><p>下面是复现之后的结果：</p>\n<p>笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/result.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Result.png\" alt=\"\"></p>\n<p>论文给出的最终结果：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png\" alt=\"\"></p>\n<p>笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/knn.png\" alt=\"\"></p>\n<p>论文给出的关系图：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png\" alt=\"\"></p>\n<p>可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p>原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：<a href=\"https://github.com/zedom1/nlp/tree/master/VSM\" target=\"_blank\" rel=\"noopener\">我的github</a></p>\n","site":{"data":{}},"excerpt":"<p>论文 <a href=\"https://ieeexplore.ieee.org/document/7372153/\" target=\"_blank\" rel=\"noopener\">Entropy-based Term Weighting Schemes for Text Categorization in VSM</a> 提出了新的基于熵的用于文本分类的词权重计算方法tf·dc,tf·bdc，通过和目前流行的权重计算方法如tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf进行实验比较，证实其提出的计算方法的可行性和优越性。 笔者通过复现论文新提出的tf_dc，tf_bdc，以及用于实验比较的tf·idf, tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf，在使用和论文实验一样的语料库 Reuters-R8 和 同样的分类模型 ：KNN和SVM后，发现确实如同论文说的outperform，起码在Reuters上的分类结果优于tf-idf。</p>\n<p>在此将整个复现的流程记录和小结一下，从阅读论文到实现计算方法再到使用分类模型到评估结果，整个过程虽然遇到了不少问题，但最终能够逐个克服并最终完成复现。</p>\n<p>复现基于python2.7，KNN使用<a href=\"http://scikit-learn.org/\" target=\"_blank\" rel=\"noopener\">sklearn</a>包，SVM和原论文同样使用<a href=\"https://www.csie.ntu.edu.tw/~cjlin/liblinear/\" target=\"_blank\" rel=\"noopener\">liblinear</a>，鉴于只是大致复现，因此除了和原论文同样对KNN的邻居数目参数进行实验外，没有细致对knn和SVM做调参。</p>","more":"<h2 id=\"理论介绍\"><a href=\"#理论介绍\" class=\"headerlink\" title=\"理论介绍\"></a>理论介绍</h2><h3 id=\"VSM向量空间模型\"><a href=\"#VSM向量空间模型\" class=\"headerlink\" title=\"VSM向量空间模型\"></a>VSM向量空间模型</h3><p>在自然语言处理过程中，第一步都是将要处理的字、词或文本转换成向量，毕竟计算机不懂文字，它只会处理数字。把词转换成向量我们有one hot, word embedding。到了文档层级，既然文档是由词语组成的，那么可以试着用词语来表示文档。来看看一个用one hot表示文章的例子：</p>\n<p>假设词汇表有  [‘one’, ‘apple’,’a’,’day’,’an’], 此时只使用one hot，即只判断记录词是否出现，不记录词的频率</p>\n<p>文章a = “one day”. 那么 它的向量则是 [1,0,0,1,0]</p>\n<p>文章b = “an apple”， 则代表b的向量是[0,1,0,0,1]</p>\n<p>one hot表示法虽然简单，但也有很多缺点，比如只记录词出现与否，词的区分能力被认为是一样的等等，由此人们提出了很多计算方法，核心思想就是表示出<strong>一个词的辨别能力</strong>。词语的辨别能力是指：这个词将一篇文档从其它文档中区分出来的能力（或者将一个类从其它类区分出来的能力）,比如说一篇文章出现 “算法” 这个词较多，那么它通常会是计算机等领域的文章，而不太可能会是体育、艺术类的文章。</p>\n<p>就拿之前的例子而言，an和One这种词明显在很多地方都会出现，因此它们的辨别能力不强，而apple就比它们好一点，那么在特征权重计算中，它的权重就会比其它两个高一些。</p>\n<p>由此，每个词语对应一个维度，每个词语有一定的权重（由训练语料训练出来，代表这个词区分各类文档或各个标签的能力），再结合词语在文本出现的次数，就能够构成一个多维向量，将文档成功投射到多维空间中，这就是向量空间模型。投射之后，计算文章之间的相似度就可以有很多方法了，比如直接计算空间当中的距离啊，cosine啊等等，那么我们就可以将文章归到和它相似度高的那类中，由此完成文档分类的过程。</p>\n<h3 id=\"旧方法\"><a href=\"#旧方法\" class=\"headerlink\" title=\"旧方法\"></a>旧方法</h3><p>为什么需要提出新的权重计算方法呢？因为旧的不够好，不够好在哪里？论文给出了理由：</p>\n<p>大多数监督学习的计算方法基于词在 PC（positive category） 和 NC（negative category） 中的出现次数，就会有以下问题：</p>\n<ol>\n<li>PC是单独一个类， 而 NC包含多个类，而把它们统一成一个数字，那么显然NC的数目要远远大于PC，在权重计算中也会占主导地位。</li>\n<li>NC包含多个类，仅归为一个数字后，词语在这些类中的分布信息就丢失了</li>\n<li>计算权重得基于标签，但测试文档本身就不具备标签</li>\n</ol>\n<p>对于非监督的计算方法，就拿tf-idf来说，其能力在于<strong>将一篇文档从其它文档区分出来，而不是将一个类从其它类区分出来</strong>。</p>\n<p>文章列举了其它较为流行的权重计算方法，并依照上面提出的问题一一举出了例子。</p>\n<h4 id=\"tf·idf\"><a href=\"#tf·idf\" class=\"headerlink\" title=\"tf·idf\"></a>tf·idf</h4><p>作为最流行的权重计算方法，其计算方法分为两个部分</p>\n<p>一个是tf(i,j)，即词i在文章j中出现的频率： $tf(i,j) = \\frac{n<em>{i,j}}{\\sum</em>{k} n_{k,j}}$ , 用词i出现的次数 / 这篇文章总长即可</p>\n<p>另一个是 idf(i,j)，称为逆文档频率，和这个词出现的文档数相关：  $idf(i) = log \\frac{|D|}{nd_{i}}$ , 用文档总数 / 出现了 i 的文档数目，而后再取log，一般为了防止分母为0会在分母上加一</p>\n<p>最终的 tf-idf就等于两者相乘。</p>\n<h4 id=\"tf·chi\"><a href=\"#tf·chi\" class=\"headerlink\" title=\"tf·chi\"></a>tf·chi</h4><p>基于统计的卡方检验和下面一些计算方法都基于以下这个表格：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/abcd.png\" alt=\"\"></p>\n<p>A：类别k中出现了词j的文档数目</p>\n<p>B：除类别k外的其它类出现了词j的文档总数，用词j出现的文档总数 - A 即可</p>\n<p>C：负文档数目，即类别k中不包含词j的数目，用 类别k的文章总数-A</p>\n<p>D：其它类别不包含词j的数目，用其它类文档总数 - B</p>\n<p>卡方检验的原始公式和近似公式：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_chi.png\" alt=\"\"></p>\n<h4 id=\"tf·ig\"><a href=\"#tf·ig\" class=\"headerlink\" title=\"tf·ig\"></a>tf·ig</h4><p>Information Gain 信息增益：增加了这个信息使得系统的熵降低了多少。</p>\n<p>在特征权重计算中，以词语出现与否分别计算整个语料库的熵，以熵的差值作为词语的信息增益，即词的权重。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/ig.png\" alt=\"\"></p>\n<p>P(Ci)：表示类别Ci出现的概率，用Ci包含的文档数除以文档总数 </p>\n<p>P(t)：词语T出现的概率，用出现过T的文档数除以总文档数 </p>\n<p>P(Ci|t)：出现T的时候，类别Ci出现的概率，用出现了T并且属于类别Ci的文档数除以出现了T的文档数 </p>\n<p>P(～t)：词语T不出现的概率，用 1 - P(t) 即可</p>\n<p>P(Ci|～t)表示未出现T的时候，类别Ci出现的概率，用未出现了T并且属于类别Ci的文档数除以未出现T的文档数 </p>\n<h4 id=\"tf·eccd\"><a href=\"#tf·eccd\" class=\"headerlink\" title=\"tf·eccd\"></a>tf·eccd</h4><p>论文 <a href=\"https://hal.archives-ouvertes.fr/hal-00617969/document\" target=\"_blank\" rel=\"noopener\">Entropy based feature selection for text categorization</a> 同样提出了一种基于熵的权重计算方法</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd0.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/eccd1.png\" alt=\"\"></p>\n<h4 id=\"tf·rf\"><a href=\"#tf·rf\" class=\"headerlink\" title=\"tf·rf\"></a>tf·rf</h4><p>由于表格中B、D的数目显然很大，为了避免它们带来的影响，人们提出了relevance frequency（rf），只是用 a和c的比值来表明一个词的辨别能力。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/rf.png\" alt=\"\"></p>\n<h4 id=\"iqf·qf·icf\"><a href=\"#iqf·qf·icf\" class=\"headerlink\" title=\"iqf·qf·icf\"></a>iqf·qf·icf</h4><p>这篇论文  <a href=\"https://www.ncbi.nlm.nih.gov/pubmed/20733219\" target=\"_blank\" rel=\"noopener\">Term weighting schemes for question categorization</a> 面对短文本（用户提出的问题）提出三种新的权重计算方式： iqf*qf*icf、qf*icf 和 vrf。</p>\n<p>和rf相比，iqf*qf*icf额外考虑了一个词出现了类数目，然而正如论文提出的那样，只考虑了类的数目，却没有考虑到词在这些类内部的分布情况。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/iqf1.png\" alt=\"\"></p>\n<h3 id=\"新的权重计算方法\"><a href=\"#新的权重计算方法\" class=\"headerlink\" title=\"新的权重计算方法\"></a>新的权重计算方法</h3><h4 id=\"tf·dc\"><a href=\"#tf·dc\" class=\"headerlink\" title=\"tf·dc\"></a>tf·dc</h4><p>论文论证了用熵来表示词语辨别能力的可行性，由此提出了新的计算方法 dc：distribution concentration。</p>\n<p>思想基于两点：</p>\n<ol>\n<li>辨别能力和词语在所有类的集中程度有关，词语集中程度越高，则它只出现在很少几个类，那么它的辨别能力就越高</li>\n<li>集中程度越高的词，具有的熵越小</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/dc.png\" alt=\"\"></p>\n<p>H(t)即代表t的熵， f(t,ci)表明词语t在类别 ci出现的文档数目</p>\n<p>由于 $H(t) \\in [0,log(|C|)]$ ，在除了log(|C|)之后就能将熵化为[0,1]区间，这使得同一篇文章内的词有了可比性。</p>\n<h4 id=\"tf·bdc\"><a href=\"#tf·bdc\" class=\"headerlink\" title=\"tf·bdc\"></a>tf·bdc</h4><p>考虑到现实中语料库类别包含的文档数目有差异，并非理想中所有类的文档数大致相等，那么为了平衡类之间的规模差异，论文在dc的基础上提出了bdc：balanced distribution concentration。</p>\n<p>为了避免大类文档数目过多带来的偏差，论文将绝对频率换成了概率，由此平衡类之间的差异。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/bdc.png\" alt=\"\"></p>\n<h2 id=\"复现过程\"><a href=\"#复现过程\" class=\"headerlink\" title=\"复现过程\"></a>复现过程</h2><h3 id=\"用特征权重进行文本分类的思路\"><a href=\"#用特征权重进行文本分类的思路\" class=\"headerlink\" title=\"用特征权重进行文本分类的思路\"></a>用特征权重进行文本分类的思路</h3><p>文本分类的整个过程如下：</p>\n<ol>\n<li>通过训练语料库计算得到词语权重，并通过将语料库文章投影成向量构成训练特征，标签则为类标签索引，以此训练KNN或SVM模型。 此步主要得到三样东西：<ol>\n<li>词语权重表</li>\n<li>词汇表：计算词语频率后删减频率过高和过低的词的产物，每个词汇表里面的词将作为一维，每篇文章为 1*n 的向量，n为词汇表大小。</li>\n<li>模型参数</li>\n</ol>\n</li>\n<li>对于每篇测试文档：<ol>\n<li>根据词汇表删去无关词汇</li>\n<li>查词语权重表，若使用tf则额外计算每个词语在文本中出现的频率。 得到每个词语的词语权重，由此得到文档的向量表示</li>\n<li>将文档向量作为特征输入分类模型中，得到预测结果</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><p>语料库和论文中同样选用路透社的语料 Reuters-21578 R8，鉴于Reuters的语料是有名的难处理再加上复现的重点不在此，因此笔者直接使用处理好的语料：<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization\" target=\"_blank\" rel=\"noopener\">Reuters-21578 R8</a>，<a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-train-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TrainingSet</a>， <a href=\"http://ana.cachopo.org/datasets-for-single-label-text-categorization/r8-test-all-terms.txt?attredirects=0\" target=\"_blank\" rel=\"noopener\">TestSet</a> .</p>\n<p>获得语料之后，一个比较重要的地方在于制作特征向量和标签。</p>\n<p>我的特征向量和标签制作方法是：</p>\n<ol>\n<li>对于文档，首先将所有词转换成one hot，转换使用了sklearn.preprocessing中的Encoder，然而一件很重要的事情在于one hot的顺序，因为Encoder会按照词汇出现顺序设置one hot的顺序，因此我的做法是把文档的词连接在词汇表后面一起导入Encoder，而后再对生成的one hot进行截取，因为词汇表的顺序和大小是固定的，所以截取也很方便。 需要注意的是要将词汇表设置为全局的，并且仅在训练集中构造词汇表，而测试集仅用词汇表进行筛选。</li>\n<li>对于类别标签，同样在训练集中构造标签表，而后串接起来导入Encoder再截取，然后用argmax获得唯一的1所在的下标，由此将字符串转换成了单个数字。</li>\n</ol>\n<h3 id=\"维度压缩\"><a href=\"#维度压缩\" class=\"headerlink\" title=\"维度压缩\"></a>维度压缩</h3><p>在复现的过程中，首先遇到的第一个小问题就是维度过大，虽然只使用了几MB的语料库，但要是把每个词都作为一维的话，那就有将近两万维，刚开始直接运行的时候电脑就报出超出内存的错误了。</p>\n<p>解决方法就是删去频率过高和过低的词：</p>\n<ol>\n<li>统计训练语料中的词语频率得到词频表和词汇表</li>\n<li>使用Counter得到各个频率的词汇数目并使用matplotlib.pyplot将词汇频率绘制成直方图，此外还将词汇表的长度作为额外参考</li>\n<li>根据长度、频率分布挑选阈值，根据上下界删减词汇表</li>\n<li>根据词汇表删去训练和测试语料的其它词，仅保留在词汇表中的词语。</li>\n</ol>\n<p>通过这么个维度压缩，使得维度从两万维降低到五千多维，不仅加快了运行速度，减少了运行需要的空间，同时也减少了停用词和自造词的干扰。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq1.png\" alt=\"\"></p>\n<center>删减前</center>\n\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_freq2.png\" alt=\"\"></p>\n<center>删减后</center>\n\n<h3 id=\"KNN中的cos近似\"><a href=\"#KNN中的cos近似\" class=\"headerlink\" title=\"KNN中的cos近似\"></a>KNN中的cos近似</h3><p>下一个比较重要的小问题在于sklearn中的KNN提供的计算距离的函数并没有cos距离，而后在寻找解决方案时发现了这条<a href=\"https://stackoverflow.com/questions/34144632/using-cosine-distance-with-scikit-learn-kneighborsclassifier\" target=\"_blank\" rel=\"noopener\">stackoverflow上的回答</a>：</p>\n<p>回答分为两个方面：</p>\n<ol>\n<li><p>指出为什么cosine相似度没有在sklearn包中：</p>\n<p>cosine相似度在两个向量完全一样时的输出结果是1，在它们完全相反时结果是-1，而这严格上并不能算作衡量指标，其它如欧几里得距离，向量相似度越高距离越小即越接近于0. （不过为什么通过1-cos近似），因此不能使用knn的加速结构来加快运算。</p>\n</li>\n<li><p>给出了解决方法：</p>\n<ol>\n<li>可以自行实现cos相似度并作为函数参数传进去，代价就是不能使用knn中用于加速的结构，只能使用暴力计算。</li>\n<li>第二个方案比较巧妙，通过深入到公式的转换把计算cosine相似度转换成用归一化之后的欧几里得即可。 </li>\n</ol>\n</li>\n</ol>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/cosine.png\" alt=\"\"></p>\n<p>看完之后笔者被那个公式转换惊叹到，而后果断地采用了这个方案，在计算出文档向量之后，额外做一次归一化，之后只需要正常传入knn，距离函数用默认的欧几里得距离即可。</p>\n<h3 id=\"论文细节\"><a href=\"#论文细节\" class=\"headerlink\" title=\"论文细节\"></a>论文细节</h3><p>论文中的实验部分有这么一句话：</p>\n<blockquote>\n<p>To represent test documents with category-specific schemes, e.g., tf·chi, tf·ig, tf·eccd, tf·rf and iqf·qf·icf, we adopt a popular method in previous studies hat assigning the maximum value among |C| estimated weights to each term in test documents.</p>\n</blockquote>\n<p>鉴于笔者缺乏大量阅读英文文档的经验，再加上当时没有考虑到实现，所以阅读论文的时候始终不明白这句话的意思，但后来在实现话中提到的 tf-chi、tf-ig等方法时程序频繁报出词典key error，而后想起这句似乎关键但并不太明白什么意思的话，再结合实现时候的问题，终于明白了。</p>\n<p>权重计算方法如 tf-idf 分为两个部分，一个是 tf ，由一个词在一篇文章内出现的频率得到，训练集和测试集均要计算，用python代码表示即是一个两层的词典  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf[document][word] = frequency[document][word] / doclength[document]</span><br></pre></td></tr></table></figure>\n<p>另一个是 idf ，由一个词在语料库中出现的文档数和文档总数计算得到，对于训练集是需要计算得到的，对于测试集则相当于权重词典，要用的时候直接查就行，而它的表现形式在tf-idf中是一个单层的词典，idf只计算每个词，和词在哪个类中没有关系。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_idf[document][word] = tf[document][word] * idf[word]</span><br></pre></td></tr></table></figure>\n<p>而对于如chi等词，它们词权重计算不仅和词相关，还和类别相关。意思就是每个词的权重在不同类是不一样的，用代码表示出来即是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf_chi[document][word] = tf[document][word] * chi[label][word]</span><br></pre></td></tr></table></figure>\n<p>那么就有一个比较重要的问题：要是测试集的词在测试文档属于的类中不存在怎么办？那句话就给出了答案：若是词在所属类中不存在权重，那么就在其它类里面选择这个词权重最大的那个作为权重，用代码表示就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> weights[labell].has_key(word):</span><br><span class=\"line\">\ttf_chi[doc][word] *= weights[labell][word]</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\ttf_chi[doc][word] *= max([ weights[x][word]  <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> weights <span class=\"keyword\">if</span> weights[x].has_key(word)])</span><br></pre></td></tr></table></figure>\n<p>由此，缺失的拼图找到了，笔者最终成功实现了这些权重计算方法。</p>\n<h3 id=\"衡量标准\"><a href=\"#衡量标准\" class=\"headerlink\" title=\"衡量标准\"></a>衡量标准</h3><p>根据论文原文，实验采用了两种衡量标准：MicroF1和MacroF1：</p>\n<ol>\n<li><p>MicroF1就是一般说的准确率：预测正确的数目 / 测试样本总数</p>\n</li>\n<li><p>MacroF1 就是通常的F1的均值：</p>\n<ol>\n<li><p>$ MacroF1 = avg(F1)$ </p>\n</li>\n<li><p>$ F1(C) = \\frac{2*precision*recall}{(precision + recall)}$ </p>\n</li>\n<li><p>$ precision = \\frac{TP} { (TP + FN)} $： 正确预测为C的数目 / 预测为C的总数<br>$ recall = \\frac{ TP}{(TP + TN)}$：  正确预测为C的数目 / 真实为C的数目</p>\n</li>\n<li><p>TP: true positive  属于C被分到C（预测正确）<br>TN: true nagative  属于C被分到其它类（预测错误）<br>FP: false positive 不属于C被正确分类（预测正确）<br>FN: false nagative 不属于C被分到C（预测错误）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"复现结果\"><a href=\"#复现结果\" class=\"headerlink\" title=\"复现结果\"></a>复现结果</h2><p>下面是复现之后的结果：</p>\n<p>笔者在未调参的SVM、KNN上，使用Reuters R8语料库的结果（KNN邻居数在1-35内选择结果最优的）：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/result.png\" alt=\"\"></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/Result.png\" alt=\"\"></p>\n<p>论文给出的最终结果：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_result.png\" alt=\"\"></p>\n<p>笔者复现的在Reuters R8中KNN邻居数和MicroF1的关系：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/knn.png\" alt=\"\"></p>\n<p>论文给出的关系图：</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/vsm_knn.png\" alt=\"\"></p>\n<p>可以看到，虽然数据上略微有差距，但经过在模型上的优化之后应该能够接近或达到论文给出的结果，提出的新的权重计算方式tf_dc和tf_bdc在Reuters R8上的表现还是不错的，不说能够傲视所有权重计算方式，起码表现足够优异，有一席之地。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过这次复现，笔者较为深入地学习了向量空间模型VSM，还了解了各种权重计算方法，谈到权重计算也不再只有单一的tf_idf了。此外，这么一个完整的，从数据到特征（虽然语料库预处理不是我做的），再到导入模型进行训练，再到预测，最后进行评估，这么个流程走下来之后，笔者对于机器学习的理解也加深了。光是从调包上讲也知道怎么用KNN和SVM，怎么做数据可视化了。</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p>原论文、笔者实现过程的完整代码（包括训练模型、测试、评估、所有权重计算方法）、笔者实验得到的数据（MicroF1和MacroF1，knn各个邻居数上的MicroF1，可直接调用评估函数查看结果）都可以在这里看到：<a href=\"https://github.com/zedom1/nlp/tree/master/VSM\" target=\"_blank\" rel=\"noopener\">我的github</a></p>"},{"layout":"post","title":"数据结构笔记（二）：栈和队列","date":"2017-08-13T16:00:00.000Z","comments":1,"_content":"\n\n# **概述**\n\n**栈**(stack)和**队列**(queue)均属于**线性存储**结构\n\n栈特性：\n\n> 1. LIFO ( last in first out ) 后进先出\n> 2. 元素插入和删除仅在一端进行\n\n队列特性：\n\n> 1. FIFO ( first in first out ) 先进先出\n> 2. 元素在队尾插入，在队头删除\n\n![栈和队列](http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg)\n\n这两种结构均可以用数组或链表实现\n\n本文主要介绍栈，以下实现均为c++.\n\n<!-- more -->\n\n# **栈**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名     | 功能        |\n| ---- | ------- | --------- |\n| bool | empty() | 判断是否为空    |\n| int  | size()  | 获取栈的大小    |\n| void | push(n) | 将n压入栈     |\n| T&   | top()   | 取栈顶元素而不弹出 |\n| T    | pop()   | 弹出栈顶元素    |\n\n## **二. 基本定义：**\n\n本文用数组实现栈。\n在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。\n\n（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）\n\n栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。\n\n```\ntemplate <typename T>\nstruct Stack\n{\nprivate:\n\tT *data;\n\tint _size,maxsize;   // 当前规模和最大规模\n\nprotected:\n\tvoid expand();  // 扩容\n\tvoid shrink();  // 缩容\n\npublic:\n\tStack(){ _size =0 ; maxsize=4; data=new T[maxsize]; };\n\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶\n\t~Stack() { delete []data; }\n\tvoid push( T const & e ) { expand(); data[_size++]=e;  }\n\tT pop( ) { shrink(); return data[--_size];   }\n\tT & top( ) { return data[_size-1];};\n\tint empty()const {return _size==0;}\n\tint size()const {return _size;}\n\tint find( T const & e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题\n};\n```\n\n## **三. 典型应用：**\n\n**一. 逆序输出**\n\n输出次序和处理过程颠倒\n\n例如：进制转换\n\n**二. 递归嵌套**\n\n具有自相似性 ( 总体和局部相似 )\n\n例如：括号匹配、栈混洗(stack permutation)\n\n**三. 延迟缓冲**\n\n线性扫描算法模式\n\n例如：中缀表达式求值\n\n**四. 栈式计算**\n\n例如：逆波兰表达式转换（RPN Reverse Polish Notation）\n\n**五. 试探回溯**\n\n例如：n皇后问题、寻路\n\n下面开始一一介绍这些应用：\n\n### **3-1. 进制转换：**\n\n思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。\n\n借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。\n\n```\nvoid convert(  int n , int base ) \n{\n\tStack<char>s;\n\tstatic char digit[]=\n\t{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\t// 进制限定在2-16，有需要可以继续扩展\n\twhile(n)\n\t{\n\t\ts.push( digit[n%base]);\n\t\tn/=base;\n\t}\n\twhile( !s.empty() )\n\t\tcout<<s.pop();\n\tcout<<endl;\n}\n```\n\n### **3-2. 括号匹配：**\n\n判断某一表达式内的括号是否完全匹配\n\n对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。\n\n然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。\n\n而借助栈我们能够很轻松地完成多括号匹配的任务。\n\n思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。\n\n显示为流程图即是\n\n![流程图](http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG)\n\n下面来看一下代码\n\n```\nbool judge ( char *s , int n ) \n{\n\tStack<char>a;\n\tfor(int i=0 ; i<n; i++)\n\t{\n\t\tif( s[i]!='(' && s[i]!=')' && s[i]!='[' && s[i]!=']' )\n\t\t\tcontinue;\n\t\tif( s[i]=='('|| s[i]=='[')\n\t\t\ta.push(s[i]);\n\t\telse if(a.empty())\n\t\t\treturn false;\n\t\telse if( (s[i]==')'&&a.top()=='(') || (s[i]==']'&&a.top()=='[') )\n\t\t\ta.pop();\n\t}\n\tif(\ta.empty() )\n\t\treturn true;\n\treturn false;\n}\n```\n\n### **3-3. 栈混洗：**\n\n#### **3-3-0. 概念：**\n\n栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。\n\n栈混洗的过程中只允许以下两个操作：\n\n> 1. A栈顶弹出并压入栈S S.push(A.pop())\n> 2. S栈顶弹出并压入栈B B.push(S.pop())\n\n#### **3-3-1. 排列种数：**\n\n先来计算一下栈通过栈混洗操作后有多少种排列方式：\n\n设总数为n的栈有SP(n)种排列方式\n\n推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]\n对于第一个元素而言，它的排列方式有SP(n)种。\n\n$$SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)$$\n\n解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$\n\n#### **3-3-2. 甄别栈混洗：**\n\n如何甄别一个序列是否是栈混洗呢？\n\n三个元素栈混洗有5种，全排列有6种, <1,2,3] 非栈混洗的排列为 <2,1,3] ( ‘<’为栈顶方向 )\n\n而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关\n\n对于 1<=i < j < k<=n,若出现 k i j的排列，则非栈混洗 （称为**禁形**）\n\n![禁形1](http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg)\n\n通过证明，禁形对于是否是栈混洗为 **充要条件**\n\n![禁形2](http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg)\n\n那么我们可以得到如下的判别方法：\n\nO(n3)判别方法：分别枚举i，j，k\n\nO(n2)判别方法：枚举 i , j , j+1\n\nO(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗\n\n以下为O(n)的判别方法的实现：\n\n```\ntemplate <typename T>\nbool stackPermutation( T *origin, T * b , int n )\n{\n\tStack<T> s;\n\tStack<T> ori( origin ,n );\n\tfor( int j=0; j<n ; j++ )\n\t{\t\n\t\tif( s.empty() )\n\t\t{\t\n\t\t\tif( ori.empty() ) \n\t\t\t\treturn false;\n\t\t\ts.push( ori.pop() );\n\t\t\tcout<<\"push\\n\";\n\t\t}\n\t\twhile( !s.empty() )\n\t\t{\n\t\t\tif( s.top()==b[j] )\n\t\t\t{\n\t\t\t\ts.pop();\n\t\t\t\tcout<<\"pop\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( ori.empty() ) \n\t\t\t\t\treturn false;\n\t\t\t\ts.push( ori.pop() );\n\t\t\t\tcout<<\"push\\n\";\n\t\t\t}\n\t\t}\n\t}\n\tif( !s.empty() || !ori.empty() )\n\t\treturn false;\n\treturn true;\n}\n```\n\n#### **3-3-3. 栈混洗与括号匹配：**\n\n值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。\n\n![栈混洗与括号匹配](http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg)\n\n结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配\n\n同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种\n\n### **3-4. 中缀表达式求值：**\n\n#### **3-4-0. 概述：**\n\n中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。\n例如 1+1 即是一个中缀表达式\n\n#### **3-4-1. 算法：**\n\n主体思路：用两个栈分别保存**操作数**和**运算符**，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。\n\n此外，值得注意的是\n\n一：为了方便判断优先级，在优先级表中**同一阶级的运算符根据出现次序不同优先级也不同**，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.\n\n二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)\n\n三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。\n\n四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。\n\n```\nconst char Prior[9][9] = \n{  \n//        +   -   *   /   ^   !   (   )  \\0\n/* + */  '>','>','<','<','<','<','<','>','>',\n/* - */  '>','>','<','<','<','<','<','>','>',\n/* * */  '>','>','>','>','<','<','<','>','>',\n/* / */  '>','>','>','>','<','<','<','>','>',\n/* ^ */  '>','>','>','>','<','<','<','>','>',\n/* ! */  '>','>','>','>','>','>',' ','>','>',\n/* ( */  '<','<','<','<','<','<','<','=',' ',\n/* ) */  ' ',' ',' ',' ',' ',' ',' ',' ',' ',\n/* \\0*/  '<','<','<','<','<','<','<',' ','='\n};\n\nvoid readNumber( char *&s , Stack<float>& opnd)\n{\n\tfloat ans=0;\n\topnd.push( *s-'0' );\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop()*10 + *s-'0' );\n\tif(*s!='.')   // 可能是小数\n\t\treturn;\n\tfloat f=1;\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop() + (*s-'0')*(f/=10.0) );\n\treturn;\n}\nvoid getnum( char a, int & num)\n{\n\tswitch(a)\n\t{\n\tcase '+': num=0;return;\n\tcase '-': num=1;return;\n\tcase '*': num=2;return;\n\tcase '/': num=3;return;\n\tcase '^': num=4;return;\n\tcase '!': num=5;return;\n\tcase '(': num=6;return;\n\tcase ')': num=7;return;\n\tcase '\\0': num=8;return;\n\t}\n}\nchar orderBetween ( char a, char b)\n{\n\tint num1,num2;\n\tgetnum( a, num1 );\n\tgetnum( b, num2 );\n\treturn Prior[num1][num2];\n}\nfloat cal( float num1, char op , float num2)\n{\n\tswitch (op)\n\t{\n\tcase '+': return num1+num2;\n\tcase '-': return num1-num2;\n\tcase '*': return num1*num2;\n\tcase '/': return num1/num2;\n\tcase '^': return pow(num1,num2);\n\tdefault : exit(1);\n\t}\n}\nfloat cal( char op, float num1)\n{\n\tif( abs(num1-0)<1e-6 )\n\t\treturn 1;\n\tfor(int i=1; i<num1 ; i++)\n\t\tnum1*=i;\n\treturn num1;\n}\nfloat evaluate ( char * s )\n{\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t// 逆向取数，可能是'-'号这些和次序相关的运算符\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了\n}\n```\n\n### **3-5. 逆波兰表达式：**\n\n中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。\n\n#### **3-5-0. 概念：**\n\n逆波兰表达式 ( RPN : Reverse Polish Notation )\n\n没有括号和约定俗成的优先级，从左至右扫描表达式，运算符**谁先出现算谁**。\n\n运算符位于参与运算的运算数之后。\n\n例如：\n\n0！1+2 3！*4+5-^\n\n值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。\n\n以上表达式翻译成中缀表达式即是：\n\n( 0! + 1 )^( 2 * 3! +4 - 5 )\n\n和中缀表达式相比，逆波兰表达式的优点在于**计算速度更快**。\n\n在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。\n\n#### **3-5-2. 计算：**\n\n计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。\n\n```\nfloat rpnEvaluate( char * RPN )\n{\n\tStack<float> opnd;\n\tfloat num1,num2;\n\tint len=strlen(RPN);\n\tRPN[len++]='\\0';\n\twhile(len--)\n\t{\n\t\tif( (*RPN)<='9'&&(*RPN)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( RPN, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar op=*RPN;\n\t\t\tif(op=='!')\n\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum2=opnd.pop();\n\t\t\t\tnum1=opnd.pop();\n\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t}\n\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n#### **3-5-2. 手工转换：**\n\n手工将中缀表达式转换成逆波兰表达式的方法如下：\n\n1.用括号显式界定所有运算符\n\n2.将所有运算符移到对应的右括号后面\n\n3.去掉所有括号\n\n4.稍加整理\n\n![手工转换](http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg)\n\n#### **3-5-3. 转换算法：**\n\n非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。\n\n```\n// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上\nvoid append( char *&RPN, float num )\n{\n\tint len=strlen(RPN);\n\tchar buf[64];\n\tif( num!= (float)(int)num )   // 判断是否为整数\n\t\tsprintf( buf, \"%.2f \\0\",num); // 小数暂取两位\n\telse\n\t\tsprintf( buf, \"%d \\0\",(int)num);\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容\n\tstrcat( RPN,buf );\n}\nvoid append( char *&RPN, char op )\n{\n\tint len=strlen( RPN );\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );\n\tsprintf( RPN+len, \"%c \\0\",op );\n}\nfloat evaluate ( char * s , char *&RPN )\n{ // s：中缀表达式， RPN：需要存放转换后表达式的位置\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\tRPN[0]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n//////// RPN转换 ////////\n\t\t\tappend( RPN, opnd.top());\n//////// RPN转换 ////////\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n//////// RPN转换 ////////\n\t\t\t\tappend( RPN, op );\n//////// RPN转换 ////////\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n### **3-6. n皇后问题：**\n\n#### **3-6-0. 概述：**\n\n试探：逐步增加候选解的长度 ，逐步向目标解靠近\n\n回溯：一旦发现和目标解不同，则回溯到上一步继续试探\n\n一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。\n\nn皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。\n\n![n皇后问题](http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg)\n\n#### **3-6-1. 算法：**\n\n用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。\n\n```\ntemplate <typename T>\nint Stack<T>::find( T const & e ) const\n{\n\tfor( int i=0 ; i<_size ; i++)\n\t\tif( data[i] == e )\n\t\t\treturn i;\n\treturn -1;\n}\nstruct Queen\n{\n\tint x,y;\n\tQueen( int xx=0, int yy=0 ):x(xx),y(yy){}\n\tbool operator == ( Queen const & a ) const\n\t{\n\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tbool operator != ( Queen const & a ) const { return !( *this == a );}\n};\nint placeQueens( int n ) // n皇后\n{\n\tint num_solution=0;\n\tStack< Queen >a; \n\tQueen q(0,0);  //当前寻求位置放的皇后\n\tdo\n\t{\n\t\tif( a.size()>=n || q.y>=n ) // 若是列数超出边界或已经构成一个解\n\t\t{\t\n\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试\n\t\t\tq.y++;\n\t\t}\n\t\twhile( q.y<n && a.find(q)>=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突\n\t\t\tq.y++;\n\t\tif( q.y<n )  // 找到位置放置皇后\n\t\t{\n\t\t\ta.push( q );\n\t\t\tif( a.size()>=n )\n\t\t\t\tnum_solution++;\n\t\t\tq.x++;  // 前往下一行找解，列数重置\n\t\t\tq.y=0;\n\t\t}\n\t}\n\twhile( !( q.x==0 && q.y>=n ) );\n\treturn num_solution;\n}\n```\n\n# **队列**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名        | 功能      |\n| ---- | ---------- | ------- |\n| bool | empty()    | 判断是否为空  |\n| int  | size()     | 获取队列的大小 |\n| void | enqueue(n) | 将n入队    |\n| T&   | front()    | 查看队头元素  |\n| T    | dequeue()  | 删除队头元素  |\n| T&   | rear()     | 查看队尾元素  |\n\n## **二. 基本定义：**\n\n队列同样可以用数组或链表实现\n\n### **2-1. 版本一：继承List类**\n\n在这里选择继承[笔记一](https://zedom1.github.io/2017/08/12/list/)中实现的双向链表List类\n\n```\ntemplate <typename T>\nstruct queue:public List<T> //利用双向链表版\n{ // size和empty直接沿用\n\tvoid enqueue ( T const& e ) {insertAsLast(e);}\n\tT dequeue() { return remove(first()); }\n\tT& front() { return first()->data; }\n\tT& rear() { return last()->data; }\n};\n```\n\n### **2-2. 版本二：从零开始的数组版**\n\n用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。\n\n```\ntemplate <typename T>\nstruct queue  // 数组模拟版\n{\nprivate:\n\tT *data;\n\tint first,last,maxsize;\n\nprotected:\n\tvoid expand();\n// expand()判断 last 或 last-first 是否接近maxsize\npublic:\n\tqueue();\n\t~queue() {delete []data;}\n\tbool empty()const {return first==last;}\n\tint size()const {return last-first;}\n\tT& front()const { if(!empty())return data[first]; else exit(1);}\n\tT& rear()const { if(!empty())return data[last-1]; else exit(1);}\n\tvoid enqueue( T const & e) { expand(); data[last++]=e; }\n\tT dequeue() { return data[(first++)-1]; }\n};\n```\n\n### **2-3. 版本三：环状数组版**\n\n与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了\n\n适用于已知数据的规模的情况\n\n数组在逻辑上相连而在物理上不相连，用取余size实现\n\n```\ntemplate <typename T>\nstruct Queue\n{\nprivate:\n\tT *data;\n\tint maxsize;\n\tint first;\n\tint last;\n\tint size;\n\npublic:\n\tQueue(int size=0)\n\t{\n\t\tmaxsize=size+1;\n\t\tlast=0;\n\t\tfirst=1;\n\t\tdata= new T[maxsize];\n\t}\n\t~Queue()\n\t{\n\t\tdelete []data;\n\t}\n\tvoid clear()\n\t{\n\t\tlast=first=0;\n\t}\n\tvoid enqueue(const T & it)\n\t{\n\t\tlast=(last+1)%maxsize;\n\t\tdata[last]=it;\n\t}\n\tT dequeue()\n\t{\n\t\tT it = data[first];\n\t\tfirst = (first+1)%maxsize;\n\t\treturn it;\n\t}\n\tconst T firstValue()\n\t{\n\t\treturn data[first];\n\t}\n\tint length()\n\t{\n\t\treturn ((last+maxsize)-first+1)%maxsize;\n\t}\n\n};\n```\n\n# **完整实现代码**\n\n[栈的完整实现 ( 附带应用的实现 )](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp)\n\n[队列的完整实现](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp)","source":"_posts/DataStructure_Stack.md","raw":"---\nlayout: post\ntitle: \"数据结构笔记（二）：栈和队列\"\ndate: 2017-08-14\ncomments: true\ntags: \n\t- 学习笔记\n\t- c++\n\t- 数据结构\n---\n\n\n# **概述**\n\n**栈**(stack)和**队列**(queue)均属于**线性存储**结构\n\n栈特性：\n\n> 1. LIFO ( last in first out ) 后进先出\n> 2. 元素插入和删除仅在一端进行\n\n队列特性：\n\n> 1. FIFO ( first in first out ) 先进先出\n> 2. 元素在队尾插入，在队头删除\n\n![栈和队列](http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg)\n\n这两种结构均可以用数组或链表实现\n\n本文主要介绍栈，以下实现均为c++.\n\n<!-- more -->\n\n# **栈**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名     | 功能        |\n| ---- | ------- | --------- |\n| bool | empty() | 判断是否为空    |\n| int  | size()  | 获取栈的大小    |\n| void | push(n) | 将n压入栈     |\n| T&   | top()   | 取栈顶元素而不弹出 |\n| T    | pop()   | 弹出栈顶元素    |\n\n## **二. 基本定义：**\n\n本文用数组实现栈。\n在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。\n\n（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）\n\n栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。\n\n```\ntemplate <typename T>\nstruct Stack\n{\nprivate:\n\tT *data;\n\tint _size,maxsize;   // 当前规模和最大规模\n\nprotected:\n\tvoid expand();  // 扩容\n\tvoid shrink();  // 缩容\n\npublic:\n\tStack(){ _size =0 ; maxsize=4; data=new T[maxsize]; };\n\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶\n\t~Stack() { delete []data; }\n\tvoid push( T const & e ) { expand(); data[_size++]=e;  }\n\tT pop( ) { shrink(); return data[--_size];   }\n\tT & top( ) { return data[_size-1];};\n\tint empty()const {return _size==0;}\n\tint size()const {return _size;}\n\tint find( T const & e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题\n};\n```\n\n## **三. 典型应用：**\n\n**一. 逆序输出**\n\n输出次序和处理过程颠倒\n\n例如：进制转换\n\n**二. 递归嵌套**\n\n具有自相似性 ( 总体和局部相似 )\n\n例如：括号匹配、栈混洗(stack permutation)\n\n**三. 延迟缓冲**\n\n线性扫描算法模式\n\n例如：中缀表达式求值\n\n**四. 栈式计算**\n\n例如：逆波兰表达式转换（RPN Reverse Polish Notation）\n\n**五. 试探回溯**\n\n例如：n皇后问题、寻路\n\n下面开始一一介绍这些应用：\n\n### **3-1. 进制转换：**\n\n思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。\n\n借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。\n\n```\nvoid convert(  int n , int base ) \n{\n\tStack<char>s;\n\tstatic char digit[]=\n\t{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\t// 进制限定在2-16，有需要可以继续扩展\n\twhile(n)\n\t{\n\t\ts.push( digit[n%base]);\n\t\tn/=base;\n\t}\n\twhile( !s.empty() )\n\t\tcout<<s.pop();\n\tcout<<endl;\n}\n```\n\n### **3-2. 括号匹配：**\n\n判断某一表达式内的括号是否完全匹配\n\n对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。\n\n然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。\n\n而借助栈我们能够很轻松地完成多括号匹配的任务。\n\n思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。\n\n显示为流程图即是\n\n![流程图](http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG)\n\n下面来看一下代码\n\n```\nbool judge ( char *s , int n ) \n{\n\tStack<char>a;\n\tfor(int i=0 ; i<n; i++)\n\t{\n\t\tif( s[i]!='(' && s[i]!=')' && s[i]!='[' && s[i]!=']' )\n\t\t\tcontinue;\n\t\tif( s[i]=='('|| s[i]=='[')\n\t\t\ta.push(s[i]);\n\t\telse if(a.empty())\n\t\t\treturn false;\n\t\telse if( (s[i]==')'&&a.top()=='(') || (s[i]==']'&&a.top()=='[') )\n\t\t\ta.pop();\n\t}\n\tif(\ta.empty() )\n\t\treturn true;\n\treturn false;\n}\n```\n\n### **3-3. 栈混洗：**\n\n#### **3-3-0. 概念：**\n\n栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。\n\n栈混洗的过程中只允许以下两个操作：\n\n> 1. A栈顶弹出并压入栈S S.push(A.pop())\n> 2. S栈顶弹出并压入栈B B.push(S.pop())\n\n#### **3-3-1. 排列种数：**\n\n先来计算一下栈通过栈混洗操作后有多少种排列方式：\n\n设总数为n的栈有SP(n)种排列方式\n\n推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]\n对于第一个元素而言，它的排列方式有SP(n)种。\n\n$$SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)$$\n\n解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$\n\n#### **3-3-2. 甄别栈混洗：**\n\n如何甄别一个序列是否是栈混洗呢？\n\n三个元素栈混洗有5种，全排列有6种, <1,2,3] 非栈混洗的排列为 <2,1,3] ( ‘<’为栈顶方向 )\n\n而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关\n\n对于 1<=i < j < k<=n,若出现 k i j的排列，则非栈混洗 （称为**禁形**）\n\n![禁形1](http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg)\n\n通过证明，禁形对于是否是栈混洗为 **充要条件**\n\n![禁形2](http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg)\n\n那么我们可以得到如下的判别方法：\n\nO(n3)判别方法：分别枚举i，j，k\n\nO(n2)判别方法：枚举 i , j , j+1\n\nO(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗\n\n以下为O(n)的判别方法的实现：\n\n```\ntemplate <typename T>\nbool stackPermutation( T *origin, T * b , int n )\n{\n\tStack<T> s;\n\tStack<T> ori( origin ,n );\n\tfor( int j=0; j<n ; j++ )\n\t{\t\n\t\tif( s.empty() )\n\t\t{\t\n\t\t\tif( ori.empty() ) \n\t\t\t\treturn false;\n\t\t\ts.push( ori.pop() );\n\t\t\tcout<<\"push\\n\";\n\t\t}\n\t\twhile( !s.empty() )\n\t\t{\n\t\t\tif( s.top()==b[j] )\n\t\t\t{\n\t\t\t\ts.pop();\n\t\t\t\tcout<<\"pop\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( ori.empty() ) \n\t\t\t\t\treturn false;\n\t\t\t\ts.push( ori.pop() );\n\t\t\t\tcout<<\"push\\n\";\n\t\t\t}\n\t\t}\n\t}\n\tif( !s.empty() || !ori.empty() )\n\t\treturn false;\n\treturn true;\n}\n```\n\n#### **3-3-3. 栈混洗与括号匹配：**\n\n值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。\n\n![栈混洗与括号匹配](http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg)\n\n结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配\n\n同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种\n\n### **3-4. 中缀表达式求值：**\n\n#### **3-4-0. 概述：**\n\n中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。\n例如 1+1 即是一个中缀表达式\n\n#### **3-4-1. 算法：**\n\n主体思路：用两个栈分别保存**操作数**和**运算符**，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。\n\n此外，值得注意的是\n\n一：为了方便判断优先级，在优先级表中**同一阶级的运算符根据出现次序不同优先级也不同**，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.\n\n二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)\n\n三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。\n\n四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。\n\n```\nconst char Prior[9][9] = \n{  \n//        +   -   *   /   ^   !   (   )  \\0\n/* + */  '>','>','<','<','<','<','<','>','>',\n/* - */  '>','>','<','<','<','<','<','>','>',\n/* * */  '>','>','>','>','<','<','<','>','>',\n/* / */  '>','>','>','>','<','<','<','>','>',\n/* ^ */  '>','>','>','>','<','<','<','>','>',\n/* ! */  '>','>','>','>','>','>',' ','>','>',\n/* ( */  '<','<','<','<','<','<','<','=',' ',\n/* ) */  ' ',' ',' ',' ',' ',' ',' ',' ',' ',\n/* \\0*/  '<','<','<','<','<','<','<',' ','='\n};\n\nvoid readNumber( char *&s , Stack<float>& opnd)\n{\n\tfloat ans=0;\n\topnd.push( *s-'0' );\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop()*10 + *s-'0' );\n\tif(*s!='.')   // 可能是小数\n\t\treturn;\n\tfloat f=1;\n\twhile( *(++s)<='9'&& *s>='0' )\n\t\topnd.push( opnd.pop() + (*s-'0')*(f/=10.0) );\n\treturn;\n}\nvoid getnum( char a, int & num)\n{\n\tswitch(a)\n\t{\n\tcase '+': num=0;return;\n\tcase '-': num=1;return;\n\tcase '*': num=2;return;\n\tcase '/': num=3;return;\n\tcase '^': num=4;return;\n\tcase '!': num=5;return;\n\tcase '(': num=6;return;\n\tcase ')': num=7;return;\n\tcase '\\0': num=8;return;\n\t}\n}\nchar orderBetween ( char a, char b)\n{\n\tint num1,num2;\n\tgetnum( a, num1 );\n\tgetnum( b, num2 );\n\treturn Prior[num1][num2];\n}\nfloat cal( float num1, char op , float num2)\n{\n\tswitch (op)\n\t{\n\tcase '+': return num1+num2;\n\tcase '-': return num1-num2;\n\tcase '*': return num1*num2;\n\tcase '/': return num1/num2;\n\tcase '^': return pow(num1,num2);\n\tdefault : exit(1);\n\t}\n}\nfloat cal( char op, float num1)\n{\n\tif( abs(num1-0)<1e-6 )\n\t\treturn 1;\n\tfor(int i=1; i<num1 ; i++)\n\t\tnum1*=i;\n\treturn num1;\n}\nfloat evaluate ( char * s )\n{\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t// 逆向取数，可能是'-'号这些和次序相关的运算符\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了\n}\n```\n\n### **3-5. 逆波兰表达式：**\n\n中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。\n\n#### **3-5-0. 概念：**\n\n逆波兰表达式 ( RPN : Reverse Polish Notation )\n\n没有括号和约定俗成的优先级，从左至右扫描表达式，运算符**谁先出现算谁**。\n\n运算符位于参与运算的运算数之后。\n\n例如：\n\n0！1+2 3！*4+5-^\n\n值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。\n\n以上表达式翻译成中缀表达式即是：\n\n( 0! + 1 )^( 2 * 3! +4 - 5 )\n\n和中缀表达式相比，逆波兰表达式的优点在于**计算速度更快**。\n\n在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。\n\n#### **3-5-2. 计算：**\n\n计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。\n\n```\nfloat rpnEvaluate( char * RPN )\n{\n\tStack<float> opnd;\n\tfloat num1,num2;\n\tint len=strlen(RPN);\n\tRPN[len++]='\\0';\n\twhile(len--)\n\t{\n\t\tif( (*RPN)<='9'&&(*RPN)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( RPN, opnd );  // 可能是多位数\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar op=*RPN;\n\t\t\tif(op=='!')\n\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum2=opnd.pop();\n\t\t\t\tnum1=opnd.pop();\n\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t}\n\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n#### **3-5-2. 手工转换：**\n\n手工将中缀表达式转换成逆波兰表达式的方法如下：\n\n1.用括号显式界定所有运算符\n\n2.将所有运算符移到对应的右括号后面\n\n3.去掉所有括号\n\n4.稍加整理\n\n![手工转换](http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg)\n\n#### **3-5-3. 转换算法：**\n\n非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。\n\n```\n// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上\nvoid append( char *&RPN, float num )\n{\n\tint len=strlen(RPN);\n\tchar buf[64];\n\tif( num!= (float)(int)num )   // 判断是否为整数\n\t\tsprintf( buf, \"%.2f \\0\",num); // 小数暂取两位\n\telse\n\t\tsprintf( buf, \"%d \\0\",(int)num);\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容\n\tstrcat( RPN,buf );\n}\nvoid append( char *&RPN, char op )\n{\n\tint len=strlen( RPN );\n\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );\n\tsprintf( RPN+len, \"%c \\0\",op );\n}\nfloat evaluate ( char * s , char *&RPN )\n{ // s：中缀表达式， RPN：需要存放转换后表达式的位置\n\tStack<float> opnd;\n\tStack<char> optr;\n\tfloat num1,num2;\n\ts[strlen(s)]='\\0';\n\tRPN[0]='\\0';\n\toptr.push('\\0'); // 结尾操作符\n\twhile( !optr.empty() )\n\t{\n\t\tif( (*s)<='9'&&(*s)>='0' ) //当前是操作数\n\t\t{\t\n\t\t\treadNumber( s, opnd );  // 可能是多位数\n//////// RPN转换 ////////\n\t\t\tappend( RPN, opnd.top());\n//////// RPN转换 ////////\n\t\t}\n\t\telse\n\t\t\tswitch( orderBetween( optr.top(),*s ) )\n\t\t\t{\n\t\t\tcase '<': optr.push(*s); s++; break;\n\t\t\tcase '=': optr.pop(); s++; break; // () \\0\n\t\t\tcase '>': \n\t\t\t{\n\t\t\t\tchar op=optr.pop();\n//////// RPN转换 ////////\n\t\t\t\tappend( RPN, op );\n//////// RPN转换 ////////\n\t\t\t\tif(op=='!')\n\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum2=opnd.pop();\n\t\t\t\t\tnum1=opnd.pop();\n\t\t\t\t\topnd.push( cal(num1,op,num2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\treturn opnd.pop();\n}\n```\n\n### **3-6. n皇后问题：**\n\n#### **3-6-0. 概述：**\n\n试探：逐步增加候选解的长度 ，逐步向目标解靠近\n\n回溯：一旦发现和目标解不同，则回溯到上一步继续试探\n\n一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。\n\nn皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。\n\n![n皇后问题](http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg)\n\n#### **3-6-1. 算法：**\n\n用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。\n\n```\ntemplate <typename T>\nint Stack<T>::find( T const & e ) const\n{\n\tfor( int i=0 ; i<_size ; i++)\n\t\tif( data[i] == e )\n\t\t\treturn i;\n\treturn -1;\n}\nstruct Queen\n{\n\tint x,y;\n\tQueen( int xx=0, int yy=0 ):x(xx),y(yy){}\n\tbool operator == ( Queen const & a ) const\n\t{\n\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tbool operator != ( Queen const & a ) const { return !( *this == a );}\n};\nint placeQueens( int n ) // n皇后\n{\n\tint num_solution=0;\n\tStack< Queen >a; \n\tQueen q(0,0);  //当前寻求位置放的皇后\n\tdo\n\t{\n\t\tif( a.size()>=n || q.y>=n ) // 若是列数超出边界或已经构成一个解\n\t\t{\t\n\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试\n\t\t\tq.y++;\n\t\t}\n\t\twhile( q.y<n && a.find(q)>=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突\n\t\t\tq.y++;\n\t\tif( q.y<n )  // 找到位置放置皇后\n\t\t{\n\t\t\ta.push( q );\n\t\t\tif( a.size()>=n )\n\t\t\t\tnum_solution++;\n\t\t\tq.x++;  // 前往下一行找解，列数重置\n\t\t\tq.y=0;\n\t\t}\n\t}\n\twhile( !( q.x==0 && q.y>=n ) );\n\treturn num_solution;\n}\n```\n\n# **队列**\n\n## **一. 常用接口：**\n\n```\ntemplate <typename T>\n```\n\n| 返回值  | 函数名        | 功能      |\n| ---- | ---------- | ------- |\n| bool | empty()    | 判断是否为空  |\n| int  | size()     | 获取队列的大小 |\n| void | enqueue(n) | 将n入队    |\n| T&   | front()    | 查看队头元素  |\n| T    | dequeue()  | 删除队头元素  |\n| T&   | rear()     | 查看队尾元素  |\n\n## **二. 基本定义：**\n\n队列同样可以用数组或链表实现\n\n### **2-1. 版本一：继承List类**\n\n在这里选择继承[笔记一](https://zedom1.github.io/2017/08/12/list/)中实现的双向链表List类\n\n```\ntemplate <typename T>\nstruct queue:public List<T> //利用双向链表版\n{ // size和empty直接沿用\n\tvoid enqueue ( T const& e ) {insertAsLast(e);}\n\tT dequeue() { return remove(first()); }\n\tT& front() { return first()->data; }\n\tT& rear() { return last()->data; }\n};\n```\n\n### **2-2. 版本二：从零开始的数组版**\n\n用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。\n\n```\ntemplate <typename T>\nstruct queue  // 数组模拟版\n{\nprivate:\n\tT *data;\n\tint first,last,maxsize;\n\nprotected:\n\tvoid expand();\n// expand()判断 last 或 last-first 是否接近maxsize\npublic:\n\tqueue();\n\t~queue() {delete []data;}\n\tbool empty()const {return first==last;}\n\tint size()const {return last-first;}\n\tT& front()const { if(!empty())return data[first]; else exit(1);}\n\tT& rear()const { if(!empty())return data[last-1]; else exit(1);}\n\tvoid enqueue( T const & e) { expand(); data[last++]=e; }\n\tT dequeue() { return data[(first++)-1]; }\n};\n```\n\n### **2-3. 版本三：环状数组版**\n\n与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了\n\n适用于已知数据的规模的情况\n\n数组在逻辑上相连而在物理上不相连，用取余size实现\n\n```\ntemplate <typename T>\nstruct Queue\n{\nprivate:\n\tT *data;\n\tint maxsize;\n\tint first;\n\tint last;\n\tint size;\n\npublic:\n\tQueue(int size=0)\n\t{\n\t\tmaxsize=size+1;\n\t\tlast=0;\n\t\tfirst=1;\n\t\tdata= new T[maxsize];\n\t}\n\t~Queue()\n\t{\n\t\tdelete []data;\n\t}\n\tvoid clear()\n\t{\n\t\tlast=first=0;\n\t}\n\tvoid enqueue(const T & it)\n\t{\n\t\tlast=(last+1)%maxsize;\n\t\tdata[last]=it;\n\t}\n\tT dequeue()\n\t{\n\t\tT it = data[first];\n\t\tfirst = (first+1)%maxsize;\n\t\treturn it;\n\t}\n\tconst T firstValue()\n\t{\n\t\treturn data[first];\n\t}\n\tint length()\n\t{\n\t\treturn ((last+maxsize)-first+1)%maxsize;\n\t}\n\n};\n```\n\n# **完整实现代码**\n\n[栈的完整实现 ( 附带应用的实现 )](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp)\n\n[队列的完整实现](https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp)","slug":"DataStructure_Stack","published":1,"updated":"2018-05-25T12:41:12.313Z","photos":[],"link":"","_id":"cjhvssaem001ajvfcu0umxmfn","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><p><strong>栈</strong>(stack)和<strong>队列</strong>(queue)均属于<strong>线性存储</strong>结构</p>\n<p>栈特性：</p>\n<blockquote>\n<ol>\n<li>LIFO ( last in first out ) 后进先出</li>\n<li>元素插入和删除仅在一端进行</li>\n</ol>\n</blockquote>\n<p>队列特性：</p>\n<blockquote>\n<ol>\n<li>FIFO ( first in first out ) 先进先出</li>\n<li>元素在队尾插入，在队头删除</li>\n</ol>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg\" alt=\"栈和队列\"></p>\n<p>这两种结构均可以用数组或链表实现</p>\n<p>本文主要介绍栈，以下实现均为c++.</p>\n<a id=\"more\"></a>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a><strong>栈</strong></h1><h2 id=\"一-常用接口：\"><a href=\"#一-常用接口：\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取栈的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>push(n)</td>\n<td>将n压入栈</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>top()</td>\n<td>取栈顶元素而不弹出</td>\n</tr>\n<tr>\n<td>T</td>\n<td>pop()</td>\n<td>弹出栈顶元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：\"><a href=\"#二-基本定义：\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>本文用数组实现栈。<br>在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。</p>\n<p>（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）</p>\n<p>栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Stack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint _size,maxsize;   // 当前规模和最大规模</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();  // 扩容</span><br><span class=\"line\">\tvoid shrink();  // 缩容</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tStack()&#123; _size =0 ; maxsize=4; data=new T[maxsize]; &#125;;</span><br><span class=\"line\">\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶</span><br><span class=\"line\">\t~Stack() &#123; delete []data; &#125;</span><br><span class=\"line\">\tvoid push( T const &amp; e ) &#123; expand(); data[_size++]=e;  &#125;</span><br><span class=\"line\">\tT pop( ) &#123; shrink(); return data[--_size];   &#125;</span><br><span class=\"line\">\tT &amp; top( ) &#123; return data[_size-1];&#125;;</span><br><span class=\"line\">\tint empty()const &#123;return _size==0;&#125;</span><br><span class=\"line\">\tint size()const &#123;return _size;&#125;</span><br><span class=\"line\">\tint find( T const &amp; e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-典型应用：\"><a href=\"#三-典型应用：\" class=\"headerlink\" title=\"三. 典型应用：\"></a><strong>三. 典型应用：</strong></h2><p><strong>一. 逆序输出</strong></p>\n<p>输出次序和处理过程颠倒</p>\n<p>例如：进制转换</p>\n<p><strong>二. 递归嵌套</strong></p>\n<p>具有自相似性 ( 总体和局部相似 )</p>\n<p>例如：括号匹配、栈混洗(stack permutation)</p>\n<p><strong>三. 延迟缓冲</strong></p>\n<p>线性扫描算法模式</p>\n<p>例如：中缀表达式求值</p>\n<p><strong>四. 栈式计算</strong></p>\n<p>例如：逆波兰表达式转换（RPN Reverse Polish Notation）</p>\n<p><strong>五. 试探回溯</strong></p>\n<p>例如：n皇后问题、寻路</p>\n<p>下面开始一一介绍这些应用：</p>\n<h3 id=\"3-1-进制转换：\"><a href=\"#3-1-进制转换：\" class=\"headerlink\" title=\"3-1. 进制转换：\"></a><strong>3-1. 进制转换：</strong></h3><p>思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。</p>\n<p>借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void convert(  int n , int base ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;s;</span><br><span class=\"line\">\tstatic char digit[]=</span><br><span class=\"line\">\t&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;;</span><br><span class=\"line\">\t// 进制限定在2-16，有需要可以继续扩展</span><br><span class=\"line\">\twhile(n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts.push( digit[n%base]);</span><br><span class=\"line\">\t\tn/=base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t\tcout&lt;&lt;s.pop();</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-括号匹配：\"><a href=\"#3-2-括号匹配：\" class=\"headerlink\" title=\"3-2. 括号匹配：\"></a><strong>3-2. 括号匹配：</strong></h3><p>判断某一表达式内的括号是否完全匹配</p>\n<p>对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。</p>\n<p>然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。</p>\n<p>而借助栈我们能够很轻松地完成多括号匹配的任务。</p>\n<p>思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。</p>\n<p>显示为流程图即是</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG\" alt=\"流程图\"></p>\n<p>下面来看一下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool judge ( char *s , int n ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;a;</span><br><span class=\"line\">\tfor(int i=0 ; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( s[i]!=&apos;(&apos; &amp;&amp; s[i]!=&apos;)&apos; &amp;&amp; s[i]!=&apos;[&apos; &amp;&amp; s[i]!=&apos;]&apos; )</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tif( s[i]==&apos;(&apos;|| s[i]==&apos;[&apos;)</span><br><span class=\"line\">\t\t\ta.push(s[i]);</span><br><span class=\"line\">\t\telse if(a.empty())</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\telse if( (s[i]==&apos;)&apos;&amp;&amp;a.top()==&apos;(&apos;) || (s[i]==&apos;]&apos;&amp;&amp;a.top()==&apos;[&apos;) )</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(\ta.empty() )</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-栈混洗：\"><a href=\"#3-3-栈混洗：\" class=\"headerlink\" title=\"3-3. 栈混洗：\"></a><strong>3-3. 栈混洗：</strong></h3><h4 id=\"3-3-0-概念：\"><a href=\"#3-3-0-概念：\" class=\"headerlink\" title=\"3-3-0. 概念：\"></a><strong>3-3-0. 概念：</strong></h4><p>栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。</p>\n<p>栈混洗的过程中只允许以下两个操作：</p>\n<blockquote>\n<ol>\n<li>A栈顶弹出并压入栈S S.push(A.pop())</li>\n<li>S栈顶弹出并压入栈B B.push(S.pop())</li>\n</ol>\n</blockquote>\n<h4 id=\"3-3-1-排列种数：\"><a href=\"#3-3-1-排列种数：\" class=\"headerlink\" title=\"3-3-1. 排列种数：\"></a><strong>3-3-1. 排列种数：</strong></h4><p>先来计算一下栈通过栈混洗操作后有多少种排列方式：</p>\n<p>设总数为n的栈有SP(n)种排列方式</p>\n<p>推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]<br>对于第一个元素而言，它的排列方式有SP(n)种。</p>\n<script type=\"math/tex; mode=display\">SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)</script><p>解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$</p>\n<h4 id=\"3-3-2-甄别栈混洗：\"><a href=\"#3-3-2-甄别栈混洗：\" class=\"headerlink\" title=\"3-3-2. 甄别栈混洗：\"></a><strong>3-3-2. 甄别栈混洗：</strong></h4><p>如何甄别一个序列是否是栈混洗呢？</p>\n<p>三个元素栈混洗有5种，全排列有6种, &lt;1,2,3] 非栈混洗的排列为 &lt;2,1,3] ( ‘&lt;’为栈顶方向 )</p>\n<p>而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关</p>\n<p>对于 1&lt;=i &lt; j &lt; k&lt;=n,若出现 k i j的排列，则非栈混洗 （称为<strong>禁形</strong>）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg\" alt=\"禁形1\"></p>\n<p>通过证明，禁形对于是否是栈混洗为 <strong>充要条件</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg\" alt=\"禁形2\"></p>\n<p>那么我们可以得到如下的判别方法：</p>\n<p>O(n3)判别方法：分别枚举i，j，k</p>\n<p>O(n2)判别方法：枚举 i , j , j+1</p>\n<p>O(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗</p>\n<p>以下为O(n)的判别方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool stackPermutation( T *origin, T * b , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;T&gt; s;</span><br><span class=\"line\">\tStack&lt;T&gt; ori( origin ,n );</span><br><span class=\"line\">\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s.empty() )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( !s.empty() )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( s.top()==b[j] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ts.pop();</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;pop\\n&quot;;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s.empty() || !ori.empty() )</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-栈混洗与括号匹配：\"><a href=\"#3-3-3-栈混洗与括号匹配：\" class=\"headerlink\" title=\"3-3-3. 栈混洗与括号匹配：\"></a><strong>3-3-3. 栈混洗与括号匹配：</strong></h4><p>值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg\" alt=\"栈混洗与括号匹配\"></p>\n<p>结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配</p>\n<p>同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种</p>\n<h3 id=\"3-4-中缀表达式求值：\"><a href=\"#3-4-中缀表达式求值：\" class=\"headerlink\" title=\"3-4. 中缀表达式求值：\"></a><strong>3-4. 中缀表达式求值：</strong></h3><h4 id=\"3-4-0-概述：\"><a href=\"#3-4-0-概述：\" class=\"headerlink\" title=\"3-4-0. 概述：\"></a><strong>3-4-0. 概述：</strong></h4><p>中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。<br>例如 1+1 即是一个中缀表达式</p>\n<h4 id=\"3-4-1-算法：\"><a href=\"#3-4-1-算法：\" class=\"headerlink\" title=\"3-4-1. 算法：\"></a><strong>3-4-1. 算法：</strong></h4><p>主体思路：用两个栈分别保存<strong>操作数</strong>和<strong>运算符</strong>，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。</p>\n<p>此外，值得注意的是</p>\n<p>一：为了方便判断优先级，在优先级表中<strong>同一阶级的运算符根据出现次序不同优先级也不同</strong>，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.</p>\n<p>二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)</p>\n<p>三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。</p>\n<p>四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const char Prior[9][9] = </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">//        +   -   *   /   ^   !   (   )  \\0</span><br><span class=\"line\">/* + */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* - */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* * */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* / */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ^ */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ! */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos; &apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ( */  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;=&apos;,&apos; &apos;,</span><br><span class=\"line\">/* ) */  &apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,</span><br><span class=\"line\">/* \\0*/  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos; &apos;,&apos;=&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void readNumber( char *&amp;s , Stack&lt;float&gt;&amp; opnd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat ans=0;</span><br><span class=\"line\">\topnd.push( *s-&apos;0&apos; );</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop()*10 + *s-&apos;0&apos; );</span><br><span class=\"line\">\tif(*s!=&apos;.&apos;)   // 可能是小数</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfloat f=1;</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop() + (*s-&apos;0&apos;)*(f/=10.0) );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void getnum( char a, int &amp; num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch(a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: num=0;return;</span><br><span class=\"line\">\tcase &apos;-&apos;: num=1;return;</span><br><span class=\"line\">\tcase &apos;*&apos;: num=2;return;</span><br><span class=\"line\">\tcase &apos;/&apos;: num=3;return;</span><br><span class=\"line\">\tcase &apos;^&apos;: num=4;return;</span><br><span class=\"line\">\tcase &apos;!&apos;: num=5;return;</span><br><span class=\"line\">\tcase &apos;(&apos;: num=6;return;</span><br><span class=\"line\">\tcase &apos;)&apos;: num=7;return;</span><br><span class=\"line\">\tcase &apos;\\0&apos;: num=8;return;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char orderBetween ( char a, char b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num1,num2;</span><br><span class=\"line\">\tgetnum( a, num1 );</span><br><span class=\"line\">\tgetnum( b, num2 );</span><br><span class=\"line\">\treturn Prior[num1][num2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( float num1, char op , float num2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch (op)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: return num1+num2;</span><br><span class=\"line\">\tcase &apos;-&apos;: return num1-num2;</span><br><span class=\"line\">\tcase &apos;*&apos;: return num1*num2;</span><br><span class=\"line\">\tcase &apos;/&apos;: return num1/num2;</span><br><span class=\"line\">\tcase &apos;^&apos;: return pow(num1,num2);</span><br><span class=\"line\">\tdefault : exit(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( char op, float num1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( abs(num1-0)&lt;1e-6 )</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;num1 ; i++)</span><br><span class=\"line\">\t\tnum1*=i;</span><br><span class=\"line\">\treturn num1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t// 逆向取数，可能是&apos;-&apos;号这些和次序相关的运算符</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-逆波兰表达式：\"><a href=\"#3-5-逆波兰表达式：\" class=\"headerlink\" title=\"3-5. 逆波兰表达式：\"></a><strong>3-5. 逆波兰表达式：</strong></h3><p>中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。</p>\n<h4 id=\"3-5-0-概念：\"><a href=\"#3-5-0-概念：\" class=\"headerlink\" title=\"3-5-0. 概念：\"></a><strong>3-5-0. 概念：</strong></h4><p>逆波兰表达式 ( RPN : Reverse Polish Notation )</p>\n<p>没有括号和约定俗成的优先级，从左至右扫描表达式，运算符<strong>谁先出现算谁</strong>。</p>\n<p>运算符位于参与运算的运算数之后。</p>\n<p>例如：</p>\n<p>0！1+2 3！*4+5-^</p>\n<p>值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。</p>\n<p>以上表达式翻译成中缀表达式即是：</p>\n<p>( 0! + 1 )^( 2 * 3! +4 - 5 )</p>\n<p>和中缀表达式相比，逆波兰表达式的优点在于<strong>计算速度更快</strong>。</p>\n<p>在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。</p>\n<h4 id=\"3-5-2-计算：\"><a href=\"#3-5-2-计算：\" class=\"headerlink\" title=\"3-5-2. 计算：\"></a><strong>3-5-2. 计算：</strong></h4><p>计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float rpnEvaluate( char * RPN )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tRPN[len++]=&apos;\\0&apos;;</span><br><span class=\"line\">\twhile(len--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*RPN)&lt;=&apos;9&apos;&amp;&amp;(*RPN)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( RPN, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchar op=*RPN;</span><br><span class=\"line\">\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-5-2-手工转换：\"><a href=\"#3-5-2-手工转换：\" class=\"headerlink\" title=\"3-5-2. 手工转换：\"></a><strong>3-5-2. 手工转换：</strong></h4><p>手工将中缀表达式转换成逆波兰表达式的方法如下：</p>\n<p>1.用括号显式界定所有运算符</p>\n<p>2.将所有运算符移到对应的右括号后面</p>\n<p>3.去掉所有括号</p>\n<p>4.稍加整理</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg\" alt=\"手工转换\"></p>\n<h4 id=\"3-5-3-转换算法：\"><a href=\"#3-5-3-转换算法：\" class=\"headerlink\" title=\"3-5-3. 转换算法：\"></a><strong>3-5-3. 转换算法：</strong></h4><p>非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上</span><br><span class=\"line\">void append( char *&amp;RPN, float num )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tchar buf[64];</span><br><span class=\"line\">\tif( num!= (float)(int)num )   // 判断是否为整数</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%.2f \\0&quot;,num); // 小数暂取两位</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%d \\0&quot;,(int)num);</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容</span><br><span class=\"line\">\tstrcat( RPN,buf );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void append( char *&amp;RPN, char op )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen( RPN );</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );</span><br><span class=\"line\">\tsprintf( RPN+len, &quot;%c \\0&quot;,op );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s , char *&amp;RPN )</span><br><span class=\"line\">&#123; // s：中缀表达式， RPN：需要存放转换后表达式的位置</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\tRPN[0]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\tappend( RPN, opnd.top());</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tappend( RPN, op );</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-n皇后问题：\"><a href=\"#3-6-n皇后问题：\" class=\"headerlink\" title=\"3-6. n皇后问题：\"></a><strong>3-6. n皇后问题：</strong></h3><h4 id=\"3-6-0-概述：\"><a href=\"#3-6-0-概述：\" class=\"headerlink\" title=\"3-6-0. 概述：\"></a><strong>3-6-0. 概述：</strong></h4><p>试探：逐步增加候选解的长度 ，逐步向目标解靠近</p>\n<p>回溯：一旦发现和目标解不同，则回溯到上一步继续试探</p>\n<p>一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。</p>\n<p>n皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg\" alt=\"n皇后问题\"></p>\n<h4 id=\"3-6-1-算法：\"><a href=\"#3-6-1-算法：\" class=\"headerlink\" title=\"3-6-1. 算法：\"></a><strong>3-6-1. 算法：</strong></h4><p>用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Stack&lt;T&gt;::find( T const &amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0 ; i&lt;_size ; i++)</span><br><span class=\"line\">\t\tif( data[i] == e )</span><br><span class=\"line\">\t\t\treturn i;</span><br><span class=\"line\">\treturn -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct Queen</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint x,y;</span><br><span class=\"line\">\tQueen( int xx=0, int yy=0 ):x(xx),y(yy)&#123;&#125;</span><br><span class=\"line\">\tbool operator == ( Queen const &amp; a ) const</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbool operator != ( Queen const &amp; a ) const &#123; return !( *this == a );&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int placeQueens( int n ) // n皇后</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num_solution=0;</span><br><span class=\"line\">\tStack&lt; Queen &gt;a; </span><br><span class=\"line\">\tQueen q(0,0);  //当前寻求位置放的皇后</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( a.size()&gt;=n || q.y&gt;=n ) // 若是列数超出边界或已经构成一个解</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( q.y&lt;n &amp;&amp; a.find(q)&gt;=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\tif( q.y&lt;n )  // 找到位置放置皇后</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta.push( q );</span><br><span class=\"line\">\t\t\tif( a.size()&gt;=n )</span><br><span class=\"line\">\t\t\t\tnum_solution++;</span><br><span class=\"line\">\t\t\tq.x++;  // 前往下一行找解，列数重置</span><br><span class=\"line\">\t\t\tq.y=0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !( q.x==0 &amp;&amp; q.y&gt;=n ) );</span><br><span class=\"line\">\treturn num_solution;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a><strong>队列</strong></h1><h2 id=\"一-常用接口：-1\"><a href=\"#一-常用接口：-1\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取队列的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>enqueue(n)</td>\n<td>将n入队</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>front()</td>\n<td>查看队头元素</td>\n</tr>\n<tr>\n<td>T</td>\n<td>dequeue()</td>\n<td>删除队头元素</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>rear()</td>\n<td>查看队尾元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：-1\"><a href=\"#二-基本定义：-1\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>队列同样可以用数组或链表实现</p>\n<h3 id=\"2-1-版本一：继承List类\"><a href=\"#2-1-版本一：继承List类\" class=\"headerlink\" title=\"2-1. 版本一：继承List类\"></a><strong>2-1. 版本一：继承List类</strong></h3><p>在这里选择继承<a href=\"https://zedom1.github.io/2017/08/12/list/\">笔记一</a>中实现的双向链表List类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue:public List&lt;T&gt; //利用双向链表版</span><br><span class=\"line\">&#123; // size和empty直接沿用</span><br><span class=\"line\">\tvoid enqueue ( T const&amp; e ) &#123;insertAsLast(e);&#125;</span><br><span class=\"line\">\tT dequeue() &#123; return remove(first()); &#125;</span><br><span class=\"line\">\tT&amp; front() &#123; return first()-&gt;data; &#125;</span><br><span class=\"line\">\tT&amp; rear() &#123; return last()-&gt;data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-版本二：从零开始的数组版\"><a href=\"#2-2-版本二：从零开始的数组版\" class=\"headerlink\" title=\"2-2. 版本二：从零开始的数组版\"></a><strong>2-2. 版本二：从零开始的数组版</strong></h3><p>用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue  // 数组模拟版</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint first,last,maxsize;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();</span><br><span class=\"line\">// expand()判断 last 或 last-first 是否接近maxsize</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tqueue();</span><br><span class=\"line\">\t~queue() &#123;delete []data;&#125;</span><br><span class=\"line\">\tbool empty()const &#123;return first==last;&#125;</span><br><span class=\"line\">\tint size()const &#123;return last-first;&#125;</span><br><span class=\"line\">\tT&amp; front()const &#123; if(!empty())return data[first]; else exit(1);&#125;</span><br><span class=\"line\">\tT&amp; rear()const &#123; if(!empty())return data[last-1]; else exit(1);&#125;</span><br><span class=\"line\">\tvoid enqueue( T const &amp; e) &#123; expand(); data[last++]=e; &#125;</span><br><span class=\"line\">\tT dequeue() &#123; return data[(first++)-1]; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-版本三：环状数组版\"><a href=\"#2-3-版本三：环状数组版\" class=\"headerlink\" title=\"2-3. 版本三：环状数组版\"></a><strong>2-3. 版本三：环状数组版</strong></h3><p>与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了</p>\n<p>适用于已知数据的规模的情况</p>\n<p>数组在逻辑上相连而在物理上不相连，用取余size实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Queue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint maxsize;</span><br><span class=\"line\">\tint first;</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tQueue(int size=0)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmaxsize=size+1;</span><br><span class=\"line\">\t\tlast=0;</span><br><span class=\"line\">\t\tfirst=1;</span><br><span class=\"line\">\t\tdata= new T[maxsize];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Queue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdelete []data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid clear()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=first=0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid enqueue(const T &amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=(last+1)%maxsize;</span><br><span class=\"line\">\t\tdata[last]=it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tT dequeue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tT it = data[first];</span><br><span class=\"line\">\t\tfirst = (first+1)%maxsize;</span><br><span class=\"line\">\t\treturn it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconst T firstValue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn data[first];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint length()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn ((last+maxsize)-first+1)%maxsize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp\" target=\"_blank\" rel=\"noopener\">栈的完整实现 ( 附带应用的实现 )</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp\" target=\"_blank\" rel=\"noopener\">队列的完整实现</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h1><p><strong>栈</strong>(stack)和<strong>队列</strong>(queue)均属于<strong>线性存储</strong>结构</p>\n<p>栈特性：</p>\n<blockquote>\n<ol>\n<li>LIFO ( last in first out ) 后进先出</li>\n<li>元素插入和删除仅在一端进行</li>\n</ol>\n</blockquote>\n<p>队列特性：</p>\n<blockquote>\n<ol>\n<li>FIFO ( first in first out ) 先进先出</li>\n<li>元素在队尾插入，在队头删除</li>\n</ol>\n</blockquote>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack0.jpg\" alt=\"栈和队列\"></p>\n<p>这两种结构均可以用数组或链表实现</p>\n<p>本文主要介绍栈，以下实现均为c++.</p>","more":"<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a><strong>栈</strong></h1><h2 id=\"一-常用接口：\"><a href=\"#一-常用接口：\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取栈的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>push(n)</td>\n<td>将n压入栈</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>top()</td>\n<td>取栈顶元素而不弹出</td>\n</tr>\n<tr>\n<td>T</td>\n<td>pop()</td>\n<td>弹出栈顶元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：\"><a href=\"#二-基本定义：\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>本文用数组实现栈。<br>在开始给栈初始化一定空间，每当插入数据达到一定规模则进行扩容，删除数据达到一定规模则进行缩容。</p>\n<p>（ 扩容和缩容均采用加倍或减半策略，分摊时间复杂度为O(1) ）</p>\n<p>栈顶在数据数组的末尾，增加元素和删除元素只需要O(1)的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Stack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint _size,maxsize;   // 当前规模和最大规模</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();  // 扩容</span><br><span class=\"line\">\tvoid shrink();  // 缩容</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tStack()&#123; _size =0 ; maxsize=4; data=new T[maxsize]; &#125;;</span><br><span class=\"line\">\tStack( T * origin , int n );   // 可由数据数组进行初始化，origin[0]对应栈顶</span><br><span class=\"line\">\t~Stack() &#123; delete []data; &#125;</span><br><span class=\"line\">\tvoid push( T const &amp; e ) &#123; expand(); data[_size++]=e;  &#125;</span><br><span class=\"line\">\tT pop( ) &#123; shrink(); return data[--_size];   &#125;</span><br><span class=\"line\">\tT &amp; top( ) &#123; return data[_size-1];&#125;;</span><br><span class=\"line\">\tint empty()const &#123;return _size==0;&#125;</span><br><span class=\"line\">\tint size()const &#123;return _size;&#125;</span><br><span class=\"line\">\tint find( T const &amp; e )const;  // 查询栈内是否有该元素，有则返回秩，用于n皇后问题</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-典型应用：\"><a href=\"#三-典型应用：\" class=\"headerlink\" title=\"三. 典型应用：\"></a><strong>三. 典型应用：</strong></h2><p><strong>一. 逆序输出</strong></p>\n<p>输出次序和处理过程颠倒</p>\n<p>例如：进制转换</p>\n<p><strong>二. 递归嵌套</strong></p>\n<p>具有自相似性 ( 总体和局部相似 )</p>\n<p>例如：括号匹配、栈混洗(stack permutation)</p>\n<p><strong>三. 延迟缓冲</strong></p>\n<p>线性扫描算法模式</p>\n<p>例如：中缀表达式求值</p>\n<p><strong>四. 栈式计算</strong></p>\n<p>例如：逆波兰表达式转换（RPN Reverse Polish Notation）</p>\n<p><strong>五. 试探回溯</strong></p>\n<p>例如：n皇后问题、寻路</p>\n<p>下面开始一一介绍这些应用：</p>\n<h3 id=\"3-1-进制转换：\"><a href=\"#3-1-进制转换：\" class=\"headerlink\" title=\"3-1. 进制转换：\"></a><strong>3-1. 进制转换：</strong></h3><p>思路：短除法。对于目前的数字n和数制base，每次记录n%base的值，而后将n除以base，最后将之前记录的值逆向输出即是n在base数制下的值。</p>\n<p>借用栈的特性我们能够很容易的实现将之前记录的值逆向输出这一功能，只需要不断将n%base入栈即可，在短除完毕后不断出栈直至栈为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void convert(  int n , int base ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;s;</span><br><span class=\"line\">\tstatic char digit[]=</span><br><span class=\"line\">\t&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;;</span><br><span class=\"line\">\t// 进制限定在2-16，有需要可以继续扩展</span><br><span class=\"line\">\twhile(n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts.push( digit[n%base]);</span><br><span class=\"line\">\t\tn/=base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !s.empty() )</span><br><span class=\"line\">\t\tcout&lt;&lt;s.pop();</span><br><span class=\"line\">\tcout&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-括号匹配：\"><a href=\"#3-2-括号匹配：\" class=\"headerlink\" title=\"3-2. 括号匹配：\"></a><strong>3-2. 括号匹配：</strong></h3><p>判断某一表达式内的括号是否完全匹配</p>\n<p>对于只有一种括号 () 的情况，我们可以用一个变量n记录括号的数目，当碰到左括号n自增，碰到右括号n自减，扫描完表达式之后若n==0同时在此期间n均大于等于0，则说明该表达式内的括号完全匹配。</p>\n<p>然而，这仅适用于只需要检测一种括号的情况，若是不仅有小括号(),还有中括号[],乃至html中自定义的括号类型 ，则计数法将失效。</p>\n<p>而借助栈我们能够很轻松地完成多括号匹配的任务。</p>\n<p>思路：每当遇到一个左括号（无论是小括号还是中括号还是其它自定义类型），就将其入栈，每当遇到一个右括号，则取栈顶元素进行鉴定，若是和右括号类型匹配的左括号，则将其出栈，若是和其类型不匹配，则可返回匹配失败。当进行到表达式结束后，若栈为空，则说明表达式匹配成功，若栈不为空，则匹配失败。</p>\n<p>显示为流程图即是</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack8.JPG\" alt=\"流程图\"></p>\n<p>下面来看一下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool judge ( char *s , int n ) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;char&gt;a;</span><br><span class=\"line\">\tfor(int i=0 ; i&lt;n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( s[i]!=&apos;(&apos; &amp;&amp; s[i]!=&apos;)&apos; &amp;&amp; s[i]!=&apos;[&apos; &amp;&amp; s[i]!=&apos;]&apos; )</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\tif( s[i]==&apos;(&apos;|| s[i]==&apos;[&apos;)</span><br><span class=\"line\">\t\t\ta.push(s[i]);</span><br><span class=\"line\">\t\telse if(a.empty())</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\telse if( (s[i]==&apos;)&apos;&amp;&amp;a.top()==&apos;(&apos;) || (s[i]==&apos;]&apos;&amp;&amp;a.top()==&apos;[&apos;) )</span><br><span class=\"line\">\t\t\ta.pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(\ta.empty() )</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-栈混洗：\"><a href=\"#3-3-栈混洗：\" class=\"headerlink\" title=\"3-3. 栈混洗：\"></a><strong>3-3. 栈混洗：</strong></h3><h4 id=\"3-3-0-概念：\"><a href=\"#3-3-0-概念：\" class=\"headerlink\" title=\"3-3-0. 概念：\"></a><strong>3-3-0. 概念：</strong></h4><p>栈混洗 ( Stack permutation )指的是：将栈A的所有元素借助中转栈S转移到栈B中。</p>\n<p>栈混洗的过程中只允许以下两个操作：</p>\n<blockquote>\n<ol>\n<li>A栈顶弹出并压入栈S S.push(A.pop())</li>\n<li>S栈顶弹出并压入栈B B.push(S.pop())</li>\n</ol>\n</blockquote>\n<h4 id=\"3-3-1-排列种数：\"><a href=\"#3-3-1-排列种数：\" class=\"headerlink\" title=\"3-3-1. 排列种数：\"></a><strong>3-3-1. 排列种数：</strong></h4><p>先来计算一下栈通过栈混洗操作后有多少种排列方式：</p>\n<p>设总数为n的栈有SP(n)种排列方式</p>\n<p>推导：对于第一个元素通过S进入栈B后，此时S为空，设B中有k个元素，则第一个元素后面有k-1个元素，而A中剩余n-k个元素，第一个元素可能第一个进入B，也可能最后一个进入B，所以k取值为[1,n]<br>对于第一个元素而言，它的排列方式有SP(n)种。</p>\n<script type=\"math/tex; mode=display\">SP(n)=\\sum_{k=1}^n SP(k-1)*SP(n-k)</script><p>解得$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$</p>\n<h4 id=\"3-3-2-甄别栈混洗：\"><a href=\"#3-3-2-甄别栈混洗：\" class=\"headerlink\" title=\"3-3-2. 甄别栈混洗：\"></a><strong>3-3-2. 甄别栈混洗：</strong></h4><p>如何甄别一个序列是否是栈混洗呢？</p>\n<p>三个元素栈混洗有5种，全排列有6种, &lt;1,2,3] 非栈混洗的排列为 &lt;2,1,3] ( ‘&lt;’为栈顶方向 )</p>\n<p>而通过观察可得，对于任意三个元素，能否按某种相对次序出现在混洗中与其他元素无关</p>\n<p>对于 1&lt;=i &lt; j &lt; k&lt;=n,若出现 k i j的排列，则非栈混洗 （称为<strong>禁形</strong>）</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack2.jpg\" alt=\"禁形1\"></p>\n<p>通过证明，禁形对于是否是栈混洗为 <strong>充要条件</strong></p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack3.jpg\" alt=\"禁形2\"></p>\n<p>那么我们可以得到如下的判别方法：</p>\n<p>O(n3)判别方法：分别枚举i，j，k</p>\n<p>O(n2)判别方法：枚举 i , j , j+1</p>\n<p>O(n)判别方法：贪心模拟栈混洗过程，看是否能够形成输出序列，若需要pop时S为空或者需要的元素在S中但不是栈顶，则判定不是栈混洗</p>\n<p>以下为O(n)的判别方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool stackPermutation( T *origin, T * b , int n )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;T&gt; s;</span><br><span class=\"line\">\tStack&lt;T&gt; ori( origin ,n );</span><br><span class=\"line\">\tfor( int j=0; j&lt;n ; j++ )</span><br><span class=\"line\">\t&#123;\t</span><br><span class=\"line\">\t\tif( s.empty() )</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( !s.empty() )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif( s.top()==b[j] )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ts.pop();</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;pop\\n&quot;;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif( ori.empty() ) </span><br><span class=\"line\">\t\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t\ts.push( ori.pop() );</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;&quot;push\\n&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif( !s.empty() || !ori.empty() )</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-栈混洗与括号匹配：\"><a href=\"#3-3-3-栈混洗与括号匹配：\" class=\"headerlink\" title=\"3-3-3. 栈混洗与括号匹配：\"></a><strong>3-3-3. 栈混洗与括号匹配：</strong></h4><p>值得注意的是，合法的栈混洗的过程中，同一元素的入栈和出栈操作和括号匹配相同，需要出栈的时候栈顶却不是对应的元素，则不是合法的栈混洗序列，在括号匹配中则是匹配失败。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack4.jpg\" alt=\"栈混洗与括号匹配\"></p>\n<p>结论：合法的括号匹配相当于合法的栈混洗，若是输出不合法的混洗序列则说明表达式的括号不匹配</p>\n<p>同时，n对括号所能构成的合法表达式同为$SP(n) = catalan(n) = \\frac{(2n)!}{(n+1)!n!}$种</p>\n<h3 id=\"3-4-中缀表达式求值：\"><a href=\"#3-4-中缀表达式求值：\" class=\"headerlink\" title=\"3-4. 中缀表达式求值：\"></a><strong>3-4. 中缀表达式求值：</strong></h3><h4 id=\"3-4-0-概述：\"><a href=\"#3-4-0-概述：\" class=\"headerlink\" title=\"3-4-0. 概述：\"></a><strong>3-4-0. 概述：</strong></h4><p>中缀表达式即是我们最常在数学中使用的形式：运算符在运算数中间，使用约定俗成的运算符优先级和使用括号来强调优先级。<br>例如 1+1 即是一个中缀表达式</p>\n<h4 id=\"3-4-1-算法：\"><a href=\"#3-4-1-算法：\" class=\"headerlink\" title=\"3-4-1. 算法：\"></a><strong>3-4-1. 算法：</strong></h4><p>主体思路：用两个栈分别保存<strong>操作数</strong>和<strong>运算符</strong>，每当有一个新的运算符，则判断栈顶运算符和当前运算符的优先级，若栈顶的优先级高，则进行栈顶的运算，若当前优先级高，则将该运算符压入栈。</p>\n<p>此外，值得注意的是</p>\n<p>一：为了方便判断优先级，在优先级表中<strong>同一阶级的运算符根据出现次序不同优先级也不同</strong>，如‘+’和‘-’，当‘+’在栈顶而’-‘作为新运算符时，’+’优先级大于’-‘，反之若’-‘在栈顶，则’-‘优先级大于’+’.</p>\n<p>二：默认表达式为合法，因此不会出现栈顶为右括号的情况(因为右括号想要入栈时，因优先级小于除左括号和\\0之外的运算符，所以它和左括号之间的运算符都会出栈)</p>\n<p>三：同时，对于优先级为’=’的运算符不予入栈处理，反而是将栈顶元素出栈，此时是将一对对子(左右括号或\\0)处理完毕。</p>\n<p>四：表达式开始前先将’\\0‘压入运算符栈，和表达式字符串末尾的\\0形成对子，可以看作一对括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const char Prior[9][9] = </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">//        +   -   *   /   ^   !   (   )  \\0</span><br><span class=\"line\">/* + */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* - */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* * */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* / */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ^ */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ! */  &apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,&apos; &apos;,&apos;&gt;&apos;,&apos;&gt;&apos;,</span><br><span class=\"line\">/* ( */  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;=&apos;,&apos; &apos;,</span><br><span class=\"line\">/* ) */  &apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,</span><br><span class=\"line\">/* \\0*/  &apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos;&lt;&apos;,&apos; &apos;,&apos;=&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void readNumber( char *&amp;s , Stack&lt;float&gt;&amp; opnd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat ans=0;</span><br><span class=\"line\">\topnd.push( *s-&apos;0&apos; );</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop()*10 + *s-&apos;0&apos; );</span><br><span class=\"line\">\tif(*s!=&apos;.&apos;)   // 可能是小数</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tfloat f=1;</span><br><span class=\"line\">\twhile( *(++s)&lt;=&apos;9&apos;&amp;&amp; *s&gt;=&apos;0&apos; )</span><br><span class=\"line\">\t\topnd.push( opnd.pop() + (*s-&apos;0&apos;)*(f/=10.0) );</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void getnum( char a, int &amp; num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch(a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: num=0;return;</span><br><span class=\"line\">\tcase &apos;-&apos;: num=1;return;</span><br><span class=\"line\">\tcase &apos;*&apos;: num=2;return;</span><br><span class=\"line\">\tcase &apos;/&apos;: num=3;return;</span><br><span class=\"line\">\tcase &apos;^&apos;: num=4;return;</span><br><span class=\"line\">\tcase &apos;!&apos;: num=5;return;</span><br><span class=\"line\">\tcase &apos;(&apos;: num=6;return;</span><br><span class=\"line\">\tcase &apos;)&apos;: num=7;return;</span><br><span class=\"line\">\tcase &apos;\\0&apos;: num=8;return;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char orderBetween ( char a, char b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num1,num2;</span><br><span class=\"line\">\tgetnum( a, num1 );</span><br><span class=\"line\">\tgetnum( b, num2 );</span><br><span class=\"line\">\treturn Prior[num1][num2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( float num1, char op , float num2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tswitch (op)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tcase &apos;+&apos;: return num1+num2;</span><br><span class=\"line\">\tcase &apos;-&apos;: return num1-num2;</span><br><span class=\"line\">\tcase &apos;*&apos;: return num1*num2;</span><br><span class=\"line\">\tcase &apos;/&apos;: return num1/num2;</span><br><span class=\"line\">\tcase &apos;^&apos;: return pow(num1,num2);</span><br><span class=\"line\">\tdefault : exit(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float cal( char op, float num1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif( abs(num1-0)&lt;1e-6 )</span><br><span class=\"line\">\t\treturn 1;</span><br><span class=\"line\">\tfor(int i=1; i&lt;num1 ; i++)</span><br><span class=\"line\">\t\tnum1*=i;</span><br><span class=\"line\">\treturn num1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t// 逆向取数，可能是&apos;-&apos;号这些和次序相关的运算符</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();  // 表达式处理完毕后运算数栈最后剩下的就是表达式结果了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-逆波兰表达式：\"><a href=\"#3-5-逆波兰表达式：\" class=\"headerlink\" title=\"3-5. 逆波兰表达式：\"></a><strong>3-5. 逆波兰表达式：</strong></h3><p>中缀表达式虽然符合人的使用和思维习惯，但是对于计算机处理而言过于繁琐了，于是就诞生了其它类型的表达式来简化计算机的运算，而逆波兰表达式就是其中一种。</p>\n<h4 id=\"3-5-0-概念：\"><a href=\"#3-5-0-概念：\" class=\"headerlink\" title=\"3-5-0. 概念：\"></a><strong>3-5-0. 概念：</strong></h4><p>逆波兰表达式 ( RPN : Reverse Polish Notation )</p>\n<p>没有括号和约定俗成的优先级，从左至右扫描表达式，运算符<strong>谁先出现算谁</strong>。</p>\n<p>运算符位于参与运算的运算数之后。</p>\n<p>例如：</p>\n<p>0！1+2 3！*4+5-^</p>\n<p>值得注意的是：不同运算数之间可能仅是以空格分格，同一运算数数字之间没有空格。</p>\n<p>以上表达式翻译成中缀表达式即是：</p>\n<p>( 0! + 1 )^( 2 * 3! +4 - 5 )</p>\n<p>和中缀表达式相比，逆波兰表达式的优点在于<strong>计算速度更快</strong>。</p>\n<p>在得到一个函数表达式后，若是之后的调用仅是修改数字而不修改运算符，那么对于中缀表达式则需要算n次，对于逆波兰表达式需要1次转换+算n次，效率将高很多，当然代价就是转换的速度很慢。</p>\n<h4 id=\"3-5-2-计算：\"><a href=\"#3-5-2-计算：\" class=\"headerlink\" title=\"3-5-2. 计算：\"></a><strong>3-5-2. 计算：</strong></h4><p>计算逆波兰表达式相比中缀表达式要简单的多，只需要一个运算数栈，遇到数字则入栈，遇到运算符就取数字计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float rpnEvaluate( char * RPN )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tRPN[len++]=&apos;\\0&apos;;</span><br><span class=\"line\">\twhile(len--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*RPN)&lt;=&apos;9&apos;&amp;&amp;(*RPN)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( RPN, opnd );  // 可能是多位数</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchar op=*RPN;</span><br><span class=\"line\">\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-5-2-手工转换：\"><a href=\"#3-5-2-手工转换：\" class=\"headerlink\" title=\"3-5-2. 手工转换：\"></a><strong>3-5-2. 手工转换：</strong></h4><p>手工将中缀表达式转换成逆波兰表达式的方法如下：</p>\n<p>1.用括号显式界定所有运算符</p>\n<p>2.将所有运算符移到对应的右括号后面</p>\n<p>3.去掉所有括号</p>\n<p>4.稍加整理</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack6.jpg\" alt=\"手工转换\"></p>\n<h4 id=\"3-5-3-转换算法：\"><a href=\"#3-5-3-转换算法：\" class=\"headerlink\" title=\"3-5-3. 转换算法：\"></a><strong>3-5-3. 转换算法：</strong></h4><p>非常有意思的是，计算中缀表达式的算法流程和转换成RPN的算法流程大致相同，只需要在将数字入栈的同时接入RPN的末尾，弹出运算符时接入RPN末尾即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// evaluate函数中调用的其它函数和中缀表达式中的一样，在此不重复附上</span><br><span class=\"line\">void append( char *&amp;RPN, float num )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen(RPN);</span><br><span class=\"line\">\tchar buf[64];</span><br><span class=\"line\">\tif( num!= (float)(int)num )   // 判断是否为整数</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%.2f \\0&quot;,num); // 小数暂取两位</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tsprintf( buf, &quot;%d \\0&quot;,(int)num);</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len+strlen( buf )+1 ) );   // 扩容</span><br><span class=\"line\">\tstrcat( RPN,buf );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void append( char *&amp;RPN, char op )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint len=strlen( RPN );</span><br><span class=\"line\">\tRPN=(char *)realloc( RPN, sizeof( char )*( len + 3 ) );</span><br><span class=\"line\">\tsprintf( RPN+len, &quot;%c \\0&quot;,op );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float evaluate ( char * s , char *&amp;RPN )</span><br><span class=\"line\">&#123; // s：中缀表达式， RPN：需要存放转换后表达式的位置</span><br><span class=\"line\">\tStack&lt;float&gt; opnd;</span><br><span class=\"line\">\tStack&lt;char&gt; optr;</span><br><span class=\"line\">\tfloat num1,num2;</span><br><span class=\"line\">\ts[strlen(s)]=&apos;\\0&apos;;</span><br><span class=\"line\">\tRPN[0]=&apos;\\0&apos;;</span><br><span class=\"line\">\toptr.push(&apos;\\0&apos;); // 结尾操作符</span><br><span class=\"line\">\twhile( !optr.empty() )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( (*s)&lt;=&apos;9&apos;&amp;&amp;(*s)&gt;=&apos;0&apos; ) //当前是操作数</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\treadNumber( s, opnd );  // 可能是多位数</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\tappend( RPN, opnd.top());</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tswitch( orderBetween( optr.top(),*s ) )</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase &apos;&lt;&apos;: optr.push(*s); s++; break;</span><br><span class=\"line\">\t\t\tcase &apos;=&apos;: optr.pop(); s++; break; // () \\0</span><br><span class=\"line\">\t\t\tcase &apos;&gt;&apos;: </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tchar op=optr.pop();</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tappend( RPN, op );</span><br><span class=\"line\">//////// RPN转换 ////////</span><br><span class=\"line\">\t\t\t\tif(op==&apos;!&apos;)</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal( op, opnd.pop() ) );</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tnum2=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\tnum1=opnd.pop();</span><br><span class=\"line\">\t\t\t\t\topnd.push( cal(num1,op,num2));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn opnd.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-n皇后问题：\"><a href=\"#3-6-n皇后问题：\" class=\"headerlink\" title=\"3-6. n皇后问题：\"></a><strong>3-6. n皇后问题：</strong></h3><h4 id=\"3-6-0-概述：\"><a href=\"#3-6-0-概述：\" class=\"headerlink\" title=\"3-6-0. 概述：\"></a><strong>3-6-0. 概述：</strong></h4><p>试探：逐步增加候选解的长度 ，逐步向目标解靠近</p>\n<p>回溯：一旦发现和目标解不同，则回溯到上一步继续试探</p>\n<p>一个形象的比方：拿着绳子探索迷宫，绳子一段绑在入口，人随意选择一方向前进，一旦遇到死路，做好标记，沿着绳子后退到上一个分叉口，选择另一个方向，若是该分叉口所有前进方向均是死路，则沿着绳子返回再上一个分支，以此直到找到出口或是试完所有可能。</p>\n<p>n皇后问题：在n*n的棋盘中放置n个皇后，n个皇后间两两不冲突。冲突的条件是一个皇后在另一个皇后同一行或同一列或正反对角线上。</p>\n<p><img src=\"http://ot1c7ttzm.bkt.clouddn.com/stack7.jpg\" alt=\"n皇后问题\"></p>\n<h4 id=\"3-6-1-算法：\"><a href=\"#3-6-1-算法：\" class=\"headerlink\" title=\"3-6-1. 算法：\"></a><strong>3-6-1. 算法：</strong></h4><p>用栈保存当前探索进度，逐行放置皇后，每当确定皇后可以在当前列放置时，将其入栈，若所有列均不可放置，则取出栈顶元素，继续向后面的列尝试放置。 若是栈的大小等于n，说明已经构成一个解，此时可以输出栈内元素也可将计数器自增。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int Stack&lt;T&gt;::find( T const &amp; e ) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor( int i=0 ; i&lt;_size ; i++)</span><br><span class=\"line\">\t\tif( data[i] == e )</span><br><span class=\"line\">\t\t\treturn i;</span><br><span class=\"line\">\treturn -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct Queen</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint x,y;</span><br><span class=\"line\">\tQueen( int xx=0, int yy=0 ):x(xx),y(yy)&#123;&#125;</span><br><span class=\"line\">\tbool operator == ( Queen const &amp; a ) const</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( x==a.x || y==a.y || x+y==a.x+a.y || x-y==a.x-a.y )</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tbool operator != ( Queen const &amp; a ) const &#123; return !( *this == a );&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int placeQueens( int n ) // n皇后</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint num_solution=0;</span><br><span class=\"line\">\tStack&lt; Queen &gt;a; </span><br><span class=\"line\">\tQueen q(0,0);  //当前寻求位置放的皇后</span><br><span class=\"line\">\tdo</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif( a.size()&gt;=n || q.y&gt;=n ) // 若是列数超出边界或已经构成一个解</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tq=a.pop();   // 取出栈顶元素，列数自增继续尝试</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile( q.y&lt;n &amp;&amp; a.find(q)&gt;=0 ) // 若和其它皇后发生冲突，则find函数会返回冲突的皇后的秩 [0,n) 若是-1则无冲突</span><br><span class=\"line\">\t\t\tq.y++;</span><br><span class=\"line\">\t\tif( q.y&lt;n )  // 找到位置放置皇后</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta.push( q );</span><br><span class=\"line\">\t\t\tif( a.size()&gt;=n )</span><br><span class=\"line\">\t\t\t\tnum_solution++;</span><br><span class=\"line\">\t\t\tq.x++;  // 前往下一行找解，列数重置</span><br><span class=\"line\">\t\t\tq.y=0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile( !( q.x==0 &amp;&amp; q.y&gt;=n ) );</span><br><span class=\"line\">\treturn num_solution;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a><strong>队列</strong></h1><h2 id=\"一-常用接口：-1\"><a href=\"#一-常用接口：-1\" class=\"headerlink\" title=\"一. 常用接口：\"></a><strong>一. 常用接口：</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>函数名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bool</td>\n<td>empty()</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>int</td>\n<td>size()</td>\n<td>获取队列的大小</td>\n</tr>\n<tr>\n<td>void</td>\n<td>enqueue(n)</td>\n<td>将n入队</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>front()</td>\n<td>查看队头元素</td>\n</tr>\n<tr>\n<td>T</td>\n<td>dequeue()</td>\n<td>删除队头元素</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>rear()</td>\n<td>查看队尾元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"二-基本定义：-1\"><a href=\"#二-基本定义：-1\" class=\"headerlink\" title=\"二. 基本定义：\"></a><strong>二. 基本定义：</strong></h2><p>队列同样可以用数组或链表实现</p>\n<h3 id=\"2-1-版本一：继承List类\"><a href=\"#2-1-版本一：继承List类\" class=\"headerlink\" title=\"2-1. 版本一：继承List类\"></a><strong>2-1. 版本一：继承List类</strong></h3><p>在这里选择继承<a href=\"https://zedom1.github.io/2017/08/12/list/\">笔记一</a>中实现的双向链表List类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue:public List&lt;T&gt; //利用双向链表版</span><br><span class=\"line\">&#123; // size和empty直接沿用</span><br><span class=\"line\">\tvoid enqueue ( T const&amp; e ) &#123;insertAsLast(e);&#125;</span><br><span class=\"line\">\tT dequeue() &#123; return remove(first()); &#125;</span><br><span class=\"line\">\tT&amp; front() &#123; return first()-&gt;data; &#125;</span><br><span class=\"line\">\tT&amp; rear() &#123; return last()-&gt;data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-版本二：从零开始的数组版\"><a href=\"#2-2-版本二：从零开始的数组版\" class=\"headerlink\" title=\"2-2. 版本二：从零开始的数组版\"></a><strong>2-2. 版本二：从零开始的数组版</strong></h3><p>用数组模拟队列时，为方便起见，用first和last作为队头和队尾的秩，而不是在删除元素时将后面所有的元素迁移一位。只是需要注意在last逼近数组边界时需要扩容或者重新安排位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct queue  // 数组模拟版</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint first,last,maxsize;</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid expand();</span><br><span class=\"line\">// expand()判断 last 或 last-first 是否接近maxsize</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tqueue();</span><br><span class=\"line\">\t~queue() &#123;delete []data;&#125;</span><br><span class=\"line\">\tbool empty()const &#123;return first==last;&#125;</span><br><span class=\"line\">\tint size()const &#123;return last-first;&#125;</span><br><span class=\"line\">\tT&amp; front()const &#123; if(!empty())return data[first]; else exit(1);&#125;</span><br><span class=\"line\">\tT&amp; rear()const &#123; if(!empty())return data[last-1]; else exit(1);&#125;</span><br><span class=\"line\">\tvoid enqueue( T const &amp; e) &#123; expand(); data[last++]=e; &#125;</span><br><span class=\"line\">\tT dequeue() &#123; return data[(first++)-1]; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-版本三：环状数组版\"><a href=\"#2-3-版本三：环状数组版\" class=\"headerlink\" title=\"2-3. 版本三：环状数组版\"></a><strong>2-3. 版本三：环状数组版</strong></h3><p>与版本二中用first和last作为队头和队尾类似，但不同点在于，数组在逻辑上是首尾相接的环状，这样在足够大的数组下就可以不考虑队列移动到数组末尾的情况了</p>\n<p>适用于已知数据的规模的情况</p>\n<p>数组在逻辑上相连而在物理上不相连，用取余size实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Queue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tT *data;</span><br><span class=\"line\">\tint maxsize;</span><br><span class=\"line\">\tint first;</span><br><span class=\"line\">\tint last;</span><br><span class=\"line\">\tint size;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tQueue(int size=0)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmaxsize=size+1;</span><br><span class=\"line\">\t\tlast=0;</span><br><span class=\"line\">\t\tfirst=1;</span><br><span class=\"line\">\t\tdata= new T[maxsize];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Queue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdelete []data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid clear()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=first=0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid enqueue(const T &amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tlast=(last+1)%maxsize;</span><br><span class=\"line\">\t\tdata[last]=it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tT dequeue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tT it = data[first];</span><br><span class=\"line\">\t\tfirst = (first+1)%maxsize;</span><br><span class=\"line\">\t\treturn it;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconst T firstValue()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn data[first];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint length()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn ((last+maxsize)-first+1)%maxsize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"完整实现代码\"><a href=\"#完整实现代码\" class=\"headerlink\" title=\"完整实现代码\"></a><strong>完整实现代码</strong></h1><p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/stack.cpp\" target=\"_blank\" rel=\"noopener\">栈的完整实现 ( 附带应用的实现 )</a></p>\n<p><a href=\"https://github.com/zedom1/DSA/blob/master/stack%20and%20queue/queue.cpp\" target=\"_blank\" rel=\"noopener\">队列的完整实现</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjhvssacz0000jvfc7vocwubt","tag_id":"cjhvssad90002jvfcjfx10fpp","_id":"cjhvssadj0008jvfc2iksy0yt"},{"post_id":"cjhvssacz0000jvfc7vocwubt","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssadk0009jvfc5awvx7vv"},{"post_id":"cjhvssad50001jvfcjprn7ada","tag_id":"cjhvssadj0007jvfcqdafqlnn","_id":"cjhvssadm000cjvfc25yxfuc7"},{"post_id":"cjhvssad50001jvfcjprn7ada","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssadm000djvfca1ml7ni7"},{"post_id":"cjhvssadc0003jvfcy0g5a7gy","tag_id":"cjhvssad90002jvfcjfx10fpp","_id":"cjhvssadn000gjvfc9esnqcfm"},{"post_id":"cjhvssadc0003jvfcy0g5a7gy","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssadn000hjvfcwe4hn3o4"},{"post_id":"cjhvssade0004jvfck8ttxrr6","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssado000ljvfcrzhlq29w"},{"post_id":"cjhvssade0004jvfck8ttxrr6","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssado000mjvfcywbpn8y6"},{"post_id":"cjhvssade0004jvfck8ttxrr6","tag_id":"cjhvssadn000jjvfcig6jjzy9","_id":"cjhvssado000ojvfc071bzqax"},{"post_id":"cjhvssadg0005jvfchbmkrhp2","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssado000qjvfcqotahb6y"},{"post_id":"cjhvssadg0005jvfchbmkrhp2","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssadp000rjvfc655dcgqw"},{"post_id":"cjhvssadg0005jvfchbmkrhp2","tag_id":"cjhvssadn000jjvfcig6jjzy9","_id":"cjhvssadp000sjvfcyyml0ppc"},{"post_id":"cjhvssae5000ujvfcjtq4p8mh","tag_id":"cjhvssadj0007jvfcqdafqlnn","_id":"cjhvssae9000xjvfcu98xycpp"},{"post_id":"cjhvssae5000ujvfcjtq4p8mh","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssaec000zjvfchcx02808"},{"post_id":"cjhvssae3000tjvfcdc2uojez","tag_id":"cjhvssae7000vjvfchpm03fn1","_id":"cjhvssaee0012jvfcht0roy31"},{"post_id":"cjhvssaej0016jvfcqsyrejbe","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssaem0019jvfc7tk1daot"},{"post_id":"cjhvssaej0016jvfcqsyrejbe","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssaen001bjvfca51o2gmr"},{"post_id":"cjhvssaej0016jvfcqsyrejbe","tag_id":"cjhvssadn000jjvfcig6jjzy9","_id":"cjhvssaeo001cjvfcjp7ch3gx"},{"post_id":"cjhvssaem001ajvfcu0umxmfn","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssaep001ejvfc47tv41bj"},{"post_id":"cjhvssaem001ajvfcu0umxmfn","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssaep001fjvfcjf96mfuk"},{"post_id":"cjhvssaem001ajvfcu0umxmfn","tag_id":"cjhvssadn000jjvfcig6jjzy9","_id":"cjhvssaep001hjvfcgy1jeb58"},{"post_id":"cjhvssae7000wjvfcavbevtue","tag_id":"cjhvssaee0011jvfcvrmkedhu","_id":"cjhvssaep001ijvfcwha9ixai"},{"post_id":"cjhvssae7000wjvfcavbevtue","tag_id":"cjhvssaei0015jvfc1hpl1jzh","_id":"cjhvssaeq001kjvfccxnuk5z0"},{"post_id":"cjhvssae7000wjvfcavbevtue","tag_id":"cjhvssael0018jvfcdg8jv0f7","_id":"cjhvssaeq001ljvfcplurj5qs"},{"post_id":"cjhvssae9000yjvfcgggejsub","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssaer001njvfcfwmi0hu1"},{"post_id":"cjhvssae9000yjvfcgggejsub","tag_id":"cjhvssaeo001djvfc5a0sr1yt","_id":"cjhvssaer001ojvfc6iskzx88"},{"post_id":"cjhvssaed0010jvfcxsq86v4u","tag_id":"cjhvssadj0006jvfc9z043s4b","_id":"cjhvssaes001qjvfc6ljndj06"},{"post_id":"cjhvssaed0010jvfcxsq86v4u","tag_id":"cjhvssaep001gjvfcdczl9gyf","_id":"cjhvssaet001rjvfcxqoz1bm5"},{"post_id":"cjhvssaef0013jvfcsjvzoivx","tag_id":"cjhvssadk000ajvfcvrnx9yv1","_id":"cjhvssaet001tjvfcb5ybkonc"},{"post_id":"cjhvssaef0013jvfcsjvzoivx","tag_id":"cjhvssadn000jjvfcig6jjzy9","_id":"cjhvssaeu001ujvfcwny8bbww"},{"post_id":"cjhvssaef0013jvfcsjvzoivx","tag_id":"cjhvssaeo001djvfc5a0sr1yt","_id":"cjhvssaeu001vjvfcy7f8xtog"},{"post_id":"cjhvssaeg0014jvfcsk6w3t01","tag_id":"cjhvssadj0007jvfcqdafqlnn","_id":"cjhvssaev001wjvfcf4b8l3yu"},{"post_id":"cjhvssaeg0014jvfcsk6w3t01","tag_id":"cjhvssaeq001mjvfc7pusjqlw","_id":"cjhvssaev001xjvfc35a5bhl8"},{"post_id":"cjhvssaek0017jvfco3f4904d","tag_id":"cjhvssael0018jvfcdg8jv0f7","_id":"cjhvssaew001yjvfcggfozknd"},{"post_id":"cjhvssaek0017jvfco3f4904d","tag_id":"cjhvssaee0011jvfcvrmkedhu","_id":"cjhvssaew001zjvfcdyulj0f5"},{"post_id":"cjhvssaek0017jvfco3f4904d","tag_id":"cjhvssaet001sjvfc01nitosv","_id":"cjhvssaex0020jvfcv3jph6zy"}],"Tag":[{"name":"编译原理","_id":"cjhvssad90002jvfcjfx10fpp"},{"name":"学习笔记","_id":"cjhvssadj0006jvfc9z043s4b"},{"name":"游戏","_id":"cjhvssadj0007jvfcqdafqlnn"},{"name":"c++","_id":"cjhvssadk000ajvfcvrnx9yv1"},{"name":"数据结构","_id":"cjhvssadn000jjvfcig6jjzy9"},{"name":"others","_id":"cjhvssae7000vjvfchpm03fn1"},{"name":"NLP","_id":"cjhvssaee0011jvfcvrmkedhu"},{"name":"阅读理解","_id":"cjhvssaei0015jvfc1hpl1jzh"},{"name":"机器学习","_id":"cjhvssael0018jvfcdg8jv0f7"},{"name":"刷题","_id":"cjhvssaeo001djvfc5a0sr1yt"},{"name":"JAVA","_id":"cjhvssaep001gjvfcdczl9gyf"},{"name":"算法","_id":"cjhvssaeq001mjvfc7pusjqlw"},{"name":"VSM","_id":"cjhvssaet001sjvfc01nitosv"}]}}